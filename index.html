<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>White Mousse Production Tracker - Cloud Sync</title>

    <!-- PWA Meta Tags -->
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#0a0a0f">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="WM Tracker">
    <link rel="apple-touch-icon" href="https://images.squarespace-cdn.com/content/v1/5501f606e4b0b9ba3b7be5ec/1537298893777-QBVYYWKI0KBKGYJGQJB5/WM.png?format=180w">
    <link rel="icon" type="image/png" href="https://images.squarespace-cdn.com/content/v1/5501f606e4b0b9ba3b7be5ec/1537298893777-QBVYYWKI0KBKGYJGQJB5/WM.png?format=32w">
    <link rel="icon" type="image/png" sizes="192x192" href="https://images.squarespace-cdn.com/content/v1/5501f606e4b0b9ba3b7be5ec/1537298893777-QBVYYWKI0KBKGYJGQJB5/WM.png?format=192w">

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&family=Work+Sans:wght@300;400;600;700&display=swap');

        :root {
            /* Electric Forest - Laser show vibes */
            --bg-primary: #000000;
            --bg-secondary: #0a0a0a;
            --bg-tertiary: #141414;
            --accent-purple: #bf00ff;
            --accent-green: #39ff14;
            --accent-blue: #0055ff;
            --accent-orange: #ff6b00;
            --accent-red: #ff0055;
            --accent-pink: #ff10f0;
            --text-primary: #ffffff;
            --text-secondary: #888888;
            --border: #222222;
            --glow-green: 0 0 20px rgba(57, 255, 20, 0.5);
            --glow-pink: 0 0 20px rgba(255, 16, 240, 0.5);
            --glow-blue: 0 0 20px rgba(0, 240, 255, 0.5);
            --glow-purple: 0 0 20px rgba(191, 0, 255, 0.5);
            font-size: 18px;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Work Sans', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            padding: 20px;
            font-size: 1.1rem; /* Increased base font size */
        }
        
        .connection-status {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            border-radius: 20px;
            font-weight: 600;
            font-size: 1rem;
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .connection-status.connected {
            background: rgba(16, 185, 129, 0.2);
            border: 2px solid var(--accent-green);
            color: var(--accent-green);
        }
        
        .connection-status.disconnected {
            background: rgba(239, 68, 68, 0.2);
            border: 2px solid var(--accent-red);
            color: var(--accent-red);
        }
        
        .connection-status.connecting {
            background: rgba(245, 158, 11, 0.2);
            border: 2px solid var(--accent-orange);
            color: var(--accent-orange);
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Celebration animations */
        @keyframes confetti-fall {
            0% { transform: translateY(-100vh) rotate(0deg); opacity: 1; }
            100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
        }

        @keyframes celebration-pop {
            0% { transform: scale(0) rotate(-10deg); opacity: 0; }
            50% { transform: scale(1.1) rotate(5deg); }
            100% { transform: scale(1) rotate(0deg); opacity: 1; }
        }

        @keyframes bounce-in {
            0% { transform: scale(0); }
            50% { transform: scale(1.2); }
            70% { transform: scale(0.9); }
            100% { transform: scale(1); }
        }

        @keyframes shimmer {
            0% { background-position: -200% center; }
            100% { background-position: 200% center; }
        }

        /* Laser show animations */
        @keyframes laser-sweep {
            0% { transform: rotate(-45deg) translateX(-100vw); opacity: 0; }
            10% { opacity: 1; }
            90% { opacity: 1; }
            100% { transform: rotate(45deg) translateX(100vw); opacity: 0; }
        }

        @keyframes laser-pulse {
            0%, 100% { opacity: 0.3; box-shadow: 0 0 20px currentColor, 0 0 40px currentColor; }
            50% { opacity: 1; box-shadow: 0 0 40px currentColor, 0 0 80px currentColor, 0 0 120px currentColor; }
        }

        @keyframes laser-rotate {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .laser-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000000;
            overflow: hidden;
        }

        .laser-beam {
            position: absolute;
            width: 3px;
            height: 200vh;
            transform-origin: center center;
            animation: laser-pulse 0.3s ease-in-out infinite;
        }

        /* Fire cannon animations */
        @keyframes fire-shoot {
            0% {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
            50% {
                opacity: 1;
            }
            100% {
                transform: translateY(100vh) scale(0.3);
                opacity: 0;
            }
        }

        @keyframes fire-flicker {
            0%, 100% { transform: scaleX(1); }
            50% { transform: scaleX(1.2); }
        }

        .fire-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 99998;
            overflow: hidden;
        }

        .fire-particle {
            position: absolute;
            top: -20px;
            border-radius: 50%;
            animation: fire-shoot ease-out forwards;
        }

        .fire-cannon {
            position: absolute;
            top: 0;
            width: 60px;
            height: 80px;
            background: linear-gradient(to bottom, #ff6b00, #ff0055, #ff10f0);
            filter: blur(20px);
            animation: fire-flicker 0.1s ease-in-out infinite;
        }

        .celebration-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            z-index: 99999;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(5px);
        }

        .celebration-content {
            text-align: center;
            animation: celebration-pop 0.5s ease-out;
            max-width: 500px;
            padding: 40px;
        }

        .celebration-emoji {
            font-size: 5rem;
            animation: bounce-in 0.6s ease-out;
            margin-bottom: 20px;
        }

        .celebration-title {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 15px;
            background: linear-gradient(90deg, var(--accent-green), var(--accent-blue), var(--accent-pink), var(--accent-green));
            background-size: 200% auto;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: shimmer 2s linear infinite;
            text-shadow: 0 0 30px rgba(57, 255, 20, 0.3);
        }

        .celebration-message {
            font-size: 1.2rem;
            color: var(--text-secondary);
            margin-bottom: 30px;
            line-height: 1.6;
        }

        .celebration-stats {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-bottom: 30px;
        }

        .celebration-stat {
            background: var(--bg-secondary);
            padding: 20px 30px;
            border-radius: 15px;
            border: 2px solid var(--accent-green);
            box-shadow: 0 0 20px rgba(57, 255, 20, 0.3), inset 0 0 20px rgba(57, 255, 20, 0.05);
        }

        .celebration-stat-value {
            font-size: 2rem;
            font-weight: 700;
            color: var(--accent-green);
            text-shadow: 0 0 10px rgba(57, 255, 20, 0.5);
        }

        .celebration-stat-label {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .celebration-btn {
            background: transparent;
            border: 2px solid var(--accent-pink);
            padding: 15px 40px;
            border-radius: 12px;
            color: var(--accent-pink);
            font-size: 1.1rem;
            font-weight: 700;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 0 20px rgba(255, 16, 240, 0.4), 0 0 40px rgba(191, 0, 255, 0.2), inset 0 0 15px rgba(255, 16, 240, 0.05);
            text-shadow: 0 0 10px rgba(255, 16, 240, 0.5);
        }

        .celebration-btn:hover {
            transform: scale(1.05);
            background: rgba(255, 16, 240, 0.15);
            box-shadow: 0 0 30px rgba(255, 16, 240, 0.6), 0 0 60px rgba(191, 0, 255, 0.4), inset 0 0 20px rgba(255, 16, 240, 0.1);
        }

        .confetti-piece {
            position: fixed;
            width: 10px;
            height: 10px;
            top: -20px;
            animation: confetti-fall linear forwards;
            z-index: 999999;
        }

        .header {
            background: transparent;
            padding: 20px;
            margin-bottom: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .header-content {
            display: flex;
            justify-content: center;
        }

        .header-logo {
            width: 250px;
            height: auto;
        }

        .header-logo img {
            max-width: 100%;
            height: auto;
            display: block;
            object-fit: contain;
            filter: drop-shadow(0 0 8px rgba(191, 0, 255, 0.8))
                    drop-shadow(0 0 15px rgba(191, 0, 255, 0.6))
                    drop-shadow(0 0 30px rgba(191, 0, 255, 0.4))
                    drop-shadow(0 0 50px rgba(0, 240, 255, 0.3));
            animation: neon-flicker 3s ease-in-out infinite;
        }

        @keyframes neon-flicker {
            0%, 100% {
                filter: drop-shadow(0 0 8px rgba(191, 0, 255, 0.8))
                        drop-shadow(0 0 15px rgba(191, 0, 255, 0.6))
                        drop-shadow(0 0 30px rgba(191, 0, 255, 0.4))
                        drop-shadow(0 0 50px rgba(0, 240, 255, 0.3));
            }
            50% {
                filter: drop-shadow(0 0 12px rgba(191, 0, 255, 1))
                        drop-shadow(0 0 25px rgba(191, 0, 255, 0.8))
                        drop-shadow(0 0 45px rgba(191, 0, 255, 0.5))
                        drop-shadow(0 0 70px rgba(0, 240, 255, 0.4));
            }
        }

        .header-logo svg {
            width: 100%;
            height: 100%;
        }

        .header h1 {
            font-family: 'Space Mono', monospace;
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .header p {
            font-size: 1rem;
            opacity: 0.9;
        }
        
        .setup-section {
            background: var(--bg-secondary);
            padding: 30px;
            border-radius: 15px;
            margin-bottom: 30px;
            border: 2px solid var(--border);
        }
        
        .setup-section h2 {
            color: var(--accent-orange);
            margin-bottom: 20px;
            font-size: 1.5rem;
        }
        
        .setup-section.hidden {
            display: none;
        }
        
        .credentials-form {
            display: grid;
            gap: 20px;
        }
        
        .form-group {
            display: flex;
            flex-direction: column;
        }
        
        .form-group label {
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text-secondary);
            font-size: 1.05rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .form-group input,
        .form-group select,
        .form-group textarea {
            padding: 14px;
            background: var(--bg-tertiary);
            border: 2px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 1.1rem;
            font-family: 'Work Sans', sans-serif;
            transition: all 0.3s ease;
        }
        
        .form-group select option {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }
        
        .form-group input:focus,
        .form-group select:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: var(--accent-purple);
            background: rgba(147, 51, 234, 0.05);
        }
        
        .form-group textarea {
            min-height: 100px;
            resize: vertical;
        }
        
        .help-text {
            font-size: 1rem;
            color: var(--text-secondary);
            margin-top: 5px;
            font-style: italic;
        }
        
        .user-login {
            padding: 25px;
            padding-top: 60px;
            margin-bottom: 30px;
        }
        
        .user-login h2 {
            font-size: 1.3rem;
            margin-bottom: 15px;
            color: var(--accent-green);
        }
        
        .user-select {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .user-btn {
            padding: 15px;
            background: transparent;
            border: 2px solid var(--border);
            color: var(--text-primary);
            border-radius: 10px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .user-btn:hover {
            border-color: var(--accent-purple);
            color: var(--accent-purple);
            background: transparent;
            box-shadow: 0 0 15px rgba(191, 0, 255, 0.3), inset 0 0 10px rgba(191, 0, 255, 0.05);
        }

        .user-btn.active {
            background: transparent;
            border-color: var(--accent-purple);
            color: var(--accent-purple);
            box-shadow: 0 0 20px rgba(191, 0, 255, 0.5), 0 0 40px rgba(191, 0, 255, 0.3), inset 0 0 15px rgba(191, 0, 255, 0.1);
        }
        
        .current-user {
            background: var(--bg-tertiary);
            padding: 15px;
            border-radius: 10px;
            border-left: 4px solid var(--accent-green);
            font-weight: 600;
        }
        
        .station-tabs {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }
        
        .station-tab {
            padding: 20px;
            background: transparent;
            border: 2px solid var(--border);
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .station-tab:hover {
            transform: translateY(-2px);
            border-color: var(--accent-purple);
            color: var(--accent-purple);
            box-shadow: 0 0 20px rgba(191, 0, 255, 0.3), 0 5px 20px rgba(0,0,0,0.3), inset 0 0 10px rgba(191, 0, 255, 0.05);
        }

        .station-tab.active {
            border-color: var(--accent-purple);
            background: transparent;
            color: var(--accent-purple);
            box-shadow: 0 0 20px rgba(191, 0, 255, 0.5), 0 0 40px rgba(191, 0, 255, 0.3), inset 0 0 15px rgba(191, 0, 255, 0.1);
        }
        
        .station-tab h3 {
            font-size: 1.2rem;
            margin-bottom: 5px;
        }
        
        .station-tab .icon {
            font-size: 2rem;
            margin-bottom: 10px;
            position: relative;
            display: inline-block;
        }
        
        .badge {
            position: absolute;
            top: -8px;
            right: -12px;
            background: linear-gradient(135deg, var(--accent-purple), var(--accent-blue));
            color: white;
            font-size: 0.75rem;
            font-weight: 700;
            padding: 3px 8px;
            border-radius: 12px;
            min-width: 20px;
            text-align: center;
            box-shadow: 0 2px 8px rgba(147, 51, 234, 0.3);
            display: none;
        }
        
        .badge.has-count {
            display: inline-block;
        }
        
        .station-content {
            display: none;
            animation: fadeIn 0.3s ease;
        }
        
        .station-content.active {
            display: block;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .form-section {
            background: var(--bg-secondary);
            padding: 30px;
            border-radius: 15px;
            margin-bottom: 20px;
            border: 2px solid var(--border);
        }
        
        .form-section h2 {
            font-size: 1.5rem;
            margin-bottom: 20px;
            color: var(--accent-purple);
            font-family: 'Space Mono', monospace;
        }
        
        .form-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .checkbox-group {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 10px;
        }
        
        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .checkbox-item:hover {
            background: rgba(147, 51, 234, 0.1);
        }
        
        .checkbox-item input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }
        
        .btn {
            padding: 15px 30px;
            background: transparent;
            color: var(--accent-purple);
            border: 2px solid var(--accent-purple);
            border-radius: 10px;
            font-size: 1rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 0 10px rgba(191, 0, 255, 0.3), inset 0 0 10px rgba(191, 0, 255, 0.05);
        }

        .btn:hover {
            background: rgba(191, 0, 255, 0.15);
            transform: translateY(-2px);
            box-shadow: 0 0 20px rgba(191, 0, 255, 0.5), 0 0 40px rgba(191, 0, 255, 0.3), inset 0 0 15px rgba(191, 0, 255, 0.1);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            box-shadow: none;
        }

        /* Neon button color variants */
        .btn[style*="--accent-green"], .btn[style*="accent-green"] {
            color: var(--accent-green);
            border-color: var(--accent-green);
            box-shadow: 0 0 10px rgba(57, 255, 20, 0.3), inset 0 0 10px rgba(57, 255, 20, 0.05);
        }
        .btn[style*="--accent-green"]:hover, .btn[style*="accent-green"]:hover {
            background: rgba(57, 255, 20, 0.15);
            box-shadow: 0 0 20px rgba(57, 255, 20, 0.5), 0 0 40px rgba(57, 255, 20, 0.3), inset 0 0 15px rgba(57, 255, 20, 0.1);
        }

        .btn[style*="--accent-blue"], .btn[style*="accent-blue"] {
            color: var(--accent-blue);
            border-color: var(--accent-blue);
            box-shadow: 0 0 10px rgba(0, 240, 255, 0.3), inset 0 0 10px rgba(0, 240, 255, 0.05);
        }
        .btn[style*="--accent-blue"]:hover, .btn[style*="accent-blue"]:hover {
            background: rgba(0, 240, 255, 0.15);
            box-shadow: 0 0 20px rgba(0, 240, 255, 0.5), 0 0 40px rgba(0, 240, 255, 0.3), inset 0 0 15px rgba(0, 240, 255, 0.1);
        }

        .btn[style*="--accent-orange"], .btn[style*="accent-orange"] {
            color: var(--accent-orange);
            border-color: var(--accent-orange);
            box-shadow: 0 0 10px rgba(255, 107, 0, 0.3), inset 0 0 10px rgba(255, 107, 0, 0.05);
        }
        .btn[style*="--accent-orange"]:hover, .btn[style*="accent-orange"]:hover {
            background: rgba(255, 107, 0, 0.15);
            box-shadow: 0 0 20px rgba(255, 107, 0, 0.5), 0 0 40px rgba(255, 107, 0, 0.3), inset 0 0 15px rgba(255, 107, 0, 0.1);
        }

        .btn[style*="--accent-red"], .btn[style*="accent-red"] {
            color: var(--accent-red);
            border-color: var(--accent-red);
            box-shadow: 0 0 10px rgba(255, 0, 85, 0.3), inset 0 0 10px rgba(255, 0, 85, 0.05);
        }
        .btn[style*="--accent-red"]:hover, .btn[style*="accent-red"]:hover {
            background: rgba(255, 0, 85, 0.15);
            box-shadow: 0 0 20px rgba(255, 0, 85, 0.5), 0 0 40px rgba(255, 0, 85, 0.3), inset 0 0 15px rgba(255, 0, 85, 0.1);
        }

        .btn[style*="--accent-pink"], .btn[style*="accent-pink"] {
            color: var(--accent-pink);
            border-color: var(--accent-pink);
            box-shadow: 0 0 10px rgba(255, 16, 240, 0.3), inset 0 0 10px rgba(255, 16, 240, 0.05);
        }
        .btn[style*="--accent-pink"]:hover, .btn[style*="accent-pink"]:hover {
            background: rgba(255, 16, 240, 0.15);
            box-shadow: 0 0 20px rgba(255, 16, 240, 0.5), 0 0 40px rgba(255, 16, 240, 0.3), inset 0 0 15px rgba(255, 16, 240, 0.1);
        }

        /* Neon outline overrides for buttons with inline background styles */
        .btn[style*="background"] {
            background: transparent !important;
            border: 2px solid var(--accent-purple) !important;
            color: var(--accent-purple) !important;
            box-shadow: 0 0 10px rgba(191, 0, 255, 0.3), inset 0 0 10px rgba(191, 0, 255, 0.05);
        }
        .btn[style*="background"]:hover {
            background: rgba(191, 0, 255, 0.15) !important;
            box-shadow: 0 0 20px rgba(191, 0, 255, 0.5), 0 0 40px rgba(191, 0, 255, 0.3), inset 0 0 15px rgba(191, 0, 255, 0.1);
        }

        /* Green neon buttons */
        .btn[style*="accent-green"], .btn[style*="#39ff14"], .btn[style*="#10B981"], .btn[style*="10B981"] {
            border-color: var(--accent-green) !important;
            color: var(--accent-green) !important;
            box-shadow: 0 0 10px rgba(57, 255, 20, 0.3), inset 0 0 10px rgba(57, 255, 20, 0.05);
        }
        .btn[style*="accent-green"]:hover, .btn[style*="#39ff14"]:hover, .btn[style*="#10B981"]:hover, .btn[style*="10B981"]:hover {
            background: rgba(57, 255, 20, 0.15) !important;
            box-shadow: 0 0 20px rgba(57, 255, 20, 0.5), 0 0 40px rgba(57, 255, 20, 0.3), inset 0 0 15px rgba(57, 255, 20, 0.1);
        }

        /* Blue neon buttons */
        .btn[style*="accent-blue"], .btn[style*="#0055ff"], .btn[style*="#3B82F6"], .btn[style*="3B82F6"] {
            border-color: var(--accent-blue) !important;
            color: var(--accent-blue) !important;
            box-shadow: 0 0 10px rgba(0, 240, 255, 0.3), inset 0 0 10px rgba(0, 240, 255, 0.05);
        }
        .btn[style*="accent-blue"]:hover, .btn[style*="#0055ff"]:hover, .btn[style*="#3B82F6"]:hover, .btn[style*="3B82F6"]:hover {
            background: rgba(0, 240, 255, 0.15) !important;
            box-shadow: 0 0 20px rgba(0, 240, 255, 0.5), 0 0 40px rgba(0, 240, 255, 0.3), inset 0 0 15px rgba(0, 240, 255, 0.1);
        }

        /* Orange neon buttons */
        .btn[style*="accent-orange"], .btn[style*="#ff6b00"] {
            border-color: var(--accent-orange) !important;
            color: var(--accent-orange) !important;
            box-shadow: 0 0 10px rgba(255, 107, 0, 0.3), inset 0 0 10px rgba(255, 107, 0, 0.05);
        }
        .btn[style*="accent-orange"]:hover, .btn[style*="#ff6b00"]:hover {
            background: rgba(255, 107, 0, 0.15) !important;
            box-shadow: 0 0 20px rgba(255, 107, 0, 0.5), 0 0 40px rgba(255, 107, 0, 0.3), inset 0 0 15px rgba(255, 107, 0, 0.1);
        }

        /* Red neon buttons */
        .btn[style*="accent-red"], .btn[style*="#ff0055"] {
            border-color: var(--accent-red) !important;
            color: var(--accent-red) !important;
            box-shadow: 0 0 10px rgba(255, 0, 85, 0.3), inset 0 0 10px rgba(255, 0, 85, 0.05);
        }
        .btn[style*="accent-red"]:hover, .btn[style*="#ff0055"]:hover {
            background: rgba(255, 0, 85, 0.15) !important;
            box-shadow: 0 0 20px rgba(255, 0, 85, 0.5), 0 0 40px rgba(255, 0, 85, 0.3), inset 0 0 15px rgba(255, 0, 85, 0.1);
        }

        /* Gradient neon buttons - use purple as primary with multi-color glow */
        .btn[style*="linear-gradient"] {
            border-color: var(--accent-purple) !important;
            color: var(--accent-purple) !important;
            box-shadow: 0 0 10px rgba(191, 0, 255, 0.3), 0 0 20px rgba(0, 240, 255, 0.2), inset 0 0 10px rgba(191, 0, 255, 0.05);
        }
        .btn[style*="linear-gradient"]:hover {
            background: rgba(191, 0, 255, 0.15) !important;
            box-shadow: 0 0 25px rgba(191, 0, 255, 0.5), 0 0 40px rgba(0, 240, 255, 0.4), 0 0 60px rgba(255, 16, 240, 0.3), inset 0 0 15px rgba(191, 0, 255, 0.1);
        }

        /* Silver neon buttons (machine status) */
        .btn[style*="#C0C0C0"], .btn[style*="C0C0C0"] {
            background: transparent !important;
            border-color: #C0C0C0 !important;
            color: #E8E8E8 !important;
            box-shadow: 0 0 15px rgba(192, 192, 192, 0.4), 0 0 30px rgba(192, 192, 192, 0.2), inset 0 0 15px rgba(192, 192, 192, 0.05) !important;
        }
        .btn[style*="#C0C0C0"]:hover, .btn[style*="C0C0C0"]:hover {
            background: rgba(192, 192, 192, 0.15) !important;
            box-shadow: 0 0 25px rgba(192, 192, 192, 0.6), 0 0 50px rgba(192, 192, 192, 0.3), inset 0 0 20px rgba(192, 192, 192, 0.1) !important;
        }

        /* Gold neon buttons (pull batch) */
        .btn[style*="#FFD700"], .btn[style*="FFD700"] {
            background: transparent !important;
            border-color: #FFD700 !important;
            color: #FFD700 !important;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.4), 0 0 30px rgba(255, 215, 0, 0.2), inset 0 0 15px rgba(255, 215, 0, 0.05) !important;
        }
        .btn[style*="#FFD700"]:hover, .btn[style*="FFD700"]:hover {
            background: rgba(255, 215, 0, 0.15) !important;
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.6), 0 0 50px rgba(255, 215, 0, 0.3), inset 0 0 20px rgba(255, 215, 0, 0.1) !important;
        }

        /* Tertiary/muted neon buttons */
        .btn[style*="bg-tertiary"] {
            border-color: var(--text-secondary) !important;
            color: var(--text-primary) !important;
            box-shadow: 0 0 8px rgba(136, 136, 136, 0.2), inset 0 0 8px rgba(136, 136, 136, 0.03);
        }
        .btn[style*="bg-tertiary"]:hover {
            border-color: var(--accent-purple) !important;
            color: var(--accent-purple) !important;
            background: rgba(191, 0, 255, 0.1) !important;
            box-shadow: 0 0 15px rgba(191, 0, 255, 0.4), inset 0 0 10px rgba(191, 0, 255, 0.05);
        }

        .batch-list {
            background: var(--bg-secondary);
            padding: 30px;
            border-radius: 15px;
            border: 2px solid var(--border);
        }
        
        .batch-list h2 {
            font-size: 1.5rem;
            margin-bottom: 20px;
            color: var(--accent-green);
            font-family: 'Space Mono', monospace;
        }
        
        .batch-item {
            background: var(--bg-tertiary);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 15px;
            border-left: 4px solid var(--accent-purple);
            position: relative;
            transition: all 0.3s ease;
        }
        
        .batch-item:hover {
            transform: translateX(5px);
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
        }
        
        .batch-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .batch-id {
            font-family: 'Space Mono', monospace;
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--accent-purple);
        }
        
        .batch-status {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 1rem;
            font-weight: 600;
            text-transform: uppercase;
        }
        
        .status-intake { background: var(--accent-blue); }
        .status-extraction { background: var(--accent-orange); }
        .status-finishing { background: var(--accent-green); }
        .status-packaging { background: var(--accent-red); }
        .status-complete { background: #6b7280; }
        
        .batch-details {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .batch-detail {
            display: flex;
            flex-direction: column;
        }
        
        .batch-detail-label {
            font-size: 0.95rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 5px;
        }
        
        .batch-detail-value {
            font-size: 1.15rem;
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .batch-actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        
        .btn-small {
            padding: 8px 16px;
            font-size: 1rem;
            background: transparent;
            color: var(--accent-purple);
            border: 2px solid var(--accent-purple);
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 0 8px rgba(191, 0, 255, 0.3), inset 0 0 8px rgba(191, 0, 255, 0.05);
        }

        .btn-small:hover {
            background: rgba(191, 0, 255, 0.15);
            box-shadow: 0 0 15px rgba(191, 0, 255, 0.5), 0 0 30px rgba(191, 0, 255, 0.3), inset 0 0 10px rgba(191, 0, 255, 0.1);
        }
        
        .filter-bar {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .filter-btn {
            padding: 10px 20px;
            background: transparent;
            border: 2px solid var(--border);
            color: var(--text-primary);
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }

        .filter-btn:hover {
            border-color: var(--accent-purple);
            color: var(--accent-purple);
            box-shadow: 0 0 15px rgba(191, 0, 255, 0.3), inset 0 0 10px rgba(191, 0, 255, 0.05);
        }

        .filter-btn.active {
            background: transparent;
            border-color: var(--accent-purple);
            color: var(--accent-purple);
            box-shadow: 0 0 15px rgba(191, 0, 255, 0.4), 0 0 30px rgba(191, 0, 255, 0.2), inset 0 0 10px rgba(191, 0, 255, 0.1);
        }
        
        .search-box {
            flex: 1;
            min-width: 250px;
        }
        
        .search-box input {
            width: 100%;
            padding: 12px;
            background: var(--bg-tertiary);
            border: 2px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 1rem;
        }
        
        .timeline {
            position: relative;
            padding-left: 30px;
            margin-top: 15px;
        }
        
        .timeline::before {
            content: '';
            position: absolute;
            left: 8px;
            top: 0;
            bottom: 0;
            width: 2px;
            background: var(--border);
        }
        
        .timeline-item {
            position: relative;
            padding-bottom: 20px;
        }
        
        .timeline-item::before {
            content: '';
            position: absolute;
            left: -26px;
            top: 5px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--accent-purple);
            border: 2px solid var(--bg-primary);
        }
        
        .timeline-content {
            background: rgba(147, 51, 234, 0.1);
            padding: 10px 15px;
            border-radius: 8px;
            border-left: 3px solid var(--accent-purple);
        }
        
        .timeline-user {
            font-weight: 600;
            color: var(--accent-purple);
        }
        
        .timeline-date {
            font-size: 1rem;
            color: var(--text-secondary);
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .stat-card {
            background: var(--bg-secondary);
            padding: 20px;
            border-radius: 15px;
            border: 2px solid var(--border);
            text-align: center;
        }
        
        .stat-value {
            font-size: 2rem;
            font-weight: 700;
            color: var(--accent-purple);
            font-family: 'Space Mono', monospace;
        }
        
        .stat-label {
            font-size: 1.05rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 5px;
        }
        
        .success-message {
            background: rgba(16, 185, 129, 0.2);
            border: 2px solid var(--accent-green);
            color: var(--accent-green);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            font-weight: 600;
            text-align: center;
        }
        
        .error-message {
            background: rgba(239, 68, 68, 0.2);
            border: 2px solid var(--accent-red);
            color: var(--accent-red);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            font-weight: 600;
            text-align: center;
        }
        
        .leaflink-section {
            background: rgba(59, 130, 246, 0.1);
            border: 2px solid var(--accent-blue);
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
        }
        
        .leaflink-section h3 {
            color: var(--accent-blue);
            margin-bottom: 15px;
        }

        .app-container {
            display: none;
        }

        .app-container.active {
            display: block;
        }

        .analytics-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        .analytics-table th {
            background: var(--bg-tertiary);
            padding: 15px;
            text-align: left;
            font-weight: 700;
            text-transform: uppercase;
            font-size: 1rem;
            letter-spacing: 0.5px;
            color: var(--text-secondary);
            border-bottom: 2px solid var(--border);
        }

        .analytics-table td {
            padding: 15px;
            border-bottom: 1px solid var(--border);
            font-size: 1.05rem;
        }

        .analytics-table tr:hover {
            background: rgba(147, 51, 234, 0.05);
        }

        .profit-positive {
            color: var(--accent-green);
            font-weight: 600;
        }

        .profit-negative {
            color: var(--accent-red);
            font-weight: 600;
        }

                /* METRC Manifest hover effects */
                #manifestsContainer > div:hover {
                    background: rgba(147, 51, 234, 0.1) !important;
                    border-color: var(--accent-purple) !important;
                    transform: translateY(-2px);
                    box-shadow: 0 8px 25px rgba(147, 51, 234, 0.3);
                }
        
                .actions-menu {
                    position: fixed;
                    top: 20px;
                    left: 20px;
                    z-index: 1000;
                }
        
                .actions-toggle-btn {
                    background: transparent;
                    color: var(--accent-purple);
                    border: 2px solid var(--accent-purple);
                    padding: 12px 24px;
                    border-radius: 12px;
                    font-weight: 700;
                    cursor: pointer;
                    font-size: 1rem;
                    box-shadow: 0 0 15px rgba(191, 0, 255, 0.4), 0 0 30px rgba(0, 240, 255, 0.2), inset 0 0 10px rgba(191, 0, 255, 0.05);
                    transition: all 0.3s ease;
                }

                .actions-toggle-btn:hover {
                    background: rgba(191, 0, 255, 0.15);
                    box-shadow: 0 0 25px rgba(191, 0, 255, 0.6), 0 0 50px rgba(0, 240, 255, 0.4), inset 0 0 15px rgba(191, 0, 255, 0.1);
                }

                .actions-dropdown {
                    display: none;
                    position: absolute;
                    top: 100%;
                    left: 0;
                    background: var(--bg-secondary);
                    border-radius: 12px;
                    padding: 10px;
                    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.5), 0 0 20px rgba(191, 0, 255, 0.2);
                    margin-top: 10px;
                    width: 200px;
                    border: 2px solid var(--accent-purple);
                }

                .actions-dropdown button {
                    display: block;
                    width: 100%;
                    padding: 10px;
                    margin-bottom: 5px;
                    text-align: left;
                    background: transparent;
                    color: var(--text-primary);
                    border: 1px solid var(--border);
                    border-radius: 8px;
                    font-size: 0.9rem;
                    transition: all 0.2s ease;
                }

                .actions-dropdown button:hover {
                    background: transparent;
                    border-color: var(--accent-purple);
                    color: var(--accent-purple);
                    box-shadow: 0 0 10px rgba(191, 0, 255, 0.3), inset 0 0 8px rgba(191, 0, 255, 0.05);
                }
                
                        #connectionStatus {
                            display: none !important;
                        }
                                
                @media (max-width: 768px) {            body {
                padding: 10px;
                font-size: 1rem;
            }

            .header {
                padding: 20px;
                margin-bottom: 20px;
            }

            .header h1 {
                font-size: 1.8rem;
            }

            .form-section, .setup-section, .user-login, .batch-list {
                padding: 20px;
            }

            .form-section h2, .batch-list h2, .setup-section h2, .user-login h2 {
                font-size: 1.3rem;
            }

            /* App Icon Style Navigation */
            .station-tabs {
                display: grid;
                grid-template-columns: repeat(3, 1fr);
                gap: 15px;
                padding: 10px;
            }

            .station-tab {
                padding: 12px 8px;
                aspect-ratio: 1;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                border-radius: 20px;
                background: linear-gradient(145deg, rgba(40, 40, 60, 0.9), rgba(25, 25, 40, 0.95));
                border: 1px solid rgba(255, 255, 255, 0.1);
                box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.1);
            }

            .station-tab:hover, .station-tab.active {
                transform: scale(1.05);
                box-shadow: 0 0 20px rgba(191, 0, 255, 0.4), 0 4px 15px rgba(0, 0, 0, 0.3);
            }

            .station-tab .icon {
                font-size: 2rem;
                margin-bottom: 5px;
            }

            .station-tab h3 {
                font-size: 0.7rem;
                text-align: center;
                margin: 0;
                line-height: 1.2;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
                max-width: 100%;
            }

            .station-tab p {
                display: none;
            }

            .station-tab .badge {
                position: absolute;
                top: -5px;
                right: -5px;
                font-size: 0.65rem;
                min-width: 16px;
                height: 16px;
                padding: 0 4px;
            }

            /* Mobile Popup Page Styles */
            .station-content {
                display: none;
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: var(--bg-primary);
                z-index: 1000;
                overflow-y: auto;
                padding: 60px 15px 20px 15px;
                animation: slideUp 0.25s ease-out;
            }

            .station-content.active {
                display: block;
            }

            @keyframes slideUp {
                from { transform: translateY(100%); opacity: 0; }
                to { transform: translateY(0); opacity: 1; }
            }

            /* Back button for mobile popups */
            .mobile-back-btn {
                position: fixed;
                top: 15px;
                left: 15px;
                z-index: 1002;
                background: rgba(30, 30, 45, 0.95);
                border: 2px solid var(--accent-purple);
                color: var(--text-primary);
                padding: 10px 18px;
                border-radius: 25px;
                font-size: 1rem;
                font-weight: 600;
                cursor: pointer;
                box-shadow: 0 0 15px rgba(191, 0, 255, 0.3);
                display: block;
            }

            /* Keep station tabs visible as home screen */
            .station-tabs {
                position: relative;
                z-index: 1;
            }

            .btn {
                padding: 12px 20px;
                font-size: 0.9rem;
            }

            #batchDetailsModal > div, #editBatchModal > div {
                width: 95%;
                margin: 20px auto;
                padding: 20px;
            }

            #myStatsBtn, #timeClockBtn, #viewTimecardsBtn {
                position: relative;
                top: auto;
                left: auto;
                width: 100%;
                margin-bottom: 10px;
                display: block !important;
            }
            
            .header-content {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .filter-bar {
                flex-direction: column;
            }
            
            .search-box {
                min-width: unset;
                width: 100%;
            }

            /* Front of House Mobile Fixes */

            /* Force Generate Post to stack vertically */
            .foh-generate-container {
                flex-direction: column !important;
            }

            #fohQuickInput {
                width: 100% !important;
                flex: none !important;
                min-width: 100% !important;
                box-sizing: border-box !important;
            }

            .foh-generate-btn {
                width: 100% !important;
                flex: none !important;
            }

            #frontofhouse div[style*="display: flex"] {
                flex-wrap: wrap !important;
            }

            #frontofhouse div[style*="display: flex"][style*="justify-content: space-between"],
            #frontofhouse div[style*="display: flex"][style*="gap: 15px"] {
                flex-direction: column !important;
                align-items: stretch !important;
                gap: 10px !important;
            }

            #frontofhouse .btn,
            #frontofhouse button.btn,
            #frontofhouse a.btn {
                width: 100% !important;
                text-align: center !important;
                padding: 12px 20px !important;
                margin: 0 !important;
            }

            #frontofhouse input[type="text"] {
                width: 100% !important;
                max-width: 100% !important;
                flex: none !important;
                margin: 0 !important;
                box-sizing: border-box !important;
            }

            /* Sales Dashboard Mobile Fixes */
            #frontofhouse select {
                width: 100% !important;
                min-width: unset !important;
            }

            /* Generated Preview buttons */
            #fohGeneratedPreview div[style*="display: flex"] {
                flex-direction: column !important;
                gap: 10px !important;
            }

            /* Reduce padding on containers */
            #frontofhouse > div > div[style*="padding: 25px"] {
                padding: 15px !important;
            }
        }

        /* Extra aggressive fix for smaller phones */
        @media (max-width: 600px) {
            body {
                font-size: 0.9rem;
            }

            .foh-generate-container {
                display: block !important;
            }

            #fohQuickInput {
                display: block !important;
                width: 100% !important;
                margin-bottom: 10px !important;
                font-size: 1rem !important;
            }

            .foh-generate-btn {
                display: block !important;
                width: 100% !important;
                font-size: 1rem !important;
                padding: 12px !important;
            }

            #frontofhouse button,
            #frontofhouse .btn {
                font-size: 0.95rem !important;
                padding: 10px 15px !important;
            }

            #frontofhouse .form-section {
                padding: 15px !important;
            }

            /* Fix Sales Dashboard grid minimum width */
            #salesDashboardStats {
                grid-template-columns: 1fr !important;
            }

            /* Sales Bar Chart mobile fixes */
            #salesBarChart {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }
        }
    </style>
</head>
<body>
    <div class="connection-status connecting" id="connectionStatus">
        <div class="status-dot"></div>
        <span id="statusText">Connecting...</span>
    </div>
    
    <div class="actions-menu" id="actionsMenu" style="display: none;">
        <button class="actions-toggle-btn" onclick="toggleActionsMenu()">Actions</button>
        <div class="actions-dropdown">
            <button id="logoutBtn" onclick="logout()" style="display: none; background: transparent; border: 2px solid var(--accent-red); color: var(--accent-red); box-shadow: 0 0 15px rgba(255, 0, 85, 0.4), 0 0 30px rgba(255, 0, 85, 0.2);">ðŸšª Log Out</button>
            <button id="myStatsBtn" onclick="openPersonalStatsModal()" style="display: none;">ðŸ‘¤ My Workload</button>
            <button id="timeClockBtn" onclick="openTimeClockModal()" style="display: none;">Time Clock</button>
            <button id="viewTimecardsBtn" onclick="openTimecardsModal()" style="display: none;">Timecards</button>
            <button id="viewTrashBtn" onclick="openTrashModal()" style="display: none;">ðŸ—‘ï¸ Deleted Batches</button>
            <button id="complianceBtn" onclick="openComplianceModal()" style="display: none;">ðŸ“‹ Compliance</button>
            <button id="loginHistoryBtn" onclick="openLoginHistoryModal()" style="display: none;">ðŸ“Š Login History</button>
            <button id="leaflinkApprovalsBtn" onclick="openLeafLinkApprovalsModal()" style="display: none;">ðŸ›’ LeafLink Queue</button>
            <button id="manageEmployeesBtn" onclick="openEmployeeManagement()" style="display: none;">ðŸ‘¥ Manage Employees</button>
            <button id="adminConfigBtn" onclick="window.open('admin-config.html', '_blank')" style="display: none;">âš™ï¸ Admin Config</button>
        </div>
    </div>

    <!-- Login History Modal -->
    <div id="loginHistoryModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); z-index: 10005; overflow-y: auto;">
        <div style="max-width: 800px; margin: 30px auto; background: var(--bg-secondary); border-radius: 20px; overflow: hidden;">
            <div style="background: linear-gradient(135deg, var(--accent-purple), var(--accent-blue)); padding: 25px; display: flex; justify-content: space-between; align-items: center;">
                <h2 style="margin: 0; color: white;">ðŸ“Š Login History</h2>
                <button onclick="closeLoginHistoryModal()" style="background: rgba(255,255,255,0.2); border: none; color: white; font-size: 1.5rem; cursor: pointer; padding: 5px 15px; border-radius: 8px;">&times;</button>
            </div>
            <div style="padding: 25px;">
                <div id="loginHistoryContent" style="max-height: 500px; overflow-y: auto;">
                    Loading...
                </div>
            </div>
        </div>
    </div>

    <!-- LeafLink Approvals Modal -->
    <div id="leaflinkApprovalsModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); z-index: 10005; overflow-y: auto;">
        <div style="max-width: 600px; margin: 30px auto; background: var(--bg-secondary); border-radius: 20px; overflow: hidden;">
            <div style="background: linear-gradient(135deg, #10B981, #059669); padding: 25px; display: flex; justify-content: space-between; align-items: center;">
                <h2 style="margin: 0; color: white;">ðŸ›’ LeafLink Approval Queue</h2>
                <button onclick="closeLeafLinkApprovalsModal()" style="background: rgba(255,255,255,0.2); border: none; color: white; font-size: 1.5rem; cursor: pointer; padding: 5px 15px; border-radius: 8px;">&times;</button>
            </div>
            <div style="padding: 25px;">
                <p style="color: var(--text-secondary); margin-bottom: 15px; font-size: 0.9em;">
                    Batches awaiting approval before being pushed to LeafLink inventory.
                </p>
                <div id="leaflinkApprovalQueue" style="max-height: 500px; overflow-y: auto;">
                    Loading...
                </div>
            </div>
        </div>
    </div>

    <!-- Employee Management Modal -->
    <div id="employeeManagementModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); z-index: 10005; overflow-y: auto;">
        <div style="max-width: 700px; margin: 30px auto; background: var(--bg-secondary); border-radius: 20px; overflow: hidden;">
            <div style="background: linear-gradient(135deg, var(--accent-purple), var(--accent-blue)); padding: 25px; display: flex; justify-content: space-between; align-items: center;">
                <h2 style="margin: 0; color: white;">ðŸ‘¥ Manage Employees</h2>
                <button onclick="closeEmployeeManagement()" style="background: rgba(255,255,255,0.2); border: none; color: white; font-size: 1.5rem; cursor: pointer; padding: 5px 15px; border-radius: 8px;">&times;</button>
            </div>
            <div style="padding: 25px;">
                <button onclick="openAddEmployee()" style="background: var(--accent-green); color: white; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-size: 1rem; margin-bottom: 20px;">+ Add Employee</button>
                <div id="employeeListContent" style="max-height: 500px; overflow-y: auto;">
                    Loading...
                </div>
            </div>
        </div>
    </div>

    <!-- Add/Edit Employee Modal -->
    <div id="employeeFormModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); z-index: 10006; overflow-y: auto;">
        <div style="max-width: 500px; margin: 30px auto; background: var(--bg-secondary); border-radius: 20px; overflow: hidden;">
            <div style="background: linear-gradient(135deg, var(--accent-green), var(--accent-blue)); padding: 25px; display: flex; justify-content: space-between; align-items: center;">
                <h2 id="employeeFormTitle" style="margin: 0; color: white;">Add Employee</h2>
                <button onclick="closeEmployeeForm()" style="background: rgba(255,255,255,0.2); border: none; color: white; font-size: 1.5rem; cursor: pointer; padding: 5px 15px; border-radius: 8px;">&times;</button>
            </div>
            <div style="padding: 25px;">
                <input type="hidden" id="employeeEditId">
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; color: var(--text-secondary);">Name</label>
                    <input type="text" id="employeeName" style="width: 100%; padding: 12px; border-radius: 8px; border: 1px solid var(--border-color); background: var(--bg-tertiary); color: var(--text-primary); font-size: 1rem;" placeholder="Employee name">
                </div>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; color: var(--text-secondary);">PIN (4 digits)</label>
                    <input type="text" id="employeePIN" maxlength="4" style="width: 100%; padding: 12px; border-radius: 8px; border: 1px solid var(--border-color); background: var(--bg-tertiary); color: var(--text-primary); font-size: 1rem;" placeholder="1234">
                </div>
                <div style="margin-bottom: 20px; display: flex; gap: 20px; flex-wrap: wrap;">
                    <label style="display: flex; align-items: center; gap: 8px; color: var(--text-primary); cursor: pointer;">
                        <input type="checkbox" id="employeeIsAdmin" style="width: 18px; height: 18px;"> Admin
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; color: var(--text-primary); cursor: pointer;">
                        <input type="checkbox" id="employeeIsSalary" style="width: 18px; height: 18px;"> Salary
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; color: var(--text-primary); cursor: pointer;">
                        <input type="checkbox" id="employeeReadOnly" style="width: 18px; height: 18px;"> Read Only
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; color: var(--text-primary); cursor: pointer;">
                        <input type="checkbox" id="employeeCanEditBatches" style="width: 18px; height: 18px;"> Can Edit Batches
                    </label>
                </div>
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 10px; color: var(--text-secondary);">Station Access</label>
                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">
                        <label style="display: flex; align-items: center; gap: 8px; color: var(--text-primary); cursor: pointer;">
                            <input type="checkbox" class="station-checkbox" value="dashboard" style="width: 16px; height: 16px;"> Dashboard
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; color: var(--text-primary); cursor: pointer;">
                            <input type="checkbox" class="station-checkbox" value="intake" style="width: 16px; height: 16px;"> Intake
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; color: var(--text-primary); cursor: pointer;">
                            <input type="checkbox" class="station-checkbox" value="extraction" style="width: 16px; height: 16px;"> Extraction
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; color: var(--text-primary); cursor: pointer;">
                            <input type="checkbox" class="station-checkbox" value="finishing" style="width: 16px; height: 16px;"> Post-Extract
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; color: var(--text-primary); cursor: pointer;">
                            <input type="checkbox" class="station-checkbox" value="packaging" style="width: 16px; height: 16px;"> Packaging
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; color: var(--text-primary); cursor: pointer;">
                            <input type="checkbox" class="station-checkbox" value="testing" style="width: 16px; height: 16px;"> Testing
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; color: var(--text-primary); cursor: pointer;">
                            <input type="checkbox" class="station-checkbox" value="labeling" style="width: 16px; height: 16px;"> Labeling
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; color: var(--text-primary); cursor: pointer;">
                            <input type="checkbox" class="station-checkbox" value="analytics" style="width: 16px; height: 16px;"> Analytics
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; color: var(--text-primary); cursor: pointer;">
                            <input type="checkbox" class="station-checkbox" value="performance" style="width: 16px; height: 16px;"> Performance
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; color: var(--text-primary); cursor: pointer;">
                            <input type="checkbox" class="station-checkbox" value="frontofhouse" style="width: 16px; height: 16px;"> Front of House
                        </label>
                    </div>
                </div>
                <div style="display: flex; gap: 10px; justify-content: space-between;">
                    <button id="deactivateEmployeeBtn" onclick="deactivateEmployee()" style="display: none; background: var(--accent-red); color: white; border: none; padding: 12px 20px; border-radius: 8px; cursor: pointer;">Deactivate</button>
                    <div style="display: flex; gap: 10px; margin-left: auto;">
                        <button onclick="closeEmployeeForm()" style="background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border-color); padding: 12px 24px; border-radius: 8px; cursor: pointer;">Cancel</button>
                        <button onclick="saveEmployee()" style="background: var(--accent-green); color: white; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer;">Save</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Setup Section -->
    <div class="setup-section hidden" id="setupSection">
        <h2>âš™ï¸ Supabase Configuration</h2>
        <p style="margin-bottom: 20px; color: var(--text-secondary);">
            Enter your Supabase credentials once. They'll be saved securely in your browser.
        </p>
        <form class="credentials-form" id="credentialsForm">
            <div class="form-group">
                <label>Supabase Project URL</label>
                <input type="text" id="supabaseUrl" placeholder="https://xxxxx.supabase.co" required>
                <div class="help-text">Found in Project Settings â†’ API â†’ Project URL</div>
            </div>
            <div class="form-group">
                <label>Supabase Anon/Public Key</label>
                <input type="text" id="supabaseKey" placeholder="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..." required>
                <div class="help-text">Found in Project Settings â†’ API â†’ Project API keys â†’ anon public</div>
            </div>
            <button type="submit" class="btn">Connect to Supabase</button>
        </form>
        <div style="margin-top: 20px; padding: 15px; background: rgba(245, 158, 11, 0.1); border-radius: 8px; border-left: 4px solid var(--accent-orange);">
            <strong>First Time Setup:</strong> After connecting, I'll automatically create the required database table for you.
        </div>
    </div>

    <!-- Main App -->
    <div class="app-container" id="appContainer">
        <div class="header">
            <div class="header-content">
                <div class="header-logo">
                    <img src="https://images.squarespace-cdn.com/content/v1/5501f606e4b0b9ba3b7be5ec/1537298893777-QBVYYWKI0KBKGYJGQJB5/WM.png?format=1500w" alt="White Mousse">
                </div>
                <div id="versionTag" style="position: absolute; top: 5px; right: 10px; font-size: 0.7rem; color: var(--text-muted); opacity: 0.6;">v8c70897</div>
                            </div>
        </div>
        <!-- Demo Mode Indicator -->
        <div id="demoIndicator" style="display: none; background: linear-gradient(90deg, var(--accent-purple), var(--accent-blue)); color: white; text-align: center; padding: 8px; font-weight: 700; font-size: 0.9rem;">
            ðŸŽ® DEMO MODE - No database changes will be saved
        </div>

        <div class="user-login" id="userLogin">
            
            <form id="pinForm" style="max-width: 300px; margin: 0 auto;" onsubmit="event.preventDefault(); login();">
                <input type="password" 
                       id="pinInput" 
                       maxlength="4" 
                       pattern="[0-9]{4}" 
                       placeholder=""
                       inputmode="numeric"
                       autocomplete="off"
                       style="width: 100%; padding: 15px; font-size: 1.5rem; text-align: center; letter-spacing: 10px; background: var(--bg-tertiary); border: 2px solid var(--border); border-radius: 10px; color: var(--text-primary); font-family: 'Space Mono', monospace; margin-bottom: 15px;">
                <button type="submit" id="loginBtn" style="width: 100%; padding: 15px; background: transparent; border: 2px solid var(--accent-purple); border-radius: 10px; color: var(--accent-purple); font-size: 1.1rem; font-weight: 700; cursor: pointer; box-shadow: 0 0 15px rgba(191, 0, 255, 0.4), 0 0 30px rgba(191, 0, 255, 0.2), inset 0 0 15px rgba(191, 0, 255, 0.05);">Login</button>
                <div id="loginError" style="color: var(--accent-red); text-align: center; margin-top: 10px; display: none;">Invalid PIN</div>
            </form>
            
        </div>

        <div id="appContent" style="display: none;">
        <div class="station-tabs">
            <div class="station-tab active" data-station="intake">
                <div class="icon">ðŸ“¦</div>
                <h3>Intake</h3>
                <p>Log trim batches</p>
            </div>
            <div class="station-tab" data-station="extraction">
                <div class="icon">âš—ï¸<span class="badge" id="badge-extraction">0</span></div>
                <h3>Extraction</h3>
                <p>Process batches</p>
            </div>
            <div class="station-tab" data-station="finishing">
                <div class="icon">âœ¨<span class="badge" id="badge-finishing">0</span></div>
                <h3>Post Extraction</h3>
                <p>Bulk weight & splitting</p>
            </div>
            <div class="station-tab" data-station="packaging">
                <div class="icon"><svg viewBox="0 0 24 24" width="28" height="28" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="vertical-align: middle;"><ellipse cx="6" cy="6" rx="4" ry="2"/><path d="M6 8c-2.2 0-4-.9-4-2v0M10 6c0 1.1-1.8 2-4 2"/><line x1="8" y1="7" x2="16" y2="15"/><path d="M14 17c0-1.5 1.5-3 4-3s4 1.5 4 3v2c0 1.1-1.8 2-4 2s-4-.9-4-2v-2z"/><path d="M12 13l-1 2"/><path d="M13 14l-1 2"/></svg><span class="badge" id="badge-packaging">0</span></div>
                <h3>Packaging</h3>
                <p>Final count & listing</p>
            </div>
            <div class="station-tab" data-station="testing">
                <div class="icon">ðŸ§ª<span class="badge" id="badge-testing">0</span></div>
                <h3>Testing</h3>
                <p>Test results entry</p>
            </div>
            <div class="station-tab" data-station="labeling">
                <div class="icon">ðŸ·ï¸<span class="badge" id="badge-labeling">0</span></div>
                <h3>Labeling</h3>
                <p>Print & apply labels</p>
            </div>
            <div class="station-tab" data-station="analytics">
                <div class="icon">ðŸ’°</div>
                <h3>Analytics</h3>
                <p>Yield & Cost</p>
            </div>
            <div class="station-tab" data-station="performance">
                <div class="icon">ðŸ‘¥</div>
                <h3>Performance</h3>
                <p>Employee Stats</p>
            </div>
            <div class="station-tab" data-station="dashboard">
                <div class="icon">ðŸ“ˆ</div>
                <h3>Dashboard</h3>
                <p>View all batches</p>
            </div>
            <div class="station-tab" data-station="frontofhouse">
                <div class="icon">ðŸ“£</div>
                <h3>Front of House</h3>
                <p>Blog & Social</p>
            </div>
        </div>

        <!-- Intake Station -->
        <div class="station-content" id="intake">
            <div class="form-section">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h2 style="margin: 0;">ðŸ“¦ New Trim Intake</h2>
                    <button type="button" class="btn" style="background: var(--accent-blue); display: none;" onclick="openMetrcImport()">
                        ðŸ“‹ Import from METRC Manifest
                    </button>
                </div>
                <form id="intakeForm">
                    <div class="form-grid">
                        <div class="form-group">
                            <label>Batch ID (Auto-Generated)</label>
                            <input type="text" id="batchId" readonly>
                        </div>
                        <div class="form-group">
                            <label>Strain Name</label>
                            <input type="text" id="strainName" required>
                        </div>

                        <div class="form-group">
                            <label id="weightLabel">Trim Weight (grams)</label>
                            <input type="number" id="trimWeight" step="0.1" required>
                        </div>
                        <div class="form-group">
                            <label id="socksLabel">Number of Socks</label>
                            <input type="number" id="socksTotal" min="1" value="1" required>
                            <div class="help-text" id="socksHelp">How many socks is this trim packed into?</div>
                        </div>
                        <div class="form-group">
                            <label>Cost of Material ($)</label>
                            <input type="number" id="materialCost" step="0.01" required>
                        </div>
                        <div class="form-group">
                            <label>Material Agreement Type</label>
                            <select id="materialAgreement" required>
                                <option value="">Select Type</option>
                                <option value="Wholesale">Wholesale Purchase (100% owned)</option>
                                <option value="50-50 Split">50/50 Split (customer gets 50% yield)</option>
                                <option value="Custom Buyback">Custom Buyback</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Pre-Sift Before BHO?</label>
                            <select id="preSift" required>
                                <option value="no">No - Direct to BHO</option>
                                <option value="yes">Yes - Sift first</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Cultivation License # (Grower)</label>
                            <input type="text" id="cultivationLicense" placeholder="403R-01007 or 404R-00000" required>
                            <div class="help-text">Grower's license number (cultivation or manufacturing)</div>
                        </div>
                        <div class="form-group">
                            <label>Grower Name (Optional)</label>
                            <input type="text" id="growerName" placeholder="Farm/supplier name">
                        </div>
                        <div class="form-group">
                            <label>METRC Tag Numbers (last 4-5 digits)</label>
                            <input type="text" id="metrcTags" placeholder="e.g., 12345, 67890, 11223">
                            <div class="help-text">Multiple tags separated by commas. Use last 4-5 digits only.</div>
                        </div>
                        <div class="form-group">
                            <label>Intake Date</label>
                            <input type="date" id="intakeDate" required>
                        </div>
                        <div class="form-group">
                            <label>Strain Type</label>
                            <select id="strainType" required>
                                <option value="">Select Type</option>
                                <option value="Indica">Indica (Blue Lid)</option>
                                <option value="Sativa">Sativa (Red Lid)</option>
                                <option value="Hybrid">Hybrid (Green Lid)</option>
                                <option value="Dealer's Choice">Dealer's Choice (Decide at Testing)</option>
                            </select>
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label>Planned Products</label>
                        <div class="checkbox-group">
                            <label class="checkbox-item">
                                <input type="checkbox" name="products" value="Live Resin Carts" onchange="updateMaterialTypeUI()">
                                <span>Live Resin Carts</span>
                            </label>
                            <label class="checkbox-item">
                                <input type="checkbox" name="products" value="Live Resin AIOs" onchange="updateMaterialTypeUI()">
                                <span>Live Resin AIOs</span>
                            </label>
                            <label class="checkbox-item">
                                <input type="checkbox" name="products" value="Wax">
                                <span>Wax</span>
                            </label>
                            <label class="checkbox-item">
                                <input type="checkbox" name="products" value="Sugar Wax">
                                <span>Sugar Wax</span>
                            </label>
                            <label class="checkbox-item">
                                <input type="checkbox" name="products" value="Shatter">
                                <span>Shatter</span>
                            </label>
                            <label class="checkbox-item">
                                <input type="checkbox" name="products" value="Extractor's Choice">
                                <span>Extractor's Choice</span>
                            </label>
                            <label class="checkbox-item">
                                <input type="checkbox" name="products" value="Brick Hash" id="brickHash">
                                <span>Brick Hash</span>
                            </label>
                            <label class="checkbox-item">
                                <input type="checkbox" name="products" value="Hash Hits" id="hashHits">
                                <span>Hash Hits</span>
                            </label>
                            <label class="checkbox-item">
                                <input type="checkbox" name="products" value="RSO Syringes">
                                <span>RSO Syringes</span>
                            </label>
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label>Notes</label>
                        <textarea id="intakeNotes" placeholder="Any special notes about this batch..."></textarea>
                    </div>
                    
                    <div style="display: flex; gap: 10px;">
                        <!-- Print button removed - auto-prints on submit -->
                        <button type="submit" class="btn" style="flex: 2;">Submit Intake</button>
                    </div>
                </form>
            </div>
        </div>

        <!-- Extraction Station -->
        <div class="station-content" id="extraction">
            <button class="mobile-back-btn" onclick="closeMobileStation()">â† Back</button>
            <div class="form-section">
                <h2>âš—ï¸ Extraction Processing</h2>
                
                <!-- Gas Tracking Button -->
                <div style="margin-bottom: 25px;">
                    <button class="btn" style="background: linear-gradient(135deg, var(--accent-orange), var(--accent-red)); padding: 20px; width: 100%; font-size: 1.1rem;" onclick="openSuppliesModal()">
                        <div style="font-weight: 700; margin-bottom: 10px;">ðŸ›¢ï¸ Extraction Supplies</div>
                        <div style="display: flex; justify-content: center; gap: 30px; font-size: 0.95rem;">
                            <span>Butane: <strong id="btnButaneDisplay">0 lbs</strong></span>
                            <span>Nitrogen: <strong id="btnNitrogenDisplay">0 tanks</strong></span>
                        </div>
                    </button>
                </div>
                
                <!-- Machine Status Buttons (Dynamic from CONFIG) -->
                <div id="machineButtonsContainer" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 15px;">
                    <!-- Populated by renderMachineButtons() -->
                </div>

                <!-- Extraction Queue with Sock Counts -->
                <div style="background: var(--bg-tertiary); padding: 20px; border-radius: 12px; margin-bottom: 25px;">
                    <h3 style="color: var(--accent-blue); margin-bottom: 15px;">ðŸ“‹ Extraction Queue</h3>
                    <div id="extractionQueueList" style="max-height: 300px; overflow-y: auto;">
                        <!-- Populated by JS -->
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Finishing Station -->
        <!-- Post Extraction Station -->
        <div class="station-content" id="finishing">
            <button class="mobile-back-btn" onclick="closeMobileStation()">â† Back</button>
            <div class="form-section">
                <h2>âœ¨ Post Extraction & Batch Splitting</h2>


                <div class="form-group">
                    <label>Select Batch to Finish</label>
                    <select id="finishingBatchSelect" required>
                        <option value="">Select a batch...</option>
                    </select>
                </div>
                
                <div id="finishingForm" style="display: none;">
                    <div id="batchInfo" style="background: var(--bg-tertiary); padding: 15px; border-radius: 10px; margin-bottom: 20px;">
                        <h3 style="color: var(--accent-purple); margin-bottom: 10px;">Batch Details</h3>
                        <div id="batchInfoContent"></div>
                    </div>

                    <div class="form-group">
                        <label>Split this batch into multiple products?</label>
                        <select id="splitBatch" required>
                            <option value="no">No - Single product batch</option>
                            <option value="yes">Yes - Split into sub-batches</option>
                        </select>
                    </div>

                    <!-- Single Product Finishing -->
                    <div id="singleFinishing">
                        <div class="form-grid">
                            <div class="form-group">
                                <label>Finishing Date</label>
                                <input type="date" id="finishingDate" required>
                            </div>
                            <div class="form-group">
                                <label>Final Bulk Weight (grams)</label>
                                <input type="number" id="finalWeight" step="0.1" required>
                            </div>
                            <div class="form-group">
                                <label>Sample Weight Pulled (grams)</label>
                                <input type="number" id="sampleWeight" step="0.1" required>                            </div>
                            <div class="form-group">
                                <label>Final Product Type</label>
                                <select id="finishingProductType">
                                    <option value="">Keep original (from pull batch)</option>
                                    <option value="Wax">Wax</option>
                                    <option value="Sugar Wax">Sugar Wax</option>
                                    <option value="Shatter">Shatter</option>
                                    <option value="Live Resin Carts">Live Resin Carts</option>
                                    <option value="Live Resin AIOs">Live Resin AIOs</option>
                                    <option value="Brick Hash">Brick Hash</option>
                                </select>
                                <div class="help-text">Change if product type changed during post-extraction</div>
                            </div>
                        </div>

                        <!-- Output Containers Section -->
                        <div id="outputContainersSection" style="display: none; background: var(--bg-tertiary); padding: 15px; border-radius: 10px; margin-bottom: 20px;">
                            <div id="bulkJarsOutput" style="display: none;">
                                <div class="form-group">
                                    <label style="color: var(--accent-purple);">ðŸ“¦ Number of Output Jars</label>
                                    <input type="number" id="outputJarsCount" min="1" value="1" style="max-width: 150px;">
                                    <div class="help-text">How many jars after merging/post-extraction?</div>
                                </div>
                            </div>
                            <div id="shatterSlabsOutput" style="display: none;">
                                <div class="form-group">
                                    <label style="color: var(--accent-orange);">ðŸ”¶ Number of Output Slabs</label>
                                    <input type="number" id="outputSlabsCount" min="1" value="1" style="max-width: 150px;">
                                    <div class="help-text">How many slabs after post-extraction?</div>
                                </div>
                            </div>
                        </div>

                        <div class="form-group">
                            <label>QC Notes</label>
                            <textarea id="finishingNotes" placeholder="Quality observations, color, consistency, issues..."></textarea>
                        </div>
                        
                        <button type="button" class="btn" onclick="submitFinishing()">Complete Finishing</button>
                    </div>

                    <!-- Split Batch Finishing -->
                    <div id="splitFinishing" style="display: none;">
                        <h3 style="color: var(--accent-green); margin: 20px 0 15px 0; font-size: 1.2rem;">Divide Batch Into Products</h3>
                        <p style="color: var(--text-secondary); margin-bottom: 20px;">Specify how much material goes to each product. System will create sub-batches.</p>
                        
                        <div id="splitProducts">
                            <div class="split-product-item" style="background: var(--bg-tertiary); padding: 20px; border-radius: 10px; margin-bottom: 15px;">
                                <h4 style="color: var(--accent-purple); margin-bottom: 15px;">Product 1</h4>
                                <div class="form-grid">
                                    <div class="form-group">
                                        <label>Product Type</label>
                                        <select class="splitProductType" required>
                                            <option value="">Select Product</option>
                                            <option value="Wax">Wax</option>
                                            <option value="Sugar Wax">Sugar Wax</option>
                                            <option value="Shatter">Shatter</option>
                                            <option value="Live Resin Carts">Live Resin Carts</option>
                                    <option value="Live Resin AIOs">Live Resin AIOs</option>
                                            <option value="Brick Hash">Brick Hash</option>
                                            <option value="Hash Hits">Hash Hits</option>
                                        </select>
                                    </div>
                                    <div class="form-group">
                                        <label>Weight Allocated (grams)</label>
                                        <input type="number" class="splitWeight" step="0.1" required>
                                    </div>
                                </div>
                            </div>

                            <div class="split-product-item" style="background: var(--bg-tertiary); padding: 20px; border-radius: 10px; margin-bottom: 15px;">
                                <h4 style="color: var(--accent-purple); margin-bottom: 15px;">Product 2</h4>
                                <div class="form-grid">
                                    <div class="form-group">
                                        <label>Product Type</label>
                                        <select class="splitProductType" required>
                                            <option value="">Select Product</option>
                                            <option value="Wax">Wax</option>
                                            <option value="Sugar Wax">Sugar Wax</option>
                                            <option value="Shatter">Shatter</option>
                                            <option value="Live Resin Carts">Live Resin Carts</option>
                                            <option value="Live Resin AIOs">Live Resin AIOs</option>
                                            <option value="Brick Hash">Brick Hash</option>
                                            <option value="Hash Hits">Hash Hits</option>
                                        </select>
                                    </div>
                                    <div class="form-group">
                                        <label>Weight Allocated (grams)</label>
                                        <input type="number" class="splitWeight" step="0.1" required>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <button type="button" class="btn" style="background: var(--accent-blue); margin-right: 10px;" onclick="addSplitProduct()">+ Add Another Product</button>
                        <button type="button" class="btn" onclick="submitSplitBatch()">Create Sub-Batches</button>
                        
                        <div id="splitValidation" style="margin-top: 15px; padding: 15px; border-radius: 10px;"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Packaging Station -->
        <div class="station-content" id="packaging">
            <button class="mobile-back-btn" onclick="closeMobileStation()">â† Back</button>
            <div class="form-section">
                <h2>ðŸ“Š Packaging & Listing</h2>
                <div class="form-group">
                    <label>Select Batch to Package</label>
                    <select id="packagingBatchSelect" required>
                        <option value="">Select a batch...</option>
                    </select>
                </div>
                
                <div id="packagingForm" style="display: none;">
                    <!-- Strain Type Indicator for Lid Color -->
                    <div id="strainTypeAlert" style="display: none; padding: 20px; border-radius: 12px; margin-bottom: 25px; text-align: center; border: 4px solid;">
                        <div style="font-size: 0.9rem; font-weight: 600; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px;">LID COLOR</div>
                        <div id="strainTypeName" style="font-size: 2.5rem; font-weight: 900; text-transform: uppercase; letter-spacing: 2px;"></div>
                    </div>

                    <div class="form-grid">
                        <div class="form-group">
                            <label>Packaging Date</label>
                            <input type="date" id="packagingDate" required>
                        </div>
                        <div class="form-group">
                            <label>Primary Product Type</label>
                            <select id="packagedProductType" required>
                                <option value="">Select Type</option>
                                <option value="Live Resin Carts">Live Resin Carts (1g)</option>
                                <option value="Live Resin AIOs">Live All-In-One (1g)</option>
                                <option value="Wax">Wax (1g & 4g)</option>
                                <option value="Sugar Wax">Sugar Wax (1g & 4g)</option>
                                <option value="Shatter">Shatter (1g)</option>
                                <option value="Brick Hash">Brick Hash (1g & 4g)</option>
                                <option value="Hash Hits">Hash Hits (2-pack & 5-pack)</option>
                                <option value="RSO Syringe">RSO Syringes</option>
                                <option value="Bulk Sale">ðŸŽ¯ Bulk Sale (Skip Labeling)</option>
                            </select>
                        </div>
                    </div>

                    <!-- Multi-size packaging section -->
                    <div id="multiSizeSection" style="display: none;">
                        <h3 style="color: var(--accent-green); margin: 20px 0 15px 0; font-size: 1.2rem;">Package Sizes</h3>
                        <div class="form-grid">
                            <div class="form-group">
                                <label>1g Units</label>
                                <input type="number" id="units1g" value="0" min="0">
                            </div>
                            <div class="form-group">
                                <label>4g Units</label>
                                <input type="number" id="units4g" value="0" min="0">
                            </div>
                            <div class="form-group">
                                <label>Total Grams Calculated</label>
                                <input type="number" id="totalGramsCalc" readonly style="background: var(--bg-primary); color: var(--accent-green); font-weight: 700;">
                            </div>
                            <div class="form-group">
                                <label>Total Units (Combined)</label>
                                <input type="number" id="totalUnitsCalc" readonly style="background: var(--bg-primary); color: var(--accent-green); font-weight: 700;">
                            </div>
                        </div>
                    </div>

                    <!-- Single size packaging section -->
                    <div id="singleSizeSection">
                        <div class="form-grid">
                            <div class="form-group">
                                <label>Total Units/Eaches</label>
                                <input type="number" id="unitsPackaged" min="0">
                            </div>
                        </div>
                    </div>
                    
                    <div class="form-group" style="display: none;">
                        <input type="number" id="wholesalePrice" step="0.01" min="0" value="0" style="display: none;">
                    </div>
                    
                    <div class="form-group">
                        <label>Packaging Notes</label>
                        <textarea id="packagingNotes" placeholder="Any issues, special packaging notes..."></textarea>
                    </div>
                    
                    <!-- Bulk Sale Alert -->
                    <div id="bulkSaleAlert" style="display: none; background: rgba(16, 185, 129, 0.15); border-left: 4px solid var(--accent-green); padding: 15px; border-radius: 8px; margin: 20px 0;">
                        <strong>ðŸŽ¯ Bulk Sale Selected</strong>
                        <p style="margin: 8px 0 0 0; color: var(--text-secondary);">
                            This batch will go through testing but will skip the labeling process after test results are entered.
                        </p>
                    </div>
                    
                    <div style="background: rgba(59, 130, 246, 0.15); border-left: 4px solid var(--accent-blue); padding: 15px; border-radius: 8px; margin: 20px 0;">
                        <strong>ðŸ’¡ Workflow Options:</strong>
                        <ul style="margin: 8px 0 0 20px; line-height: 1.8;">
                            <li><strong>Start Packaging:</strong> Mark batch as in-progress (tracking only, can finish later)</li>
                            <li><strong>Pause/Resume:</strong> Temporarily pause work (breaks, end of shift, equipment issues)</li>
                            <li><strong>Complete Packaging:</strong> Finish packaging (skips "start" if single session)</li>
                        </ul>
                    </div>
                    
                    <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                        <button type="button" class="btn" style="background: var(--accent-blue); flex: 1; min-width: 200px;" onclick="startPackaging()">â–¶ï¸ Start Packaging</button>
                        <button type="button" class="btn" id="pausePackagingBtn" style="background: var(--accent-orange); flex: 1; min-width: 200px; display: none;" onclick="togglePausePackaging()">â¸ï¸ Pause</button>
                        <button type="button" class="btn" style="background: var(--accent-green); flex: 1; min-width: 200px;" onclick="submitPackaging()">âœ… Complete Packaging</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Testing Station -->
        <div class="station-content" id="testing">
            <button class="mobile-back-btn" onclick="closeMobileStation()">â† Back</button>
            <div class="form-section">
                <h2>ðŸ§ª Test Results Entry</h2>
                <div class="form-group">
                    <label>Select Batch for Test Results</label>
                    <select id="testingBatchSelect" required>
                        <option value="">Select a batch...</option>
                    </select>
                </div>
                
                <div id="testingForm" style="display: none;">
                    <div id="currentTestInfo" style="background: var(--bg-tertiary); padding: 15px; border-radius: 10px; margin-bottom: 20px;">
                        <h3 style="color: var(--accent-purple); margin-bottom: 10px;">Current Batch Info</h3>
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <div>
                                <strong style="color: var(--accent-orange);">Current Batch ID:</strong> 
                                <span id="currentBatchIdDisplay" style="font-family: 'Space Mono', monospace; font-size: 1.2rem; font-weight: 700; color: var(--accent-green);"></span>
                            </div>
                        </div>
                        <div id="testBatchDetails"></div>
<!-- Print Label Section -->                        <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--border);">                            <div style="display: flex; align-items: center; gap: 15px; flex-wrap: wrap;">                                <label style="color: var(--text-secondary); margin: 0;">Print Label:</label>                                <select id="testingLabelType" style="padding: 8px 12px; border-radius: 8px; border: 2px solid var(--border); background: var(--bg-tertiary); color: var(--text-primary);">                                    <option value="intake">ðŸ“¥ Intake Label (2x3)</option>                                    <option value="postprod">ðŸ“¦ Post-Production Label (2x1.5)</option>                                    <option value="labeling">ðŸ·ï¸ Labeling Complete Label</option>                                </select>                                <button type="button" onclick="printTestingLabel()" class="btn" style="background: var(--accent-purple); padding: 8px 20px;">                                    ðŸ–¨ï¸ Print                                </button>                            </div>                        </div>
                    </div>

                    <!-- Finalize Batch for Testing -->
                    <div style="background: linear-gradient(135deg, rgba(245, 158, 11, 0.15), rgba(147, 51, 234, 0.15)); padding: 20px; border-radius: 12px; margin-bottom: 25px; border: 2px solid var(--accent-orange);">
                        <h3 style="color: var(--accent-orange); margin-bottom: 10px; display: flex; align-items: center; gap: 10px;">
                            <span>ðŸ“‹</span> Finalize Batch for Testing
                        </h3>
                        <p style="color: var(--text-secondary); font-size: 0.9rem; margin-bottom: 15px; line-height: 1.5;">
                            Complete this section when extraction is done. Batch ID protocol: M.D.XXXX (expiration month.day.last 4 of METRC tag)
                        </p>

                        <div id="readyForTestingStatus" style="margin-bottom: 15px;"></div>

                        <div id="dealersChoiceAlert" style="display: none; background: rgba(245, 158, 11, 0.2); border: 2px solid var(--accent-orange); padding: 15px; border-radius: 10px; margin-bottom: 15px;">
                            <strong style="color: var(--accent-orange);">ðŸŽ² Dealer's Choice Batch</strong>
                            <p style="margin: 5px 0 0 0; color: var(--text-secondary); font-size: 0.9rem;">This batch was marked for dealer's choice at intake. Select the final strain type below.</p>
                        </div>

                        <div class="form-grid" style="margin-bottom: 15px;">
                            <div class="form-group" style="margin-bottom: 0;">
                                <label>Product Name</label>
                                <input type="text" id="finalProductName" placeholder="e.g., Blue Dream Live Resin" required>
                                <div class="help-text">Final name for this batch</div>
                            </div>
                            <div class="form-group" style="margin-bottom: 0;">
                                <label>Product Type</label>
                                <select id="finalConsistency" required>
                                    <option value="">Select product type...</option>
                                    <option value="Wax">Wax</option>
                                    <option value="Sugar Wax">Sugar Wax</option>
                                    <option value="Shatter">Shatter</option>
                                    <option value="Live Resin Carts">Live Resin Carts</option>
                                    <option value="Live Resin AIOs">Live Resin AIOs</option>
                                    <option value="Brick Hash">Brick Hash</option>
                                    <option value="Hash Hits">Hash Hits</option>
                                </select>
                                <div class="help-text">Final product type</div>
                            </div>
                        </div>

                        <div class="form-grid" style="margin-bottom: 15px;">
                            <div class="form-group" style="margin-bottom: 0;">
                                <label>Strain Type (Lid Color)</label>
                                <select id="finalStrainType" required>
                                    <option value="Indica">Indica (Blue Lid)</option>
                                    <option value="Sativa">Sativa (Red Lid)</option>
                                    <option value="Hybrid">Hybrid (Green Lid)</option>
                                </select>
                                <div class="help-text">Redesignate if needed</div>
                            </div>
                            <div class="form-group" style="margin-bottom: 0;">
                                <label>Expiration Date</label>
                                <input type="date" id="testExpirationDate" required>
                                <div class="help-text">For batch ID generation</div>
                            </div>
                        </div>

                        <div class="form-grid" style="margin-bottom: 15px;">
                            <div class="form-group" style="margin-bottom: 0;">
                                <label>Last 4 of METRC Tag (Optional)</label>
                                <input type="text" id="metrcLast4" maxlength="4" placeholder="e.g., 5678" style="font-family: 'Space Mono', monospace; font-size: 1.1rem; font-weight: 700;">
                                <div class="help-text">For new batch ID</div>
                            </div>
                            <div class="form-group" style="margin-bottom: 0;">
                                <label>Generated Batch ID</label>
                                <input type="text" id="newBatchId" readonly placeholder="Enter expiration date & METRC tag" style="font-family: 'Space Mono', monospace; font-size: 1.1rem; font-weight: 700; background: var(--bg-primary); color: var(--accent-green);">
                                <div class="help-text">Format: M.D.XXXX</div>
                            </div>
                        </div>

                        <button type="button" id="markReadyForTestingBtn" onclick="markReadyForTesting()" style="background: linear-gradient(135deg, #22c55e, #16a34a); color: white; border: none; padding: 14px 24px; border-radius: 8px; cursor: pointer; font-weight: 600; display: flex; align-items: center; justify-content: center; gap: 10px; width: 100%; font-size: 1.1rem;">
                            <span>âœ“</span> Mark as Extraction Complete (Ready for Testing)
                        </button>
                        <div class="help-text" style="margin-top: 8px; text-align: center;">Saves product info and marks batch ready for lab submission</div>
                    </div>

                    <div class="form-grid">
                        <div class="form-group">
                            <label>Date Submitted to Lab</label>
                            <input type="date" id="testSubmittedDate" required>
                        </div>
                        <div class="form-group">
                            <label>RTA (Full Panel)?</label>
                            <select id="isRTA" required onchange="updateTestResultVisibility()">
                                <option value="no">No - Standard Potency Only</option>
                                <option value="yes">Yes - Full Panel RTA</option>
                            </select>
                            <div class="help-text">Full panel RTA required once per month</div>
                        </div>
                        <div class="form-group" id="testResultGroup" style="display: none;">
                            <label>Full Panel Test Result</label>
                            <select id="fullPanelResult">
                                <option value="pending">Pending - Awaiting Results</option>
                                <option value="pass">âœ“ PASSED - All Tests Clear</option>
                                <option value="fail">âœ— FAILED - Contamination Found</option>
                            </select>
                            <div class="help-text">Update when lab results arrive</div>
                        </div>
                        <div class="form-group">
                            <label>THC % (if results received)</label>
                            <input type="number" id="testThcPercent" step="0.01" placeholder="Enter when results arrive">
                        </div>
                        <div class="form-group">
                            <label>CBD % (if results received)</label>
                            <input type="number" id="testCbdPercent" step="0.01" placeholder="Enter when results arrive">
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label>Test Results Notes</label>
                        <textarea id="testResultsNotes" placeholder="Any issues, terpene highlights, pass/fail status..."></textarea>
                    </div>
                    
                    <button type="button" class="btn" onclick="submitTestResults()">Save Test Results</button>
                </div>

                                <!-- RTA Qualification Status -->
                <div id="rtaQualificationSection" style="margin-top: 30px; background: var(--bg-tertiary); padding: 20px; border-radius: 12px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                        <h3 style="margin: 0; color: var(--accent-purple);">ðŸ“‹ RTA Status</h3>
                        <button class="btn" style="padding: 8px 15px; font-size: 0.9rem;" onclick="openRTAManager()">Manage</button>
                    </div>
                    <div id="rtaQuickStatus" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px;">
                        <!-- Populated by JS -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Labeling Station -->
        <div class="station-content" id="labeling">
            <button class="mobile-back-btn" onclick="closeMobileStation()">â† Back</button>
            <div class="form-section">
                <h2>ðŸ·ï¸ Label Printing & Application</h2>
                
                <div class="form-group">
                    <label>Select Batch to Label</label>
                    <select id="labelingBatchSelect" required>
                        <option value="">Select a batch...</option>
                    </select>
                </div>
                
                <div id="labelingForm" style="display: none;">
                    <!-- Batch Info Display -->
                    <div style="background: var(--bg-tertiary); padding: 20px; border-radius: 10px; margin-bottom: 20px; border-left: 4px solid var(--accent-purple);">
                        <h3 style="color: var(--accent-purple); margin-bottom: 15px;">Label Information</h3>
                        <div id="labelPreview" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                            <!-- Auto-populated from batch data -->
                        </div>
                    </div>

                    <!-- Weight Verification -->
                    <div style="background: rgba(16, 185, 129, 0.1); padding: 20px; border-radius: 10px; margin-bottom: 20px; border: 2px solid var(--accent-green);">
                        <h3 style="color: var(--accent-green); margin-bottom: 15px;">ðŸ“Š Total Grams Labeled</h3>
                        
                        <div class="form-group">
                            <label>Total Grams Labeled (weighed after labeling)</label>
                            <input type="number" id="gramsLabeled" step="0.1" placeholder="Total weight with labels" required>
                            <div class="help-text">Actual weight after all labels applied</div>
                        </div>

                        <!-- Expected Weight Display -->
                        <div id="expectedWeightDisplay" style="padding: 15px; background: var(--bg-primary); border-radius: 8px; margin-top: 15px;">
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                                <div>
                                    <div style="color: var(--text-secondary); font-size: 0.9rem;">Expected Weight (from packaging)</div>
                                    <div id="expectedWeight" style="font-size: 1.5rem; font-weight: 700; color: var(--accent-blue); font-family: 'Space Mono', monospace;">-</div>
                                </div>
                                <div>
                                    <div style="color: var(--text-secondary); font-size: 0.9rem;">Actual Weight Labeled</div>
                                    <div id="actualWeight" style="font-size: 1.5rem; font-weight: 700; color: var(--accent-green); font-family: 'Space Mono', monospace;">-</div>
                                </div>
                            </div>
                            <div id="discrepancyAlert" style="display: none; margin-top: 15px; padding: 15px; background: rgba(239, 68, 68, 0.2); border: 2px solid var(--accent-red); border-radius: 8px;">
                                <div style="color: var(--accent-red); font-weight: 700; margin-bottom: 10px;">âš ï¸ Weight Discrepancy Detected</div>
                                <div id="discrepancyDetails" style="color: var(--text-primary); margin-bottom: 15px;"></div>
                                <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                                    <input type="checkbox" id="acceptDiscrepancy" style="width: 20px; height: 20px;">
                                    <span style="font-weight: 600;">I verify this weight is correct and accept the discrepancy</span>
                                </label>
                            </div>
                        </div>
                    </div>

                    <!-- Mark as Labeled -->
                    <div class="form-group">
                        <label>Labeling Notes</label>
                        <textarea id="labelingNotes" placeholder="Any issues with labeling, printer problems, etc..."></textarea>
                    </div>
                    
                    <div style="background: rgba(59, 130, 246, 0.15); border-left: 4px solid var(--accent-blue); padding: 15px; border-radius: 8px; margin: 20px 0;">
                        <strong>ðŸ’¡ Workflow Options:</strong>
                        <ul style="margin: 8px 0 0 20px; line-height: 1.8;">
                            <li><strong>Print Labels:</strong> Open printable label page (use browser print)</li>
                            <li><strong>Start Labeling:</strong> Mark batch as in-progress (tracking only, can finish later)</li>
                            <li><strong>Pause/Resume:</strong> Temporarily pause work (breaks, end of shift, equipment issues)</li>
                            <li><strong>Complete Labeling:</strong> Finish labeling with weight verification</li>
                        </ul>
                    </div>
                    
                    <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                        <button type="button" class="btn" style="background: linear-gradient(135deg, var(--accent-purple), var(--accent-blue)); flex: 1; min-width: 200px;" onclick="openPrintableLabels()">ðŸ–¨ï¸ Print Labels</button>
                        <button type="button" class="btn" style="background: var(--accent-blue); flex: 1; min-width: 200px;" onclick="startLabeling()">â–¶ï¸ Start Labeling</button>
                        <button type="button" class="btn" id="pauseLabelingBtn" style="background: var(--accent-orange); flex: 1; min-width: 200px; display: none;" onclick="togglePauseLabeling()">â¸ï¸ Pause</button>
                        <button type="button" class="btn" style="background: var(--accent-green); flex: 1; min-width: 200px;" onclick="markAsLabeled()">âœ… Complete Labeling</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Waste Log -->
        <!-- Analytics -->
        <div class="station-content" id="analytics">
            <button class="mobile-back-btn" onclick="closeMobileStation()">â† Back</button>
            <h2 style="margin-bottom: 30px;">ðŸ“Š Completed Batches Analytics</h2>
            
            <!-- Summary Stats -->
            <div class="stats-grid" style="margin-bottom: 40px;">
                <div class="stat-card">
                    <div class="stat-value" id="avgYield">0%</div>
                    <div class="stat-label">Average Yield</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="avgThc">0%</div>
                    <div class="stat-label">Average THC</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="avgProcessingTime">0d</div>
                    <div class="stat-label">Avg Processing Time</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="avgCostPerGram">$0</div>
                    <div class="stat-label">Avg Cost Per Gram</div>
                </div>
            </div>

            <!-- Filter Bar -->
            <div class="filter-bar" style="margin-bottom: 30px;">
                <button class="filter-btn active" data-filter-analytics="all" onclick="filterAnalytics('all')">All Completed</button>
                <button class="filter-btn" data-filter-analytics="thisMonth" onclick="filterAnalytics('thisMonth')">This Month</button>
                <button class="filter-btn" data-filter-analytics="lastMonth" onclick="filterAnalytics('lastMonth')">Last Month</button>
            </div>

            <!-- Batch Cards Grid -->
            <div id="completedBatchesGrid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(350px, 1fr)); gap: 20px;"></div>
        </div>

        <!-- Batch Details Modal -->
        <div id="batchDetailsModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); z-index: 10000; overflow-y: auto;">
            <div style="max-width: 1000px; margin: 50px auto; background: var(--bg-secondary); border-radius: 16px; padding: 30px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 30px;">
                    <h2 id="modalBatchId" style="color: var(--accent-green); font-family: 'Space Mono', monospace;">WM-1001</h2>
                    <button onclick="closeBatchDetails()" style="background: none; border: none; color: var(--text-primary); font-size: 2.5rem; cursor: pointer; padding: 0; width: 50px; height: 50px; line-height: 40px;">&times;</button>
                </div>
                
                <!-- Batch Overview -->
                <div id="modalBatchOverview" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 30px;"></div>
<!-- Batch Tracking Details -->                <div style="background: var(--bg-tertiary); padding: 20px; border-radius: 12px; margin-bottom: 30px;">                    <h3 style="color: var(--accent-blue); margin-bottom: 20px;">ðŸ“‹ Batch Tracking</h3>                    <div id="modalTracking"></div>                </div>
                
                <!-- Processing Timeline Visualization -->
                <div style="background: var(--bg-tertiary); padding: 20px; border-radius: 12px; margin-bottom: 30px;">
                    <h3 style="color: var(--accent-purple); margin-bottom: 20px;">â±ï¸ Processing Timeline</h3>
                    <div id="modalTimeline"></div>
                </div>
                
                <!-- Performance Metrics -->
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin-bottom: 30px;">
                    <div style="background: var(--bg-tertiary); padding: 20px; border-radius: 12px;">
                        <h4 style="color: var(--accent-green); margin-bottom: 15px;">ðŸ’° Economics</h4>
                        <div id="modalEconomics"></div>
                    </div>
                    <div style="background: var(--bg-tertiary); padding: 20px; border-radius: 12px;">
                        <h4 style="color: var(--accent-blue); margin-bottom: 15px;">ðŸ§ª Testing Results</h4>
                        <div id="modalTesting"></div>
                    </div>
                    <div style="background: var(--bg-tertiary); padding: 20px; border-radius: 12px;">
                        <h4 style="color: var(--accent-orange); margin-bottom: 15px;">ðŸ“¦ Production</h4>
                        <div id="modalProduction"></div>
                    </div>
                </div>
                
                <!-- Team Members -->
                <div style="background: var(--bg-tertiary); padding: 20px; border-radius: 12px;">
                    <h3 style="color: var(--accent-purple); margin-bottom: 15px;">ðŸ‘¥ Team Members</h3>
                    <div id="modalTeam"></div>
                </div>
            </div>
        </div>

                <!-- Performance Station -->
        <div class="station-content" id="performance">
            <button class="mobile-back-btn" onclick="closeMobileStation()">â† Back</button>
            <div class="form-section">
                <h2>Team Performance</h2>
                <p style="color: var(--text-secondary); margin-bottom: 20px;">Click any employee card for detailed performance view</p>

                <!-- Time Period Selector -->
                <div style="display: flex; gap: 15px; margin-bottom: 25px; flex-wrap: wrap; align-items: center;">
                    <div class="form-group" style="margin: 0; min-width: 180px;">
                        <select id="performanceTimeRange" onchange="renderPerformanceAnalytics()" style="padding: 10px 15px; font-size: 1rem;">
                            <option value="1">Today</option>
                            <option value="7">Last 7 Days</option>
                            <option value="14">Last 14 Days</option>
                            <option value="30" selected>Last 30 Days</option>
                            <option value="60">Last 60 Days</option>
                            <option value="90">Last 90 Days</option>
                        </select>
                    </div>
                    <span id="performanceDateRange" style="color: var(--text-secondary); font-size: 0.9rem;"></span>
                    <!-- Hidden for backwards compatibility -->
                    <select id="performanceFilter" style="display: none;"><option value="all">All</option></select>
                    <select id="performanceViewMode" style="display: none;"><option value="overview">Overview</option></select>
                </div>

                <!-- Employee Cards Grid -->
                <div id="employeeCardsGrid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 20px; margin-bottom: 30px;"></div>

                <!-- Hidden containers for backwards compatibility -->
                <div id="performanceStats" style="display: none;"></div>
                <div id="staffingRecommendations" style="display: none;"></div>
                <div id="todayDate" style="display: none;"></div>
                <div id="todayTrimExtracted" style="display: none;"></div>
                <div id="todayTrimBatches" style="display: none;"></div>
                <div id="todayFinished" style="display: none;"></div>
                <div id="todayFinishedBatches" style="display: none;"></div>
                <div id="todayPackaged" style="display: none;"></div>
                <div id="todayPackagedWeight" style="display: none;"></div>
                <div id="todayLabeled" style="display: none;"></div>
                <div id="todayLabeledWeight" style="display: none;"></div>
                <div id="activeUsers" style="display: none;"></div>
                <div id="recentLogins" style="display: none;"></div>
                <div id="companyPeriodRange" style="display: none;"></div>
                <div id="companyTrimExtracted" style="display: none;"></div>
                <div id="companyTrimBatches" style="display: none;"></div>
                <div id="companyFinished" style="display: none;"></div>
                <div id="companyFinishedBatches" style="display: none;"></div>
                <div id="companyPackaged" style="display: none;"></div>
                <div id="companyPackagedWeight" style="display: none;"></div>
                <div id="companyLabeled" style="display: none;"></div>
                <div id="companyLabeledWeight" style="display: none;"></div>
            </div>

            <!-- Collapsible Settings Section -->
            <div class="form-section">
                <div onclick="var content = this.nextElementSibling; content.style.display = content.style.display === 'none' ? 'block' : 'none'; this.querySelector('.settings-toggle').textContent = content.style.display === 'none' ? 'Show Settings' : 'Hide Settings';" style="cursor: pointer; display: flex; justify-content: space-between; align-items: center;">
                    <h2 style="margin: 0;">Production Targets</h2>
                    <span class="settings-toggle" style="font-size: 0.9rem; color: var(--accent-blue);">Show Settings</span>
                </div>
                <div class="settings-content" style="display: none; margin-top: 20px;">
                    <div style="background: var(--bg-tertiary); padding: 20px; border-radius: 12px;">
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                            <div>
                                <label style="display: block; margin-bottom: 5px; font-size: 0.9rem;">Packaging (units/day)</label>
                                <input type="number" id="targetPackagingUnits" value="200" min="0" style="width: 100%; padding: 10px; background: var(--bg-primary); border: 2px solid var(--border); border-radius: 8px; color: var(--text-primary);" onchange="saveTargets(); renderPerformanceAnalytics();">
                            </div>
                            <div>
                                <label style="display: block; margin-bottom: 5px; font-size: 0.9rem;">Labeling (units/day)</label>
                                <input type="number" id="targetLabelingUnits" value="300" min="0" style="width: 100%; padding: 10px; background: var(--bg-primary); border: 2px solid var(--border); border-radius: 8px; color: var(--text-primary);" onchange="saveTargets(); renderPerformanceAnalytics();">
                            </div>
                            <div>
                                <label style="display: block; margin-bottom: 5px; font-size: 0.9rem;">Extraction (g/day)</label>
                                <input type="number" id="targetExtractionTrim" value="11200" min="0" step="100" style="width: 100%; padding: 10px; background: var(--bg-primary); border: 2px solid var(--border); border-radius: 8px; color: var(--text-primary);" onchange="saveTargets(); renderPerformanceAnalytics();">
                            </div>
                        </div>
                    </div>
                </div>
                <div id="capacityPlanning" style="display: none;"></div>
                <div id="activityLog" style="display: none;"></div>
            </div>
        </div>

        <!-- Dashboard -->
        <div class="station-content" id="dashboard">
            <button class="mobile-back-btn" onclick="closeMobileStation()">â† Back</button>
            <!-- Dashboard Needs Section -->
            <div id="dashboardNeedsSection" style="margin-bottom: 20px;">
                <div class="foh-box" style="border-left: 4px solid #F59E0B; background: var(--bg-secondary); border-radius: 12px; padding: 12px;">
                    <h4 style="color: #F59E0B; margin: 0 0 10px 0; font-size: 1rem; font-weight: 600; text-align: center;">What We Need</h4>
                    <div id="dashboardNeedsGrid" class="foh-items" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px;"></div>
                </div>
            </div>

            <!-- Personal Quick Stats -->
            <div id="personalStats" style="background: linear-gradient(135deg, rgba(147, 51, 234, 0.2), rgba(59, 130, 246, 0.2)); padding: 20px; border-radius: 12px; margin-bottom: 25px; border: 2px solid var(--accent-purple);">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <h2 style="color: var(--accent-purple); margin: 0; display: flex; align-items: center; gap: 10px;">
                        <span>ðŸ‘¤</span>
                        <span id="personalStatsTitle">Your Workload</span>
                    </h2>
                    <div style="display: flex; gap: 10px;">
                        <button class="btn" style="background: var(--accent-orange); padding: 10px 20px;" onclick="recalculateAllSubBatchYields()">
                            ðŸ”„ Fix Sub-Batch Yields
                        </button>
                        <button class="btn" style="background: var(--accent-green); padding: 10px 20px;" onclick="showDailyReportPopup()">
                            ðŸ“Š Daily Report
                        </button>
                    </div>
                </div>
                <div id="personalStatsGrid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                    <!-- Populated dynamically -->
                </div>
            </div>

            <!-- System-Wide Stats -->
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-value" id="totalBatches">0</div>
                    <div class="stat-label">Total Batches</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="activeBatches">0</div>
                    <div class="stat-label">In Progress</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="completedBatches">0</div>
                    <div class="stat-label">Completed</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="totalGramsIn">0g</div>
                    <div class="stat-label">Total Trim In</div>
                </div>
                <div class="stat-card" id="weightDiscrepancyCard" style="display: none;">
                    <div class="stat-value" id="totalWeightLoss" style="color: var(--accent-orange);">0g</div>
                    <div class="stat-label">âš ï¸ Weight Loss (Bulkâ†’Label)</div>
                </div>
            </div>

            <!-- Waste Log Section - Collapsible -->
            <div style="margin: 30px 0;">
                <div onclick="document.getElementById('wasteLogContent').style.display = document.getElementById('wasteLogContent').style.display === 'none' ? 'block' : 'none'; this.querySelector('.waste-arrow').textContent = document.getElementById('wasteLogContent').style.display === 'none' ? 'â–¶' : 'â–¼';"
                     style="display: flex; justify-content: space-between; align-items: center; padding: 15px 20px; background: var(--bg-secondary); border-radius: 12px; cursor: pointer; box-shadow: 0 2px 4px rgba(0,0,0,0.2);">
                    <div style="display: flex; align-items: center; gap: 12px;">
                        <span class="waste-arrow" style="font-size: 1rem;">â–¶</span>
                        <h2 style="margin: 0; font-size: 1.3rem;">ðŸ—‘ï¸ Trim Waste Log</h2>
                    </div>
                    <div style="display: flex; gap: 15px; align-items: center;" onclick="event.stopPropagation();">
                        <div style="background: var(--bg-tertiary); padding: 8px 15px; border-radius: 8px;">
                            <span style="color: var(--text-secondary);">Pending:</span>
                            <span id="wastePendingCount" style="color: var(--accent-orange); font-weight: 600;">0</span>
                        </div>
                        <div style="background: var(--bg-tertiary); padding: 8px 15px; border-radius: 8px;">
                            <span style="color: var(--text-secondary);">Total:</span>
                            <span id="wasteTotalWeight" style="color: var(--accent-green); font-weight: 600;">0g</span>
                        </div>
                        <div style="background: var(--bg-tertiary); padding: 8px 15px; border-radius: 8px;">
                            <span style="color: var(--text-secondary);">Next Disposal:</span>
                            <span id="wasteNextDisposal" style="color: var(--accent-blue); font-weight: 600;">--</span>
                        </div>
                        <button onclick="exportWasteLog()" style="background: var(--accent-green); border: none; padding: 8px 15px; border-radius: 8px; color: white; cursor: pointer; font-weight: 600;">ðŸ“¥ Export</button>
                    </div>
                </div>

                <div id="wasteLogContent" style="display: none; margin-top: 10px;">
                    <div style="background: var(--bg-primary); border-radius: 12px; overflow: hidden; border: 1px solid var(--border);">
                        <div style="max-height: 400px; overflow-y: auto;">
                            <table style="width: 100%; border-collapse: collapse; font-size: 0.85rem;">
                                <thead style="position: sticky; top: 0; background: var(--bg-tertiary); z-index: 1;">
                                    <tr>
                                        <th style="padding: 12px 8px; text-align: left; color: var(--text-secondary);">Batch</th>
                                        <th style="padding: 12px 8px; text-align: left; color: var(--text-secondary);">Strain</th>
                                        <th style="padding: 12px 8px; text-align: right; color: var(--text-secondary);">Trim</th>
                                        <th style="padding: 12px 8px; text-align: right; color: var(--text-secondary);">Waste</th>
                                        <th style="padding: 12px 8px; text-align: center; color: var(--text-secondary);">Extraction</th>
                                        <th style="padding: 12px 8px; text-align: center; color: var(--text-secondary);">Disposal</th>
                                        <th style="padding: 12px 8px; text-align: center; color: var(--text-secondary);">METRC</th>
                                        <th style="padding: 12px 8px; text-align: center; color: var(--text-secondary);">Mixed</th>
                                        <th style="padding: 12px 8px; text-align: center; color: var(--text-secondary);">Facility</th>
                                    </tr>
                                </thead>
                                <tbody id="wasteLogTableBody">
                                    <tr><td colspan="9" style="padding: 30px; text-align: center; color: var(--text-secondary);">Loading...</td></tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>

            <div class="batch-list">
                <h2>ðŸ“‹ All Production Batches</h2>
                <div class="filter-bar">
                    <button class="filter-btn active" data-filter="all">All</button>
                    <button class="filter-btn" data-filter="intake">Intake</button>
                    <button class="filter-btn" data-filter="extraction">Extraction</button>
                    <button class="filter-btn" data-filter="finishing">Post Extraction</button>
                    <button class="filter-btn" data-filter="packaging">Packaging</button>
                    <button class="filter-btn" data-filter="testing">Testing</button>
                    <button class="filter-btn" data-filter="labeling">Labeling</button>
                    <button class="filter-btn" data-filter="complete">Complete</button>
                    <div class="search-box">
                        <input type="text" id="searchBatches" placeholder="Search batches...">
                    </div>
                </div>
                <div id="batchesList"></div>
            </div>
        </div>

        <!-- Front of House Station -->
        <div class="station-content" id="frontofhouse">
            <button class="mobile-back-btn" onclick="closeMobileStation()">â† Back</button>
            <div class="form-section">
                <!-- Pipeline, Inventory, Needs Sections -->
                <style>
                    .foh-wrapper { display: flex; flex-direction: column; gap: 15px; margin-bottom: 20px; }
                    @media (min-width: 768px) { .foh-wrapper { flex-direction: row; } .foh-box { flex: 1; } }
                    .foh-box { background: var(--bg-secondary); border-radius: 12px; padding: 12px; }
                    .foh-box h4 { margin: 0 0 10px 0; font-size: 1rem; font-weight: 600; text-align: center; }
                    .foh-items { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; }
                    @media (max-width: 500px) { .foh-items { grid-template-columns: repeat(2, 1fr); } }
                    .foh-btn { background: var(--bg-primary); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; padding: 12px 8px; cursor: pointer; text-align: center; width: 100%; transition: all 0.2s; }
                    .foh-btn:hover { transform: scale(1.02); background: rgba(255,255,255,0.05); }
                    .foh-btn-name { font-size: 0.95rem; font-weight: 600; color: #fff; margin-bottom: 4px; }
                    .foh-btn-num { font-size: 1.6rem; font-weight: 700; color: #111; line-height: 1; text-shadow: 0 0 8px #fff, 0 0 15px #fff, 0 0 25px #fff, 0 0 40px #fff; animation: num-glow 2s ease-in-out infinite; }
                    .foh-needs-num { animation: none !important; }
                    .foh-btn-sub { font-size: 0.8rem; color: rgba(255,255,255,0.7); margin-top: 4px; }
                    @keyframes num-glow { 0%, 100% { text-shadow: 0 0 8px #fff, 0 0 15px #fff, 0 0 25px #fff; } 50% { text-shadow: 0 0 10px #fff, 0 0 20px #fff, 0 0 35px #fff, 0 0 50px #fff; } }
                </style>
                <div class="foh-wrapper">
                    <!-- Needs -->
                    <div class="foh-box" style="border-left: 4px solid #F59E0B;">
                        <h4 style="color: #F59E0B;">Needs</h4>
                        <div id="inlineNeedsGrid" class="foh-items"></div>
                    </div>
                    <!-- Pipeline -->
                    <div class="foh-box" style="border-left: 4px solid #10B981;">
                        <h4 style="color: #10B981;">Pipeline</h4>
                        <div id="inlinePipelineGrid" class="foh-items"></div>
                    </div>
                    <!-- Inventory -->
                    <div class="foh-box" style="border-left: 4px solid #8B5CF6;">
                        <h4 style="color: #8B5CF6;">Inventory</h4>
                        <div id="inlineInventoryGrid" class="foh-items"></div>
                    </div>
                </div>

<!-- Sales Dashboard -->
                <div style="background: linear-gradient(135deg, rgba(255, 215, 0, 0.1), rgba(147, 51, 234, 0.1)); border: 2px solid #FFD700; border-radius: 16px; padding: 25px; margin-bottom: 30px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; flex-wrap: wrap; gap: 15px;">
                        <div>
                            <h3 style="margin: 0; display: flex; align-items: center; gap: 10px; color: #FFD700;">
                                <span>ðŸ’°</span> Sales Dashboard
                            </h3>
                            <p style="color: var(--text-secondary); margin: 5px 0 0 0; font-size: 0.9rem;">Sales performance, commissions, and rep tracking</p>
                        </div>
                        <div style="display: flex; flex-wrap: wrap; gap: 10px; align-items: center;">
                            <button onclick="openDropCalendarModal()" class="btn" style="background: linear-gradient(135deg, #10B981, #059669); padding: 10px 20px; font-weight: 600; flex: 1 1 auto;">Calendar</button>
                            <select id="salesRepFilter" onchange="updateSalesDashboard()" style="background: var(--bg-primary); border: 1px solid var(--border-color); color: var(--text-primary); padding: 10px 15px; border-radius: 8px; min-width: 0; flex: 1 1 160px;">
                                <option value="all">All Sales Reps</option>
                            </select>
                            <button onclick="forceRefreshSales()" class="btn" style="background: #FFD700; color: #000; padding: 10px 20px; font-weight: 600; flex: 1 1 auto;">Refresh</button>
                        </div>
                    </div>

                    <!-- Sales Stats Grid -->
                    <div id="salesDashboardStats" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 15px; margin-bottom: 25px;">
                        <div style="background: var(--bg-primary); padding: 20px; border-radius: 12px; text-align: center; border-left: 4px solid var(--accent-blue);">
                            <div style="font-size: 2.2rem; font-weight: 700; color: var(--accent-blue);" id="salesStatTotalOrders">--</div>
                            <div style="color: var(--text-secondary); font-size: 0.85rem;">Total Orders</div>
                        </div>
                        <div style="background: var(--bg-primary); padding: 20px; border-radius: 12px; text-align: center; border-left: 4px solid #FFD700;">
                            <div style="font-size: 2.2rem; font-weight: 700; color: #FFD700;" id="salesStatTotalRevenue">--</div>
                            <div style="color: var(--text-secondary); font-size: 0.85rem;">Last 30 Days</div>
                        </div>
                        <div style="background: var(--bg-primary); padding: 20px; border-radius: 12px; text-align: center; border-left: 4px solid var(--accent-green);">
                            <div style="font-size: 2.2rem; font-weight: 700; color: var(--accent-green);" id="salesStatPaidOrders">--</div>
                            <div style="color: var(--text-secondary); font-size: 0.85rem;">Paid Orders</div>
                        </div>
                        <div style="background: var(--bg-primary); padding: 20px; border-radius: 12px; text-align: center; border-left: 4px solid var(--accent-orange);">
                            <div style="font-size: 2.2rem; font-weight: 700; color: var(--accent-orange);" id="salesStatUnpaidOrders">--</div>
                            <div style="color: var(--text-secondary); font-size: 0.85rem;">Unpaid Orders</div>
                        </div>
                        <div style="background: var(--bg-primary); padding: 20px; border-radius: 12px; text-align: center; border-left: 4px solid var(--accent-purple);">
                            <div style="font-size: 2.2rem; font-weight: 700; color: var(--accent-purple);" id="salesStatNewCustomers">--</div>
                            <div style="color: var(--text-secondary); font-size: 0.85rem;">New Customers</div>
                        </div>
                    </div>

                    <!-- Commission Calculator Section -->
                    <div style="background: linear-gradient(135deg, rgba(147, 51, 234, 0.15), rgba(168, 85, 247, 0.1)); border: 1px solid rgba(147, 51, 234, 0.4); border-radius: 12px; padding: 20px; margin-bottom: 20px;">
                        <h4 style="margin: 0 0 15px 0; color: var(--accent-purple); display: flex; align-items: center; gap: 10px;">
                            <span>ðŸ’µ</span> Commission Calculator (8% on Paid Invoices)
                        </h4>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 15px;">
                            <div style="background: var(--bg-primary); padding: 20px; border-radius: 10px; text-align: center; cursor: pointer; transition: all 0.3s ease;" onclick="showCommissionDetails('currentMonth')" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(147, 51, 234, 0.3)';" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none';">
                                <div style="font-size: 0.8rem; color: var(--text-secondary); margin-bottom: 5px;">Current Month Commission</div>
                                <div style="font-size: 1.8rem; font-weight: 700; color: var(--accent-purple);" id="commissionCurrentMonth">$0.00</div>
                                <div style="font-size: 0.75rem; color: var(--text-secondary); margin-top: 5px;" id="commissionCurrentMonthLabel">January 2025</div>
                                <div style="font-size: 0.65rem; color: var(--text-secondary); margin-top: 8px; opacity: 0.7;">Click for details</div>
                            </div>
                            <div style="background: var(--bg-primary); padding: 20px; border-radius: 10px; text-align: center; cursor: pointer; transition: all 0.3s ease;" onclick="showCommissionDetails('prevMonth')" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(16, 185, 129, 0.3)';" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none';">
                                <div style="font-size: 0.8rem; color: var(--text-secondary); margin-bottom: 5px;">Previous Month Commission</div>
                                <div style="font-size: 1.8rem; font-weight: 700; color: var(--accent-green);" id="commissionPrevMonth">$0.00</div>
                                <div style="font-size: 0.75rem; color: var(--text-secondary); margin-top: 5px;" id="commissionPrevMonthLabel">December 2024</div>
                                <div style="font-size: 0.65rem; color: var(--text-secondary); margin-top: 8px; opacity: 0.7;">Click for details</div>
                            </div>
                            <div style="background: linear-gradient(135deg, rgba(16, 185, 129, 0.2), rgba(147, 51, 234, 0.2)); padding: 20px; border-radius: 10px; text-align: center; border: 2px solid var(--accent-green); cursor: pointer; transition: all 0.3s ease;" onclick="showCommissionDetails('nextPaycheck')" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(16, 185, 129, 0.4)';" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none';">
                                <div style="font-size: 0.8rem; color: var(--accent-green); margin-bottom: 5px; font-weight: 600;">Next Paycheck</div>
                                <div style="font-size: 2rem; font-weight: 700; color: var(--accent-green);" id="commissionNextPaycheck">$0.00</div>
                                <div style="font-size: 0.75rem; color: var(--text-secondary); margin-top: 5px;" id="commissionPaydayDate">January 9, 2025</div>
                                <div style="font-size: 0.65rem; color: var(--text-secondary); margin-top: 8px; opacity: 0.7;">Click for details</div>
                            </div>
                        </div>
                        <div style="margin-top: 15px; padding: 12px; background: var(--bg-tertiary); border-radius: 8px; font-size: 0.85rem; color: var(--text-secondary);">
                            <strong style="color: var(--accent-purple);">Pay Schedule:</strong> Commission paid every 2 weeks on Friday. First pay period of each month includes previous month's commission.
                            <span id="commissionPayScheduleNote" style="display: block; margin-top: 5px;"></span>
                        </div>
                    </div>

                    <!-- Monthly Breakdown -->
                    <div style="background: var(--bg-primary); border-radius: 12px; padding: 20px;">
                        <h4 style="margin: 0 0 15px 0; color: var(--text-primary); display: flex; align-items: center; gap: 10px;">
                            <span>ðŸ“Š</span> Monthly Sales Breakdown
                        </h4>
                        <div id="salesMonthlyBreakdown" style="max-height: 300px; overflow-y: auto;">
                            <div style="text-align: center; padding: 30px; color: var(--text-secondary);">
                                Loading sales data...
                            </div>
                        </div>
                    </div>

                    <!-- Sales Bar Chart -->
                    <div style="background: var(--bg-primary); border-radius: 12px; padding: 20px; margin-top: 20px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                            <h4 style="margin: 0; color: var(--text-primary); display: flex; align-items: center; gap: 10px;">
                                Sales Trends (Last 6 Months)
                            </h4>
                            <div style="display: flex; gap: 8px;">
                                <button onclick="setSalesChartType('revenue')" id="chartTypeRevenue" class="btn" style="background: var(--accent-orange); padding: 6px 12px; font-size: 0.8rem;">Revenue</button>
                                <button onclick="setSalesChartType('orders')" id="chartTypeOrders" class="btn" style="background: var(--bg-tertiary); padding: 6px 12px; font-size: 0.8rem;">Orders</button>
                            </div>
                        </div>
                        <div id="salesBarChart" style="min-height: 200px;">
                            <div style="text-align: center; padding: 40px; color: var(--text-secondary);">Loading chart...</div>
                        </div>
                        <!-- Data cache status -->
                        <div id="salesCacheStatus" style="margin-top: 15px; padding: 10px; background: var(--bg-tertiary); border-radius: 8px; font-size: 0.8rem; color: var(--text-secondary); display: flex; justify-content: space-between; align-items: center;">
                            <span id="cacheStatusText">Data not cached</span>
                            <button onclick="forceSyncSalesData()" class="btn" style="background: var(--accent-purple); padding: 5px 10px; font-size: 0.75rem;">Sync to Cloud</button>
                        </div>
                    </div>
                </div>

                <!-- Blog Generator Toggle Button -->
                <div style="display: flex; gap: 10px; margin-bottom: 20px;">
                    <button onclick="toggleBlogGenerator()" class="btn" style="background: linear-gradient(135deg, var(--accent-purple), var(--accent-blue)); padding: 15px 30px; font-size: 1.1rem; flex: 1;">ðŸ“ Blog Generator</button>
                    <a href="/blog" target="_blank" class="btn" style="background: var(--accent-blue); padding: 15px 30px; font-size: 1.1rem; text-decoration: none; display: flex; align-items: center; justify-content: center;">ðŸŒ View Blog</a>
                </div>
                
                <!-- Blog Generator Section (hidden by default) -->
                <div id="blogGeneratorSection" style="display: none;">
                
                <!-- Quick Update Section -->
                <div style="background: linear-gradient(135deg, rgba(0, 240, 255, 0.1), rgba(191, 0, 255, 0.1)); border: 2px solid var(--accent-blue); border-radius: 16px; padding: 25px; margin-bottom: 30px;">
                    <h3 style="color: var(--accent-blue); margin: 0 0 10px 0; display: flex; align-items: center; gap: 10px;">
                        <span>âš¡</span> Quick Update
                    </h3>
                    <p style="color: var(--text-secondary); margin: 0 0 15px 0;">Type a quick note and I'll turn it into an engaging post. Mention partners and they'll be auto-tagged!</p>

                    <div class="foh-generate-container" style="display: flex; flex-wrap: wrap; gap: 15px; margin-bottom: 15px;">
                        <input type="text" id="fohQuickInput" placeholder="e.g., Grabbed some fire GMO trim from In The Flow..." style="flex: 1 1 100%; min-width: 0; padding: 15px; font-size: 1.1rem; border-radius: 10px; border: 2px solid var(--border); background: var(--bg-primary); color: var(--text-primary); box-sizing: border-box;">
                        <button onclick="generateBlogPost()" class="btn foh-generate-btn" style="background: linear-gradient(135deg, var(--accent-purple), var(--accent-blue)); padding: 15px 30px; font-size: 1.1rem; flex: 1 1 100%;">
                            âœ¨ Generate Post
                        </button>
                    </div>

                    <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                        <span style="color: var(--text-secondary); font-size: 0.9rem;">Quick tags:</span>
                        <button onclick="addQuickTag('new hardware')" class="quick-tag-btn">ðŸ”§ Equipment</button>
                        <button onclick="addQuickTag('fresh batch')" class="quick-tag-btn">ðŸ§ª New Batch</button>
                        <button onclick="addQuickTag('new strain')" class="quick-tag-btn">ðŸŒ¿ New Strain</button>
                        <button onclick="addQuickTag('lab update')" class="quick-tag-btn">âš—ï¸ Lab Update</button>
                    </div>
                </div>

                <!-- Generated Preview -->
                <div id="fohGeneratedPreview" style="display: none; background: var(--bg-secondary); border-radius: 16px; padding: 25px; margin-bottom: 30px; border: 2px solid var(--accent-green);">
                    <div style="display: flex; flex-wrap: wrap; justify-content: space-between; align-items: center; margin-bottom: 15px; gap: 10px;">
                        <h3 style="color: var(--accent-green); margin: 0;">âœ… Generated Post Preview</h3>
                        <div style="display: flex; flex-wrap: wrap; gap: 10px;">
                            <button onclick="regenerateBlogPost()" class="btn" style="background: var(--bg-tertiary); flex: 1 1 auto;">ðŸ”„ Regenerate</button>
                            <button onclick="editBlogPost()" class="btn" style="background: var(--accent-orange); flex: 1 1 auto;">âœï¸ Edit</button>
                            <button onclick="publishBlogPost()" class="btn" style="background: var(--accent-green); flex: 1 1 auto;">ðŸš€ Publish</button>
                        </div>
                    </div>
                    <div id="fohPartnerInfo"></div>
                    <h4 id="fohPreviewTitle" style="font-size: 1.4rem; margin: 0 0 15px 0;"></h4>
                    <div id="fohPreviewContent" style="color: var(--text-secondary); line-height: 1.6;"></div>
                </div>

                <!-- Recent Completed Batches for Blog -->
                <div style="background: var(--bg-secondary); border-radius: 16px; padding: 25px; margin-bottom: 30px;">
                    <h3 style="margin: 0 0 20px 0; display: flex; align-items: center; gap: 10px;">
                        <span>ðŸ”¥</span> Recent Completed Batches
                        <span style="font-size: 0.8rem; color: var(--text-secondary); font-weight: normal;">Click to create post</span>
                    </h3>
                    <div id="fohRecentBatches" style="display: grid; gap: 15px;">
                        <!-- Populated dynamically -->
                        <div style="text-align: center; padding: 40px; color: var(--text-secondary);">Loading batches...</div>
                    </div>
                </div>
                </div>


                <!-- Published Posts -->
                <div style="background: var(--bg-secondary); border-radius: 16px; padding: 25px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <h3 style="margin: 0; display: flex; align-items: center; gap: 10px;">
                            <span>ðŸ“</span> Recent Blog Posts
                        </h3>
                        <button onclick="loadFOHPosts()" class="btn" style="background: var(--bg-tertiary); padding: 8px 15px;">ðŸ”„ Refresh</button>
                    </div>
                    <div id="fohPostsList">
                        <div style="text-align: center; padding: 40px; color: var(--text-secondary);">Loading posts...</div>
                    </div>
                </div>
            </div>
        </div>

        </div><!-- end appContent -->
    </div>

    <!-- Edit Batch Modal -->
    <div id="editBatchModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.8); z-index: 10000; overflow-y: auto;">
        <div style="max-width: 800px; margin: 50px auto; background: var(--bg-secondary); border-radius: 16px; padding: 30px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h2 style="color: var(--accent-orange);">âœï¸ Edit Batch</h2>
                <button onclick="closeEditBatch()" style="background: none; border: none; color: var(--text-primary); font-size: 2rem; cursor: pointer; padding: 0; width: 40px; height: 40px;">&times;</button>
            </div>
            
            <div id="editBatchForm">
                <input type="hidden" id="originalBatchId">
                
                <div class="form-grid">
                    <div class="form-group">
                        <label>Batch ID</label>
                        <input type="text" id="editBatchId" style="font-family: 'Space Mono', monospace; font-weight: 700; font-size: 1.2rem;">
                        <div class="help-text">Format: M.D.XXXX (e.g., 9.15.5678)</div>
                    </div>
                </div>
                
                <!-- Auto-Parsed Information -->
                <div style="background: linear-gradient(135deg, rgba(16, 185, 129, 0.1), rgba(59, 130, 246, 0.1)); padding: 20px; border-radius: 12px; margin-bottom: 20px; border: 2px solid var(--accent-green);">
                    <h3 style="color: var(--accent-green); margin-bottom: 15px; display: flex; align-items: center; gap: 10px;">
                        <span>ðŸ”„</span> Auto-Parsed from Batch ID
                    </h3>
                    <div class="form-grid">
                        <div class="form-group" style="margin: 0;">
                            <label>METRC Last 4 Digits</label>
                            <input type="text" id="parsedMetrcLast4" readonly style="background: var(--bg-primary); color: var(--accent-green); font-family: 'Space Mono', monospace; font-size: 1.3rem; font-weight: 700; text-align: center;">
                            <div class="help-text">Extracted from batch ID</div>
                        </div>
                        <div class="form-group" style="margin: 0;">
                            <label>Expiration Date</label>
                            <input type="date" id="parsedExpirationDate" readonly style="background: var(--bg-primary); color: var(--accent-green); font-size: 1.1rem; font-weight: 700;">
                            <div class="help-text">Calculated from batch ID month.day</div>
                        </div>
                    </div>
                </div>
                
                <!-- Strain Name at Top -->
                <div style="background: var(--bg-tertiary); padding: 20px; border-radius: 12px; margin-bottom: 25px; border-left: 4px solid var(--accent-purple);">
                    <div class="form-group" style="margin: 0;">
                        <label>Strain Name</label>
                        <input type="text" id="editStrainName" style="font-size: 1.4rem; font-weight: 700; padding: 16px;">
                    </div>
                </div>
                
                <div class="form-grid">
                    <div class="form-group">
                        <label>Status</label>
                        <select id="editBatchStatus">
                            <option value="intake">Intake</option>
                            <option value="extraction">Extraction</option>
                            <option value="finishing">Post-Extraction</option>
                            <option value="packaging">Packaging</option>
                            <option value="complete">Complete</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                            <input type="checkbox" id="editLabelsApplied" style="width: 18px; height: 18px;">
                            Labels Applied
                        </label>
                        <div class="help-text">Uncheck to send back to labeling queue</div>
                    </div>
                    <div class="form-group">
                        <label>Strain Type</label>
                        <select id="editStrainType">
                            <option value="Indica">Indica (Blue Lid)</option>
                            <option value="Sativa">Sativa (Red Lid)</option>
                            <option value="Hybrid">Hybrid (Green Lid)</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Trim Weight (g)</label>
                        <input type="number" id="editTrimWeight" step="0.1">
                    </div>
                    <div class="form-group">
                        <label>Socks Remaining</label>
                        <input type="number" id="editSocksRemaining" min="0">
                        <div class="help-text">Socks left to extract</div>
                    </div>
                    <div class="form-group">
                        <label>Bulk Weight (g)</label>
                        <input type="number" id="editBulkWeight" step="0.1">
                        <div class="help-text">Post-extraction final weight</div>
                    </div>
                    <div class="form-group">
                        <label>Material Cost ($)</label>
                        <input type="number" id="editMaterialCost" step="0.01">
                    </div>
                    <div class="form-group">
                        <label>Cultivation License</label>
                        <input type="text" id="editCultivationLicense">
                    </div>
                    <div class="form-group">
                        <label>Grower Name</label>
                        <input type="text" id="editGrowerName">
                    </div>
                    <div class="form-group">
                        <label>METRC Tags</label>
                        <input type="text" id="editMetrcTags" placeholder="12345, 67890">
                    </div>
                </div>
                
                <div class="form-group">
                    <label>Edit Notes (Why are you making this change?)</label>
                    <textarea id="editNotes" placeholder="Explain what you're changing and why..." required></textarea>
                </div>
                
                <div style="display: flex; gap: 10px; margin-top: 20px;">
                    <button class="btn" style="background: var(--accent-green); flex: 1;" onclick="saveEditedBatch()">ðŸ’¾ Save Changes</button>
                    <button class="btn" style="background: var(--bg-tertiary); flex: 1;" onclick="closeEditBatch()">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Create Sub-Batch Modal -->
    <div id="createSubBatchModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.8); z-index: 10000; overflow-y: auto;">
        <div style="max-width: 800px; margin: 50px auto; background: var(--bg-secondary); border-radius: 16px; padding: 30px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h2 style="color: var(--accent-green);">âž• Create Retroactive Sub-Batch</h2>
                <button onclick="closeCreateSubBatch()" style="background: none; border: none; color: var(--text-primary); font-size: 2rem; cursor: pointer; padding: 0; width: 40px; height: 40px;">&times;</button>
            </div>
            
            <div style="background: rgba(59, 130, 246, 0.15); border-left: 4px solid var(--accent-blue); padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                <strong>â„¹ï¸ About Retroactive Sub-Batches:</strong>
                <p style="margin: 8px 0 0 0; line-height: 1.6;">
                    Use this when a batch was split into multiple products, but wasn't recorded as sub-batches during production. 
                    This creates a new sub-batch with its own ID, product type, and weight from the parent batch's final weight.
                </p>
            </div>

            <div id="subBatchParentInfo" style="background: var(--bg-tertiary); padding: 15px; border-radius: 10px; margin-bottom: 20px;">
                <h3 style="color: var(--accent-purple); margin-bottom: 10px;">Parent Batch Info</h3>
                <div id="subBatchParentDetails"></div>
            </div>
            
            <div id="createSubBatchForm">
                <input type="hidden" id="subBatchParentId">
                
                <div class="form-grid">
                    <div class="form-group">
                        <label>Sub-Batch ID</label>
                        <input type="text" id="newSubBatchId" readonly style="background: var(--bg-primary); font-family: 'Space Mono', monospace; font-weight: 700; color: var(--accent-green);">
                        <div class="help-text">Auto-generated from parent batch</div>
                    </div>
                    <div class="form-group">
                        <label>Product Type</label>
                        <select id="subBatchProductType" required>
                            <option value="">Select Product Type</option>
                            <option value="Wax">Wax</option>
                            <option value="Sugar Wax">Sugar Wax</option>
                            <option value="Shatter">Shatter</option>
                            <option value="Live Resin Carts">Live Resin Carts</option>
                            <option value="Live Resin AIOs">Live Resin AIOs</option>
                            <option value="Brick Hash">Brick Hash</option>
                            <option value="Hash Hits">Hash Hits</option>
                            <option value="RSO">RSO</option>
                        </select>
                        <div class="help-text">What product was this portion made into?</div>
                    </div>
                </div>
                
                <div style="background: rgba(245, 158, 11, 0.2); border-left: 4px solid var(--accent-orange); padding: 15px; border-radius: 8px; margin: 20px 0;">
                    <strong style="color: var(--accent-orange);">âš™ï¸ Post-Processing Required</strong>
                    <p style="margin: 8px 0 0 0; color: var(--text-secondary);">
                        This sub-batch will be created at <strong>extraction</strong> status. The post-processor must complete it on the <strong>Post Extraction</strong> page to enter weights and finish it properly.
                    </p>
                </div>
                
                <div class="form-group">
                    <label>Notes / Reason for Retroactive Creation</label>
                    <textarea id="subBatchNotes" placeholder="Why is this sub-batch being created retroactively? What happened?" required></textarea>
                </div>
                
                <div style="display: flex; gap: 10px; margin-top: 20px;">
                    <button class="btn" style="background: var(--accent-green); flex: 1;" onclick="saveSubBatch()">âœ… Create Sub-Batch (Needs Post-Processing)</button>
                    <button class="btn" style="background: var(--bg-tertiary); flex: 1;" onclick="closeCreateSubBatch()">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <!-- METRC Manifest Import Modal -->
    <div id="metrcImportModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); z-index: 10000; overflow-y: auto;">
        <div style="max-width: 1200px; margin: 30px auto; background: var(--bg-secondary); border-radius: 20px; padding: 40px; border: 3px solid var(--accent-blue);">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 30px;">
                <div>
                    <h2 style="color: var(--accent-blue); margin-bottom: 5px;">ðŸ“‹ Import from METRC Manifest</h2>
                    <p style="color: var(--text-secondary); font-size: 0.9rem;">Pull incoming transfers and select tags for batch intake</p>
                </div>
                <button onclick="closeMetrcImport()" style="background: none; border: none; color: var(--text-primary); font-size: 2.5rem; cursor: pointer; padding: 0; width: 50px; height: 50px; line-height: 40px;">&times;</button>
            </div>
            
            <!-- METRC API Configuration -->
            <div id="metrcConfigSection" style="background: rgba(59, 130, 246, 0.1); border: 2px solid var(--accent-blue); padding: 25px; border-radius: 15px; margin-bottom: 30px;">
                <h3 style="color: var(--accent-blue); margin-bottom: 20px; display: flex; align-items: center; gap: 10px;">
                    <span>ðŸ”‘</span> METRC API Credentials
                    <span id="metrcConfigStatus" style="margin-left: auto; font-size: 0.85rem; padding: 5px 12px; border-radius: 15px;"></span>
                </h3>
                
                <div style="background: rgba(59, 130, 246, 0.15); border-left: 4px solid var(--accent-blue); padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                    <strong>ðŸ“˜ METRC Requires Two API Keys:</strong>
                    <ol style="margin: 10px 0 0 20px; line-height: 1.8;">
                        <li><strong>Integrator/Software API Key</strong> - Your company's key from METRC Connect
                            <div style="font-size: 0.9rem; color: var(--text-secondary); margin-top: 3px;">This stays the same for all users</div>
                        </li>
                        <li><strong>User API Key</strong> - Created by the user in their METRC account
                            <div style="font-size: 0.9rem; color: var(--text-secondary); margin-top: 3px;">Settings â†’ Integrations â†’ User API Keys</div>
                        </li>
                    </ol>
                </div>

                <div style="background: rgba(239, 68, 68, 0.1); border-left: 4px solid var(--accent-red); padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                    <strong>âš ï¸ Browser CORS Limitation:</strong>
                    <ul style="margin: 10px 0 0 20px; line-height: 1.6;">
                        <li>Direct API calls from browsers are blocked by CORS security</li>
                        <li>Even with correct keys, browser connections will likely fail</li>
                        <li><strong>Recommended:</strong> Use Manual Entry tab or set up a server proxy</li>
                    </ul>
                </div>

                <form id="metrcCredentialsForm" onsubmit="event.preventDefault(); saveMetrcConfig();">
                    <div class="form-grid">
                        <div class="form-group">
                            <label>Integrator API Key (Software Key)</label>
                            <input type="password" id="metrcIntegratorKey" placeholder="Your White Mousse integrator key" autocomplete="off">
                            <div class="help-text">From METRC Connect - stays the same for all users</div>
                        </div>
                        <div class="form-group">
                            <label>User API Key</label>
                            <input type="password" id="metrcUserKey" placeholder="Individual user's API key" autocomplete="off">
                            <div class="help-text">Created in METRC: Settings â†’ Integrations â†’ User API Keys</div>
                        </div>
                        <div class="form-group">
                            <label>Manufacturing License Number</label>
                            <input type="text" id="metrcLicenseNumber" value="404R-00016" readonly style="opacity: 0.7; background: var(--bg-tertiary);">
                            <div class="help-text">Your White Mousse manufacturing license (locked)</div>
                        </div>
                    </div>
                    
                    <div style="display: flex; gap: 10px; margin-top: 15px;">
                        <button type="submit" class="btn" style="background: var(--accent-blue); flex: 1;">
                            ðŸ’¾ Save Credentials
                        </button>
                        <button type="button" class="btn" style="background: var(--accent-green); flex: 1;" onclick="testMetrcConnection()">
                            ðŸ”¬ Test Connection
                        </button>
                    </div>
                </form>
                <div id="metrcTestResult" style="margin-top: 15px; display: none;"></div>
            </div>

            <!-- Tab switcher for API vs Manual -->
            <div style="display: flex; gap: 10px; margin-bottom: 20px; border-bottom: 2px solid var(--border);">
                <button class="metrc-tab-btn" data-tab="api" onclick="switchMetrcTab('api')" 
                        style="flex: 1; padding: 15px; background: none; border: none; border-bottom: 3px solid transparent; color: var(--text-secondary); font-weight: 700; cursor: pointer; transition: all 0.3s;">
                    ðŸ”Œ API Import (Advanced)
                </button>
                <button class="metrc-tab-btn active" data-tab="manual" onclick="switchMetrcTab('manual')"
                        style="flex: 1; padding: 15px; background: none; border: none; border-bottom: 3px solid var(--accent-purple); color: var(--accent-purple); font-weight: 700; cursor: pointer; transition: all 0.3s;">
                    âœï¸ Manual Entry (Recommended)
                </button>
            </div>

            <!-- API Load Section -->
            <div id="metrcLoadSection" style="display: none;">
                <div style="display: flex; gap: 15px; margin-bottom: 25px; align-items: end;">
                    <div class="form-group" style="flex: 1; margin: 0;">
                        <label>Start Date</label>
                        <input type="date" id="metrcStartDate" style="width: 100%;">
                    </div>
                    <div class="form-group" style="flex: 1; margin: 0;">
                        <label>End Date</label>
                        <input type="date" id="metrcEndDate" style="width: 100%;">
                    </div>
                    <button class="btn" style="background: var(--accent-green); white-space: nowrap;" onclick="loadMetrcManifests()">
                        ðŸ”„ Load Incoming Transfers
                    </button>
                </div>

                <div id="metrcLoadingIndicator" style="display: none; text-align: center; padding: 40px; color: var(--accent-blue);">
                    <div style="font-size: 3rem; margin-bottom: 10px;">â³</div>
                    <div>Loading manifests from METRC...</div>
                </div>

                <div id="metrcError" style="display: none; background: rgba(239, 68, 68, 0.2); border: 2px solid var(--accent-red); color: var(--accent-red); padding: 20px; border-radius: 10px; margin-bottom: 20px;"></div>

                <!-- Manifests List -->
                <div id="metrcManifestsList" style="display: none;">
                    <h3 style="color: var(--accent-purple); margin-bottom: 20px;">Select a Manifest to Import</h3>
                    <div id="manifestsContainer"></div>
                </div>

                <!-- Selected Manifest Details -->
                <div id="manifestDetailsSection" style="display: none;">
                    <div style="background: linear-gradient(135deg, rgba(147, 51, 234, 0.15), rgba(59, 130, 246, 0.15)); padding: 25px; border-radius: 15px; margin-bottom: 25px; border: 2px solid var(--accent-purple);">
                        <h3 style="color: var(--accent-purple); margin-bottom: 15px;">ðŸ“¦ Manifest Details</h3>
                        <div id="manifestInfo" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px;"></div>
                    </div>

                    <h3 style="color: var(--accent-green); margin-bottom: 20px;">Select Tags for Batch</h3>
                    <div id="tagsContainer" style="display: grid; gap: 10px; margin-bottom: 25px;"></div>

                    <div style="background: var(--bg-tertiary); padding: 20px; border-radius: 12px; margin-bottom: 25px;">
                        <h4 style="color: var(--accent-orange); margin-bottom: 15px;">Selected Tags Summary</h4>
                        <div id="selectedTagsSummary"></div>
                    </div>

                    <div style="display: flex; gap: 15px;">
                        <button class="btn" style="background: var(--accent-green); flex: 1;" onclick="importManifestToBatch()">
                            âœ… Import to Batch Intake Form
                        </button>
                        <button class="btn" style="background: var(--bg-tertiary); flex: 1;" onclick="clearManifestSelection()">
                            â†©ï¸ Back to Manifests
                        </button>
                    </div>
                </div>
            </div>

            <!-- Manual Entry Section -->
            <div id="metrcManualSection">
                <div style="background: rgba(16, 185, 129, 0.1); border: 2px solid var(--accent-green); padding: 20px; border-radius: 12px; margin-bottom: 20px;">
                    <h3 style="color: var(--accent-green); margin-bottom: 10px;">âœ… Recommended Method</h3>
                    <p style="color: var(--text-secondary); font-size: 0.95rem; line-height: 1.6;">
                        This is the most reliable way to import manifest data. Simply open METRC in another tab, 
                        view your incoming transfer, and copy the information here. Fast, simple, and always works!
                    </p>
                </div>

                <div class="form-grid" style="margin-bottom: 20px;">
                    <div class="form-group">
                        <label>Manifest Number</label>
                        <input type="text" id="manualManifestNumber" placeholder="e.g., 0000123456">
                    </div>
                    <div class="form-group">
                        <label>Received Date</label>
                        <input type="date" id="manualReceivedDate">
                    </div>
                    <div class="form-group">
                        <label>Shipper Facility Name</label>
                        <input type="text" id="manualShipperName" placeholder="e.g., ABC Cultivation">
                    </div>
                    <div class="form-group">
                        <label>Shipper License (403R/404R)</label>
                        <input type="text" id="manualShipperLicense" placeholder="403R-00000 or 404R-00000">
                    </div>
                </div>

                <div style="background: var(--bg-tertiary); padding: 20px; border-radius: 12px; margin-bottom: 20px;">
                    <h4 style="color: var(--accent-green); margin-bottom: 15px;">Add Package Tags</h4>
                    <p style="color: var(--text-secondary); font-size: 0.9rem; margin-bottom: 15px;">
                        Enter each package tag from the manifest. You can add multiple packages.
                    </p>
                    
                    <div id="manualPackagesContainer">
                        <div class="manual-package-row" style="display: grid; grid-template-columns: 2fr 1fr 1fr auto; gap: 10px; margin-bottom: 10px; align-items: end;">
                            <div class="form-group" style="margin: 0;">
                                <label>METRC Tag Number</label>
                                <input type="text" class="manual-tag-number" placeholder="1A4060300001234567890">
                            </div>
                            <div class="form-group" style="margin: 0;">
                                <label>Weight (g)</label>
                                <input type="number" class="manual-tag-weight" step="0.1" placeholder="0">
                            </div>
                            <div class="form-group" style="margin: 0;">
                                <label>Strain/Product</label>
                                <input type="text" class="manual-tag-strain" placeholder="OG Kush Trim">
                            </div>
                        </div>
                    </div>
                    
                    <button class="btn" style="background: var(--accent-green); margin-top: 10px;" onclick="addManualPackageRow()">
                        âž• Add Another Package
                    </button>
                </div>

                <div style="background: var(--bg-primary); padding: 20px; border-radius: 12px; margin-bottom: 20px;">
                    <h4 style="color: var(--accent-orange); margin-bottom: 10px;">Summary</h4>
                    <div id="manualSummary" style="color: var(--text-secondary); font-style: italic;">
                        Enter package details above to see summary
                    </div>
                </div>

                <button class="btn" style="background: var(--accent-purple); width: 100%;" onclick="importManualManifest()">
                    âœ… Import Manual Entry to Batch Form
                </button>
            </div>
        </div>
    </div>

    <!-- Personal Stats Modal -->
    <div id="personalStatsModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); z-index: 10001; overflow-y: auto;">
        <div style="max-width: 1000px; margin: 30px auto; background: var(--bg-secondary); border-radius: 20px; padding: 0; box-shadow: 0 20px 60px rgba(147, 51, 234, 0.4);">
            <!-- Header -->
            <div style="background: linear-gradient(135deg, var(--accent-purple), var(--accent-blue)); padding: 30px; border-radius: 20px 20px 0 0;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <h2 style="color: white; margin: 0 0 10px 0; font-size: 2rem;">
                            ðŸ‘¤ <span id="modalPersonalStatName">Your Workload</span>
                        </h2>
                        <p style="color: rgba(255,255,255,0.9); margin: 0;">Your tasks and progress for today</p>
                    </div>
                    <button onclick="closePersonalStatsModal()" style="background: rgba(255,255,255,0.2); border: none; color: white; font-size: 2rem; cursor: pointer; padding: 5px 15px; border-radius: 10px; transition: all 0.3s ease;">&times;</button>
                </div>
            </div>
            
            <!-- Content -->
            <div style="padding: 30px;">
                <!-- What's Next Section -->
                <div id="whatsNextSection" style="background: linear-gradient(135deg, rgba(16, 185, 129, 0.2), rgba(59, 130, 246, 0.2)); padding: 25px; border-radius: 12px; margin-bottom: 25px; border: 2px solid var(--accent-green);">
                    <h3 style="color: var(--accent-green); margin: 0 0 15px 0; font-size: 1.3rem;">âš¡ What's Next</h3>
                    <div id="whatsNextContent">
                        <!-- Populated dynamically -->
                    </div>
                </div>
                
                <!-- Today's Progress -->
                <div style="background: linear-gradient(135deg, rgba(147, 51, 234, 0.2), rgba(59, 130, 246, 0.2)); padding: 25px; border-radius: 12px; margin-bottom: 25px; border: 2px solid var(--accent-purple);">
                    <h3 style="color: var(--accent-purple); margin: 0 0 15px 0; font-size: 1.3rem;">ðŸ“Š Today's Progress</h3>
                    <div id="todayProgressContent" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px;">
                        <!-- Populated dynamically -->
                    </div>
                </div>
                
                <!-- Quick Time Selector -->
                <div style="display: flex; gap: 10px; justify-content: center; margin-bottom: 20px; flex-wrap: wrap;">
                    <button class="personal-time-btn active" data-period="today" onclick="updatePersonalStats('today')">Today</button>
                    <button class="personal-time-btn" data-period="week" onclick="updatePersonalStats('week')">This Week</button>
                    <button class="personal-time-btn" data-period="month" onclick="updatePersonalStats('month')">This Month</button>
                    <button class="personal-time-btn" data-period="all" onclick="updatePersonalStats('all')">All Time</button>
                </div>
                
                <!-- Stats Grid -->
                <div id="personalStatsContent" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 20px; margin-bottom: 30px;">
                    <!-- Populated dynamically -->
                </div>

                <!-- Sales Overdue Placeholder (hidden by default) -->
                <div id="myBatchesSection" style="display: none; margin-top: 30px; padding-top: 30px; border-top: 2px solid var(--border);"></div>

                <!-- Personal Records -->
                <div id="personalRecords" style="padding-top: 30px; border-top: 2px solid var(--border); margin-top: 30px;">
                    <h3 style="color: var(--accent-purple); margin-bottom: 20px; text-align: center; font-size: 1.5rem;">ðŸ† Your Best Days</h3>
                    <div id="personalRecordsContent" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                        <!-- Populated dynamically -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Compliance Modal -->
    <div id="complianceModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); z-index: 10003; overflow-y: auto;">
        <div style="max-width: 900px; margin: 30px auto; background: var(--bg-secondary); border-radius: 20px; padding: 0; box-shadow: 0 20px 60px rgba(16, 185, 129, 0.3);">
            <!-- Header -->
            <div style="background: linear-gradient(135deg, #10B981, #059669); padding: 25px 30px; border-radius: 20px 20px 0 0; display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <h2 style="margin: 0; color: white; font-size: 1.8rem;">ðŸ“‹ Compliance Assistant</h2>
                    <p style="margin: 5px 0 0 0; color: rgba(255,255,255,0.8); font-size: 0.95rem;">Colorado MED Rules (1 CCR 212-3) - Effective Jan 5, 2026</p>
                </div>
                <button onclick="closeComplianceModal()" style="background: rgba(255,255,255,0.2); border: none; color: white; font-size: 2rem; cursor: pointer; padding: 5px 15px; border-radius: 10px;">&times;</button>
            </div>

            <!-- Search Section -->
            <div style="padding: 25px 30px; border-bottom: 2px solid var(--border);">
                <div style="display: flex; gap: 15px; flex-wrap: wrap;">
                    <input type="text" id="complianceSearchInput" placeholder="Search rules... (e.g., waste log, METRC, labeling)"
                        style="flex: 1; min-width: 250px; padding: 15px 20px; border-radius: 10px; border: 2px solid var(--border); background: var(--bg-tertiary); color: var(--text-primary); font-size: 1rem;"
                        onkeyup="if(event.key === 'Enter') searchComplianceRules()">
                    <button onclick="searchComplianceRules()" class="btn" style="background: var(--accent-green); border-color: var(--accent-green); padding: 15px 30px;">ðŸ” Search</button>
                </div>

                <!-- Quick Topics -->
                <div style="margin-top: 15px; display: flex; gap: 10px; flex-wrap: wrap;">
                    <span style="color: var(--text-secondary); padding: 8px 0;">Quick topics:</span>
                    <button onclick="searchComplianceTopic('waste')" class="compliance-topic-btn">Waste Disposal</button>
                    <button onclick="searchComplianceTopic('metrc')" class="compliance-topic-btn">METRC/Tracking</button>
                    <button onclick="searchComplianceTopic('label')" class="compliance-topic-btn">Labeling</button>
                    <button onclick="searchComplianceTopic('security')" class="compliance-topic-btn">Security</button>
                    <button onclick="searchComplianceTopic('transport')" class="compliance-topic-btn">Transport</button>
                    <button onclick="searchComplianceTopic('testing')" class="compliance-topic-btn">Testing</button>
                    <button onclick="searchComplianceTopic('reducedtesting')" class="compliance-topic-btn">Reduced Testing</button>
                </div>
            </div>

            <!-- Results Section -->
            <div id="complianceResults" style="padding: 25px 30px; max-height: 500px; overflow-y: auto;">
                <div style="text-align: center; color: var(--text-secondary); padding: 40px;">
                    <div style="font-size: 3rem; margin-bottom: 15px;">ðŸ“š</div>
                    <p>Search Colorado MED rules or select a quick topic above.</p>
                    <p style="font-size: 0.9rem; margin-top: 10px;">Covers: Definitions, Licensing, Operations, Cultivation, Manufacturing, Testing, Retail, Inventory Tracking, Waste, Labeling, Transportation</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Commission Details Modal -->
    <div id="commissionDetailsModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); z-index: 10002; overflow-y: auto;">
        <div style="max-width: 1100px; margin: 30px auto; background: var(--bg-secondary); border-radius: 20px; padding: 0; box-shadow: 0 20px 60px rgba(147, 51, 234, 0.4);">
            <!-- Header -->
            <div id="commissionModalHeader" style="background: linear-gradient(135deg, var(--accent-purple), var(--accent-green)); padding: 30px; border-radius: 20px 20px 0 0;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <h2 style="color: white; margin: 0 0 10px 0; font-size: 1.8rem;" id="commissionModalTitle">Commission Details</h2>
                        <p style="color: rgba(255,255,255,0.9); margin: 0;" id="commissionModalSubtitle">Payments from Dec 6, 2024 to Jan 5, 2025</p>
                    </div>
                    <button onclick="closeCommissionDetailsModal()" style="background: rgba(255,255,255,0.2); border: none; color: white; font-size: 2rem; cursor: pointer; padding: 5px 15px; border-radius: 10px; transition: all 0.3s ease;">&times;</button>
                </div>
            </div>

            <!-- Content -->
            <div style="padding: 30px;">
                <!-- Action Buttons -->
                <div style="display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap;">
                    <button onclick="copyCommissionToClipboard()" class="btn" style="background: var(--accent-blue); padding: 10px 20px; display: flex; align-items: center; gap: 8px;">
                        <span>ðŸ“‹</span> Copy to Clipboard
                    </button>
                    <span id="commissionCopyStatus" style="color: var(--accent-green); display: none; align-self: center;">Copied!</span>
                </div>

                <!-- Table Container -->
                <div style="background: var(--bg-primary); border-radius: 12px; overflow: hidden; border: 1px solid var(--border);">
                    <div style="max-height: 500px; overflow-y: auto;">
                        <table id="commissionDetailsTable" style="width: 100%; border-collapse: collapse; font-size: 0.9rem;">
                            <thead style="position: sticky; top: 0; background: var(--bg-tertiary); z-index: 1;">
                                <tr>
                                    <th style="padding: 15px 12px; text-align: left; color: var(--text-secondary); font-weight: 600; border-bottom: 2px solid var(--border);">Invoice Number</th>
                                    <th style="padding: 15px 12px; text-align: left; color: var(--text-secondary); font-weight: 600; border-bottom: 2px solid var(--border);">Store</th>
                                    <th style="padding: 15px 12px; text-align: right; color: var(--text-secondary); font-weight: 600; border-bottom: 2px solid var(--border);">Amount</th>
                                    <th style="padding: 15px 12px; text-align: right; color: var(--text-secondary); font-weight: 600; border-bottom: 2px solid var(--border);">Pay Amount (8%)</th>
                                    <th style="padding: 15px 12px; text-align: left; color: var(--text-secondary); font-weight: 600; border-bottom: 2px solid var(--border);">Paid Date</th>
                                </tr>
                            </thead>
                            <tbody id="commissionDetailsBody">
                                <!-- Populated dynamically -->
                            </tbody>
                        </table>
                    </div>
                </div>

                <!-- Totals Footer -->
                <div id="commissionTotalsFooter" style="margin-top: 20px; padding: 20px; background: linear-gradient(135deg, rgba(147, 51, 234, 0.15), rgba(16, 185, 129, 0.15)); border-radius: 12px; border: 2px solid var(--accent-purple);">
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; text-align: center;">
                        <div>
                            <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 5px;">Total Orders</div>
                            <div style="font-size: 1.5rem; font-weight: 700; color: var(--text-primary);" id="commissionTotalOrders">0</div>
                        </div>
                        <div>
                            <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 5px;">Total Amount</div>
                            <div style="font-size: 1.5rem; font-weight: 700; color: var(--accent-blue);" id="commissionTotalAmount">$0.00</div>
                        </div>
                        <div>
                            <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 5px;">Total Commission (8%)</div>
                            <div style="font-size: 1.8rem; font-weight: 700; color: var(--accent-green);" id="commissionTotalPay">$0.00</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Inventory Management Modal -->
    <div id="inventoryModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); z-index: 10001; overflow-y: auto;">
        <div style="max-width: 600px; margin: 50px auto; background: var(--bg-secondary); border-radius: 20px; padding: 0; box-shadow: 0 20px 60px rgba(245, 158, 11, 0.4);">
            <!-- Header -->
            <div style="background: linear-gradient(135deg, var(--accent-orange), var(--accent-red)); padding: 30px; border-radius: 20px 20px 0 0;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <h2 style="color: white; margin: 0 0 10px 0; font-size: 2rem;">
                            ðŸ“¦ Update Supply Inventory
                        </h2>
                        <p style="color: rgba(255,255,255,0.9); margin: 0;">Track butane and nitrogen levels</p>
                    </div>
                    <button onclick="closeInventoryModal()" style="background: rgba(255,255,255,0.2); border: none; color: white; font-size: 2rem; cursor: pointer; padding: 5px 15px; border-radius: 10px; transition: all 0.3s ease;">&times;</button>
                </div>
            </div>
            
            <!-- Content -->
            <div style="padding: 30px;">
                <p style="text-align: center; color: var(--text-secondary);">Use the Gas Logging button in the Extraction tab to manage butane.</p>
            </div>
        </div>
    </div>
    
    <!-- Pull Batch Modal -->
    <div id="pullBatchModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); z-index: 10003; overflow-y: auto;">
        <div style="max-width: 600px; margin: 50px auto; background: var(--bg-secondary); border-radius: 20px; padding: 0; box-shadow: 0 20px 60px rgba(16, 185, 129, 0.4);">
            <div style="background: linear-gradient(135deg, var(--accent-green), var(--accent-blue)); padding: 30px; border-radius: 20px 20px 0 0;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <h2 style="color: white; margin: 0; font-size: 1.8rem;" id="pullBatchModalTitle">ðŸ«™ Pull Batch from Pot</h2>
                    <button onclick="closePullBatchModal()" style="background: rgba(255,255,255,0.2); border: none; color: white; font-size: 2rem; cursor: pointer; padding: 5px 15px; border-radius: 10px;">&times;</button>
                </div>
            </div>
            <div style="padding: 30px;">
                <!-- Current Pot Info -->
                <div id="pullBatchInfo" style="background: var(--bg-tertiary); padding: 20px; border-radius: 10px; margin-bottom: 25px; text-align: center;">
                    <div style="font-size: 0.9rem; color: var(--text-secondary); margin-bottom: 5px;">Batch in Pot</div>
                    <div id="pullBatchNumber" style="font-size: 1.8rem; font-weight: 700; color: var(--accent-blue); margin-bottom: 5px;">-</div>
                    <div id="pullBatchStrain" style="font-size: 1.3rem; font-weight: 600; color: var(--accent-purple); margin-bottom: 10px;">-</div>
                    <div id="pullBatchRuns" style="font-size: 1.1rem; color: var(--text-primary); margin-bottom: 15px;">0 runs collected</div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; text-align: center; padding-top: 15px; border-top: 1px solid var(--border);">
                        <div>
                            <div style="font-size: 0.8rem; color: var(--text-secondary);">Trim in Pot</div>
                            <div id="pullBatchTrimWeight" style="font-size: 1.4rem; font-weight: 700; color: var(--text-primary);">0g</div>
                        </div>
                        <div>
                            <div style="font-size: 0.8rem; color: var(--text-secondary);">Projected Yield</div>
                            <div id="pullBatchProjectedYield" style="font-size: 1.4rem; font-weight: 700; color: var(--accent-green);">0g</div>
                        </div>
                    </div>
                </div>
                
                <form id="pullBatchForm" onsubmit="event.preventDefault(); submitPullBatch();">
                    <!-- Product Type Selection -->
                    <div class="form-group">
                        <label>Product Type Pulled</label>
                        <select id="pullProductType" required onchange="updatePullFields()">
                            <option value="">Select product type...</option>
                            <option value="shatter">Shatter (count slabs)</option>
                            <option value="wax">Wax (count bowls)</option>
                            <option value="sugar_wax">Sugar Wax (count bowls)</option>
                            <option value="live_resin">Live Resin Oil (count bowls)</option>
                        </select>
                    </div>
                    
                    <!-- Shatter Fields -->
                    <div id="shatterFields" style="display: none;">
                        <div class="form-group">
                            <label>Number of Slabs</label>
                            <input type="number" id="pullSlabs" min="0" placeholder="0">
                            <div class="help-text">How many slabs of shatter were pulled?</div>
                        </div>
                    </div>
                    
                    <!-- Wax / Sugar Wax Fields (1g & 4g) -->
                    <div id="waxFields" style="display: none;">
                        <div class="form-group">
                            <label>Number of Bowls</label>
                            <input type="number" id="pullBowls" min="0" placeholder="0">
                            <div class="help-text">How many bowls of wax/sugar wax were pulled?</div>
                        </div>
                    </div>
                    
                    <!-- Notes -->
                    <div class="form-group">
                        <label>Notes (Optional)</label>
                        <textarea id="pullNotes" placeholder="Consistency, color, any observations..."></textarea>
                    </div>
                    
                    <button type="submit" class="btn" style="background: var(--accent-green); width: 100%; font-size: 1.1rem;">
                        âœ… Record Pull & Empty Pot
                    </button>
                </form>
            </div>
        </div>
    </div>
    
    <!-- Machine Status Modal -->
    <div id="machineModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); z-index: 10003; overflow-y: auto;">
        <div style="max-width: 600px; margin: 50px auto; background: var(--bg-secondary); border-radius: 20px; padding: 0; box-shadow: 0 20px 60px rgba(147, 51, 234, 0.4);">
            <div style="background: linear-gradient(135deg, var(--accent-blue), var(--accent-purple)); padding: 30px; border-radius: 20px 20px 0 0;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <h2 style="color: white; margin: 0; font-size: 1.8rem;" id="machineModalTitle">âš—ï¸ Machine Status</h2>
                    <button onclick="closeMachineModal()" style="background: rgba(255,255,255,0.2); border: none; color: white; font-size: 2rem; cursor: pointer; padding: 5px 15px; border-radius: 10px;">&times;</button>
                </div>
            </div>
            <div style="padding: 30px;">
                <form id="machineForm" onsubmit="event.preventDefault(); saveMachineStatus();">
                    <!-- Dynamic Columns (generated based on machine config) -->
                    <div id="machineColumnsContainer">
                        <!-- Populated by openMachineModal() based on machine config -->
                    </div>

                    <!-- Pot Status (BHO only) -->
                    <div id="machinePotSection" style="background: rgba(147, 51, 234, 0.1); border-left: 4px solid var(--accent-purple); padding: 20px; border-radius: 8px; margin-bottom: 20px;">
                        <h3 style="color: var(--accent-purple); margin: 0 0 15px 0;">ðŸ«™ Pot</h3>
                        <div id="potLedgerDisplay" style="display: none; background: var(--bg-tertiary); padding: 12px; border-radius: 8px; margin-bottom: 15px; font-size: 0.9rem;">
                            <!-- Populated by JS -->
                        </div>
                        <div class="form-grid">
                            <div class="form-group">
                                <label>Batch in Pot</label>
                                <input type="text" id="machinePotBatchDisplay" readonly style="background: var(--bg-tertiary);" placeholder="Empty">
                                <input type="hidden" id="machinePotBatch" value="">
                            </div>
                            <div class="form-group">
                                <label>Runs in Pot</label>
                                <input type="number" id="machinePotRuns" min="0" placeholder="0" readonly style="background: var(--bg-tertiary);">
                            </div>
                        </div>
                        <button type="button" id="modalPullBatchBtn" class="btn" style="display: none; background: linear-gradient(135deg, #FFD700, #FFA500); color: #1a1a2e; width: 100%; margin-top: 15px; padding: 15px; font-size: 1.1rem; font-weight: 700; box-shadow: 0 0 20px rgba(255, 215, 0, 0.4);" onclick="openPullBatchFromModal()">
                            ðŸ«™ Pull Batch from Pot
                        </button>
                    </div>

                    <!-- Filter Status (BHO only) -->
                    <div id="machineFilterSection" style="background: rgba(16, 185, 129, 0.1); border-left: 4px solid var(--accent-green); padding: 20px; border-radius: 8px; margin-bottom: 20px;">
                        <h3 style="color: var(--accent-green); margin: 0 0 15px 0;">ðŸ”¬ Filter Column</h3>
                        <div class="form-grid">
                            <div class="form-group">
                                <label>Clay (cups)</label>
                                <input type="number" id="machineFilterClay" step="0.5" min="0" placeholder="0">
                            </div>
                            <div class="form-group">
                                <label>Silica (cups)</label>
                                <input type="number" id="machineFilterSilica" step="0.5" min="0" placeholder="0">
                            </div>
                        </div>
                        <div class="form-group" style="margin-bottom: 0;">
                            <label>Runs Through Filter</label>
                            <input type="number" id="machineFilterRuns" min="0" placeholder="0">
                            <div class="help-text">How many runs have been processed through this filter?</div>
                        </div>
                    </div>
                    
                    <div id="machineFormButtons" style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                        <button type="button" class="btn" style="background: var(--accent-red);" onclick="clearMachineStatus()">ðŸ—‘ï¸ Clear All</button>
                        <button type="submit" class="btn" style="background: var(--accent-green);">âœ… Save Status</button>
                    </div>
                </form>
            </div>
        </div>
    </div>
    
    <!-- Extraction Supplies Modal -->
    <div id="suppliesModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); z-index: 10002; overflow-y: auto;">
        <div style="max-width: 700px; margin: 50px auto; background: var(--bg-secondary); border-radius: 20px; padding: 0; box-shadow: 0 20px 60px rgba(245, 158, 11, 0.4);">
            <div style="background: linear-gradient(135deg, var(--accent-orange), var(--accent-red)); padding: 30px; border-radius: 20px 20px 0 0;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <h2 style="color: white; margin: 0; font-size: 1.8rem;">ðŸ›¢ï¸ Extraction Supplies</h2>
                    <button onclick="closeSuppliesModal()" style="background: rgba(255,255,255,0.2); border: none; color: white; font-size: 2rem; cursor: pointer; padding: 5px 15px; border-radius: 10px;">&times;</button>
                </div>
            </div>
            <div style="padding: 30px;">
                <!-- Current Levels -->
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 30px;">
                    <div style="text-align: center; background: var(--bg-tertiary); padding: 20px; border-radius: 10px;">
                        <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 5px;">ðŸ›¢ï¸ Butane Bulk Tank</div>
                        <div id="modalButaneDisplay" style="font-size: 2.5rem; font-weight: 700; color: var(--accent-blue);">0 lbs</div>
                    </div>
                    <div style="text-align: center; background: var(--bg-tertiary); padding: 20px; border-radius: 10px;">
                        <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 5px;">ðŸ’¨ Nitrogen Tanks</div>
                        <div id="modalNitrogenDisplay" style="font-size: 2.5rem; font-weight: 700; color: var(--accent-purple);">0</div>
                    </div>
                </div>
                
                <!-- Withdraw Section -->
                <div style="background: rgba(239, 68, 68, 0.1); border-left: 4px solid var(--accent-red); padding: 20px; border-radius: 8px; margin-bottom: 25px;">
                    <h3 style="color: var(--accent-red); margin: 0 0 15px 0;">ðŸ“¤ Withdraw Supplies</h3>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                        <div>
                            <label style="display: block; margin-bottom: 8px; font-weight: 600;">Butane (lbs)</label>
                            <input type="number" id="modalWithdrawButane" step="0.1" min="0" placeholder="0.0" style="width: 100%; padding: 12px; font-size: 1.1rem; background: var(--bg-primary); border: 2px solid var(--border); border-radius: 8px; color: var(--text-primary); margin-bottom: 10px;">
                            <button class="btn" style="background: var(--accent-red); padding: 12px; width: 100%;" onclick="withdrawButaneFromModal()">Take</button>
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 8px; font-weight: 600;">Nitrogen (tanks)</label>
                            <input type="number" id="modalWithdrawNitrogen" step="0.5" min="0" placeholder="0.0" style="width: 100%; padding: 12px; font-size: 1.1rem; background: var(--bg-primary); border: 2px solid var(--border); border-radius: 8px; color: var(--text-primary); margin-bottom: 10px;">
                            <button class="btn" style="background: var(--accent-red); padding: 12px; width: 100%;" onclick="withdrawNitrogenFromModal()">Take</button>
                        </div>
                    </div>
                </div>
                
                <!-- Action Buttons -->
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">
                    <button class="btn" style="background: var(--accent-green); padding: 12px 10px; font-size: 0.9rem;" onclick="openAddButaneModal()">âž• Add Butane</button>
                    <button class="btn" style="background: var(--accent-green); padding: 12px 10px; font-size: 0.9rem;" onclick="openAddNitrogenModal()">âž• Add Nâ‚‚</button>
                    <button class="btn" style="background: var(--accent-orange); padding: 12px 10px; font-size: 0.9rem;" onclick="openEditButaneModal()">ðŸ”§ Edit Butane</button>
                    <button class="btn" style="background: var(--accent-orange); padding: 12px 10px; font-size: 0.9rem;" onclick="openEditNitrogenModal()">ðŸ”§ Edit Nâ‚‚</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Add Shipment Modal (Butane) -->
    <div id="addShipmentModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); z-index: 10002; overflow-y: auto;">
        <div style="max-width: 500px; margin: 100px auto; background: var(--bg-secondary); border-radius: 20px; padding: 0; box-shadow: 0 20px 60px rgba(16, 185, 129, 0.4);">
            <div style="background: linear-gradient(135deg, var(--accent-green), var(--accent-blue)); padding: 30px; border-radius: 20px 20px 0 0;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <h2 style="color: white; margin: 0; font-size: 1.8rem;">âž• Add Butane Shipment</h2>
                    <button onclick="closeAddButaneModal()" style="background: rgba(255,255,255,0.2); border: none; color: white; font-size: 2rem; cursor: pointer; padding: 5px 15px; border-radius: 10px;">&times;</button>
                </div>
            </div>
            <div style="padding: 30px;">
                <form onsubmit="event.preventDefault(); addButaneShipment();">
                    <div class="form-group">
                        <label>Butane Received (lbs)</label>
                        <input type="number" id="butaneShipmentAmount" step="0.1" min="0" placeholder="110" required autofocus style="font-size: 1.2rem; padding: 15px;">
                        <div class="help-text">Typically 110 lbs per tank</div>
                    </div>
                    <div class="form-group">
                        <label>Notes (Optional)</label>
                        <textarea id="butaneShipmentNotes" placeholder="Delivery info, vendor, etc..."></textarea>
                    </div>
                    <button type="submit" class="btn" style="background: var(--accent-green); width: 100%; font-size: 1.1rem;">
                        âœ… Add to Bulk Tank
                    </button>
                </form>
            </div>
        </div>
    </div>
    
    <!-- Edit Bulk Weight Modal (Butane) -->
    <div id="editBulkModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); z-index: 10002; overflow-y: auto;">
        <div style="max-width: 500px; margin: 100px auto; background: var(--bg-secondary); border-radius: 20px; padding: 0; box-shadow: 0 20px 60px rgba(245, 158, 11, 0.4);">
            <div style="background: linear-gradient(135deg, var(--accent-orange), var(--accent-red)); padding: 30px; border-radius: 20px 20px 0 0;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <h2 style="color: white; margin: 0; font-size: 1.8rem;">ðŸ”§ Edit Butane Tank Weight</h2>
                    <button onclick="closeEditButaneModal()" style="background: rgba(255,255,255,0.2); border: none; color: white; font-size: 2rem; cursor: pointer; padding: 5px 15px; border-radius: 10px;">&times;</button>
                </div>
            </div>
            <div style="padding: 30px;">
                <div style="background: rgba(239, 68, 68, 0.1); padding: 15px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid var(--accent-red);">
                    <strong>âš ï¸ Use with caution</strong>
                    <p style="margin: 5px 0 0 0; font-size: 0.9rem; color: var(--text-secondary);">Only use this to correct errors or set initial inventory</p>
                </div>
                <div style="text-align: center; margin-bottom: 20px;">
                    <div style="font-size: 1.6rem; font-weight: 700; color: ${statusColor};">Current Bulk Tank</div>
                    <div id="editButaneCurrentDisplay" style="font-size: 2rem; font-weight: 700; color: var(--accent-blue);">0 lbs</div>
                </div>
                <form onsubmit="event.preventDefault(); setButaneWeight();">
                    <div class="form-group">
                        <label>Set Bulk Tank To (lbs)</label>
                        <input type="number" id="butaneSetAmount" step="0.1" min="0" placeholder="Enter exact amount" required autofocus style="font-size: 1.2rem; padding: 15px;">
                    </div>
                    <div class="form-group">
                        <label>Reason for Change</label>
                        <textarea id="butaneSetNotes" placeholder="Why are you manually changing this?" required></textarea>
                    </div>
                    <button type="submit" class="btn" style="background: var(--accent-orange); width: 100%; font-size: 1.1rem;">
                        âœ… Update Bulk Tank
                    </button>
                </form>
            </div>
        </div>
    </div>
    
    <!-- Add Nitrogen Modal -->
    <div id="addNitrogenModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); z-index: 10002; overflow-y: auto;">
        <div style="max-width: 500px; margin: 100px auto; background: var(--bg-secondary); border-radius: 20px; padding: 0; box-shadow: 0 20px 60px rgba(147, 51, 234, 0.4);">
            <div style="background: linear-gradient(135deg, var(--accent-purple), var(--accent-blue)); padding: 30px; border-radius: 20px 20px 0 0;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <h2 style="color: white; margin: 0; font-size: 1.8rem;">âž• Add Nitrogen Tanks</h2>
                    <button onclick="closeAddNitrogenModal()" style="background: rgba(255,255,255,0.2); border: none; color: white; font-size: 2rem; cursor: pointer; padding: 5px 15px; border-radius: 10px;">&times;</button>
                </div>
            </div>
            <div style="padding: 30px;">
                <form onsubmit="event.preventDefault(); addNitrogenShipment();">
                    <div class="form-group">
                        <label>Nitrogen Tanks Received</label>
                        <input type="number" id="nitrogenShipmentAmount" step="0.5" min="0" placeholder="Number of tanks" required autofocus style="font-size: 1.2rem; padding: 15px;">
                        <div class="help-text">Full or partial tanks (e.g., 5, 2.5, 10)</div>
                    </div>
                    <div class="form-group">
                        <label>Notes (Optional)</label>
                        <textarea id="nitrogenShipmentNotes" placeholder="Delivery info, vendor, etc..."></textarea>
                    </div>
                    <button type="submit" class="btn" style="background: var(--accent-purple); width: 100%; font-size: 1.1rem;">
                        âœ… Add Tanks
                    </button>
                </form>
            </div>
        </div>
    </div>
    
    <!-- Edit Nitrogen Modal -->
    <div id="editNitrogenModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); z-index: 10002; overflow-y: auto;">
        <div style="max-width: 500px; margin: 100px auto; background: var(--bg-secondary); border-radius: 20px; padding: 0; box-shadow: 0 20px 60px rgba(245, 158, 11, 0.4);">
            <div style="background: linear-gradient(135deg, var(--accent-orange), var(--accent-red)); padding: 30px; border-radius: 20px 20px 0 0;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <h2 style="color: white; margin: 0; font-size: 1.8rem;">ðŸ”§ Edit Nitrogen Inventory</h2>
                    <button onclick="closeEditNitrogenModal()" style="background: rgba(255,255,255,0.2); border: none; color: white; font-size: 2rem; cursor: pointer; padding: 5px 15px; border-radius: 10px;">&times;</button>
                </div>
            </div>
            <div style="padding: 30px;">
                <div style="background: rgba(239, 68, 68, 0.1); padding: 15px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid var(--accent-red);">
                    <strong>âš ï¸ Use with caution</strong>
                    <p style="margin: 5px 0 0 0; font-size: 0.9rem; color: var(--text-secondary);">Only use this to correct errors or set initial inventory</p>
                </div>
                <div style="text-align: center; margin-bottom: 20px;">
                    <div style="font-size: 1.6rem; font-weight: 700; color: ${statusColor};">Current Nitrogen Tanks</div>
                    <div id="editNitrogenCurrentDisplay" style="font-size: 2rem; font-weight: 700; color: var(--accent-purple);">0 tanks</div>
                </div>
                <form onsubmit="event.preventDefault(); setNitrogenAmount();">
                    <div class="form-group">
                        <label>Set Nitrogen To (tanks)</label>
                        <input type="number" id="nitrogenSetAmount" step="0.5" min="0" placeholder="Enter exact amount" required autofocus style="font-size: 1.2rem; padding: 15px;">
                    </div>
                    <div class="form-group">
                        <label>Reason for Change</label>
                        <textarea id="nitrogenSetNotes" placeholder="Why are you manually changing this?" required></textarea>
                    </div>
                    <button type="submit" class="btn" style="background: var(--accent-orange); width: 100%; font-size: 1.1rem;">
                        âœ… Update Nitrogen Inventory
                    </button>
                </form>
            </div>
        </div>
    </div>
    
    <style>
        .personal-time-btn {
            padding: 10px 20px;
            background: var(--bg-secondary);
            border: 2px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .personal-time-btn:hover {
            border-color: var(--accent-purple);
            background: rgba(147, 51, 234, 0.1);
            transform: translateY(-2px);
        }
        
        .personal-time-btn.active {
            background: var(--accent-purple);
            border-color: var(--accent-purple);
            color: white;
        }

        .overdue-sort-btn.active {
            background: rgba(239, 68, 68, 0.2) !important;
            border-color: var(--accent-red) !important;
            color: var(--accent-red) !important;
        }

        .overdue-sort-btn:hover {
            background: rgba(239, 68, 68, 0.1);
            border-color: var(--accent-red);
            color: var(--accent-red);
        }
        
        
        .compliance-topic-btn {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-secondary);
            padding: 8px 15px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.2s ease;
        }
        .compliance-topic-btn:hover {
            background: rgba(16, 185, 129, 0.1);
            border-color: var(--accent-green);
            color: var(--accent-green);
        }
        .compliance-result {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 15px;
        }
        .compliance-result h4 {
            color: var(--accent-green);
            margin: 0 0 10px 0;
            font-size: 1.1rem;
        }
        .compliance-result p {
            color: var(--text-primary);
            margin: 0;
            line-height: 1.6;
        }
        .compliance-rule-num {
            background: rgba(16, 185, 129, 0.2);
            color: var(--accent-green);
            padding: 3px 10px;
            border-radius: 15px;
            font-size: 0.8rem;
            font-weight: 600;
            margin-right: 10px;
        }

        .stat-box {
            background: var(--bg-tertiary);
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            border: 2px solid var(--border);
            transition: all 0.3s ease;
        }
        
        .stat-box:hover {
            border-color: var(--accent-purple);
            transform: translateY(-2px);
        }
        
        .stat-number {
            font-size: 2.5rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--accent-purple), var(--accent-blue));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 5px;
        }
        
        .stat-label {
            color: var(--text-secondary);
            font-size: 0.9rem;
            font-weight: 600;
        }
        
        .record-box {
            background: var(--bg-secondary);
            padding: 15px;
            border-radius: 10px;
            border-left: 4px solid var(--accent-green);
        }
        
        #myStatsBtn:hover {
            transform: translateY(-2px);
            box-shadow: 0 0 20px rgba(191, 0, 255, 0.5), 0 0 40px rgba(191, 0, 255, 0.3), inset 0 0 15px rgba(191, 0, 255, 0.1);
        }

        /* Front of House Styles */
        .quick-tag-btn {
            background: transparent;
            border: 2px solid var(--accent-blue);
            color: var(--accent-blue);
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 0 8px rgba(0, 240, 255, 0.3), inset 0 0 6px rgba(0, 240, 255, 0.05);
        }
        .quick-tag-btn:hover {
            background: rgba(0, 240, 255, 0.15);
            border-color: var(--accent-blue);
            box-shadow: 0 0 15px rgba(0, 240, 255, 0.5), 0 0 30px rgba(0, 240, 255, 0.3), inset 0 0 10px rgba(0, 240, 255, 0.1);
        }
        .foh-batch-card {
            background: var(--bg-tertiary);
            border: 2px solid var(--border);
            border-radius: 12px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .foh-batch-card:hover {
            border-color: var(--accent-purple);
            transform: translateY(-2px);
        }
        .foh-post-card {
            background: var(--bg-tertiary);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .foh-post-status {
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 600;
        }
        .foh-post-status.published {
            background: rgba(57, 255, 20, 0.2);
            color: var(--accent-green);
        }
        .foh-post-status.draft {
            background: rgba(255, 107, 0, 0.2);
            color: var(--accent-orange);
        }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <!-- Time Clock Modal -->
    <div id="timeClockModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); z-index: 10001; overflow-y: auto;">
        <div style="max-width: 500px; margin: 50px auto; background: var(--bg-secondary); border-radius: 20px; padding: 0; box-shadow: 0 20px 60px rgba(57, 255, 20, 0.4);">
            <!-- Header -->
            <div style="background: linear-gradient(135deg, var(--accent-green), #00aa00); padding: 30px; border-radius: 20px 20px 0 0;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <h2 style="color: white; margin: 0 0 10px 0; font-size: 2rem;">
                            Time Clock
                        </h2>
                        <p style="color: rgba(255,255,255,0.9); margin: 0;" id="timeClockUserName">Welcome!</p>
                    </div>
                    <button onclick="closeTimeClockModal()" style="background: rgba(255,255,255,0.2); border: none; color: white; font-size: 2rem; cursor: pointer; padding: 5px 15px; border-radius: 10px; transition: all 0.3s ease;">&times;</button>
                </div>
            </div>

            <!-- Content -->
            <div style="padding: 30px;">
                <!-- Current Status -->
                <div id="clockStatusDisplay" style="background: var(--bg-tertiary); padding: 25px; border-radius: 15px; margin-bottom: 25px; text-align: center;">
                    <div style="font-size: 0.9rem; color: var(--text-secondary); margin-bottom: 5px;">Current Status</div>
                    <div id="clockStatusText" style="font-size: 2rem; font-weight: 700; color: var(--accent-red);">Clocked Out</div>
                    <div id="clockLastPunch" style="font-size: 0.9rem; color: var(--text-secondary); margin-top: 10px;">Last punch: --</div>
                </div>

                <!-- Current Time Display -->
                <div style="text-align: center; margin-bottom: 25px;">
                    <div id="currentTimeDisplay" style="font-family: 'Space Mono', monospace; font-size: 2.5rem; color: var(--accent-blue);"></div>
                    <div id="currentDateDisplay" style="font-size: 1rem; color: var(--text-secondary);"></div>
                </div>

                <!-- Clock In/Out Button -->
                <div style="text-align: center; margin-bottom: 30px;">
                    <button id="clockActionBtn" onclick="performClockAction()" style="width: 200px; height: 200px; border-radius: 50%; font-size: 1.5rem; font-weight: 700; cursor: pointer; transition: all 0.3s ease; border: 4px solid var(--accent-green); background: linear-gradient(135deg, var(--accent-green), #00aa00); color: white; box-shadow: 0 10px 40px rgba(57, 255, 20, 0.4);">
                        CLOCK IN
                    </button>
                </div>

                <!-- IP Status -->
                <div id="ipStatusDisplay" style="background: var(--bg-tertiary); padding: 15px; border-radius: 10px; margin-bottom: 20px; text-align: center; font-size: 0.85rem;">
                    <span style="color: var(--text-secondary);">IP Status: </span>
                    <span id="ipStatusText" style="color: var(--accent-orange);">Checking...</span>
                </div>

                <!-- Hours Summary -->
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                    <div style="background: var(--bg-tertiary); padding: 20px; border-radius: 12px; text-align: center;">
                        <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 5px;">Today's Hours</div>
                        <div id="todayHours" style="font-size: 1.8rem; font-weight: 700; color: var(--accent-blue);">0.00</div>
                    </div>
                    <div style="background: var(--bg-tertiary); padding: 20px; border-radius: 12px; text-align: center;">
                        <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 5px;">Pay Period Hours</div>
                        <div id="payPeriodHours" style="font-size: 1.8rem; font-weight: 700; color: var(--accent-purple);">0.00</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Timecards Admin Modal -->
    <div id="timecardsModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); z-index: 10001; overflow-y: auto;">
        <div style="max-width: 1200px; margin: 30px auto; background: var(--bg-secondary); border-radius: 20px; padding: 0; box-shadow: 0 20px 60px rgba(255, 107, 0, 0.4);">
            <!-- Header -->
            <div style="background: linear-gradient(135deg, var(--accent-orange), #cc5500); padding: 30px; border-radius: 20px 20px 0 0;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <h2 style="color: white; margin: 0 0 10px 0; font-size: 2rem;">
                            Employee Timecards
                        </h2>
                        <p style="color: rgba(255,255,255,0.9); margin: 0;">View and manage employee time records</p>
                    </div>
                    <button onclick="closeTimecardsModal()" style="background: rgba(255,255,255,0.2); border: none; color: white; font-size: 2rem; cursor: pointer; padding: 5px 15px; border-radius: 10px; transition: all 0.3s ease;">&times;</button>
                </div>
            </div>

            <!-- Content -->
            <div style="padding: 30px;">
                <!-- Currently Clocked In Section -->
                <div style="background: linear-gradient(135deg, rgba(57, 255, 20, 0.15), rgba(0, 200, 150, 0.15)); padding: 20px; border-radius: 15px; margin-bottom: 25px; border: 2px solid var(--accent-green);">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                        <h3 style="color: var(--accent-green); margin: 0; font-size: 1.3rem;">
                            Currently Clocked In
                        </h3>
                        <button onclick="renderCurrentlyClockedIn()" style="background: var(--bg-tertiary); border: 1px solid var(--border); padding: 8px 15px; border-radius: 6px; color: var(--text-secondary); cursor: pointer; font-size: 0.85rem;">
                            Refresh
                        </button>
                    </div>
                    <div id="currentlyClockedInContainer">
                        <div style="text-align: center; padding: 20px; color: var(--text-secondary);">
                            Loading...
                        </div>
                    </div>
                </div>

                <!-- Employee Selector -->
                <div style="display: flex; gap: 15px; margin-bottom: 25px; flex-wrap: wrap;">
                    <select id="timecardEmployeeSelect" onchange="loadEmployeeTimecard()" style="flex: 1; min-width: 200px; padding: 12px; background: var(--bg-tertiary); border: 2px solid var(--border); border-radius: 8px; color: var(--text-primary); font-size: 1rem;">
                        <option value="">Select Employee...</option>
                    </select>
                    <select id="timecardPayPeriodSelect" onchange="loadEmployeeTimecard()" style="flex: 1; min-width: 200px; padding: 12px; background: var(--bg-tertiary); border: 2px solid var(--border); border-radius: 8px; color: var(--text-primary); font-size: 1rem;">
                        <option value="current">Current Pay Period</option>
                        <option value="previous">Previous Pay Period</option>
                    </select>
                    <button onclick="printTimecard()" style="padding: 12px 24px; background: transparent; border: 2px solid var(--accent-blue); border-radius: 8px; color: var(--accent-blue); font-weight: 600; cursor: pointer; box-shadow: 0 0 15px rgba(0, 240, 255, 0.4), 0 0 30px rgba(0, 240, 255, 0.2);">
                        Print/Export
                    </button>
                    <button onclick="exportAllTimecards()" style="padding: 12px 24px; background: transparent; border: 2px solid var(--accent-green); border-radius: 8px; color: var(--accent-green); font-weight: 600; cursor: pointer; box-shadow: 0 0 15px rgba(57, 255, 20, 0.4), 0 0 30px rgba(57, 255, 20, 0.2);">
                        ðŸ“¥ Export Summary
                    </button>
                    <button onclick="exportForQuickBooks()" style="padding: 12px 24px; background: transparent; border: 2px solid #2CA01C; border-radius: 8px; color: #2CA01C; font-weight: 600; cursor: pointer; box-shadow: 0 0 15px rgba(44, 160, 28, 0.4), 0 0 30px rgba(44, 160, 28, 0.2);">
                        ðŸ“Š Export for QuickBooks
                    </button>
                    <button onclick="openAddSickDayModal()" style="padding: 12px 24px; background: transparent; border: 2px solid var(--accent-orange); border-radius: 8px; color: var(--accent-orange); font-weight: 600; cursor: pointer; box-shadow: 0 0 15px rgba(255, 107, 0, 0.4), 0 0 30px rgba(255, 107, 0, 0.2);">
                        ðŸ¤’ Add Sick Day
                    </button>
                </div>

                <!-- Pay Period Info -->
                <div id="timecardPeriodInfo" style="background: linear-gradient(135deg, rgba(147, 51, 234, 0.2), rgba(59, 130, 246, 0.2)); padding: 20px; border-radius: 12px; margin-bottom: 25px; text-align: center; border: 2px solid var(--accent-purple);">
                    <div style="font-size: 1.6rem; font-weight: 700; color: ${statusColor};">Pay Period</div>
                    <div id="timecardPeriodDates" style="font-size: 1.3rem; font-weight: 600; color: var(--accent-purple);">--</div>
                </div>

                <!-- Timecard Table -->
                <div style="background: var(--bg-primary); border-radius: 12px; overflow: hidden; border: 1px solid var(--border);">
                    <div style="max-height: 500px; overflow-y: auto;">
                        <table id="timecardTable" style="width: 100%; border-collapse: collapse; font-size: 0.95rem;">
                            <thead style="position: sticky; top: 0; background: var(--bg-tertiary); z-index: 1;">
                                <tr>
                                    <th style="padding: 15px 12px; text-align: left; color: var(--text-secondary); font-weight: 600; border-bottom: 2px solid var(--border);">Date</th>
                                    <th style="padding: 15px 12px; text-align: center; color: var(--text-secondary); font-weight: 600; border-bottom: 2px solid var(--border);">Clock In</th>
                                    <th style="padding: 15px 12px; text-align: center; color: var(--text-secondary); font-weight: 600; border-bottom: 2px solid var(--border);">Clock Out</th>
                                    <th style="padding: 15px 12px; text-align: right; color: var(--text-secondary); font-weight: 600; border-bottom: 2px solid var(--border);">Hours</th>
                                    <th style="padding: 15px 12px; text-align: right; color: var(--text-secondary); font-weight: 600; border-bottom: 2px solid var(--border);">Daily Total</th>
                                    <th style="padding: 15px 12px; text-align: center; color: var(--text-secondary); font-weight: 600; border-bottom: 2px solid var(--border);">Notes</th>
                                    <th style="padding: 15px 12px; text-align: center; color: var(--text-secondary); font-weight: 600; border-bottom: 2px solid var(--border);">Actions</th>
                                </tr>
                            </thead>
                            <tbody id="timecardTableBody">
                                <tr>
                                    <td colspan="7" style="padding: 40px; text-align: center; color: var(--text-secondary);">Select an employee to view their timecard</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>

                <!-- Summary Section -->
                <div id="timecardSummary" style="display: none; margin-top: 25px; background: linear-gradient(135deg, rgba(57, 255, 20, 0.1), rgba(0, 240, 255, 0.1)); padding: 25px; border-radius: 12px; border: 2px solid var(--accent-green);">
                    <h3 style="color: var(--accent-green); margin: 0 0 20px 0; text-align: center;">Pay Period Summary</h3>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 20px;">
                        <div style="text-align: center;">
                            <div style="font-size: 0.85rem; color: var(--text-secondary);">Regular Hours</div>
                            <div id="summaryRegularHours" style="font-size: 1.8rem; font-weight: 700; color: var(--accent-blue);">0.00</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="font-size: 0.85rem; color: var(--text-secondary);">Overtime Hours</div>
                            <div id="summaryOvertimeHours" style="font-size: 1.8rem; font-weight: 700; color: var(--accent-orange);">0.00</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="font-size: 0.85rem; color: var(--text-secondary);">Total Hours</div>
                            <div id="summaryTotalHours" style="font-size: 1.8rem; font-weight: 700; color: var(--accent-green);">0.00</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="font-size: 0.85rem; color: var(--text-secondary);">Days Worked</div>
                            <div id="summaryDaysWorked" style="font-size: 1.8rem; font-weight: 700; color: var(--accent-purple);">0</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Deleted Batches (Trash) Modal -->
    <div id="trashModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); z-index: 10001; overflow-y: auto;">
        <div style="max-width: 900px; margin: 30px auto; background: var(--bg-secondary); border-radius: 20px; padding: 0; box-shadow: 0 20px 60px rgba(239, 68, 68, 0.4);">
            <!-- Header -->
            <div style="background: linear-gradient(135deg, #ef4444, #b91c1c); padding: 30px; border-radius: 20px 20px 0 0;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <h2 style="color: white; margin: 0 0 10px 0; font-size: 2rem;">
                            ðŸ—‘ï¸ Deleted Batches
                        </h2>
                        <p style="color: rgba(255,255,255,0.9); margin: 0;">Batches that have been removed from production</p>
                    </div>
                    <button onclick="closeTrashModal()" style="background: rgba(255,255,255,0.2); border: none; color: white; font-size: 2rem; cursor: pointer; padding: 5px 15px; border-radius: 10px; transition: all 0.3s ease;">&times;</button>
                </div>
            </div>

            <!-- Content -->
            <div style="padding: 30px;">
                <div id="trashBatchesList">
                    <div style="text-align: center; padding: 40px; color: var(--text-secondary);">
                        Loading deleted batches...
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Delete Batch Confirmation Modal -->
    <div id="deleteBatchModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); z-index: 10006; overflow-y: auto;">
        <div style="max-width: 500px; margin: 80px auto; background: var(--bg-secondary); border-radius: 20px; padding: 30px; box-shadow: 0 20px 60px rgba(239, 68, 68, 0.4); border: 2px solid #ef4444;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 25px;">
                <h2 style="color: #ef4444; margin: 0;">ðŸ—‘ï¸ Delete Batch</h2>
                <button onclick="closeDeleteBatchModal()" style="background: none; border: none; color: var(--text-secondary); font-size: 1.5rem; cursor: pointer;">Ã—</button>
            </div>

            <div style="background: var(--bg-tertiary); padding: 15px; border-radius: 10px; margin-bottom: 20px;">
                <div style="font-size: 1.6rem; font-weight: 700; color: ${statusColor};">Batch to delete:</div>
                <div id="deleteBatchId" style="font-weight: 700; font-size: 1.3rem; color: #ef4444; margin-top: 5px;"></div>
                <div id="deleteBatchInfo" style="font-size: 0.9rem; color: var(--text-secondary); margin-top: 5px;"></div>
            </div>

            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 8px; color: var(--text-secondary); font-size: 0.9rem;">Reason for deletion (required)</label>
                <textarea id="deleteNoteInput" rows="3" placeholder="Why is this batch being deleted?" style="width: 100%; padding: 12px; background: var(--bg-tertiary); border: 2px solid var(--border); border-radius: 8px; color: var(--text-primary); font-size: 1rem; resize: vertical;"></textarea>
            </div>

            <div style="display: flex; gap: 10px;">
                <button onclick="closeDeleteBatchModal()" style="flex: 1; padding: 12px; background: var(--bg-tertiary); border: 1px solid var(--border); border-radius: 8px; color: var(--text-primary); cursor: pointer;">Cancel</button>
                <button onclick="confirmDeleteBatch()" style="flex: 1; padding: 12px; background: #ef4444; border: none; border-radius: 8px; color: white; font-weight: 600; cursor: pointer;">Delete Batch</button>
            </div>
        </div>
    </div>

    <!-- Edit Punch Time Modal -->
    <div id="editPunchModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); z-index: 10006; overflow-y: auto;">
        <div style="max-width: 500px; margin: 80px auto; background: var(--bg-secondary); border-radius: 20px; padding: 30px; box-shadow: 0 20px 60px rgba(255, 107, 0, 0.4); border: 2px solid var(--accent-orange);">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 25px;">
                <h2 style="color: var(--accent-orange); margin: 0;">âœï¸ Edit Punch Time</h2>
                <button onclick="closeEditPunchModal()" style="background: none; border: none; color: var(--text-secondary); font-size: 1.5rem; cursor: pointer;">Ã—</button>
            </div>
            
            <div style="background: var(--bg-tertiary); padding: 15px; border-radius: 10px; margin-bottom: 20px;">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                    <div>
                        <div style="font-size: 0.8rem; color: var(--text-secondary);">Employee</div>
                        <div id="editPunchEmployee" style="font-weight: 600; color: var(--text-primary);"></div>
                    </div>
                    <div>
                        <div style="font-size: 0.8rem; color: var(--text-secondary);">Punch Type</div>
                        <div id="editPunchType" style="font-weight: 600;"></div>
                    </div>
                </div>
            </div>
            
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 8px; color: var(--text-secondary); font-size: 0.9rem;">Original Time</label>
                <div id="editPunchOriginal" style="padding: 12px; background: var(--bg-tertiary); border-radius: 8px; color: var(--text-primary);"></div>
            </div>
            
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 8px; color: var(--text-secondary); font-size: 0.9rem;">New Date & Time</label>
                <input type="datetime-local" id="editPunchNewTime" style="width: 100%; padding: 12px; background: var(--bg-tertiary); border: 2px solid var(--border); border-radius: 8px; color: var(--text-primary); font-size: 1rem;">
            </div>
            
            <div style="margin-bottom: 25px;">
                <label style="display: block; margin-bottom: 8px; color: var(--text-secondary); font-size: 0.9rem;">Reason for Adjustment <span style="color: var(--accent-red);">*</span></label>
                <textarea id="editPunchReason" rows="3" placeholder="Explain why this time needs to be adjusted..." style="width: 100%; padding: 12px; background: var(--bg-tertiary); border: 2px solid var(--border); border-radius: 8px; color: var(--text-primary); font-size: 1rem; resize: vertical;"></textarea>
            </div>
            
            <input type="hidden" id="editPunchId">
            
            <div style="display: flex; gap: 15px;">
                <button onclick="saveEditedPunch()" style="flex: 1; padding: 15px; background: var(--accent-green); border: none; border-radius: 10px; color: white; font-size: 1rem; font-weight: 600; cursor: pointer;">ðŸ’¾ Save Changes</button>
                <button onclick="closeEditPunchModal()" style="flex: 1; padding: 15px; background: var(--bg-tertiary); border: 2px solid var(--border); border-radius: 10px; color: var(--text-primary); font-size: 1rem; cursor: pointer;">Cancel</button>
            </div>
        </div>
    </div>
    <!-- Edit Shift Modal -->
    <div id="editShiftModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); z-index: 10006; overflow-y: auto;">
        <div style="max-width: 500px; margin: 80px auto; background: var(--bg-secondary); border-radius: 20px; padding: 30px; box-shadow: 0 20px 60px rgba(255, 107, 0, 0.4); border: 2px solid var(--accent-orange);">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 25px;">
                <h2 style="color: var(--accent-orange); margin: 0;">âœï¸ Edit Shift</h2>
                <button onclick="closeEditShiftModal()" style="background: none; border: none; color: var(--text-secondary); font-size: 1.5rem; cursor: pointer;">Ã—</button>
            </div>
            <div style="background: var(--bg-tertiary); padding: 15px; border-radius: 10px; margin-bottom: 20px;">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                    <div>
                        <div style="font-size: 0.8rem; color: var(--text-secondary);">Employee</div>
                        <div id="editShiftEmployee" style="font-weight: 600; color: var(--text-primary);"></div>
                    </div>
                    <div>
                        <div style="font-size: 0.8rem; color: var(--text-secondary);">Date</div>
                        <div id="editShiftDate" style="font-weight: 600; color: var(--text-primary);"></div>
                    </div>
                </div>
            </div>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px;">
                <div>
                    <label style="display: block; margin-bottom: 8px; color: var(--accent-green); font-size: 0.9rem; font-weight: 600;">Clock In</label>
                    <input type="datetime-local" id="editShiftInTime" style="width: 100%; padding: 12px; background: var(--bg-tertiary); border: 2px solid var(--accent-green); border-radius: 8px; color: var(--text-primary); font-size: 1rem;">
                </div>
                <div>
                    <label style="display: block; margin-bottom: 8px; color: var(--accent-orange); font-size: 0.9rem; font-weight: 600;">Clock Out</label>
                    <input type="datetime-local" id="editShiftOutTime" style="width: 100%; padding: 12px; background: var(--bg-tertiary); border: 2px solid var(--accent-orange); border-radius: 8px; color: var(--text-primary); font-size: 1rem;">
                </div>
            </div>
            <div style="margin-bottom: 25px;">
                <label style="display: block; margin-bottom: 8px; color: var(--text-secondary); font-size: 0.9rem;">Reason for Adjustment <span style="color: var(--accent-red);">*</span></label>
                <textarea id="editShiftReason" rows="2" placeholder="e.g., Forgot to clock out, incorrect time entry" style="width: 100%; padding: 12px; background: var(--bg-tertiary); border: 2px solid var(--border); border-radius: 8px; color: var(--text-primary); font-size: 1rem; resize: vertical;"></textarea>
            </div>
            <input type="hidden" id="editShiftInPunchId">
            <input type="hidden" id="editShiftOutPunchId">
            <div style="display: flex; gap: 15px;">
                <button onclick="saveEditedShift()" style="flex: 1; padding: 15px; background: var(--accent-green); border: none; border-radius: 10px; color: white; font-size: 1rem; font-weight: 600; cursor: pointer;">ðŸ’¾ Save Changes</button>
                <button onclick="closeEditShiftModal()" style="flex: 1; padding: 15px; background: var(--bg-tertiary); border: 2px solid var(--border); border-radius: 10px; color: var(--text-primary); font-size: 1rem; cursor: pointer;">Cancel</button>
            </div>
        </div>
    </div>
    <!-- Add Sick Day Modal -->
    <div id="addSickDayModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); z-index: 10006; overflow-y: auto;">
        <div style="max-width: 500px; margin: 50px auto; background: var(--bg-secondary); border-radius: 15px; padding: 25px; border: 2px solid var(--accent-blue);">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h2 style="color: var(--accent-blue); margin: 0;">ðŸ¤’ Add Sick Day</h2>
                <button onclick="closeAddSickDayModal()" style="background: none; border: none; color: var(--text-secondary); font-size: 1.5rem; cursor: pointer;">Ã—</button>
            </div>
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 8px; color: var(--text-secondary); font-size: 0.9rem;">Employee</label>
                <select id="sickDayEmployee" style="width: 100%; padding: 12px; background: var(--bg-tertiary); border: 2px solid var(--border); border-radius: 8px; color: var(--text-primary); font-size: 1rem;">
                </select>
            </div>
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 8px; color: var(--text-secondary); font-size: 0.9rem;">Date</label>
                <input type="date" id="sickDayDate" style="width: 100%; padding: 12px; background: var(--bg-tertiary); border: 2px solid var(--border); border-radius: 8px; color: var(--text-primary); font-size: 1rem;">
            </div>
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 8px; color: var(--text-secondary); font-size: 0.9rem;">Hours (default 8)</label>
                <input type="number" id="sickDayHours" value="8" min="1" max="12" style="width: 100%; padding: 12px; background: var(--bg-tertiary); border: 2px solid var(--border); border-radius: 8px; color: var(--text-primary); font-size: 1rem;">
            </div>
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 8px; color: var(--text-secondary); font-size: 0.9rem;">Notes (optional)</label>
                <textarea id="sickDayNotes" rows="2" placeholder="e.g., Called in sick, Doctor appointment" style="width: 100%; padding: 12px; background: var(--bg-tertiary); border: 2px solid var(--border); border-radius: 8px; color: var(--text-primary); font-size: 1rem; resize: vertical;"></textarea>
            </div>
            <div style="display: flex; gap: 10px;">
                <button onclick="saveSickDay()" style="flex: 1; padding: 15px; background: var(--accent-blue); border: none; border-radius: 10px; color: white; font-size: 1rem; font-weight: 600; cursor: pointer;">ðŸ’¾ Add Sick Day</button>
                <button onclick="closeAddSickDayModal()" style="flex: 1; padding: 15px; background: var(--bg-tertiary); border: 2px solid var(--border); border-radius: 10px; color: var(--text-primary); font-size: 1rem; cursor: pointer;">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Add Clock Out Modal -->
    <div id="addClockOutModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); z-index: 10006; overflow-y: auto;">
        <div style="max-width: 500px; margin: 80px auto; background: var(--bg-secondary); border-radius: 20px; padding: 30px; box-shadow: 0 20px 60px rgba(255, 107, 0, 0.4); border: 2px solid var(--accent-orange);">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 25px;">
                <h2 style="color: var(--accent-orange); margin: 0;">â±ï¸ Add Clock Out</h2>
                <button onclick="closeAddClockOutModal()" style="background: none; border: none; color: var(--text-secondary); font-size: 1.5rem; cursor: pointer;">Ã—</button>
            </div>
            <div style="background: var(--bg-tertiary); padding: 15px; border-radius: 10px; margin-bottom: 20px;">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                    <div>
                        <div style="font-size: 0.8rem; color: var(--text-secondary);">Employee</div>
                        <div id="addClockOutEmployee" style="font-weight: 600; color: var(--text-primary);"></div>
                    </div>
                    <div>
                        <div style="font-size: 0.8rem; color: var(--text-secondary);">Clocked In At</div>
                        <div id="addClockOutClockInTime" style="font-weight: 600; color: var(--accent-green);"></div>
                    </div>
                </div>
            </div>
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 8px; color: var(--text-secondary); font-size: 0.9rem;">Clock Out Time</label>
                <input type="datetime-local" id="addClockOutTime" style="width: 100%; padding: 12px; background: var(--bg-tertiary); border: 2px solid var(--border); border-radius: 8px; color: var(--text-primary); font-size: 1rem;">
            </div>
            <div style="margin-bottom: 25px;">
                <label style="display: block; margin-bottom: 8px; color: var(--text-secondary); font-size: 0.9rem;">Reason <span style="color: var(--accent-red);">*</span></label>
                <textarea id="addClockOutReason" rows="2" placeholder="e.g., Forgot to clock out" style="width: 100%; padding: 12px; background: var(--bg-tertiary); border: 2px solid var(--border); border-radius: 8px; color: var(--text-primary); font-size: 1rem; resize: vertical;"></textarea>
            </div>
            <input type="hidden" id="addClockOutClockInId">
            <div style="display: flex; gap: 15px;">
                <button onclick="saveAddClockOut()" style="flex: 1; padding: 15px; background: var(--accent-green); border: none; border-radius: 10px; color: white; font-size: 1rem; font-weight: 600; cursor: pointer;">ðŸ’¾ Add Clock Out</button>
                <button onclick="closeAddClockOutModal()" style="flex: 1; padding: 15px; background: var(--bg-tertiary); border: 2px solid var(--border); border-radius: 10px; color: var(--text-primary); font-size: 1rem; cursor: pointer;">Cancel</button>
            </div>
        </div>
    </div>
    <!-- Overtime Alert Modal -->
    <div id="overtimeAlertModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); z-index: 10005; overflow-y: auto;">
        <div style="max-width: 400px; margin: 100px auto; background: var(--bg-secondary); border-radius: 20px; padding: 0; box-shadow: 0 20px 60px rgba(255, 107, 0, 0.6); border: 3px solid var(--accent-orange);">
            <div style="background: linear-gradient(135deg, var(--accent-orange), var(--accent-red)); padding: 30px; border-radius: 17px 17px 0 0; text-align: center;">
                <div style="font-size: 4rem; margin-bottom: 10px;">!</div>
                <h2 style="color: white; margin: 0; font-size: 1.8rem;">Overtime Alert</h2>
            </div>
            <div style="padding: 30px; text-align: center;">
                <p id="overtimeAlertMessage" style="font-size: 1.2rem; color: var(--text-primary); margin-bottom: 25px;">You have exceeded normal hours.</p>
                <button onclick="closeOvertimeAlert()" style="padding: 15px 40px; background: var(--accent-orange); border: none; border-radius: 10px; color: white; font-size: 1.1rem; font-weight: 600; cursor: pointer;">
                    Acknowledge
                </button>
            </div>
        </div>
    </div>

    <!-- Sales Pipeline Modal -->
    <div id="salesPipelineModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); z-index: 10001; overflow-y: auto;">
        <div style="max-width: 800px; margin: 50px auto; background: var(--bg-secondary); border-radius: 20px; padding: 0; box-shadow: 0 20px 60px rgba(16, 185, 129, 0.4);">
            <!-- Header -->
            <div style="background: linear-gradient(135deg, #10B981, #3B82F6); padding: 25px 30px; border-radius: 20px 20px 0 0;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <h2 style="color: white; margin: 0; font-size: 1.5rem;">Pipeline</h2>
                    <button onclick="closeSalesPipelineModal()" style="background: rgba(255,255,255,0.2); border: none; color: white; font-size: 1.5rem; cursor: pointer; padding: 5px 12px; border-radius: 8px;">&times;</button>
                </div>
            </div>

            <!-- Content -->
            <div style="padding: 30px;">
                <!-- Product Category Grid -->
                <div id="pipelineCategoryGrid" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px;">
                    <!-- Populated dynamically -->
                </div>
            </div>
        </div>
    </div>

    <!-- Pipeline Strains Popup -->
    <div id="pipelineStrainsPopup" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); z-index: 10002; overflow-y: auto;">
        <div style="max-width: 500px; margin: 80px auto; background: var(--bg-secondary); border-radius: 16px; padding: 0; box-shadow: 0 20px 60px rgba(0,0,0,0.5);">
            <div style="background: var(--bg-tertiary); padding: 20px 25px; border-radius: 16px 16px 0 0; display: flex; justify-content: space-between; align-items: center;">
                <h3 id="pipelinePopupTitle" style="margin: 0; color: var(--text-primary); font-size: 1.2rem;">Strains</h3>
                <button onclick="closePipelineStrainsPopup()" style="background: none; border: none; color: var(--text-secondary); font-size: 1.5rem; cursor: pointer;">&times;</button>
            </div>
            <div id="pipelinePopupContent" style="padding: 20px 25px; max-height: 400px; overflow-y: auto;">
                <!-- Populated dynamically -->
            </div>
        </div>
    </div>

    <!-- Drop Calendar Modal -->
    <div id="dropCalendarModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); z-index: 10001; overflow-y: auto;">
        <div style="max-width: 900px; margin: 50px auto; background: var(--bg-secondary); border-radius: 20px; padding: 0; box-shadow: 0 20px 60px rgba(16, 185, 129, 0.4);">
            <!-- Header -->
            <div style="background: linear-gradient(135deg, #10B981, #059669); padding: 25px 30px; border-radius: 20px 20px 0 0;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <h2 style="color: white; margin: 0; font-size: 1.5rem;">Drop Calendar</h2>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <button onclick="loadDropCalendar()" style="background: rgba(255,255,255,0.2); border: none; color: white; padding: 8px 16px; border-radius: 8px; cursor: pointer; font-weight: 600;">Refresh</button>
                        <button onclick="closeDropCalendarModal()" style="background: rgba(255,255,255,0.2); border: none; color: white; font-size: 1.5rem; cursor: pointer; padding: 5px 12px; border-radius: 8px;">&times;</button>
                    </div>
                </div>
                <p style="color: rgba(255,255,255,0.8); margin: 10px 0 0 0; font-size: 0.9rem;">Customer deliveries from LeafLink</p>
            </div>

            <!-- Content -->
            <div style="padding: 30px;">
                <!-- Calendar Stats -->
                <div id="dropCalendarStats" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px; margin-bottom: 20px;">
                    <div style="background: var(--bg-primary); padding: 15px; border-radius: 10px; text-align: center;">
                        <div style="font-size: 2rem; font-weight: 700; color: var(--accent-blue);" id="statTotalDrops">--</div>
                        <div style="color: var(--text-secondary); font-size: 0.85rem;">Total Drops</div>
                    </div>
                    <div style="background: var(--bg-primary); padding: 15px; border-radius: 10px; text-align: center;">
                        <div style="font-size: 2rem; font-weight: 700; color: var(--accent-green);" id="statUniqueCustomers">--</div>
                        <div style="color: var(--text-secondary); font-size: 0.85rem;">Customers</div>
                    </div>
                    <div style="background: var(--bg-primary); padding: 15px; border-radius: 10px; text-align: center;">
                        <div style="font-size: 2rem; font-weight: 700; color: var(--accent-purple);" id="statThisWeek">--</div>
                        <div style="color: var(--text-secondary); font-size: 0.85rem;">This Week</div>
                    </div>
                    <div style="background: var(--bg-primary); padding: 15px; border-radius: 10px; text-align: center;">
                        <div style="font-size: 2rem; font-weight: 700; color: var(--accent-orange);" id="statTotalProducts">--</div>
                        <div style="color: var(--text-secondary); font-size: 0.85rem;">Products Moved</div>
                    </div>
                </div>

                <!-- Calendar View Toggle -->
                <div style="display: flex; gap: 10px; margin-bottom: 20px;">
                    <button onclick="setCalendarView('calendar')" id="viewCalendarBtn" class="btn" style="background: var(--accent-blue); padding: 8px 16px;">Calendar</button>
                    <button onclick="setCalendarView('list')" id="viewListBtn" class="btn" style="background: var(--bg-tertiary); padding: 8px 16px;">Customer List</button>
                    <button onclick="setCalendarView('frequency')" id="viewFreqBtn" class="btn" style="background: var(--bg-tertiary); padding: 8px 16px;">Frequency</button>
                </div>

                <!-- Calendar Content -->
                <div id="dropCalendarContent" style="background: var(--bg-primary); border-radius: 12px; padding: 20px; min-height: 300px;">
                    <div style="text-align: center; padding: 60px; color: var(--text-secondary);">
                        <div style="font-size: 3rem; margin-bottom: 10px;">ðŸ“…</div>
                        Click "Refresh" to load drop data from LeafLink
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Blog Post View Modal -->
    <div id="blogPostViewModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); z-index: 10001; overflow-y: auto;">
        <div style="max-width: 800px; margin: 50px auto; background: var(--bg-secondary); border-radius: 20px; padding: 0; box-shadow: 0 20px 60px rgba(59, 130, 246, 0.4);">
            <!-- Header -->
            <div style="background: linear-gradient(135deg, var(--accent-blue), var(--accent-purple)); padding: 30px; border-radius: 20px 20px 0 0;">
                <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                    <div style="flex: 1;">
                        <h2 id="blogPostViewTitle" style="color: white; margin: 0 0 10px 0; font-size: 1.8rem;"></h2>
                        <p id="blogPostViewMeta" style="color: rgba(255,255,255,0.8); margin: 0; font-size: 0.9rem;"></p>
                    </div>
                    <button onclick="closeBlogPostView()" style="background: rgba(255,255,255,0.2); border: none; color: white; font-size: 2rem; cursor: pointer; padding: 5px 15px; border-radius: 10px; transition: all 0.3s ease;">&times;</button>
                </div>
            </div>
            <!-- Content -->
            <div style="padding: 30px;">
                <div id="blogPostViewContent" style="color: var(--text-primary); line-height: 1.8; font-size: 1.1rem; white-space: pre-wrap;"></div>
            </div>
        </div>
    </div>

    <script>
        // Role configuration - loaded from database on init
        // Demo user is hardcoded as fallback, all others from wm_employees table
        let ROLES = {
            demo: {
                name: 'Demo User',
                displayName: 'Demo User',
                pin: '0000',
                tabs: ['dashboard', 'intake', 'extraction', 'finishing', 'packaging', 'testing', 'labeling', 'analytics', 'performance', 'frontofhouse'],
                access: ['dashboard', 'intake', 'extraction', 'finishing', 'packaging', 'testing', 'labeling', 'analytics', 'performance', 'frontofhouse'],
                readOnly: true,
                salary: true,
                isDemo: true
            }
        };

        // Load employees from database and populate ROLES object
        async function loadEmployees() {
            try {
                const { data, error } = await supabaseClient
                    .from('wm_employees')
                    .select('*')
                    .eq('is_active', true);

                if (error) {
                    console.error('Error loading employees:', error);
                    return;
                }

                // Convert database rows to ROLES format
                data.forEach(emp => {
                    const key = emp.name.toLowerCase().replace(/[^a-z]/g, '');
                    ROLES[key] = {
                        id: emp.id,
                        name: emp.name,
                        displayName: emp.is_admin ? emp.name + ' (Admin)' : emp.name,
                        pin: emp.pin,
                        tabs: emp.stations || [],
                        access: emp.stations || [],
                        readOnly: emp.read_only || false,
                        salary: emp.is_salary || false,
                        isAdmin: emp.is_admin || false,
                        canEditBatches: emp.can_edit_batches || emp.is_admin || false
                    };
                });

                console.log('Loaded ' + data.length + ' employees from database');
            } catch (err) {
                console.error('Failed to load employees:', err);
            }
        }

        // ==================== DEMO MODE ====================
        // Demo mode (PIN: 0000) provides realistic fake data for client demonstrations
        //
        // Demo Data Components:
        // 1. generateDemoBatches() - Fake production batches with realistic weights, strains, and test results
        // 2. generateDemoLeafLinkOrders() - Fake sales orders from LeafLink
        // 3. generateDemoBlogPosts() - Fake blog posts for Front of House section
        // 4. demoFOHPartners - Fake partner/grower database for auto-tagging
        //
        // Features:
        // - All company names and partners are clearly fake (use "example.com" domains)
        // - Demo banner displayed prominently at top of app
        // - Publishing/editing disabled with helpful alerts
        // - Data persists only in memory (no database writes)
        // - Realistic enough for professional client demos
        // ====================================================

        function isDemoMode() {
            return currentRole && currentRole.isDemo === true;
        }

        function hidePINsForDemo() {
            if (!isDemoMode()) return;

            // Hide PINs in performance filter dropdown
            const performanceFilter = document.getElementById('performanceFilter');
            if (performanceFilter) {
                Array.from(performanceFilter.options).forEach(option => {
                    option.text = option.text.replace(/ - PIN: \d+/, '');
                });
            }

            // Hide any other PIN displays in the UI
            document.querySelectorAll('[data-pin]').forEach(el => {
                el.textContent = el.textContent.replace(/PIN: \d+/, 'PIN: ****');
            });

            // Add demo banner
            const header = document.querySelector('.header');
            if (header && !document.querySelector('.demo-banner')) {
                const demoBanner = document.createElement('div');
                demoBanner.className = 'demo-banner';
                demoBanner.style.cssText = 'background: linear-gradient(135deg, #ff6b00, #ff0055); color: white; padding: 10px; text-align: center; font-weight: 600; border-radius: 8px; margin-bottom: 15px;';
                demoBanner.innerHTML = 'ðŸŽ­ DEMO MODE - All data is fake for demonstration purposes';
                header.after(demoBanner);
            }
        }

        // ==================== EMPLOYEE MANAGEMENT ====================

        function openEmployeeManagement() {
            document.getElementById('employeeManagementModal').style.display = 'block';
            renderEmployeeList();
        }

        function closeEmployeeManagement() {
            document.getElementById('employeeManagementModal').style.display = 'none';
        }

        async function renderEmployeeList() {
            const container = document.getElementById('employeeListContent');
            container.innerHTML = 'Loading...';

            try {
                const { data, error } = await supabaseClient
                    .from('wm_employees')
                    .select('*')
                    .eq('is_active', true)
                    .order('name');

                if (error) throw error;

                if (data.length === 0) {
                    container.innerHTML = '<p style="color: var(--text-secondary);">No employees found.</p>';
                    return;
                }

                container.innerHTML = data.map(emp => `
                    <div style="background: var(--bg-tertiary); border-radius: 12px; padding: 15px; margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <div style="font-size: 1.1rem; font-weight: 600; color: var(--text-primary);">
                                ${emp.name} ${emp.is_admin ? '<span style="color: var(--accent-purple); font-size: 0.85rem;">(Admin)</span>' : ''}
                            </div>
                            <div style="color: var(--text-secondary); font-size: 0.9rem; margin-top: 4px;">
                                PIN: ${emp.pin} | ${(emp.stations || []).length} stations
                                ${emp.is_salary ? ' | Salary' : ''}
                                ${emp.read_only ? ' | Read Only' : ''}
                            </div>
                        </div>
                        <button onclick="openEditEmployee('${emp.id}')" style="background: var(--accent-blue); color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer;">Edit</button>
                    </div>
                `).join('');
            } catch (err) {
                console.error('Error loading employees:', err);
                container.innerHTML = '<p style="color: var(--accent-red);">Error loading employees.</p>';
            }
        }

        function openAddEmployee() {
            document.getElementById('employeeFormTitle').textContent = 'Add Employee';
            document.getElementById('employeeEditId').value = '';
            document.getElementById('employeeName').value = '';
            document.getElementById('employeePIN').value = '';
            document.getElementById('employeeIsAdmin').checked = false;
            document.getElementById('employeeIsSalary').checked = false;
            document.getElementById('employeeReadOnly').checked = false;
            document.getElementById('employeeCanEditBatches').checked = false;
            document.querySelectorAll('.station-checkbox').forEach(cb => cb.checked = false);
            document.getElementById('deactivateEmployeeBtn').style.display = 'none';
            document.getElementById('employeeFormModal').style.display = 'block';
        }

        async function openEditEmployee(id) {
            document.getElementById('employeeFormTitle').textContent = 'Edit Employee';
            document.getElementById('employeeEditId').value = id;
            document.getElementById('deactivateEmployeeBtn').style.display = 'block';

            try {
                const { data, error } = await supabaseClient
                    .from('wm_employees')
                    .select('*')
                    .eq('id', id)
                    .single();

                if (error) throw error;

                document.getElementById('employeeName').value = data.name || '';
                document.getElementById('employeePIN').value = data.pin || '';
                document.getElementById('employeeIsAdmin').checked = data.is_admin || false;
                document.getElementById('employeeIsSalary').checked = data.is_salary || false;
                document.getElementById('employeeReadOnly').checked = data.read_only || false;
                document.getElementById('employeeCanEditBatches').checked = data.can_edit_batches || false;

                document.querySelectorAll('.station-checkbox').forEach(cb => {
                    cb.checked = (data.stations || []).includes(cb.value);
                });

                document.getElementById('employeeFormModal').style.display = 'block';
            } catch (err) {
                console.error('Error loading employee:', err);
                alert('Error loading employee data');
            }
        }

        function closeEmployeeForm() {
            document.getElementById('employeeFormModal').style.display = 'none';
        }

        async function saveEmployee() {
            const id = document.getElementById('employeeEditId').value;
            const name = document.getElementById('employeeName').value.trim();
            const pin = document.getElementById('employeePIN').value.trim();
            const isAdmin = document.getElementById('employeeIsAdmin').checked;
            const isSalary = document.getElementById('employeeIsSalary').checked;
            const readOnly = document.getElementById('employeeReadOnly').checked;
            const canEditBatches = document.getElementById('employeeCanEditBatches').checked;
            const stations = Array.from(document.querySelectorAll('.station-checkbox:checked')).map(cb => cb.value);

            if (!name) {
                alert('Please enter a name');
                return;
            }
            if (!pin || pin.length !== 4 || !/^\d{4}$/.test(pin)) {
                alert('Please enter a 4-digit PIN');
                return;
            }
            if (stations.length === 0) {
                alert('Please select at least one station');
                return;
            }

            const employeeData = {
                name,
                pin,
                is_admin: isAdmin,
                is_salary: isSalary,
                read_only: readOnly,
                can_edit_batches: canEditBatches,
                stations,
                updated_at: new Date().toISOString()
            };

            try {
                let result;
                if (id) {
                    // Update existing
                    result = await supabaseClient
                        .from('wm_employees')
                        .update(employeeData)
                        .eq('id', id);
                } else {
                    // Insert new
                    employeeData.is_active = true;
                    employeeData.created_at = new Date().toISOString();
                    result = await supabaseClient
                        .from('wm_employees')
                        .insert(employeeData);
                }

                if (result.error) throw result.error;

                // Reload employees into ROLES
                await loadEmployees();

                closeEmployeeForm();
                renderEmployeeList();
                alert(id ? 'Employee updated!' : 'Employee added!');
            } catch (err) {
                console.error('Error saving employee:', err);
                alert('Error saving employee: ' + err.message);
            }
        }

        async function deactivateEmployee() {
            const id = document.getElementById('employeeEditId').value;
            const name = document.getElementById('employeeName').value;

            if (!confirm('Are you sure you want to deactivate ' + name + '? They will no longer be able to log in.')) {
                return;
            }

            try {
                const { error } = await supabaseClient
                    .from('wm_employees')
                    .update({ is_active: false, updated_at: new Date().toISOString() })
                    .eq('id', id);

                if (error) throw error;

                // Reload employees into ROLES
                await loadEmployees();

                closeEmployeeForm();
                renderEmployeeList();
                alert('Employee deactivated');
            } catch (err) {
                console.error('Error deactivating employee:', err);
                alert('Error deactivating employee: ' + err.message);
            }
        }

        function generateDemoBatches() {
            const strains = ['GMO Cookies', 'Wedding Cake', 'Gelato', 'Blue Dream', 'OG Kush', 'Sour Diesel', 'Purple Punch', 'Zkittlez', 'Skywalker OG', 'Strawberry Cough'];
            const suppliers = ['Boulder Built Farms', 'Wonderland Cannabis', 'In The Flow Farms', 'Loud Seeds', 'Green Valley Farms'];
            const statuses = ['intake', 'extraction', 'finishing', 'packaging', 'testing', 'labeling', 'completed'];
            const machines = ['left', 'right'];
            const materialTypes = ['Trim', 'Fresh Frozen', 'Whole Flower'];

            const demoBatches = [];
            const now = Date.now();

            // Create more completed batches for FOH showcase (first 10 batches)
            for (let i = 0; i < 10; i++) {
                const strain = strains[Math.floor(Math.random() * strains.length)];
                const supplier = suppliers[Math.floor(Math.random() * suppliers.length)];
                const trimWeight = Math.floor(Math.random() * 5000) + 2000;
                const yieldPercent = (Math.random() * 8 + 15).toFixed(2); // 15-23% yield
                const bulkWeight = (trimWeight * yieldPercent / 100).toFixed(1);
                const materialType = materialTypes[Math.floor(Math.random() * materialTypes.length)];

                demoBatches.push({
                    id: `WM${1000 + i}`,
                    strain: strain,
                    supplier: supplier,
                    material_type: materialType,
                    trim_weight_grams: trimWeight,
                    status: 'completed',
                    stage: 'complete',
                    machine: null,
                    bulk_weight_grams: bulkWeight,
                    final_weight: bulkWeight,
                    jar_count: Math.floor(Math.random() * 50) + 20,
                    created_at: new Date(now - (i + 2) * 24 * 60 * 60 * 1000).toISOString(),
                    updated_at: new Date(now - i * 24 * 60 * 60 * 1000).toISOString(),
                    completed_at: new Date(now - i * 24 * 60 * 60 * 1000).toISOString(),
                    created_by: 'Demo User',
                    notes: 'Excellent quality material',
                    test_results: JSON.stringify({
                        thc: (Math.random() * 20 + 65).toFixed(2),
                        cbd: (Math.random() * 2).toFixed(2),
                        terpenes: (Math.random() * 5 + 3).toFixed(2)
                    })
                });
            }

            // Add regular mix of batches (remaining 15)
            for (let i = 10; i < 25; i++) {
                const strain = strains[Math.floor(Math.random() * strains.length)];
                const supplier = suppliers[Math.floor(Math.random() * suppliers.length)];
                const status = statuses[Math.floor(Math.random() * statuses.length)];
                const trimWeight = Math.floor(Math.random() * 5000) + 1000;
                const yieldPercent = (Math.random() * 15 + 10).toFixed(2);
                const bulkWeight = status === 'completed' ? (trimWeight * yieldPercent / 100).toFixed(1) : null;
                const materialType = materialTypes[Math.floor(Math.random() * materialTypes.length)];

                demoBatches.push({
                    id: `WM${1000 + i}`,
                    strain: strain,
                    supplier: supplier,
                    material_type: materialType,
                    trim_weight_grams: trimWeight,
                    status: status,
                    stage: status === 'completed' ? 'complete' : status,
                    machine: status === 'extraction' ? machines[Math.floor(Math.random() * machines.length)] : null,
                    bulk_weight_grams: bulkWeight,
                    final_weight: bulkWeight,
                    jar_count: status === 'completed' ? Math.floor(Math.random() * 50) + 10 : null,
                    created_at: new Date(now - Math.random() * 30 * 24 * 60 * 60 * 1000).toISOString(),
                    updated_at: new Date(now - Math.random() * 7 * 24 * 60 * 60 * 1000).toISOString(),
                    created_by: 'Demo User',
                    notes: i % 3 === 0 ? 'Looking good!' : null,
                    test_results: status === 'completed' ? JSON.stringify({
                        thc: (Math.random() * 30 + 60).toFixed(2),
                        cbd: (Math.random() * 2).toFixed(2)
                    }) : null
                });
            }

            return demoBatches;
        }

        function generateDemoLeafLinkOrders() {
            const companies = ['Green Valley Dispensary', 'Mountain High', 'Coastal Cannabis', 'Urban Leaf', 'Valley Verde'];
            const salesReps = ['Ryan Thompson', 'Drew Martinez', 'Sarah Johnson'];
            const demoOrders = [];
            const now = Date.now();

            for (let i = 0; i < 50; i++) {
                const company = companies[Math.floor(Math.random() * companies.length)];
                const orderDate = new Date(now - Math.random() * 60 * 24 * 60 * 60 * 1000);
                const total = (Math.random() * 5000 + 500).toFixed(2);

                demoOrders.push({
                    id: `DEMO-${1000 + i}`,
                    number: `WM${1000 + i}`,
                    company: { name: company },
                    customer: { company_name: company },
                    status: Math.random() > 0.3 ? 'Complete' : 'Shipped',
                    seller_company: { name: 'White Mousse' },
                    created_on: orderDate.toISOString(),
                    total: total,
                    total_paid: Math.random() > 0.2 ? total : (parseFloat(total) * 0.5).toFixed(2),
                    payment_status: Math.random() > 0.2 ? 'Paid' : 'Unpaid',
                    sales_rep: { name: salesReps[Math.floor(Math.random() * salesReps.length)] },
                    line_items: [
                        {
                            product: { name: 'Live Resin - ' + ['GMO', 'Wedding Cake', 'Gelato'][Math.floor(Math.random() * 3)] },
                            quantity: Math.floor(Math.random() * 10) + 1,
                            unit_price: (Math.random() * 50 + 20).toFixed(2)
                        }
                    ]
                });
            }

            return demoOrders;
        }

        // Generate realistic demo blog posts for Front of House section
        // These posts showcase the social media content generation features
        // and partner auto-tagging functionality in demo mode
        function generateDemoBlogPosts() {
            const now = Date.now();
            const demoPosts = [];

            const postTemplates = [
                {
                    title: 'ðŸ”¥ Fresh Heat Incoming: Skywalker OG Live Resin',
                    content: `The terp hunters have spoken!\n\nSo here's the deal: Just grabbed some fire Skywalker OG trim from Boulder Built Farms. And let me tell you, it's absolutely fire!\n\nWhen you prioritize terps and quality, the results are always fire.\n\n---\n\n**ðŸ¤ Shoutouts**\n\nHuge shoutout to Boulder Built Farms for this incredible material! @boulderbuilt\n\nKeep your eyes peeled at your local dispensary! ðŸ‘€\n\n---\n#WhiteMousse #ColoradoConcentrates #LiveResin #Terps #CannabisCommunity #BoulderBuilt #SkywalkerOG`,
                    excerpt: 'The terp hunters have spoken! So here\'s the deal: Just grabbed some fire Skywalker OG trim from Boulder...',
                    category: 'strains',
                    emoji: 'ðŸ”¥',
                    status: 'published',
                    daysAgo: 2
                },
                {
                    title: 'ðŸ§ª Fresh Batch Alert: Purple Punch Live Resin',
                    content: `The extractors have been BUSY!\n\nBig news from the lab: Just wrapped up a fresh batch of Purple Punch. We're honestly so hyped about this one.\n\nAnother batch, another banger. When you prioritize terps and quality, the results are always fire.\n\n---\n\n**ðŸ¤ Shoutouts**\n\nThis fire came straight from Wonderland Cannabis! @wonderlandcannabis\n\nAsk your budtender about White Mousse! ðŸ”¥\n\n---\n#WhiteMousse #ColoradoConcentrates #LiveResin #Terps #CannabisCommunity #WonderlandCannabis #PurplePunch`,
                    excerpt: 'The extractors have been BUSY! Big news from the lab: Just wrapped up a fresh batch of Purple Punch...',
                    category: 'update',
                    emoji: 'ðŸ§ª',
                    status: 'published',
                    daysAgo: 5
                },
                {
                    title: 'ðŸ’Ž Quality Check: PASSED - GMO Cookies',
                    content: `Another day, another chance to serve the terps!\n\nHad to share this with y'all: Our GMO Cookies batch just came back from testing. The quality is next level.\n\nThe nose on this one is INSANE. Test results came back at 78.4% THC with an incredible terpene profile.\n\n---\n\n**ðŸ¤ Shoutouts**\n\nHuge shoutout to In The Flow Farms for this incredible material! @intheflow_farms\n\nKeep an eye out at your local spot! ðŸ‘€\n\n---\n#WhiteMousse #ColoradoConcentrates #LiveResin #Terps #CannabisCommunity #InTheFlowFarms #GMOCookies`,
                    excerpt: 'Another day, another chance to serve the terps! Had to share this with y\'all: Our GMO Cookies batch...',
                    category: 'update',
                    emoji: 'ðŸ’Ž',
                    status: 'published',
                    daysAgo: 7
                },
                {
                    title: 'âš¡ New Tech in the Lab',
                    content: `When you're obsessed with quality, you never stop upgrading.\n\nSo here's the deal: Just added some new hardware to dial in our extraction process. And let me tell you, it's game-changing!\n\nBetter equipment = better terps. We're always pushing our extraction game to the next level.\n\nStay tuned for even better concentrates! ðŸš€\n\n---\n#WhiteMousse #ColoradoConcentrates #LiveResin #Terps #CannabisCommunity #ExtractionTech`,
                    excerpt: 'When you\'re obsessed with quality, you never stop upgrading. So here\'s the deal: Just added some new...',
                    category: 'update',
                    emoji: 'âš¡',
                    status: 'published',
                    daysAgo: 10
                },
                {
                    title: 'ðŸŒŸ Strain Alert: Wedding Cake x Gelato',
                    content: `Sometimes a strain walks in and you just KNOW it's gonna be special.\n\nBig news from the lab: Grabbed some Wedding Cake x Gelato from our partners. We're honestly so hyped about this one.\n\nThe terpene profile on this one is chef's kiss. Beautiful blend of sweet, creamy terps with that classic cake finish.\n\n---\n\n**ðŸ¤ Shoutouts**\n\nThis fire came straight from Loud Seeds! @loudseeds\n\nComing soon to a dispo near you! ðŸƒâ€â™‚ï¸\n\n---\n#WhiteMousse #ColoradoConcentrates #LiveResin #Terps #CannabisCommunity #LoudSeeds #WeddingCake #Gelato`,
                    excerpt: 'Sometimes a strain walks in and you just KNOW it\'s gonna be special. Big news from the lab: Grabbed...',
                    category: 'strains',
                    emoji: 'ðŸŒŸ',
                    status: 'published',
                    daysAgo: 14
                },
                {
                    title: 'ðŸŽ¯ Lab Update: December Recap',
                    content: `Just had to hop on and share what's happening at the lab!\n\nWhat a month! We processed over 15 batches, worked with some incredible flower from our amazing partners, and maintained our commitment to quality over quantity.\n\nYou know we're always cooking up something special. Thanks for rocking with White Mousse!\n\nMore updates coming soon. Stay lifted! âœŒï¸\n\n---\n#WhiteMousse #ColoradoConcentrates #LiveResin #Terps #CannabisCommunabis #YearEndRecap`,
                    excerpt: 'Just had to hop on and share what\'s happening at the lab! What a month! We processed over 15 batches...',
                    category: 'update',
                    emoji: 'ðŸŽ¯',
                    status: 'published',
                    daysAgo: 21
                },
                {
                    title: 'ðŸ”§ Gear Upgrade Alert: New Extraction System',
                    content: `The lab just got a serious upgrade, fam!\n\nHad to share this with y'all: We just installed a new closed-loop extraction system. The quality is premium.\n\nWe're always pushing our extraction game to the next level. This new setup is going to let us dial in terpene preservation like never before.\n\nBetter equipment = better terps. Stay tuned for even better concentrates! ðŸš€\n\n---\n#WhiteMousse #ColoradoConcentrates #LiveResin #Terps #CannabisCommunity #LabUpgrade`,
                    excerpt: 'The lab just got a serious upgrade, fam! Had to share this with y\'all: We just installed a new...',
                    category: 'update',
                    emoji: 'ðŸ”§',
                    status: 'published',
                    daysAgo: 28
                },
                {
                    title: 'âœ¨ Behind the Scenes: Extraction Process',
                    content: `Ever wonder what goes into making premium live resin?\n\nBig news from the lab: Thought we'd pull back the curtain a bit. We're honestly so hyped about this one.\n\nFrom fresh frozen material to final product, every step matters. Temperature control, solvent quality, purge times - it's all dialed in to preserve those precious terpenes.\n\nThe results speak for themselves. Keep your eyes peeled at your local dispensary! ðŸ‘€\n\n---\n#WhiteMousse #ColoradoConcentrates #LiveResin #Terps #CannabisCommunity #BehindTheScenes #ProcessMatters`,
                    excerpt: 'Ever wonder what goes into making premium live resin? Big news from the lab: Thought we\'d pull back...',
                    category: 'update',
                    emoji: 'âœ¨',
                    status: 'published',
                    daysAgo: 35
                }
            ];

            // Generate posts with proper IDs and timestamps
            postTemplates.forEach((template, idx) => {
                const postDate = new Date(now - template.daysAgo * 24 * 60 * 60 * 1000);
                demoPosts.push({
                    id: `demo-post-${1000 + idx}`,
                    title: template.title,
                    content: template.content,
                    excerpt: template.excerpt,
                    category: template.category,
                    emoji: template.emoji,
                    status: template.status,
                    created_at: postDate.toISOString(),
                    updated_at: postDate.toISOString()
                });
            });

            return demoPosts;
        }

        // Demo partners database (fake versions of real partners)
        const demoFOHPartners = {
            'boulder built': { name: 'Boulder Built Farms', instagram: '@boulderbuilt', website: 'https://example.com/boulderbuilt', type: 'farm', hashtags: ['#BoulderBuilt', '#ColoradoGrown'] },
            'wonderland': { name: 'Wonderland Cannabis', instagram: '@wonderlandcannabis', website: 'https://example.com/wonderland', type: 'farm', hashtags: ['#WonderlandCannabis', '#DenverGrown'] },
            'in the flow': { name: 'In The Flow Farms', instagram: '@intheflow_farms', website: 'https://example.com/intheflow', type: 'farm', hashtags: ['#InTheFlowFarms', '#OrganicGrown'] },
            'loud seeds': { name: 'Loud Seeds', instagram: '@loudseeds', website: null, type: 'farm', hashtags: ['#LoudSeeds'] },
            'green valley': { name: 'Green Valley Dispensary', instagram: '@greenvalleydispensary', website: 'https://example.com/greenvalley', type: 'dispensary', hashtags: ['#GreenValley'] },
            'mountain high': { name: 'Mountain High', instagram: '@mountainhighdispensary', website: 'https://example.com/mountainhigh', type: 'dispensary', hashtags: ['#MountainHigh'] }
        };

        let supabaseClient = null;
        let batches = [];
        let currentRole = null;
        let currentMachine = null; // 'left' or 'right' for machine modal
        let currentPullMachine = null; // 'left' or 'right' for pull batch modal
        let batchCounter = 1000;
        let realtimeChannel = null;

        // ==================== DEMO MODE ====================
        let DEMO_MODE = false;

        const DEMO_BATCHES = [
            { id: 'DEMO-001', strain: 'Blue Dream', partner: 'Demo Farm', status: 'intake', trim_weight: 500, socks_total: 10, socks_remaining: 10, material_type: 'Trim', metrc_source_tag: 'DEMO123456', pre_sift: 'no', created_at: new Date().toISOString() },
            { id: 'DEMO-002', strain: 'OG Kush', partner: 'Demo Farm', status: 'intake', trim_weight: 750, socks_total: 15, socks_remaining: 15, material_type: 'Trim', metrc_source_tag: 'DEMO789012', pre_sift: 'yes', created_at: new Date().toISOString() },
            { id: 'DEMO-003', strain: 'Gelato', partner: 'Test Partner', status: 'intake', trim_weight: 300, socks_total: 6, socks_remaining: 6, material_type: 'Trim', metrc_source_tag: 'DEMO345678', pre_sift: 'yes', created_at: new Date().toISOString() },
            { id: 'DEMO-004', strain: 'Purple Punch', partner: 'Test Partner', status: 'intake', trim_weight: 1000, socks_total: 20, socks_remaining: 20, material_type: 'Whole Flower', metrc_source_tag: 'DEMO901234', pre_sift: 'no', created_at: new Date().toISOString() }
        ];

        function toggleDemoMode() {
            DEMO_MODE = !DEMO_MODE;
            const btn = document.getElementById('demoModeBtn');
            const indicator = document.getElementById('demoIndicator');

            if (DEMO_MODE) {
                // Load demo data
                batches = [...DEMO_BATCHES];
                CONFIG.machines = [
                    { id: 'demo-bho', name: 'Demo BHO', position: 'Left', machine_type: 'bho', config: { columns: 6, socks_per_run: 6 }, is_active: true },
                    { id: 'demo-resinator', name: 'Demo Resinator', position: 'Resinator', machine_type: 'resinator', config: { second_sift: true }, is_active: true }
                ];
                CONFIG.loaded = true;

                if (btn) {
                    btn.textContent = 'ðŸ”´ Exit Demo';
                    btn.style.background = 'var(--accent-red)';
                }
                if (indicator) indicator.style.display = 'block';

                // Re-render UI
                renderMachineButtons();
                populateExtractionQueue();
                alert('ðŸŽ® DEMO MODE ACTIVE\n\nUsing mock data - no database changes will be made.\n\nDemo batches and machines loaded.');
            } else {
                if (btn) {
                    btn.textContent = 'ðŸŽ® Demo Mode';
                    btn.style.background = 'var(--accent-purple)';
                }
                if (indicator) indicator.style.display = 'none';

                alert('Demo mode disabled. Refresh to reconnect to live database.');
                location.reload();
            }
        }

        // Demo mode storage helpers
        function demoGetMachineStatus(machineKey) {
            const stored = localStorage.getItem(`demo_machine_${machineKey}`);
            return stored ? JSON.parse(stored) : {};
        }

        function demoSaveMachineStatus(machineKey, status) {
            localStorage.setItem(`demo_machine_${machineKey}`, JSON.stringify(status));
            return Promise.resolve({ error: null });
        }

        function demoUpdateBatch(batchId, updates) {
            const batch = batches.find(b => b.id === batchId);
            if (batch) {
                Object.assign(batch, updates);
            }
            return Promise.resolve({ error: null });
        }

        // ==================== ADMIN CONFIG ====================
        let CONFIG = {
            machines: [],
            productTypes: [],
            materialTypes: [],
            loaded: false
        };

        const CONFIG_DEFAULTS = {
            machines: [
                { id: 'default-1', name: 'Machine 1', position: 'Left', machine_type: 'bho', config: { columns: 6, socks_per_run: 6 }, is_active: true },
                { id: 'default-2', name: 'Machine 2', position: 'Right', machine_type: 'bho', config: { columns: 6, socks_per_run: 6 }, is_active: true }
            ],
            productTypes: [
                { name: 'Wax', category: 'concentrate', unit_sizes: [{size: 1, label: '1g'}, {size: 4, label: '4g'}], packaging_type: 'jar', is_live_resin: false },
                { name: 'Sugar Wax', category: 'concentrate', unit_sizes: [{size: 1, label: '1g'}, {size: 4, label: '4g'}], packaging_type: 'jar', is_live_resin: false },
                { name: 'Shatter', category: 'concentrate', unit_sizes: [{size: 1, label: '1g'}], packaging_type: 'slab', is_live_resin: false },
                { name: 'Live Resin Carts', category: 'cart', unit_sizes: [{size: 1, label: '1g'}], packaging_type: 'cart', is_live_resin: true },
                { name: 'Live Resin AIOs', category: 'cart', unit_sizes: [{size: 1, label: '1g'}], packaging_type: 'aio', is_live_resin: true },
                { name: 'Brick Hash', category: 'concentrate', unit_sizes: [{size: 1, label: '1g'}, {size: 4, label: '4g'}], packaging_type: 'jar', is_live_resin: false }
            ],
            materialTypes: [
                { name: 'Trim', expected_yield: 13.00 },
                { name: 'Fresh Frozen', expected_yield: 3.50 },
                { name: 'Whole Flower', expected_yield: 18.00 }
            ]
        };

        async function loadConfig() {
            if (!supabaseClient) return;
            try {
                const { data: machines } = await supabaseClient.from('wm_machines').select('*').eq('is_active', true).order('sort_order');
                if (machines && machines.length > 0) {
                    CONFIG.machines = machines.map(m => ({ ...m, config: typeof m.config === 'string' ? JSON.parse(m.config) : (m.config || {}) }));
                } else { CONFIG.machines = CONFIG_DEFAULTS.machines; }

                const { data: products } = await supabaseClient.from('wm_product_types').select('*').eq('is_active', true).order('sort_order');
                if (products && products.length > 0) {
                    CONFIG.productTypes = products.map(p => ({ ...p, unit_sizes: typeof p.unit_sizes === 'string' ? JSON.parse(p.unit_sizes) : (p.unit_sizes || []) }));
                } else { CONFIG.productTypes = CONFIG_DEFAULTS.productTypes; }

                const { data: materials } = await supabaseClient.from('wm_material_types').select('*').eq('is_active', true).order('sort_order');
                if (materials && materials.length > 0) { CONFIG.materialTypes = materials; }
                else { CONFIG.materialTypes = CONFIG_DEFAULTS.materialTypes; }

                CONFIG.loaded = true;
                console.log('Admin Config loaded:', CONFIG);
                populateProductDropdowns();
                renderMachineButtons();
            } catch (err) {
                console.error('Error loading config:', err);
                CONFIG.machines = CONFIG_DEFAULTS.machines;
                CONFIG.productTypes = CONFIG_DEFAULTS.productTypes;
                CONFIG.materialTypes = CONFIG_DEFAULTS.materialTypes;
                CONFIG.loaded = true;
                // Still render buttons even with defaults
                populateProductDropdowns();
                renderMachineButtons();
            }
        }

        function populateProductDropdowns() {
            const selectors = ['#editFinalProductType', '#subBatchProductType', '#finalConsistency', '#packagingProductType'];
            selectors.forEach(sel => {
                const dd = document.querySelector(sel);
                if (dd && CONFIG.productTypes.length > 0) {
                    const val = dd.value;
                    dd.innerHTML = CONFIG.productTypes.filter(p => p.is_active !== false).map(p => '<option value="' + p.name + '">' + p.name + '</option>').join('');
                    if (val) dd.value = val;
                }
            });
        }

        function renderMachineButtons() {
            const machineContainer = document.getElementById('machineButtonsContainer');

            if (!machineContainer) return;

            // Use CONFIG.machines or defaults
            const machines = CONFIG.machines.length > 0 ? CONFIG.machines : CONFIG_DEFAULTS.machines;

            // Render machine status buttons
            machineContainer.innerHTML = machines.map((machine, idx) => {
                const machineKey = (machine.position?.toLowerCase() || machine.name.toLowerCase()).replace(/[^a-z0-9]/g, '');
                const machineType = machine.machine_type || 'bho';
                const config = machine.config || {};

                // Get icon based on machine type
                const icon = machineType === 'bho' ? 'âš—ï¸' : machineType === 'rosin' ? 'ðŸ«§' : 'ðŸŒ€';

                // Build status display based on machine type
                let statusHtml = '';
                if (machineType === 'bho') {
                    // Dynamic column layout based on config
                    const numCols = Math.min(6, Math.max(2, config.columns || 6));
                    const columnLabels = ['A', 'B', 'C', 'D', 'E', 'F'].slice(0, numCols);
                    const colSize = numCols <= 3 ? 85 : 75;

                    // Build column circles - stack in rows of 3 for 4+ columns
                    let columnsHtml = '';
                    if (numCols <= 3) {
                        // Single row for 2-3 columns
                        columnsHtml = '<div style="display: flex; justify-content: center; gap: 10px; margin-bottom: 12px;">';
                        columnLabels.forEach(col => {
                            columnsHtml += '<button id="' + machineKey + 'Col' + col + 'Btn" onclick="event.stopPropagation(); openComponentSelector(\'' + machineKey + '\', \'column' + col + '\')" style="width: ' + colSize + 'px; height: ' + colSize + 'px; border-radius: 50%; border: 3px solid var(--accent-blue); background: linear-gradient(145deg, rgba(59,130,246,0.25) 0%, rgba(59,130,246,0.1) 100%); cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 5px; box-shadow: 0 4px 12px rgba(59,130,246,0.3);">' +
                                '<div style="font-weight: 700; color: var(--text-secondary); font-size: 0.7rem; margin-bottom: 2px;">' + col + '</div>' +
                                '<div id="' + machineKey + 'Col' + col + 'Strain" style="font-size: 0.7rem; font-weight: 600; color: var(--text-primary); text-align: center; line-height: 1.2; word-wrap: break-word; max-width: 90%; overflow: hidden;">-</div></button>';
                        });
                        columnsHtml += '</div>';
                    } else {
                        // Two rows for 4-6 columns (split evenly or 3+remainder)
                        const firstRowCount = Math.ceil(numCols / 2);
                        const firstRow = columnLabels.slice(0, firstRowCount);
                        const secondRow = columnLabels.slice(firstRowCount);

                        columnsHtml = '<div style="display: flex; justify-content: center; gap: 8px; margin-bottom: 8px;">';
                        firstRow.forEach(col => {
                            columnsHtml += '<button id="' + machineKey + 'Col' + col + 'Btn" onclick="event.stopPropagation(); openComponentSelector(\'' + machineKey + '\', \'column' + col + '\')" style="width: ' + colSize + 'px; height: ' + colSize + 'px; border-radius: 50%; border: 3px solid var(--accent-blue); background: linear-gradient(145deg, rgba(59,130,246,0.25) 0%, rgba(59,130,246,0.1) 100%); cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 5px; box-shadow: 0 4px 12px rgba(59,130,246,0.3);">' +
                                '<div style="font-weight: 700; color: var(--text-secondary); font-size: 0.7rem; margin-bottom: 2px;">' + col + '</div>' +
                                '<div id="' + machineKey + 'Col' + col + 'Strain" style="font-size: 0.7rem; font-weight: 600; color: var(--text-primary); text-align: center; line-height: 1.2; word-wrap: break-word; max-width: 90%; overflow: hidden;">-</div></button>';
                        });
                        columnsHtml += '</div><div style="display: flex; justify-content: center; gap: 8px; margin-bottom: 12px;">';
                        secondRow.forEach(col => {
                            columnsHtml += '<button id="' + machineKey + 'Col' + col + 'Btn" onclick="event.stopPropagation(); openComponentSelector(\'' + machineKey + '\', \'column' + col + '\')" style="width: ' + colSize + 'px; height: ' + colSize + 'px; border-radius: 50%; border: 3px solid var(--accent-blue); background: linear-gradient(145deg, rgba(59,130,246,0.25) 0%, rgba(59,130,246,0.1) 100%); cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 5px; box-shadow: 0 4px 12px rgba(59,130,246,0.3);">' +
                                '<div style="font-weight: 700; color: var(--text-secondary); font-size: 0.7rem; margin-bottom: 2px;">' + col + '</div>' +
                                '<div id="' + machineKey + 'Col' + col + 'Strain" style="font-size: 0.7rem; font-weight: 600; color: var(--text-primary); text-align: center; line-height: 1.2; word-wrap: break-word; max-width: 90%; overflow: hidden;">-</div></button>';
                        });
                        columnsHtml += '</div>';
                    }

                    // Pot and filter row
                    statusHtml = '<div style="margin-top: 10px;">' + columnsHtml +
                        '<div style="display: flex; justify-content: center; align-items: center; gap: 20px;">' +
                        // Pot circle
                        '<button id="' + machineKey + 'PotBtn" onclick="event.stopPropagation(); openComponentSelector(\'' + machineKey + '\', \'pot\')" style="width: 120px; height: 120px; border-radius: 50%; border: 4px solid var(--accent-purple); background: linear-gradient(145deg, rgba(147,51,234,0.3) 0%, rgba(147,51,234,0.1) 100%); cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 8px; box-shadow: 0 6px 20px rgba(147,51,234,0.4);">' +
                        '<div id="' + machineKey + 'PotStrain" style="font-size: 0.8rem; font-weight: 700; color: var(--text-primary); text-align: center; line-height: 1.2;">Empty</div>' +
                        '<div id="' + machineKey + 'PotRuns" style="font-size: 0.7rem; color: var(--text-secondary); margin-top: 2px;"></div>' +
                        '<div id="' + machineKey + 'PotYield" style="font-size: 0.75rem; font-weight: 600; color: var(--accent-green); margin-top: 2px;"></div></button>' +
                        // Filter circle
                        '<button id="' + machineKey + 'FilterBtn" onclick="event.stopPropagation(); openComponentSelector(\'' + machineKey + '\', \'filter\')" style="width: 60px; height: 60px; border-radius: 50%; border: 3px solid var(--accent-green); background: linear-gradient(145deg, rgba(16,185,129,0.25) 0%, rgba(16,185,129,0.1) 100%); cursor: pointer; display: flex; align-items: center; justify-content: center; box-shadow: 0 4px 12px rgba(16,185,129,0.3);">' +
                        '<div id="' + machineKey + 'FilterRuns" style="font-size: 1rem; font-weight: 700; color: var(--text-primary);">0</div></button>' +
                        '</div></div>';
                } else if (machineType === 'rosin') {
                    statusHtml = '<div>Wash 1: <span id="' + machineKey + 'Wash1">Empty</span></div>';
                    if (config.second_wash === true) {
                        statusHtml += '<div>Wash 2: <span id="' + machineKey + 'Wash2">Empty</span></div>';
                    }
                } else if (machineType === 'resinator') {
                    statusHtml = '<div>Sift 1: <span id="' + machineKey + 'Sift1">Empty</span></div>';
                    if (config.second_sift === true) {
                        statusHtml += '<div>Sift 2: <span id="' + machineKey + 'Sift2">Empty</span></div>';
                    }
                }

                // For BHO machines with circular buttons, use a div container instead of button
                if (machineType === 'bho') {
                    return '<div class="btn" onclick="openMachineModal(\'' + machineKey + '\')" style="cursor: pointer; background: var(--bg-secondary); border: 2px solid #C0C0C0; color: #E8E8E8; padding: 15px; text-align: left; box-shadow: 0 0 15px rgba(192, 192, 192, 0.4), 0 0 30px rgba(192, 192, 192, 0.2), inset 0 0 15px rgba(192, 192, 192, 0.05); border-radius: 16px;">' +
                        '<div style="font-weight: 700; margin-bottom: 5px; text-align: center;">' + icon + ' ' + machine.name + '</div>' +
                        '<div id="' + machineKey + 'MachineStatus" style="font-size: 0.85rem;">' + statusHtml + '</div>' +
                    '</div>';
                }
                return '<button class="btn" style="background: transparent; border: 2px solid #C0C0C0; color: #E8E8E8; padding: 20px; text-align: left; box-shadow: 0 0 15px rgba(192, 192, 192, 0.4), 0 0 30px rgba(192, 192, 192, 0.2), inset 0 0 15px rgba(192, 192, 192, 0.05);" onclick="openMachineModal(\'' + machineKey + '\')">' +
                    '<div style="font-weight: 700; margin-bottom: 8px;">' + icon + ' ' + machine.name + '</div>' +
                    '<div id="' + machineKey + 'MachineStatus" style="font-size: 0.85rem; opacity: 0.9;">' + statusHtml + '</div>' +
                '</button>';
            }).join('');
        }

        function getExpectedYieldFromConfig(materialType) {
            const mat = CONFIG.materialTypes.find(m => m.name.toLowerCase() === materialType?.toLowerCase());
            return mat ? parseFloat(mat.expected_yield) : 13;
        }

        

        // Initialize on load
        document.addEventListener('DOMContentLoaded', function() {
            // Setup PIN login
            const pinInput = document.getElementById('pinInput');
            const loginBtn = document.getElementById('loginBtn');
            
            if (pinInput) {
                pinInput.addEventListener('input', function() {
                    this.value = this.value.replace(/[^0-9]/g, '');
                });
            }
            
            // Check for existing session
            const savedRole = localStorage.getItem('wmRole');
            const sessionTime = localStorage.getItem('wmSession');
            
            // Session expires after 12 hours
            if (savedRole && sessionTime && (Date.now() - parseInt(sessionTime)) < 12 * 60 * 60 * 1000) {
                currentRole = ROLES[savedRole];
                if (currentRole) {
                    document.getElementById('pinInput').style.display = 'none';
                    document.getElementById('loginBtn').style.display = 'none';
                    document.getElementById('actionsMenu').style.display = 'block';
                    document.getElementById('userLogin').style.display = 'none';
                    document.getElementById('appContent').style.display = 'block';
                    document.getElementById('myStatsBtn').style.display = 'block';
                document.getElementById('logoutBtn').style.display = 'block'; if(!currentRole.salary){document.getElementById('timeClockBtn').style.display = 'block';} const isAdminUser = currentRole.isAdmin || currentRole.name.includes('Admin') || currentRole.name === 'Ryan' || currentRole.name === 'Alex'; if(isAdminUser){document.getElementById('viewTimecardsBtn').style.display = 'block'; document.getElementById('manageEmployeesBtn').style.display = 'block'; document.getElementById('adminConfigBtn').style.display = 'block'; document.getElementById('loginHistoryBtn').style.display = 'block'; document.getElementById('viewTrashBtn').style.display = 'block';}
                    document.getElementById('complianceBtn').style.display = 'block';
                    applyRolePermissions();
                    hidePINsForDemo(); // Hide PINs if in demo mode
                }
            }
            
            const savedUrl = localStorage.getItem('supabaseUrl');
            const savedKey = localStorage.getItem('supabaseKey');
            
            // Auto-connect with hardcoded credentials
            const SUPABASE_URL = 'https://nspmwcpvukehaqswaewt.supabase.co';
            const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im5zcG13Y3B2dWtlaGFxc3dhZXd0Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjE0NzE2NDQsImV4cCI6MjA3NzA0NzY0NH0.JGYZ4223nhgO_Er619DkB0tOXrIJzfldG9yNkaHCdtI';
            
            if (SUPABASE_URL !== 'YOUR_SUPABASE_URL_HERE' && SUPABASE_KEY !== 'YOUR_SUPABASE_KEY_HERE') {
                // Use hardcoded credentials
                connectSupabase(SUPABASE_URL, SUPABASE_KEY);
            } else if (savedUrl && savedKey) {
                // Fallback to saved credentials
                connectSupabase(savedUrl, savedKey);
            } else {
                // Show setup form
                document.getElementById('setupSection').classList.remove('hidden');
            }
        });

        // Credentials form
        document.getElementById('credentialsForm').addEventListener('submit', async function(e) {
            e.preventDefault();
            const url = document.getElementById('supabaseUrl').value.trim();
            const key = document.getElementById('supabaseKey').value.trim();
            
            localStorage.setItem('supabaseUrl', url);
            localStorage.setItem('supabaseKey', key);
            
            await connectSupabase(url, key);
        });

        async function connectSupabase(url, key) {
            try {
                updateConnectionStatus('connecting', 'Connecting...');
                
                supabaseClient = window.supabase.createClient(url, key);
                
                // Test connection and setup table
                try {
                    await setupDatabase();
                } catch (dbError) {
                    console.error('Database setup error:', dbError);
                    throw new Error('Database setup failed: ' + dbError.message);
                }
                
                // Load employees from database
                try {
                    await loadEmployees();
                    console.log('Employees loaded from database');
                } catch (empError) {
                    console.error('Error loading employees:', empError);
                }

                // Load admin config (machines, products, materials)
                try {
                    await loadConfig();
                } catch (configError) {
                    console.error("Error loading config:", configError);
                }

                // Load batches
                try {
                    await loadBatches();
                    updateMachineDisplays(); // Load machine status
                    updateSuppliesButton(); // Load inventory levels
                } catch (loadError) {
                    console.error('Load batches error:', loadError);
                    throw new Error('Failed to load batches: ' + loadError.message);
                }
                
                // Setup realtime subscription
                setupRealtime();
                
                // Show app
                document.getElementById('setupSection').classList.add('hidden');
                document.getElementById('appContainer').classList.add('active');
                
                updateConnectionStatus('connected', 'Connected');
                
                // Initialize app
                initializeApp(); initializeTimeclock();

                // Re-check saved session now that employees are loaded from database
                const savedRole = localStorage.getItem('wmRole');
                const sessionTime = localStorage.getItem('wmSession');
                if (savedRole && sessionTime && (Date.now() - parseInt(sessionTime)) < 12 * 60 * 60 * 1000) {
                    if (ROLES[savedRole] && !currentRole) {
                        currentRole = ROLES[savedRole];
                        document.getElementById('pinInput').style.display = 'none';
                        document.getElementById('loginBtn').style.display = 'none';
                        document.getElementById('actionsMenu').style.display = 'block';
                        document.getElementById('userLogin').style.display = 'none';
                        document.getElementById('appContent').style.display = 'block';
                        document.getElementById('myStatsBtn').style.display = 'block';
                        document.getElementById('logoutBtn').style.display = 'block';
                        if(!currentRole.salary) document.getElementById('timeClockBtn').style.display = 'block';
                        const isAdminCheck = currentRole.isAdmin || currentRole.name.includes('Admin') || currentRole.name === 'Ryan' || currentRole.name === 'Alex';
                        if(isAdminCheck) {
                            document.getElementById('viewTimecardsBtn').style.display = 'block';
                            document.getElementById('manageEmployeesBtn').style.display = 'block'; document.getElementById('adminConfigBtn').style.display = 'block';
                            document.getElementById('loginHistoryBtn').style.display = 'block';
                            document.getElementById('viewTrashBtn').style.display = 'block';
                            document.getElementById('leaflinkApprovalsBtn').style.display = 'block';
                        }
                        document.getElementById('complianceBtn').style.display = 'block';
                        applyRolePermissions();
                        hidePINsForDemo();
                    }
                }
                
            } catch (error) {
                console.error('Connection error:', error);
                updateConnectionStatus('disconnected', 'Connection Failed');
                alert('Failed to connect to Supabase.\n\nError: ' + error.message + '\n\nPlease check:\n1. URL is correct (https://xxxxx.supabase.co)\n2. Anon key is correct\n3. Project is not paused');
            }
        }

        async function setupDatabase() {
            // Check if table exists by trying to query it
            const { data, error } = await supabaseClient
                .from('wm_batches')
                .select('id')
                .limit(1);
            
            if (error && error.code === '42P01') {
                // Table doesn't exist, create it
                console.log('Creating wm_batches table...');
                
                // We can't create tables via JS client, so show instructions
                const createTableSQL = `
CREATE TABLE wm_batches (
    id TEXT PRIMARY KEY,
    strain TEXT NOT NULL,
    strain_type TEXT NOT NULL,
    trim_weight DECIMAL(10,2) NOT NULL,
    material_cost DECIMAL(10,2) NOT NULL,
    material_agreement TEXT,
    cultivation_license TEXT NOT NULL,
    grower_name TEXT,
    metrc_tags TEXT,
    intake_date DATE NOT NULL,
    planned_products JSONB NOT NULL,
    intake_notes TEXT,
    status TEXT NOT NULL DEFAULT 'intake',
    intake_user TEXT NOT NULL,
    timeline JSONB NOT NULL DEFAULT '[]'::jsonb,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    -- Extraction fields
    extraction_date DATE,
    extraction_method TEXT,
    extraction_machine TEXT,
    extraction_runs INTEGER,
    extraction_slabs INTEGER,
    extraction_bowls INTEGER,
    extraction_notes TEXT,
    butane_used DECIMAL(10,2),
    nitrogen_tanks_used DECIMAL(5,2),
    product_made TEXT,
    crude_weight DECIMAL(10,2),
    extraction_user TEXT,
    extraction_yield DECIMAL(5,2),
    extraction_paused BOOLEAN DEFAULT FALSE,
    bulk_jars_count INTEGER,
    shatter_slabs_count INTEGER,
    sift_weight DECIMAL(10,2),
    adjusted_trim_weight DECIMAL(10,2),
    sift_sub_batch_created BOOLEAN DEFAULT FALSE,
    sift_sub_batch_id TEXT,
    parent_batch_id TEXT,
    is_sub_batch BOOLEAN DEFAULT FALSE,
    pre_sift TEXT,
    
    -- Finishing fields
    finishing_date DATE,
    final_weight DECIMAL(10,2),
    sample_weight DECIMAL(10,2),
    test_results_expected_date DATE,
    finishing_notes TEXT,
    finishing_user TEXT,
    net_weight DECIMAL(10,2),
    
    -- Test results fields
    test_results_received_date DATE,
    test_thc_percent DECIMAL(5,2),
    test_cbd_percent DECIMAL(5,2),
    test_lab_name TEXT,
    test_sample_id TEXT,
    test_results_notes TEXT,
    
    -- Packaging fields
    packaging_date DATE,
    packaged_product_type TEXT,
    units_packaged INTEGER,
    units_1g INTEGER,
    units_4g INTEGER,
    total_grams_packaged DECIMAL(10,2),
    packaging_breakdown TEXT,
    packaging_paused BOOLEAN DEFAULT FALSE,
    thc_percent DECIMAL(5,2),
    cbd_percent DECIMAL(5,2),
    ready_to_list TEXT,
    wholesale_price DECIMAL(10,2),
    leaflink_description TEXT,
    packaging_notes TEXT,
    packaging_user TEXT,
    
    -- Labeling fields
    labeling_paused BOOLEAN DEFAULT FALSE,
    
    completed_at TIMESTAMP WITH TIME ZONE
);

-- Enable realtime
ALTER PUBLICATION supabase_realtime ADD TABLE wm_batches;
                `;
                
                alert(`Please run this SQL in your Supabase SQL Editor:\n\n${createTableSQL}\n\nThen refresh this page.`);
                throw new Error('Table setup required');
            }
            
            // Get the highest batch number
            const { data: maxBatch } = await supabaseClient
                .from('wm_batches')
                .select('id')
                .order('id', { ascending: false })
                .limit(1);
            
            if (maxBatch && maxBatch.length > 0) {
                const lastId = maxBatch[0].id;
                const num = parseInt(lastId.split('-')[1]);
                batchCounter = num + 1;
            }
        }

        // Update pause button visibility and text based on current batch selection
        function updatePauseButtons() {
            // Update extraction pause button
            const extractionBatchId = document.getElementById('extractionBatchSelect')?.value;
            const extractionBatch = batches.find(b => b.id === extractionBatchId);
            const extractionPauseBtn = document.getElementById('pauseExtractionBtn');
            
            if (extractionPauseBtn && extractionBatch) {
                // Show button only if batch has been started (has extraction_method or timeline entry)
                const hasStarted = extractionBatch.extraction_method || 
                                  (extractionBatch.timeline || []).some(t => t.stage === 'extraction');
                
                if (hasStarted && extractionBatch.status === 'intake') {
                    extractionPauseBtn.style.display = 'block';
                    const isPaused = extractionBatch.extraction_paused || false;
                    extractionPauseBtn.innerHTML = isPaused ? 'â–¶ï¸ Resume' : 'â¸ï¸ Pause';
                    extractionPauseBtn.style.background = isPaused ? 'var(--accent-blue)' : 'var(--accent-orange)';
                } else {
                    extractionPauseBtn.style.display = 'none';
                }
            }
            
            // Update packaging pause button
            const packagingBatchId = document.getElementById('packagingBatchSelect')?.value;
            const packagingBatch = batches.find(b => b.id === packagingBatchId);
            const packagingPauseBtn = document.getElementById('pausePackagingBtn');
            
            if (packagingPauseBtn && packagingBatch) {
                const hasStarted = packagingBatch.product_type || 
                                  (packagingBatch.timeline || []).some(t => t.stage === 'packaging');
                
                if (hasStarted && packagingBatch.status === 'finishing') {
                    packagingPauseBtn.style.display = 'block';
                    const isPaused = packagingBatch.packaging_paused || false;
                    packagingPauseBtn.innerHTML = isPaused ? 'â–¶ï¸ Resume' : 'â¸ï¸ Pause';
                    packagingPauseBtn.style.background = isPaused ? 'var(--accent-blue)' : 'var(--accent-orange)';
                } else {
                    packagingPauseBtn.style.display = 'none';
                }
            }
            
            // Update labeling pause button
            const labelingBatchId = document.getElementById('labelingBatchSelect')?.value;
            const labelingBatch = batches.find(b => b.id === labelingBatchId);
            const labelingPauseBtn = document.getElementById('pauseLabelingBtn');
            
            if (labelingPauseBtn && labelingBatch) {
                const hasStarted = (labelingBatch.timeline || []).some(t => t.stage === 'labeling');
                
                if (hasStarted && labelingBatch.status === 'packaged') {
                    labelingPauseBtn.style.display = 'block';
                    const isPaused = labelingBatch.labeling_paused || false;
                    labelingPauseBtn.innerHTML = isPaused ? 'â–¶ï¸ Resume' : 'â¸ï¸ Pause';
                    labelingPauseBtn.style.background = isPaused ? 'var(--accent-blue)' : 'var(--accent-orange)';
                } else {
                    labelingPauseBtn.style.display = 'none';
                }
            }
        }

        // Admin helper to fix batch status (call from console: fixBatchStatus('9.30.5622', 'finishing'))
        window.fixBatchStatus = async function(batchId, newStatus) {
            if (!supabaseClient) {
                console.error('Supabase not connected');
                return;
            }
            const validStatuses = ['intake', 'extraction', 'finishing', 'packaging', 'complete'];
            if (!validStatuses.includes(newStatus)) {
                console.error('Invalid status. Use one of:', validStatuses);
                return;
            }
            const { error } = await supabaseClient
                .from('wm_batches')
                .update({ status: newStatus })
                .eq('id', batchId);
            if (error) {
                console.error('Error updating batch:', error);
            } else {
                console.log(`Batch ${batchId} status updated to "${newStatus}". Refreshing...`);
                await loadBatches();
                alert(`Batch ${batchId} status reset to "${newStatus}"`);
            }
        };
        
        // Admin helper to revert batch to testing status (call from console: revertToTesting('9.30.5622'))
        window.revertToTesting = async function(batchId) {
            if (!supabaseClient) {
                console.error('Supabase not connected');
                return;
            }
            const batch = batches.find(b => b.id === batchId);
            if (!batch) {
                console.error('Batch not found:', batchId);
                return;
            }
            const timeline = batch.timeline || [];
            timeline.push({
                stage: 'admin_revert',
                user: currentRole ? currentRole.name : 'Admin',
                date: new Date().toISOString(),
                action: 'Batch reverted to testing queue'
            });
            const { error } = await supabaseClient
                .from('wm_batches')
                .update({
                    status: 'packaging',
                    labels_applied: false,
                    labeling_date: null,
                    labeling_user: null,
                    labeling_notes: null,
                    completed_at: null,
                    timeline: timeline
                })
                .eq('id', batchId);
            if (error) {
                console.error('Error reverting batch:', error);
            } else {
                console.log('Batch ' + batchId + ' reverted to testing. Refreshing...');
                await loadBatches();
                alert('Batch ' + batchId + ' has been reverted to Testing queue');
            }
        };

        async function loadBatches() {
            // Use demo data if in demo mode
            if (isDemoMode()) {
                batches = generateDemoBatches();
                updateDashboard();
                renderBatches();
                updateSuppliesButton();
                updateMachineDisplays();

                if (!window.searchFiltersInitialized) {
                    setTimeout(() => {
                        addDropdownSearchFilters();
                        window.searchFiltersInitialized = true;
                    }, 500);
                }
                return;
            }

            const { data, error } = await supabaseClient
                .from('wm_batches')
                .select('*')
                .neq('status', 'deleted')
                .order('created_at', { ascending: false });

            if (error) {
                console.error('Error loading batches:', error);
                return;
            }

            batches = data || [];
            updateDashboard();
            renderBatches();
            renderWasteLog(); // Update waste log display
            updateSuppliesButton(); // Update supplies button display
            updateMachineDisplays(); // Update machine status displays

            // Initialize dropdown search filters (only once)
            if (!window.searchFiltersInitialized) {
                setTimeout(() => {
                    addDropdownSearchFilters();
                    window.searchFiltersInitialized = true;
                }, 500);
            }
        }

        function setupRealtime() {
            if (realtimeChannel) {
                realtimeChannel.unsubscribe();
            }
            
            realtimeChannel = supabaseClient
                .channel('wm_batches_changes')
                .on('postgres_changes',
                    { event: '*', schema: 'public', table: 'wm_batches' },
                    () => {
                        loadBatches(); // Reload on any change
                    }
                )
                .subscribe();
        }

        // Celebration function for completed tasks
        function showCelebration(options = {}) {
            // Remove any existing celebrations first
            document.querySelectorAll('.celebration-overlay').forEach(el => el.remove());
            document.querySelectorAll('.confetti-piece').forEach(el => el.remove());
            document.querySelectorAll('.laser-container').forEach(el => el.remove());
            document.querySelectorAll('.fire-container').forEach(el => el.remove());

            const {
                emoji = 'ðŸŽ‰',
                title = 'Great Job!',
                message = 'Task completed successfully!',
                stats = [],
                confettiCount = 50,
                laserCount = 8,
                showFire = true,
                buttonText = 'Awesome!'
            } = options;

            // Create confetti - neon laser colors
            const colors = ['#39ff14', '#0055ff', '#ff10f0', '#bf00ff', '#ff0055', '#ff6b00'];
            const shapes = ['square', 'circle'];

            for (let i = 0; i < confettiCount; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'confetti-piece';
                const color = colors[Math.floor(Math.random() * colors.length)];
                confetti.style.left = Math.random() * 100 + 'vw';
                confetti.style.background = color;
                confetti.style.boxShadow = `0 0 6px ${color}, 0 0 10px ${color}`;
                confetti.style.borderRadius = shapes[Math.floor(Math.random() * shapes.length)] === 'circle' ? '50%' : '2px';
                confetti.style.width = (Math.random() * 10 + 5) + 'px';
                confetti.style.height = (Math.random() * 10 + 5) + 'px';
                confetti.style.animationDuration = (Math.random() * 2 + 2) + 's';
                confetti.style.animationDelay = (Math.random() * 0.5) + 's';
                document.body.appendChild(confetti);

                // Remove confetti after animation
                setTimeout(() => confetti.remove(), 4500);
            }

            // Create laser show from top
            const laserContainer = document.createElement('div');
            laserContainer.className = 'laser-container';
            document.body.appendChild(laserContainer);

            const laserColors = ['#39ff14', '#0055ff', '#ff10f0', '#bf00ff', '#ff0055', '#ff6b00'];

            for (let i = 0; i < laserCount; i++) {
                const laser = document.createElement('div');
                laser.className = 'laser-beam';
                const color = laserColors[i % laserColors.length];
                laser.style.background = `linear-gradient(to bottom, ${color}, transparent 70%)`;
                laser.style.color = color;
                laser.style.boxShadow = `0 0 15px ${color}, 0 0 30px ${color}`;

                // Position lasers across the top, fanning out
                const spreadAngle = 120; // degrees of spread
                const startAngle = -spreadAngle / 2;
                const angleStep = spreadAngle / (laserCount - 1 || 1);
                const angle = startAngle + (i * angleStep);

                laser.style.left = `${10 + (i / laserCount) * 80}%`;
                laser.style.top = '0';
                laser.style.transformOrigin = 'top center';
                laser.style.transform = `rotate(${angle}deg)`;
                laser.style.animation = `laser-pulse ${0.8 + Math.random() * 0.4}s ease-in-out infinite`;

                // Sweep animation
                let currentAngle = angle;
                const sweepSpeed = (Math.random() - 0.5) * 4;
                const rotateInterval = setInterval(() => {
                    currentAngle += sweepSpeed;
                    // Bounce back at limits
                    if (currentAngle > 60 || currentAngle < -60) {
                        currentAngle = Math.max(-60, Math.min(60, currentAngle));
                    }
                    laser.style.transform = `rotate(${currentAngle}deg)`;
                }, 50);

                laserContainer.appendChild(laser);

                setTimeout(() => clearInterval(rotateInterval), 5000);
            }

            // Remove laser container after animation
            setTimeout(() => laserContainer.remove(), 5000);

            // Create fire cannons (if enabled)
            if (showFire) {
            const fireContainer = document.createElement('div');
            fireContainer.className = 'fire-container';
            document.body.appendChild(fireContainer);

            // Fire cannon positions (left and right corners, and center)
            const cannonPositions = [10, 50, 90];
            const fireColors = ['#ff6b00', '#ff0055', '#ffff00', '#ff10f0'];

            // Create base cannon glow
            cannonPositions.forEach(pos => {
                const cannon = document.createElement('div');
                cannon.className = 'fire-cannon';
                cannon.style.left = `${pos - 3}%`;
                fireContainer.appendChild(cannon);
                setTimeout(() => cannon.remove(), 3000);
            });

            // Shoot fire particles
            const shootParticles = () => {
                cannonPositions.forEach(pos => {
                    for (let i = 0; i < 5; i++) {
                        const particle = document.createElement('div');
                        particle.className = 'fire-particle';
                        const color = fireColors[Math.floor(Math.random() * fireColors.length)];
                        const size = 10 + Math.random() * 20;
                        particle.style.width = size + 'px';
                        particle.style.height = size + 'px';
                        particle.style.left = `${pos + (Math.random() - 0.5) * 10}%`;
                        particle.style.background = `radial-gradient(circle, ${color}, transparent)`;
                        particle.style.boxShadow = `0 0 ${size}px ${color}, 0 0 ${size * 2}px ${color}`;
                        particle.style.animationDuration = (0.8 + Math.random() * 0.5) + 's';
                        particle.style.animationDelay = (Math.random() * 0.1) + 's';
                        fireContainer.appendChild(particle);

                        setTimeout(() => particle.remove(), 1500);
                    }
                });
            };

            // Shoot multiple bursts
            shootParticles();
            setTimeout(shootParticles, 300);
            setTimeout(shootParticles, 600);
            setTimeout(shootParticles, 900);
            setTimeout(shootParticles, 1200);

            // Remove fire container after animation
            setTimeout(() => fireContainer.remove(), 3000);
            }

            // Build stats HTML
            let statsHtml = '';
            if (stats.length > 0) {
                statsHtml = `<div class="celebration-stats">
                    ${stats.map(s => `
                        <div class="celebration-stat">
                            <div class="celebration-stat-value">${s.value}</div>
                            <div class="celebration-stat-label">${s.label}</div>
                        </div>
                    `).join('')}
                </div>`;
            }

            // Create celebration overlay
            const overlay = document.createElement('div');
            overlay.className = 'celebration-overlay';
            overlay.innerHTML = `
                <div class="celebration-content">
                    <div class="celebration-emoji">${emoji}</div>
                    <div class="celebration-title">${title}</div>
                    <div class="celebration-message">${message}</div>
                    ${statsHtml}
                    <button class="celebration-btn" onclick="this.closest('.celebration-overlay').remove()">
                        ${buttonText}
                    </button>
                </div>
            `;
            document.body.appendChild(overlay);

            // Auto-close after 10 seconds
            setTimeout(() => {
                if (overlay.parentNode) overlay.remove();
            }, 10000);

            // Close on overlay click (not content)
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) overlay.remove();
            });
        }

        function updateConnectionStatus(status, text) {
            const statusEl = document.getElementById('connectionStatus');
            const textEl = document.getElementById('statusText');
            
            statusEl.className = `connection-status ${status}`;
            textEl.textContent = text;
        }

        // PIN Login
        function login() {
            const pin = document.getElementById('pinInput').value;
            const errorMsg = document.getElementById('loginError');
            
            if (pin.length !== 4) {
                errorMsg.textContent = 'Please enter a 4-digit PIN';
                errorMsg.style.display = 'block';
                setTimeout(() => errorMsg.style.display = 'none', 3000);
                return;
            }
            
            // Find role by PIN
            const roleKey = Object.keys(ROLES).find(key => ROLES[key].pin === pin);
            
            if (roleKey) {
                // Successful login
                currentRole = ROLES[roleKey];
                localStorage.setItem('wmRole', roleKey);
                const sessionId = Date.now();
                localStorage.setItem('wmSession', sessionId);
                localStorage.setItem('wmSessionId', sessionId); // Store session ID for logout tracking
                
                document.getElementById('pinInput').style.display = 'none';
                document.getElementById('loginBtn').style.display = 'none';
                document.getElementById('actionsMenu').style.display = 'block';
                document.getElementById('userLogin').style.display = 'none';
                document.getElementById('appContent').style.display = 'block';
                document.getElementById('myStatsBtn').style.display = 'block'; document.getElementById('logoutBtn').style.display = 'block'; if(!currentRole.salary){document.getElementById('timeClockBtn').style.display = 'block';} const isAdmin = currentRole.isAdmin || currentRole.name.includes('Admin') || currentRole.name === 'Ryan' || currentRole.name === 'Alex'; if(isAdmin){document.getElementById('viewTimecardsBtn').style.display = 'block'; document.getElementById('manageEmployeesBtn').style.display = 'block'; document.getElementById('adminConfigBtn').style.display = 'block'; document.getElementById('loginHistoryBtn').style.display = 'block'; document.getElementById('viewTrashBtn').style.display = 'block';}
                errorMsg.style.display = 'none';

                // Log login to database with IP (including demo mode)
                    // Fetch IP address and log login
                    console.log('Attempting to fetch IP...');
                    fetch('https://api.ipify.org?format=json')
                        .then(r => r.json())
                        .then(ipData => {
                            console.log('Got IP:', ipData.ip);
                            return supabaseClient
                                .from('wm_login_history')
                                .insert({
                                    user_name: currentRole.name,
                                    login_time: new Date().toISOString(),
                                    ip_address: ipData.ip
                                })
                                .select();
                        })
                        .then(({ data, error }) => {
                            console.log('Login insert result:', { data, error });
                            if (error) {
                                console.error('Error logging login:', error);
                            } else if (data && data.length > 0) {
                                // Store the login record ID for logout tracking
                                localStorage.setItem('wmLoginRecordId', data[0].id);
                            }
                        })
                        .catch(err => {
                            // If IP fetch fails, log without IP
                            console.error('IP FETCH FAILED:', err);
                            supabaseClient
                                .from('wm_login_history')
                                .insert({
                                    user_name: currentRole.name,
                                    login_time: new Date().toISOString()
                                })
                                .select()
                                .then(({ data, error }) => {
                                    if (!error && data && data.length > 0) {
                                        localStorage.setItem('wmLoginRecordId', data[0].id);
                                    }
                                });
                        });

                // Start activity tracking - update last_activity every 30 seconds when user is active
                startActivityTracking();

                applyRolePermissions();
                hidePINsForDemo(); // Hide PINs if in demo mode

                // Welcome celebration with random messages
                const welcomeMessages = [
                    // Original messages
                    "Ready to crush it today? Let's get to work!",
                    "Time to make some magic happen! âœ¨",
                    "Another day, another dab! ðŸ’¨",
                    "May your yields be high and your temps be low! ðŸŒ¡ï¸",
                    "Time to turn trim into triumph! ðŸ†",
                    // Movie quotes
                    "I'm kind of a big deal. â€” Anchorman",
                    "That's what she said. â€” The Office",
                    "I'm not even supposed to be here today! â€” Clerks",
                    "Alright, alright, alright. â€” Dazed and Confused",
                    "I'm gonna need you to come in on Saturday. â€” Office Space",
                    "So you're telling me there's a chance? â€” Dumb and Dumber",
                    "The Dude abides. â€” The Big Lebowski",
                    "Did we just become best friends?! â€” Step Brothers",
                    "Life moves pretty fast. If you don't stop and look around once in a while, you could miss it. â€” Ferris Bueller",
                    "I've got a fever, and the only prescription is more cowbell! â€” SNL",
                    "It's showtime! â€” Beetlejuice",
                    "Be excellent to each other. â€” Bill & Ted",
                    "You're gonna need a bigger boat. â€” Jaws",
                    "I ain't afraid of no ghosts! â€” Ghostbusters",
                    "Cinderella story, outta nowhere! â€” Caddyshack",
                    "How do you like them apples? â€” Good Will Hunting",
                    "I'm walkin' here! â€” Midnight Cowboy",
                    "You had me at hello. â€” Jerry Maguire",
                    "Just keep swimming. â€” Finding Nemo",
                    "To infinity and beyond! â€” Toy Story"
                ];
                const welcomeButtons = [
                    "Hell yes!",
                    "Let's gooo!",
                    "I'm ready!",
                    "Heck yeah!",
                    "Let's crush it!",
                    "Born ready!",
                    "LFG! ðŸš€",
                    "Oh yeahhh!",
                    "Groovy!",
                    "Excellent!",
                    "Alrighty then!",
                    "I'm on it!",
                    "Let's do this!",
                    "Party on!",
                    "Cowabunga!"
                ];
                const randomMessage = welcomeMessages[Math.floor(Math.random() * welcomeMessages.length)];
                const randomButton = welcomeButtons[Math.floor(Math.random() * welcomeButtons.length)];

                showCelebration({
                    emoji: 'ðŸ‘‹',
                    title: `Welcome, ${currentRole.name}!`,
                    message: randomMessage,
                    stats: [],
                    confettiCount: 0,
                    laserCount: 24,
                    showFire: false,
                    buttonText: randomButton
                });
            } else {
                // Failed login
                errorMsg.textContent = 'Invalid PIN. Please try again.';
                errorMsg.style.display = 'block';
                document.getElementById('pinInput').value = '';
                setTimeout(() => errorMsg.style.display = 'none', 3000);
            }
        }

        function logout() {
            // Hide actions menu
            document.getElementById('actionsMenu').style.display = 'none';

            // Cleanup realtime subscription
            if (realtimeChannel) {
                realtimeChannel.unsubscribe();
                realtimeChannel = null;
            }

            const loginRecordId = localStorage.getItem('wmLoginRecordId');
            const sessionStart = parseInt(localStorage.getItem('wmSession'));

            const clearAndReload = () => {
                localStorage.removeItem('wmRole');
                localStorage.removeItem('wmSession');
                localStorage.removeItem('wmSessionId');
                localStorage.removeItem('wmLoginRecordId');
                location.reload();
            };

            if (loginRecordId && sessionStart) {
                const sessionDuration = Math.floor((Date.now() - sessionStart) / 1000 / 60); // minutes

                // Update logout time and duration
                supabaseClient
                    .from('wm_login_history')
                    .update({
                        logout_time: new Date().toISOString(),
                        session_duration: sessionDuration
                    })
                    .eq('id', loginRecordId)
                    .then(clearAndReload)
                    .catch(err => {
                        console.error('Logout update failed:', err);
                        clearAndReload();
                    });
            } else {
                clearAndReload();
            }
        }

        // Activity tracking - updates last_activity timestamp when user interacts
        let lastActivityUpdate = 0;
        let activityTimeout = null;

        function startActivityTracking() {
            // Track user activity on clicks and key presses
            document.addEventListener('click', recordActivity);
            document.addEventListener('keypress', recordActivity);
            document.addEventListener('touchstart', recordActivity);

            // Also update every 30 seconds if there's been any activity
            setInterval(() => {
                if (Date.now() - lastActivityUpdate < 60000) { // Activity in last minute
                    updateLastActivity();
                }
            }, 30000);
        }

        function recordActivity() {
            lastActivityUpdate = Date.now();
            // Debounce - only actually update DB every 30 seconds max
            if (!activityTimeout) {
                activityTimeout = setTimeout(() => {
                    updateLastActivity();
                    activityTimeout = null;
                }, 5000); // Wait 5 seconds of inactivity before updating
            }
        }

        function updateLastActivity() {
            const loginRecordId = localStorage.getItem('wmLoginRecordId');
            if (!loginRecordId || !supabaseClient) return;

            supabaseClient
                .from('wm_login_history')
                .update({ last_activity: new Date().toISOString() })
                .eq('id', loginRecordId)
                .then(() => {})
                .catch(err => console.log('Activity update failed:', err));
        }

        // Close mobile station popup and return to app grid
        function closeMobileStation() {
            document.querySelectorAll('.station-content').forEach(c => c.classList.remove('active'));
            document.querySelectorAll('.station-tab').forEach(t => t.classList.remove('active'));
        }

        // Swipe gesture detection for mobile navigation
        (function initSwipeGestures() {
            let touchStartX = 0;
            let touchStartY = 0;
            let touchEndX = 0;
            let touchEndY = 0;

            document.addEventListener('touchstart', function(e) {
                touchStartX = e.changedTouches[0].screenX;
                touchStartY = e.changedTouches[0].screenY;
            }, { passive: true });

            document.addEventListener('touchend', function(e) {
                touchEndX = e.changedTouches[0].screenX;
                touchEndY = e.changedTouches[0].screenY;
                handleSwipe();
            }, { passive: true });

            function handleSwipe() {
                const diffX = touchEndX - touchStartX;
                const diffY = touchEndY - touchStartY;
                const minSwipeDistance = 100;

                // Only trigger if horizontal swipe is dominant
                if (Math.abs(diffX) > Math.abs(diffY)) {
                    // Swipe right to go back
                    if (diffX > minSwipeDistance) {
                        const activeStation = document.querySelector('.station-content.active');
                        if (activeStation && window.innerWidth <= 768) {
                            closeMobileStation();
                        }
                    }
                }
            }
        })();

        function applyRolePermissions() {
            if (!currentRole) return;
            
            // Show/hide tabs based on role
            document.querySelectorAll('.station-tab').forEach(tab => {
                const station = tab.dataset.station;
                if (currentRole.tabs.includes(station)) {
                    tab.style.display = '';
                } else {
                    tab.style.display = 'none';
                }
            });
            
            // Show first available tab (skip on mobile - let user pick from app grid)
            const isMobile = window.innerWidth <= 768;
            if (!isMobile) {
                const firstTab = document.querySelector('.station-tab[style=""]') || document.querySelector('.station-tab:not([style*="display: none"])');
                if (firstTab) {
                    firstTab.click();
                }
            }
        }

        // Station tabs
        document.querySelectorAll('.station-tab').forEach(tab => {
            tab.addEventListener('click', function() {
                const station = this.dataset.station;
                
                document.querySelectorAll('.station-tab').forEach(t => t.classList.remove('active'));
                this.classList.add('active');
                
                document.querySelectorAll('.station-content').forEach(c => c.classList.remove('active'));
                document.getElementById(station).classList.add('active');
                
                // Scroll to top when opening station on mobile
                window.scrollTo(0, 0);

                if (station === 'dashboard') {
                    updateDashboard();
                    renderBatches();
                    renderWasteLog();
                } else if (station === 'analytics') {
                    updateAnalytics();
                } else if (station === 'performance') {
                    renderPerformanceAnalytics();
                } else if (station === 'extraction') {
                    populateExtractionQueue();
                } else if (station === 'finishing') {
                    populateFinishingSelect();
                } else if (station === 'packaging') {
                    populatePackagingSelect();
                } else if (station === 'testing') {
                    populateTestingSelect();
                    checkRTAStatus();
                } else if (station === 'labeling') {
                    populateLabelingSelect();
                } else if (station === 'frontofhouse') {
                    loadFOHRecentBatches();
                    loadFOHPosts();
                    loadSalesDashboard();
                }
            });
        });

        // Intake form submission
        document.getElementById('intakeForm').addEventListener('submit', async function(e) {
            e.preventDefault();
            
            if (!currentRole) {
                alert('Please select a user first!');
                return;
            }

            const products = Array.from(document.querySelectorAll('input[name="products"]:checked'))
                .map(cb => cb.value);
            
            if (products.length === 0) {
                alert('Please select at least one planned product!');
                return;
            }
            
            // Validate pre-sift requires hash products
            const preSift = document.getElementById('preSift').value;
            if (preSift === 'yes') {
                const hasHashProducts = products.some(p => p === 'Brick Hash' || p === 'Hash Hits');
                if (!hasHashProducts) {
                    alert('Pre-sift requires at least one hash product!\n\nPlease select:\nâ€¢ Brick Hash, or\nâ€¢ Hash Hits, or\nâ€¢ Both');
                    return;
                }
            }
            
            const trimWeight = parseFloat(document.getElementById('trimWeight').value);
            const socksTotal = parseInt(document.getElementById('socksTotal').value) || 1;
            const trimPerSock = trimWeight / socksTotal;

            // Auto-detect material type based on Live Resin product selection
            const selectedProducts = Array.from(document.querySelectorAll('input[name="products"]:checked')).map(cb => cb.value);
            const isLiveResin = selectedProducts.some(p => p.includes('Live Resin'));
            const materialType = isLiveResin ? 'Fresh Frozen' : 'Trim';
            // Build strain name with product type(s)
            const baseStrainName = document.getElementById('strainName').value;
            const productSuffix = products.length > 0 ? ' ' + products.join('/') : '';
            const fullStrainName = baseStrainName + productSuffix;

            const batch = {
                id: `WM-${batchCounter}`,
                strain: fullStrainName,
                strain_type: document.getElementById('strainType').value,
                material_type: materialType,
                expected_yield: getExpectedYield(materialType),
                trim_weight: trimWeight,
                socks_total: socksTotal,
                socks_remaining: socksTotal,
                trim_per_sock: trimPerSock,
                material_cost: parseFloat(document.getElementById('materialCost').value),
                material_agreement: document.getElementById('materialAgreement').value,
                pre_sift: document.getElementById('preSift').value,
                cultivation_license: document.getElementById('cultivationLicense').value,
                grower_name: document.getElementById('growerName').value || document.getElementById('cultivationLicense').value,
                metrc_tags: document.getElementById('metrcTags').value || null,
                intake_date: document.getElementById('intakeDate').value,
                planned_products: products,
                intake_notes: document.getElementById('intakeNotes').value,
                status: 'intake',
                intake_user: currentRole ? currentRole.name : "Unknown",
                parent_batch_id: null,
                is_sub_batch: false,
                timeline: [{
                    stage: 'intake',
                    user: currentRole ? currentRole.name : "Unknown",
                    date: new Date().toISOString(),
                    action: `Batch created - ${document.getElementById('materialAgreement').value} - ${socksTotal} socks - Cultivated by ${document.getElementById('cultivationLicense').value}`
                }],
                created_at: new Date().toISOString()
            };
            
            const { error } = await supabaseClient
                .from('wm_batches')
                .insert([batch]);
            
            if (error) {
                console.error('Error creating batch:', error);
                alert('Error creating batch. Please try again.');
                return;
            }
            
            batchCounter++;
            
            // Auto-print batch tracking label
            printIntakeBatchLabel(batch);
            
            // Save fields we want to keep after reset
            const savedLicense = document.getElementById('cultivationLicense').value;
            const savedGrowerName = document.getElementById('growerName').value;
            const savedIntakeDate = document.getElementById('intakeDate').value;
            
            // Reset form
            this.reset();
            
            // Restore saved fields
            document.getElementById('cultivationLicense').value = savedLicense;
            document.getElementById('growerName').value = savedGrowerName;
            document.getElementById('intakeDate').value = savedIntakeDate;
            
            // Update batch ID for next submission
            document.getElementById('batchId').value = `WM-${batchCounter}`;
            
            await loadBatches();
        });

        // Test print batch label with current form data (no batch creation)
        function testPrintBatchLabel() {
            // Gather data from form - using correct field IDs
            const batchId = document.getElementById('batchId')?.value || 'WM-TEST';
            const strain = document.getElementById('strainName')?.value || 'Test Strain';
            const strainType = document.getElementById('strainType')?.value || 'Hybrid';
            const trimWeight = document.getElementById('trimWeight')?.value || '100';
            const intakeDate = document.getElementById('intakeDate')?.value || new Date().toISOString().split('T')[0];
            const cultivationLicense = document.getElementById('cultivationLicense')?.value || '403R-01007';
            const materialAgreement = document.getElementById('materialAgreement')?.value || 'Wholesale';
            
            // Get planned products
            const checkboxes = document.querySelectorAll('input[name="products"]:checked');
            const products = Array.from(checkboxes).map(cb => ({ type: cb.value }));
            
            // Create test batch object
            const testBatch = {
                id: batchId,
                strain: strain,
                strain_type: strainType,
                trim_weight: trimWeight,
                intake_date: intakeDate,
                cultivation_license: cultivationLicense,
                material_agreement: materialAgreement,
                planned_products: products
            };
            
            // Print directly to static IP
            printIntakeLabelDirectly(testBatch);
        }

        // Print directly to Zebra printer via IP
        async function printIntakeLabelDirectly(batch) {
            const printerIP = '10.1.10.95';
            const zpl = generateIntakeBatchLabelZPL(batch);

            try {
                await fetch(`http://${printerIP}:9100`, {
                    method: 'POST',
                    mode: 'no-cors',
                    body: zpl
                });
                console.log(`Label sent to printer: ${batch.id}`);
            } catch (error) {
                console.error('Print error:', error);
            }
        }

        // Download ZPL file for intake label
        function downloadIntakeLabelZPL(batch) {
            const zpl = generateIntakeBatchLabelZPL(batch);
            
            // Create blob and download
            const blob = new Blob([zpl], { type: 'text/plain' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `batch-label-${batch.id}.zpl`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
            
            alert(`ZPL file downloaded: batch-label-${batch.id}.zpl\n\nTo print:\n1. Open Zebra Setup Utilities\n2. Go to Tools â†’ Send File\n3. Select the .zpl file\n4. Click Send`);
        }

        // Print label from Testing page - direct IP printing
        window.printTestingLabel = async function() {
            const batchId = document.getElementById('testingBatchSelect').value;
            if (!batchId) {
                alert('Please select a batch first!');
                return;
            }

            const batch = batches.find(b => b.id === batchId);
            if (!batch) {
                alert('Batch not found!');
                return;
            }

            const labelType = document.getElementById('testingLabelType').value;
            let zpl = '';

            if (labelType === 'intake') {
                zpl = generateIntakeBatchLabelZPL(batch);
            } else if (labelType === 'postprod') {
                const finalWeight = parseFloat(batch.final_weight) || parseFloat(batch.net_weight) || 0;
                const sampleWeight = parseFloat(batch.sample_weight) || 0;
                zpl = generatePostProductionLabelZPL(batch, finalWeight, sampleWeight);
            } else if (labelType === 'labeling') {
                const labeledBy = currentRole ? currentRole.name : 'Test User';
                zpl = generateLabelingCompletionZPL(batch, labeledBy);
            }

            // Print directly to Zebra IP
            const printerIP = '10.1.10.95';
            try {
                await fetch(`http://${printerIP}:9100`, {
                    method: 'POST',
                    mode: 'no-cors',
                    body: zpl
                });
                alert(`âœ… Label sent to printer!`);
            } catch (error) {
                console.error('Print error:', error);
                alert('Print error - check console');
            }
        }

        // Print labeling completion label with alert (for testing)
        async function printLabelingCompletionLabelWithAlert(batch, labeledBy) {
            const printerIP = '10.1.10.95';
            const zpl = generateLabelingCompletionZPL(batch, labeledBy);

            try {
                await fetch(`http://${printerIP}:9100`, {
                    method: 'POST',
                    mode: 'no-cors',
                    body: zpl
                });
                alert(`âœ… Label sent to printer!\n\nBatch: ${batch.id}\nStrain: ${batch.strain || 'Unknown'}\nTotal Units: ${batch.units_packaged || 0}\n1g: ${batch.units_1g || 0}  |  4g: ${batch.units_4g || 0}`);
            } catch (error) {
                console.error('Print error:', error);
                alert('Print error - check console for details');
            }
        }

        // Print post-production label directly to Zebra IP
        async function printPostProductionLabelDirectly(batch, finalWeight, sampleWeight) {
            const printerIP = '10.1.10.95';
            const zpl = generatePostProductionLabelZPL(batch, finalWeight, sampleWeight);

            try {
                await fetch(`http://${printerIP}:9100`, {
                    method: 'POST',
                    mode: 'no-cors',
                    body: zpl
                });
                alert(`âœ… Post-production label sent to printer!\n\nBatch: ${batch.id}`);
            } catch (error) {
                console.error('Print error:', error);
                alert('Print error - check console for details');
            }
        }

        // Generate ZPL for labeling completion label (4" x 2" landscape)
        function generateLabelingCompletionZPL(batch, labeledBy) {
            // 4" x 2" label at 203dpi = 812 x 406 dots
            const width = 812;
            const height = 406;

            // Get data
            const strainName = (batch.strain || batch.strain_name || 'Unknown').toUpperCase();
            const batchId = batch.id || '';
            const totalUnits = batch.units_packaged || 0;
            const units1g = batch.units_1g || 0;
            const units4g = batch.units_4g || 0;
            const handler = labeledBy || 'Unknown';
            const gramsLabeled = batch.grams_labeled || batch.total_grams_packaged || 0;

            // Material agreement
            let agreement = batch.material_agreement || 'Wholesale';
            if (agreement === '50-50 Split') agreement = '50/50 Split';
            if (agreement === 'Custom Buyback') agreement = 'Buyback';

            // Grower info
            const license = batch.cultivation_license || '';
            const growerName = batch.grower_name || '';

            // Date
            const today = new Date().toLocaleDateString('en-US', { month: '2-digit', day: '2-digit', year: '2-digit' });

            const zpl = `^XA
^MMT
^PW${width}
^LL${height}
^LS0
^LT-100
~SD25

^FO0,0^GB${width},${height},4^FS

^FO15,15^GB250,70,70^FS
^CF0,30
^FO25,35^FR^FD LABELING COMPLETE ^FS

^CF0,40
^FO15,100^FD${strainName.substring(0, 28)}^FS

^CF0,28
^FO15,150^FDBatch: ${batchId}^FS

^FO0,190^GB${width},3,3^FS

^CF0,60
^FO15,210^FD${totalUnits} UNITS^FS

^CF0,32
^FO250,215^FD1g: ${units1g}^FS
^FO400,215^FD4g: ${units4g}^FS
^FO550,215^FD${parseFloat(gramsLabeled).toFixed(1)}g^FS

^FO0,280^GB${width},3,3^FS

^CF0,24
^FO15,295^FDLabeled by: ${handler.substring(0, 15)}^FS
^FO300,295^FD${agreement}^FS
^FO550,295^FD${today}^FS

^CF0,22
^FO15,340^FDGrower: ${license}^FS
${growerName ? `^FO300,340^FD${growerName.substring(0, 30)}^FS` : ''}

^XZ`;

            return zpl;
        }

        // Print labeling completion label directly to Zebra IP
        async function printLabelingCompletionLabel(batch, labeledBy) {
            const printerIP = '10.1.10.95';
            const zpl = generateLabelingCompletionZPL(batch, labeledBy);

            try {
                await fetch(`http://${printerIP}:9100`, {
                    method: 'POST',
                    mode: 'no-cors',
                    body: zpl
                });
                console.log('Labeling completion label sent to printer');
            } catch (error) {
                console.error('Print error for labeling completion:', error);
            }
        }

        // Open printable intake batch label
        function openPrintableIntakeLabel(batch) {
            // Format date
            const date = new Date(batch.intake_date).toLocaleDateString('en-US', {month: '2-digit', day: '2-digit', year: 'numeric'});
            
            // Get planned products as string
            let plannedProducts = 'See notes';
            if (batch.planned_products && batch.planned_products.length > 0) {
                plannedProducts = batch.planned_products.join(', ');
            }

            // Truncate products if too long
            if (plannedProducts.length > 20) {
                plannedProducts = plannedProducts.substring(0, 17) + '...';
            }
            
            // Create popup window
            const popup = window.open('', 'PrintIntakeLabel', 'width=700,height=600');
            popup.document.write(`
<!DOCTYPE html>
<html>
<head>
    <title>Print Batch Label - ${batch.id}</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        @page {
            size: 2in 1.5in landscape;
            margin: 0mm;
        }
        
        @media print {
            html, body {
                width: 2in;
                height: 1.5in;
                margin: 0;
                padding: 0;
            }
            
            .no-print {
                display: none !important;
            }
            
            .page-wrapper {
                width: 2in;
                height: 1.5in;
                position: relative;
                page-break-after: avoid;
            }
            
            .batch-label {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
            }
        }
        
        body {
            font-family: Arial, sans-serif;
            background: #f0f0f0;
            padding: 20px;
        }
        
        .no-print {
            background: white;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            text-align: center;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
        }
        
        .no-print h1 {
            margin: 0 0 10px 0;
            color: #333;
            font-size: 20px;
        }
        
        .no-print button {
            background: #9333ea;
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 16px;
            border-radius: 6px;
            cursor: pointer;
            margin: 5px;
        }
        
        .no-print button:hover {
            background: #7c2db8;
        }
        
        .page-wrapper {
            width: 2in;
            height: 1.5in;
            margin: 0 auto;
            background: white;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        .batch-label {
            width: 100%;
            height: 100%;
            border: 3px solid #000;
            padding: 8px;
            display: flex;
            flex-direction: column;
        }
        
        .strain-name {
            font-size: 20pt;
            font-weight: bold;
            text-align: left;
            line-height: 0.9;
            text-transform: uppercase;
            border-bottom: 2px solid #000;
            padding-bottom: 2px;
            margin-bottom: 2px;
        }
        
        .batch-id {
            font-size: 16pt;
            font-weight: bold;
            text-align: left;
            border-bottom: 2px solid #000;
            padding: 2px 0;
            margin-bottom: 4px;
        }
        
        .details-row {
            display: grid;
            grid-template-columns: 0.9in 1.1in;
            gap: 0;
            font-size: 8pt;
            line-height: 1.4;
            flex: 1;
        }
        
        .left-col, .right-col {
            text-align: left;
        }
        
        .details-row div {
            margin: 0.5px 0;
        }
    </style>
</head>
<body>
    <div class="no-print">
        <h1>Intake Batch Label - ${batch.id}</h1>
        <p>Size: 2" Ã— 1.5" (Horizontal)</p>
        <div style="background: #fff3cd; padding: 10px; border-radius: 5px; margin: 10px 0; border-left: 4px solid #ff9800;">
            <strong>âš ï¸ Important Print Settings:</strong>
            <ol style="text-align: left; margin: 10px 0 0 20px;">
                <li>In print dialog, click "More settings"</li>
                <li>Set <strong>Margins</strong> to "None"</li>
                <li>Set <strong>Scale</strong> to "Default" (100%)</li>
                <li>Uncheck "Headers and footers"</li>
                <li>Make sure orientation is <strong>Landscape</strong></li>
            </ol>
        </div>
        <button onclick="window.print()">ðŸ–¨ï¸ Print Label</button>
        <button onclick="window.close()">Close</button>
    </div>
    
    <div class="page-wrapper">
        <div class="batch-label">
            <div class="strain-name">${batch.strain.toUpperCase()}</div>
            <div class="batch-id">BATCH: ${batch.id}</div>
            <div class="details-row">
                <div class="left-col">
                    <div><strong>Type:</strong> ${batch.strain_type}</div>
                    <div><strong>Weight:</strong> ${batch.trim_weight}g</div>
                    <div><strong>Date:</strong> ${date}</div>
                </div>
                <div class="right-col">
                    <div><strong>Grower:</strong></div>
                    <div>${batch.cultivation_license}</div>
                    <div><strong>Products:</strong></div>
                    <div>${plannedProducts}</div>
                </div>
            </div>
        </div>
    </div>
</body>
</html>
            `);
            popup.document.close();
        }

        // Generate ZPL for intake batch tracking label (4" x 2" landscape)
        function generateIntakeBatchLabelZPL(batch) {
            // 4" x 2" label at 203dpi = 812 x 406 dots
            const width = 812;
            const height = 406;

            // Format date
            const date = new Date(batch.intake_date).toLocaleDateString('en-US', {month: '2-digit', day: '2-digit', year: 'numeric'});

            // Get planned products as string
            let plannedProducts = 'See notes';
            if (batch.planned_products && batch.planned_products.length > 0) {
                if (Array.isArray(batch.planned_products)) {
                    plannedProducts = batch.planned_products.map(p => typeof p === 'object' ? p.type : p).join(', ');
                } else {
                    plannedProducts = batch.planned_products;
                }
            }

            // Material agreement
            let agreement = batch.material_agreement || 'Wholesale';
            if (agreement === '50-50 Split') agreement = '50/50 Split';
            if (agreement === 'Custom Buyback') agreement = 'Buyback';

            // Grower info
            const growerName = batch.grower_name || '';

            const zpl = `^XA
^MMT
^PW${width}
^LL${height}
^LS0
^LT-100
~SD20

^CF0,35
^FO20,20^FDINTAKE^FS

^CF0,45
^FO20,70^FD${(batch.strain || 'Unknown').toUpperCase().substring(0, 25)}^FS

^CF0,30
^FO20,130^FDBatch: ${batch.id}^FS
^FO400,130^FD${batch.strain_type || 'Hybrid'}^FS

^CF0,50
^FO20,180^FD${batch.trim_weight}g^FS
^CF0,25
^FO20,240^FDTRIM WEIGHT^FS

^CF0,25
^FO400,180^FDDate: ${date}^FS
^FO400,220^FDGrower: ${batch.cultivation_license || 'N/A'}^FS
^FO400,260^FD${agreement}^FS

^CF0,22
^FO20,300^FDProducts: ${plannedProducts.substring(0, 40)}^FS
${growerName ? `^FO20,340^FD${growerName.substring(0, 40)}^FS` : ''}

^XZ`;

            return zpl;
        }

        // Print intake batch tracking label
        async function printIntakeBatchLabel(batch) {
            console.log('printIntakeBatchLabel called for:', batch.id);
            const zpl = generateIntakeBatchLabelZPL(batch);

            // Try print server first
            const printServerURL = localStorage.getItem('printServerURL') || 'http://localhost:3000/print';

            try {
                const response = await fetch(printServerURL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ zpl: zpl })
                });

                if (response.ok) {
                    console.log('Label sent via print server');
                    return;
                }
            } catch (error) {
                console.log('Print server error:', error.message);
            }

            // Fallback to Browser Print
            if (window.BrowserPrint) {
                try {
                    const printer = await window.BrowserPrint.getDefaultDevice('printer');
                    printer.send(zpl, undefined, (error) => {
                        if (error) {
                            openPrintableIntakeLabel(batch);
                        }
                    });
                } catch (error) {
                    openPrintableIntakeLabel(batch);
                }
            } else {
                // No direct print - open printable view
                openPrintableIntakeLabel(batch);
            }
        }

        // Generate ZPL for post-production label (4" x 2" landscape)
        function generatePostProductionLabelZPL(batch, finalWeight, sampleWeight) {
            // 4" x 2" label at 203dpi = 812 x 406 dots
            const width = 812;
            const height = 406;

            // Get product name and batch ID
            const productName = (batch.strain || 'Unknown').toUpperCase();
            const batchId = batch.id || '';

            // Weights
            const trimWeight = parseFloat(batch.trim_weight) || 0;
            const finalWt = parseFloat(finalWeight) || 0;
            const sampleWt = parseFloat(sampleWeight) || 0;

            // Calculate yield
            const yieldPercent = trimWeight > 0 ? ((finalWt / trimWeight) * 100).toFixed(1) : '0.0';

            // METRC tags
            let metrcTags = batch.metrc_tags || '';
            if (metrcTags.length > 35) {
                metrcTags = metrcTags.substring(0, 32) + '...';
            }

            // Source contributions for partial tag info
            let partialInfo = '';
            let sourceContributions = batch.source_contributions || [];
            if (typeof sourceContributions === 'string') {
                try { sourceContributions = JSON.parse(sourceContributions); } catch(e) { sourceContributions = []; }
            }
            if (sourceContributions.length > 0) {
                const firstSource = sourceContributions[0];
                const trimUsed = parseFloat(firstSource.trim_weight) || 0;
                partialInfo = `${firstSource.batch_id} (${trimUsed.toFixed(0)}g)`;
                if (sourceContributions.length > 1) {
                    partialInfo += ` +${sourceContributions.length - 1}`;
                }
            }

            // Agreement type
            let agreement = batch.material_agreement || 'Wholesale';
            if (agreement === '50-50 Split') agreement = '50/50 Split';
            if (agreement === 'Custom Buyback') agreement = 'Buyback';

            // Grower info
            const license = batch.cultivation_license || '';
            const growerName = batch.grower_name || '';

            // Date
            const today = new Date().toLocaleDateString('en-US', { month: '2-digit', day: '2-digit', year: '2-digit' });

            const zpl = `^XA
^MMT
^PW${width}
^LL${height}
^LS0
^LT-100
~SD25

^FO0,0^GB${width},${height},4^FS

^FO15,15^GB280,70,70^FS
^CF0,30
^FO25,35^FR^FD POST-PRODUCTION ^FS

^CF0,40
^FO15,100^FD${productName.substring(0, 28)}^FS

^CF0,28
^FO15,150^FDBatch: ${batchId}^FS

^FO0,190^GB${width},3,3^FS

^CF0,50
^FO15,205^FD${finalWt.toFixed(1)}g^FS
^CF0,22
^FO160,220^FDFINAL^FS

^CF0,32
^FO250,205^FDTrim: ${trimWeight}g^FS
^FO250,245^FDYield: ${yieldPercent}%^FS

^CF0,32
^FO450,205^FDSample: ${sampleWt.toFixed(1)}g^FS
^CF0,24
^FO450,245^FD${today}^FS

^FO0,285^GB${width},3,3^FS

^CF0,22
^FO15,300^FDMETRC: ${metrcTags || 'N/A'}^FS
${partialInfo ? `^FO500,300^FDPartial: ${partialInfo}^FS` : ''}

^FO15,340^FDGrower: ${license}^FS
^FO300,340^FD${agreement}^FS
${growerName ? `^FO500,340^FD${growerName.substring(0, 20)}^FS` : ''}

^XZ`;

            return zpl;
        }

        // Print post-production labels (multiple copies) - direct to Zebra IP
        async function printPostProductionLabels(batch, finalWeight, sampleWeight, copies) {
const zpl = generatePostProductionLabelZPL(batch, finalWeight, sampleWeight);            const printServerURL = localStorage.getItem("printServerURL") || "http://localhost:3000/print";            for (let i = 0; i < copies; i++) {                let printed = false;                try {                    const response = await fetch(printServerURL, { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({ zpl: zpl }) });                    if (response.ok) printed = true;                } catch (e) { }                if (!printed && window.BrowserPrint) {                    try { const printer = await window.BrowserPrint.getDefaultDevice("printer"); printer.send(zpl); printed = true; } catch (e) { }                }                if (!printed && i === 0) {                    const blob = new Blob([zpl], { type: "text/plain" });                    const url = window.URL.createObjectURL(blob);                    const a = document.createElement("a"); a.href = url; a.download = "label-" + batch.id + ".zpl";                    document.body.appendChild(a); a.click(); document.body.removeChild(a);                    alert("Downloaded ZPL file. Use Zebra Setup Utilities to print."); break;                }            }
        }

        // Extraction functions
        
        // Finishing functions
        function populateFinishingSelect() {
            const select = document.getElementById('finishingBatchSelect');
            // Include both regular batches AND sub-batches that are at extraction status
            // (Sub-batches can be retroactively created and need post-processing)
            const extractionBatches = batches.filter(b => b.status === 'extraction');

            select.innerHTML = '<option value="">Select a batch...</option>';
            extractionBatches.forEach(batch => {
                let label;
                
                if (batch.is_sub_batch) {
                    const estYield = ((parseFloat(batch.trim_weight) || 0) * 0.13).toFixed(0);
                    label = `${batch.id} - ${batch.strain} (~${estYield}g yield) - ${batch.product_made} (SUB-BATCH)`;
                } else {
                    // Build label with jar/slab counts from pull batch
                    let counts = [];
                    if (batch.extraction_slabs && batch.extraction_slabs > 0) {
                        counts.push(`${batch.extraction_slabs} slabs`);
                    }
                    if (batch.extraction_bowls && batch.extraction_bowls > 0) {
                        counts.push(`${batch.extraction_bowls} bowls`);
                    }
                    // Fallback to old fields if they exist
                    if (!counts.length && batch.bulk_jars_count && batch.bulk_jars_count > 0) {
                        counts.push(`${batch.bulk_jars_count} jars`);
                    }
                    if (!counts.length && batch.shatter_slabs_count && batch.shatter_slabs_count > 0) {
                        counts.push(`${batch.shatter_slabs_count} slabs`);
                    }
                    
                    const countText = counts.length > 0 ? counts.join(', ') : 'no counts';
                    const estYield = ((parseFloat(batch.trim_weight) || 0) * 0.13).toFixed(0);
                    label = `${batch.id} - ${batch.strain} (~${estYield}g yield) - ${batch.product_made} (${countText})`;
                }

                const workerIndicator = batch.finishing_user ? ` â–¶ ${batch.finishing_user.split(' ')[0]}` : '';
                select.innerHTML += `<option value="${batch.id}">${label}${workerIndicator}</option>`;
            });
        }

        document.getElementById('finishingBatchSelect').addEventListener('change', function() {
            const form = document.getElementById('finishingForm');
            form.style.display = this.value ? 'block' : 'none';

            // Check if Live Resin batch to show split section
            checkShowSplitSection(this.value);
            
            if (this.value) {
                const batch = batches.find(b => b.id === this.value);
                document.getElementById('finishingDate').value = new Date().toISOString().split('T')[0];
                
                // Show batch info
                let info = `
                    <p><strong>Strain:</strong> ${batch.strain} (${batch.strain_type})</p>
                    <p><strong>Product Type:</strong> ${batch.product_made}</p>
                    <p><strong>Material Agreement:</strong> ${batch.material_agreement}</p>
                `;
                
                // Show counts from pull batch
                if (batch.extraction_slabs && batch.extraction_slabs > 0) {
                    info += `<p style="background: rgba(245, 158, 11, 0.2); padding: 10px; border-radius: 8px; border-left: 4px solid var(--accent-orange); margin-top: 10px;">
                        <strong>ðŸ”¶ Shatter Slabs to Process:</strong> <span style="font-size: 1.3rem; font-weight: 700; color: var(--accent-orange);">${batch.extraction_slabs}</span>
                    </p>`;
                }
                
                if (batch.extraction_bowls && batch.extraction_bowls > 0) {
                    const productName = batch.product_type === 'Sugar Wax' ? 'Sugar Wax' : batch.product_type === 'Live Resin Oil' ? 'Live Resin' : 'Wax';
                    info += `<p style="background: rgba(147, 51, 234, 0.2); padding: 10px; border-radius: 8px; border-left: 4px solid var(--accent-purple); margin-top: 10px;">
                        <strong>ðŸ“¦ ${productName} Bowls to Process:</strong> <span style="font-size: 1.3rem; font-weight: 700; color: var(--accent-purple);">${batch.extraction_bowls}</span>
                    </p>`;
                }
                
                // Fallback to old fields if they exist (for legacy batches)
                if (batch.bulk_jars_count && batch.bulk_jars_count > 0 && !batch.extraction_bowls) {
                    info += `<p style="background: rgba(147, 51, 234, 0.2); padding: 10px; border-radius: 8px; border-left: 4px solid var(--accent-purple); margin-top: 10px;">
                        <strong>ðŸ“¦ Bulk Jars to Process:</strong> <span style="font-size: 1.3rem; font-weight: 700; color: var(--accent-purple);">${batch.bulk_jars_count}</span>
                    </p>`;
                }
                
                if (batch.shatter_slabs_count && batch.shatter_slabs_count > 0 && !batch.extraction_slabs) {
                    info += `<p style="background: rgba(245, 158, 11, 0.2); padding: 10px; border-radius: 8px; border-left: 4px solid var(--accent-orange); margin-top: 10px;">
                        <strong>ðŸ”¶ Shatter Slabs to Process:</strong> <span style="font-size: 1.3rem; font-weight: 700; color: var(--accent-orange);">${batch.shatter_slabs_count}</span>
                    </p>`;
                }
                
                if (batch.is_sub_batch) {
                    info += `<p style="color: var(--accent-purple); font-weight: 700;"><strong>âš¡ RETROACTIVE SUB-BATCH</strong> of ${batch.parent_batch_id}</p>`;
                    info += `<p style="color: var(--accent-orange);"><strong>Note:</strong> Enter the actual weight of this separated material</p>`;
                } else {
                    if (batch.sift_weight) {
                        info += `<p><strong>Pre-Sift Collected:</strong> ${batch.sift_weight}g</p>`;
                    }
                    info += `<p style="color: var(--accent-orange);"><strong>Note:</strong> Actual weight will be entered below or when splitting</p>`;
                }

                document.getElementById('batchInfoContent').innerHTML = info;

                // Show/hide output containers section based on product type
                const outputSection = document.getElementById('outputContainersSection');
                const bulkJarsOutput = document.getElementById('bulkJarsOutput');
                const shatterSlabsOutput = document.getElementById('shatterSlabsOutput');
                const productMade = newProductType || batch.product_made || '';

                // Check if it's a bulk product (Wax, Sugar Wax) or Shatter
                const isBulk = productMade === 'Wax' || productMade === 'Sugar Wax' ||
                               batch.extraction_bowls > 0 || batch.bulk_jars_count > 0;
                const isShatter = productMade === 'Shatter' ||
                                  batch.extraction_slabs > 0 || batch.shatter_slabs_count > 0;

                if (isBulk || isShatter) {
                    outputSection.style.display = 'block';
                    bulkJarsOutput.style.display = isBulk ? 'block' : 'none';
                    shatterSlabsOutput.style.display = isShatter ? 'block' : 'none';

                    // Set default values
                    // Bulk (wax/sugar) defaults to 1 jar
                    document.getElementById('outputJarsCount').value = 1;
                    // Shatter defaults to same number of input slabs
                    const inputSlabs = batch.extraction_slabs || batch.shatter_slabs_count || 1;
                    document.getElementById('outputSlabsCount').value = inputSlabs;
                } else {
                    outputSection.style.display = 'none';
                }
            }
        });

        document.getElementById('splitBatch').addEventListener('change', function() {
            const singleSection = document.getElementById('singleFinishing');
            const splitSection = document.getElementById('splitFinishing');
            
            if (this.value === 'yes') {
                singleSection.style.display = 'none';
                splitSection.style.display = 'block';
                // Make single fields not required
                document.getElementById('finalWeight').required = false;
                document.getElementById('sampleWeight').required = false;
                
                // Update split weight listeners
                updateSplitValidation();
            } else {
                singleSection.style.display = 'block';
                splitSection.style.display = 'none';
                document.getElementById('finalWeight').required = true;
                document.getElementById('sampleWeight').required = true;
            }
        });

        function addSplitProduct() {
            const container = document.getElementById('splitProducts');
            const count = container.children.length + 1;
            
            const newProduct = document.createElement('div');
            newProduct.className = 'split-product-item';
            newProduct.style.cssText = 'background: var(--bg-tertiary); padding: 20px; border-radius: 10px; margin-bottom: 15px;';
            newProduct.innerHTML = `
                <h4 style="color: var(--accent-purple); margin-bottom: 15px;">Product ${count}</h4>
                <div class="form-grid">
                    <div class="form-group">
                        <label>Product Type</label>
                        <select class="splitProductType" required>
                            <option value="">Select Product</option>
                            <option value="Wax">Wax</option>
                            <option value="Sugar Wax">Sugar Wax</option>
                            <option value="Shatter">Shatter</option>
                            <option value="Live Resin Carts">Live Resin Carts</option>
                            <option value="Live Resin AIOs">Live Resin AIOs</option>
                            <option value="Brick Hash">Brick Hash</option>
                            <option value="Hash Hits">Hash Hits</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Weight Allocated (grams)</label>
                        <input type="number" class="splitWeight" step="0.1" required>
                    </div>
                </div>
            `;
            container.appendChild(newProduct);
            
            // Add listeners to new inputs
            newProduct.querySelector('.splitWeight').addEventListener('input', updateSplitValidation);
        }

        function updateSplitValidation() {
            const weights = Array.from(document.querySelectorAll('.splitWeight'))
                .map(input => parseFloat(input.value) || 0);
            
            const totalAllocated = weights.reduce((sum, w) => sum + w, 0);
            
            const validationDiv = document.getElementById('splitValidation');
            
            if (totalAllocated > 0) {
                validationDiv.style.background = 'rgba(16, 185, 129, 0.2)';
                validationDiv.style.border = '2px solid var(--accent-green)';
                validationDiv.innerHTML = `
                    <strong style="color: var(--accent-green);">âœ“ Total weight to allocate:</strong><br>
                    ${totalAllocated.toFixed(1)}g across ${weights.filter(w => w > 0).length} products
                `;
            } else {
                validationDiv.style.background = 'rgba(245, 158, 11, 0.2)';
                validationDiv.style.border = '2px solid var(--accent-orange)';
                validationDiv.innerHTML = `
                    <strong style="color: var(--accent-orange);">Enter weights for each product</strong>
                `;
            }
        }

        // Add listeners to initial split weight inputs
        document.addEventListener('DOMContentLoaded', function() {
            document.querySelectorAll('.splitWeight').forEach(input => {
                input.addEventListener('input', updateSplitValidation);
            });
        });

        async function submitSplitBatch() {
            if (!currentRole) {
                alert('Please select a user first!');
                return;
            }

            const batchId = document.getElementById('finishingBatchSelect').value;
            const batch = batches.find(b => b.id === batchId);
            
            if (!batch) return;
            
            // Collect split data
            const splitItems = document.querySelectorAll('.split-product-item');
            const splits = [];
            
            splitItems.forEach(item => {
                const productType = item.querySelector('.splitProductType').value;
                const weight = parseFloat(item.querySelector('.splitWeight').value) || 0;
                
                if (productType && weight > 0) {
                    splits.push({ productType, weight });
                }
            });
            
            if (splits.length < 2) {
                alert('Please specify at least 2 products to split the batch');
                return;
            }
            
            const totalAllocated = splits.reduce((sum, s) => sum + s.weight, 0);
            
            // Calculate overall yield percentage from parent batch
            const parentTrimWeight = parseFloat(batch.trim_weight) || 0;
            const overallYieldPercent = parentTrimWeight > 0 ? (totalAllocated / parentTrimWeight) * 100 : 0;
            
            if (!confirm(`Create ${splits.length} sub-batches from ${batchId}?\n\nParent Trim: ${parentTrimWeight.toFixed(1)}g\nTotal Yield: ${totalAllocated.toFixed(1)}g\nYield %: ${overallYieldPercent.toFixed(2)}%\n\n${splits.map((s, i) => `${String.fromCharCode(65 + i)}: ${s.weight}g â†’ ${s.productType}`).join('\n')}`)) {
                return;
            }
            
            // Create sub-batches
            const subBatches = [];
            const parentTimeline = batch.timeline || [];
            
            parentTimeline.push({
                stage: 'finishing',
                user: currentRole ? currentRole.name : "Unknown",
                date: new Date().toISOString(),
                action: `Split into ${splits.length} sub-batches: ${splits.map(s => s.productType).join(', ')} - Total yield: ${overallYieldPercent.toFixed(2)}%`
            });
            
            for (let i = 0; i < splits.length; i++) {
                const split = splits[i];
                const subBatchId = `${batchId}-${String.fromCharCode(65 + i)}`;
                
                // Calculate proportional trim weight based on this sub-batch's contribution to total yield
                // If overall yield is 18% and this sub-batch is 50g, then it used (50 / 0.18) = 277.8g of trim
                const subBatchTrimWeight = overallYieldPercent > 0 
                    ? (split.weight / overallYieldPercent) * 100
                    : parentTrimWeight * (split.weight / totalAllocated);
                
                const subBatch = {
                    id: subBatchId,
                    parent_batch_id: batchId,
                    is_sub_batch: true,
                    strain: batch.strain,
                    strain_type: batch.strain_type,
                    trim_weight: subBatchTrimWeight, // Proportional trim weight based on actual yield
                    material_cost: batch.material_cost * (split.weight / totalAllocated), // Proportional cost
                    material_agreement: batch.material_agreement,
                    pre_sift: batch.pre_sift,
                    cultivation_license: batch.cultivation_license,
                    grower_name: batch.grower_name,
                    intake_date: batch.intake_date,
                    planned_products: [split.productType],
                    intake_notes: `Sub-batch from ${batchId} - Allocated ${subBatchTrimWeight.toFixed(1)}g trim for ${split.weight}g final product`,
                    status: 'finishing',
                    intake_user: batch.intake_user,
                    extraction_date: batch.extraction_date,
                    extraction_method: batch.extraction_method,
                    product_made: split.productType,
                    product_type: split.productType,
                    extraction_user: batch.extraction_user,
                    finishing_date: new Date().toISOString().split('T')[0],
                    finishing_user: currentRole ? currentRole.name : "Unknown",
                    final_weight: split.weight, // The weight allocated IS the final weight
                    timeline: [
                        {
                            stage: 'split',
                            user: currentRole ? currentRole.name : "Unknown",
                            date: new Date().toISOString(),
                            action: `Created from ${batchId} - ${subBatchTrimWeight.toFixed(1)}g trim â†’ ${split.weight}g ${split.productType} (${overallYieldPercent.toFixed(2)}% yield)`
                        }
                    ],
                    created_at: new Date().toISOString()
                };
                
                subBatches.push(subBatch);
            }
            
            // Insert all sub-batches
            const { error: insertError } = await supabaseClient
                .from('wm_batches')
                .insert(subBatches);
            
            if (insertError) {
                console.error('Error creating sub-batches:', insertError);
                alert('Error creating sub-batches. Please try again.');
                return;
            }
            
            // Update parent batch to mark as split
            const { error: updateError } = await supabaseClient
                .from('wm_batches')
                .update({
                    status: 'split',
                    timeline: parentTimeline
                })
                .eq('id', batchId);
            
            if (updateError) {
                console.error('Error updating parent batch:', updateError);
            }
            
            showCelebration({
                emoji: 'ðŸ”¥',
                title: 'Batch Split Complete!',
                message: `Created ${splits.length} sub-batches from ${batchId}`,
                stats: [
                    { value: splits.length, label: 'Sub-Batches' },
                    { value: `${overallYieldPercent.toFixed(1)}%`, label: 'Overall Yield' }
                ]
            });
            // Print labels for each sub-batch
            for (const subBatch of subBatches) {
                printPostProductionLabels(subBatch, subBatch.final_weight, 0, 1);
            }

            document.getElementById('finishingForm').style.display = 'none';
            document.getElementById('finishingBatchSelect').value = '';
            
            await loadBatches();
            populateFinishingSelect();
        }

        async function submitFinishing() {
            if (!currentRole) {
                alert('Please select a user first!');
                return;
            }

            const batchId = document.getElementById('finishingBatchSelect').value;
            const batch = batches.find(b => b.id === batchId);
            
            if (!batch) return;
            
            const finalWeight = parseFloat(document.getElementById('finalWeight').value);
            const sampleWeight = parseFloat(document.getElementById('sampleWeight').value);
            const netWeight = finalWeight - sampleWeight;

            // Get output container counts
            const outputJarsCount = parseInt(document.getElementById('outputJarsCount').value) || 1;
            const outputSlabsCount = parseInt(document.getElementById('outputSlabsCount').value) || 1;

            // Get product type change if selected
            const newProductType = document.getElementById('finishingProductType')?.value || '';

            // Determine if bulk or shatter based on product type
            const productMade = batch.product_made || '';
            const isBulk = productMade === 'Wax' || productMade === 'Sugar Wax' ||
                           batch.extraction_bowls > 0 || batch.bulk_jars_count > 0;
            const isShatter = productMade === 'Shatter' ||
                              batch.extraction_slabs > 0 || batch.shatter_slabs_count > 0;

            // Build container info for timeline
            let containerInfo = '';
            if (isBulk) {
                containerInfo = `, ${outputJarsCount} output jar${outputJarsCount > 1 ? 's' : ''}`;
            } else if (isShatter) {
                containerInfo = `, ${outputSlabsCount} output slab${outputSlabsCount > 1 ? 's' : ''}`;
            }

            const timeline = batch.timeline || [];
            timeline.push({
                stage: 'finishing',
                user: currentRole ? currentRole.name : "Unknown",
                date: new Date().toISOString(),
                action: `Finishing completed - QC: ${finalWeight}g bulk, ${sampleWeight}g sample pulled for testing${containerInfo}`
            });

            // Build update object
            const updateData = {
                status: 'finishing',
                finishing_date: document.getElementById('finishingDate').value,
                final_weight: finalWeight,
                sample_weight: sampleWeight,
                finishing_notes: document.getElementById('finishingNotes').value,
                finishing_user: currentRole ? currentRole.name : "Unknown",
                net_weight: netWeight,
                timeline: timeline
            };

            // Update product_made if changed
            if (newProductType) {
                updateData.product_made = newProductType;
            }

            // Add output container counts
            if (isBulk) {
                updateData.output_jars_count = outputJarsCount;
            }
            if (isShatter) {
                updateData.output_slabs_count = outputSlabsCount;
            }

            const { error } = await supabaseClient
                .from('wm_batches')
                .update(updateData)
                .eq('id', batchId);
            
            if (error) {
                console.error('Error updating batch:', error);
                alert('Error updating batch. Please try again.');
                return;
            }
            
            // Build stats array for celebration
            const celebrationStats = [
                { value: `${finalWeight}g`, label: 'Final Weight' },
                { value: `${((netWeight / batch.trim_weight) * 100).toFixed(1)}%`, label: 'Yield' }
            ];

            // Add container count to stats if applicable
            if (isBulk) {
                celebrationStats.push({ value: `${outputJarsCount}`, label: outputJarsCount === 1 ? 'Output Jar' : 'Output Jars' });
            } else if (isShatter) {
                celebrationStats.push({ value: `${outputSlabsCount}`, label: outputSlabsCount === 1 ? 'Output Slab' : 'Output Slabs' });
            }

            // Register batch for RTA qualification tracking


            const rtaProductType = getRTAProductType(batch);
            registerQualificationBatch(rtaProductType, batchId);

            showCelebration({
                emoji: 'âœ¨',
                title: 'Finishing Complete!',
                message: `${batchId} has been processed and is ready for packaging.`,
                stats: celebrationStats
            });

            // Auto-print post-production labels (one per slab/jar)
            const labelCount = isShatter ? outputSlabsCount : (isBulk ? outputJarsCount : 1);
            printPostProductionLabels(batch, finalWeight, sampleWeight, labelCount);

            document.getElementById('finishingForm').style.display = 'none';
            document.getElementById('finishingBatchSelect').value = '';
            document.getElementById('finishingNotes').value = '';

            // Reset output containers section
            document.getElementById('outputContainersSection').style.display = 'none';
            document.getElementById('outputJarsCount').value = 1;
            document.getElementById('outputSlabsCount').value = 1;

            await loadBatches();
            populateFinishingSelect();
        }

        // Packaging functions
        function populatePackagingSelect() {
            const select = document.getElementById('packagingBatchSelect');
            const finishingBatches = batches.filter(b => b.status === 'finishing');

            select.innerHTML = '<option value="">Select a batch...</option>';
            finishingBatches.forEach(batch => {
                const weight = batch.final_weight || batch.net_weight || 0;
                const pauseIndicator = batch.packaging_paused ? ' â¸ï¸ PAUSED' : '';
                const workerIndicator = batch.packaging_user ? ` â–¶ ${batch.packaging_user.split(' ')[0]}` : '';

                // Show output container count if available
                let containerIndicator = '';
                if (batch.output_jars_count && batch.output_jars_count > 0) {
                    containerIndicator = ` [${batch.output_jars_count} jar${batch.output_jars_count > 1 ? 's' : ''}]`;
                } else if (batch.output_slabs_count && batch.output_slabs_count > 0) {
                    containerIndicator = ` [${batch.output_slabs_count} slab${batch.output_slabs_count > 1 ? 's' : ''}]`;
                }

                select.innerHTML += `<option value="${batch.id}">${batch.id} - ${batch.strain} - ${batch.product_made} (${weight}g)${containerIndicator}${workerIndicator}${pauseIndicator}</option>`;
            });
        }

        document.getElementById('packagingBatchSelect').addEventListener('change', function() {
            const form = document.getElementById('packagingForm');
            form.style.display = this.value ? 'block' : 'none';
            
            if (this.value) {
                const batch = batches.find(b => b.id === this.value);
                document.getElementById('packagingDate').value = new Date().toISOString().split('T')[0];
                
                // Show strain type with color coding
                const strainTypeAlert = document.getElementById('strainTypeAlert');
                const strainTypeName = document.getElementById('strainTypeName');
                
                if (batch.strain_type) {
                    strainTypeAlert.style.display = 'block';
                    strainTypeName.textContent = batch.strain_type;
                    
                    // Color code based on strain type
                    if (batch.strain_type === 'Indica') {
                        // BLUE for Indica
                        strainTypeAlert.style.background = 'rgba(59, 130, 246, 0.2)';
                        strainTypeAlert.style.borderColor = 'var(--accent-blue)';
                        strainTypeName.style.color = 'var(--accent-blue)';
                    } else if (batch.strain_type === 'Sativa') {
                        // RED for Sativa
                        strainTypeAlert.style.background = 'rgba(239, 68, 68, 0.2)';
                        strainTypeAlert.style.borderColor = 'var(--accent-red)';
                        strainTypeName.style.color = 'var(--accent-red)';
                    } else if (batch.strain_type === 'Hybrid') {
                        // GREEN for Hybrid
                        strainTypeAlert.style.background = 'rgba(16, 185, 129, 0.2)';
                        strainTypeAlert.style.borderColor = 'var(--accent-green)';
                        strainTypeName.style.color = 'var(--accent-green)';
                    }
                } else {
                    strainTypeAlert.style.display = 'none';
                }
                
                // Update pause button visibility
                updatePauseButtons();
            }
        });

        // Handle product type selection for multi-size vs single-size
        document.getElementById('packagedProductType').addEventListener('change', function() {
            const multiSize = document.getElementById('multiSizeSection');
            const singleSize = document.getElementById('singleSizeSection');
            const bulkSaleAlert = document.getElementById('bulkSaleAlert');
            const units1gLabel = multiSize.querySelector('label[for="units1g"]') || multiSize.querySelectorAll('label')[0];
            const units4gLabel = multiSize.querySelector('label[for="units4g"]') || multiSize.querySelectorAll('label')[1];
            
            // Show/hide bulk sale alert
            if (this.value === 'Bulk Sale') {
                bulkSaleAlert.style.display = 'block';
            } else {
                bulkSaleAlert.style.display = 'none';
            }
            
            if (this.value === 'Wax' || this.value === 'Sugar Wax' || this.value === 'Brick Hash') {
                multiSize.style.display = 'block';
                singleSize.style.display = 'none';
                document.getElementById('unitsPackaged').required = false;
                
                // Set labels for 1g/4g
                if (units1gLabel) units1gLabel.textContent = '1g Units';
                if (units4gLabel) units4gLabel.textContent = '4g Units';
                
            } else if (this.value === 'Hash Hits') {
                multiSize.style.display = 'block';
                singleSize.style.display = 'none';
                document.getElementById('unitsPackaged').required = false;
                
                // Set labels for 2-pack/5-pack
                if (units1gLabel) units1gLabel.textContent = '2-Packs';
                if (units4gLabel) units4gLabel.textContent = '5-Packs';
                
            } else {
                multiSize.style.display = 'none';
                singleSize.style.display = 'block';
                document.getElementById('unitsPackaged').required = true;
                // Reset multi-size fields
                document.getElementById('units1g').value = 0;
                document.getElementById('units4g').value = 0;
            }
        });

        // Auto-calculate totals for multi-size packaging
        function updateMultiSizeCalcs() {
            const productType = document.getElementById('packagedProductType').value;
            const units1g = parseInt(document.getElementById('units1g').value) || 0;
            const units4g = parseInt(document.getElementById('units4g').value) || 0;
            
            let totalGrams, totalUnits;
            
            if (productType === 'Hash Hits') {
                // Hash Hits: 0.2g per hit, 2-packs and 5-packs
                const totalHits = (units1g * 2) + (units4g * 5);
                totalGrams = totalHits * 0.2;
                totalUnits = units1g + units4g; // Total packs
                
                document.getElementById('totalGramsCalc').value = `${totalGrams.toFixed(1)}g (${totalHits} hits)`;
                document.getElementById('totalUnitsCalc').value = `${totalUnits} packs`;
            } else {
                // Regular 1g/4g products
                totalGrams = (units1g * 1) + (units4g * 4);
                totalUnits = units1g + units4g;
                
                document.getElementById('totalGramsCalc').value = totalGrams;
                document.getElementById('totalUnitsCalc').value = totalUnits;
            }
            
            // Update pricing when quantities change
            updatePricing();
        }

        // Calculate wholesale price based on SKU pricing (internal use only, not displayed to packagers)
        document.getElementById('units1g').addEventListener('input', updateMultiSizeCalcs);
        document.getElementById('units4g').addEventListener('input', updateMultiSizeCalcs);

        // Start packaging (marks batch as in-progress)
        async function startPackaging() {
            if (!currentRole) {
                alert('Please select a user first!');
                return;
            }

            const batchId = document.getElementById('packagingBatchSelect').value;
            const batch = batches.find(b => b.id === batchId);
            
            if (!batch) return;
            
            const packagingDate = document.getElementById('packagingDate').value;
            const productType = document.getElementById('packagedProductType').value;
            
            if (!packagingDate || !productType) {
                alert('Please select packaging date and product type');
                return;
            }
            
            const confirmation = confirm(
                `Mark batch ${batchId} as STARTED packaging?\n\n` +
                `This will:\n` +
                `â€¢ Add "Packaging Started" to timeline\n` +
                `â€¢ Keep status as "finishing" (not yet complete)\n` +
                `â€¢ Allow you to finish later\n\n` +
                `You can skip this and go straight to "Complete Packaging" for single sessions.`
            );
            
            if (!confirmation) return;
            
            const timeline = batch.timeline || [];
            timeline.push({
                stage: 'packaging',
                user: currentRole ? currentRole.name : "Unknown",
                date: new Date().toISOString(),
                action: `Packaging started - ${productType}`
            });
            
            const { error } = await supabaseClient
                .from('wm_batches')
                .update({
                    packaging_date: packagingDate,
                    packaged_product_type: productType,
                    packaging_notes: document.getElementById('packagingNotes').value || null,
                    timeline: timeline
                })
                .eq('id', batchId);
            
            if (error) {
                console.error('Error marking batch as started:', error);
                alert('Error updating batch. Please try again.');
                return;
            }
            
            alert(`âœ… Batch ${batchId} marked as packaging in progress!\n\n` +
                  `Product Type: ${productType}\n` +
                  `Started by: ${currentRole.name}\n\n` +
                  `This batch will remain in the dropdown until you click "Complete Packaging".`);
            
            // Refresh batch data but keep form open and batch selected
            await loadBatches();
            populatePackagingSelect();
            
            // Re-select the batch
            document.getElementById('packagingBatchSelect').value = batchId;
            document.getElementById('packagingForm').style.display = 'block';
        }

        // Toggle pause/resume for packaging
        async function togglePausePackaging() {
            if (!currentRole) {
                alert('Please select a user first!');
                return;
            }

            const batchId = document.getElementById('packagingBatchSelect').value;
            const batch = batches.find(b => b.id === batchId);
            
            if (!batch) {
                alert('Please select a batch first!');
                return;
            }
            
            const isPaused = batch.packaging_paused || false;
            const action = isPaused ? 'RESUME' : 'PAUSE';
            const actionVerb = isPaused ? 'Resumed' : 'Paused';
            
            const confirmation = confirm(
                `${action} packaging for batch ${batchId}?\n\n` +
                `This will:\n` +
                `â€¢ Add "${actionVerb}" to timeline\n` +
                `â€¢ ${isPaused ? 'Allow work to continue' : 'Temporarily stop work'}\n` +
                `â€¢ Keep batch in packaging stage`
            );
            
            if (!confirmation) return;
            
            const timeline = batch.timeline || [];
            timeline.push({
                stage: 'packaging',
                user: currentRole ? currentRole.name : "Unknown",
                date: new Date().toISOString(),
                action: `Packaging ${actionVerb.toLowerCase()} - ${batch.product_type || 'unknown product'}`
            });
            
            const { error } = await supabaseClient
                .from('wm_batches')
                .update({
                    packaging_paused: !isPaused,
                    timeline: timeline
                })
                .eq('id', batchId);
            
            if (error) {
                console.error('Error toggling pause:', error);
                alert('Error updating batch. Please try again.');
                return;
            }
            
            alert(`âœ… Packaging ${actionVerb.toLowerCase()} for batch ${batchId}!\n\n` +
                  `${isPaused ? 'Work can continue.' : 'Work temporarily stopped.'}\n` +
                  `${actionVerb} by: ${currentRole.name}`);
            
            await loadBatches();
            populatePackagingSelect();
            // Keep the batch selected
            document.getElementById('packagingBatchSelect').value = batchId;
            document.getElementById('packagingBatchSelect').dispatchEvent(new Event('change'));
        }

        async function submitPackaging() {
            if (!currentRole) {
                alert('Please select a user first!');
                return;
            }
            
            const batchId = document.getElementById('packagingBatchSelect').value;
            const batch = batches.find(b => b.id === batchId);

            if (!batch) {
                alert('Batch not found. Please select a batch.');
                return;
            }

            const packagedProductType = document.getElementById('packagedProductType').value;

            if (!packagedProductType) {
                alert('Please select a product type');
                return;
            }

            let unitsPackaged, totalGrams, packagingDetails;

            // Wholesale price set to 0 (staff doesn't know this info)
            const wholesalePrice = 0;
            
            // Handle multi-size packaging
            if (packagedProductType === 'Wax' || packagedProductType === 'Sugar Wax' || packagedProductType === 'Brick Hash' || packagedProductType === 'Hash Hits') {
                const units1g = parseInt(document.getElementById('units1g').value) || 0;
                const units4g = parseInt(document.getElementById('units4g').value) || 0;
                
                if (units1g === 0 && units4g === 0) {
                    alert('Please enter at least one package size');
                    return;
                }
                
                if (packagedProductType === 'Hash Hits') {
                    // Hash Hits: 0.2g per hit
                    const totalHits = (units1g * 2) + (units4g * 5);
                    totalGrams = totalHits * 0.2;
                    unitsPackaged = units1g + units4g; // Total packs
                    
                    packagingDetails = {
                        units_1g: units1g,
                        units_4g: units4g,
                        total_grams: totalGrams,
                        packaging_breakdown: `${units1g}x 2-pack, ${units4g}x 5-pack`
                    };
                } else {
                    // Wax, Sugar Wax, or Brick Hash
                    totalGrams = (units1g * 1) + (units4g * 4);
                    unitsPackaged = units1g + units4g;
                    
                    packagingDetails = {
                        units_1g: units1g,
                        units_4g: units4g,
                        total_grams: totalGrams,
                        packaging_breakdown: `${units1g}x 1g, ${units4g}x 4g`
                    };
                }
            } else {
                // Single size packaging
                unitsPackaged = parseInt(document.getElementById('unitsPackaged').value);
                
                if (!unitsPackaged || unitsPackaged === 0) {
                    alert('Please enter units packaged');
                    return;
                }
                
                packagingDetails = {
                    units_1g: null,
                    units_4g: null,
                    total_grams: null,
                    packaging_breakdown: null
                };
            }
            
            const timeline = batch.timeline || [];
            
            // Check if this is a bulk sale
            const isBulkSale = packagedProductType === 'Bulk Sale';
            
            if (packagedProductType === 'Wax' || packagedProductType === 'Sugar Wax' || packagedProductType === 'Brick Hash') {
                timeline.push({
                    stage: 'packaging',
                    user: currentRole ? currentRole.name : "Unknown",
                    date: new Date().toISOString(),
                    action: `Packaged ${unitsPackaged} total units (${packagingDetails.packaging_breakdown} = ${totalGrams}g) - ${packagedProductType}`
                });
            } else if (isBulkSale) {
                timeline.push({
                    stage: 'packaging',
                    user: currentRole ? currentRole.name : "Unknown",
                    date: new Date().toISOString(),
                    action: `Bulk sale - ${unitsPackaged} unit(s) - Proceeding to testing`
                });
            } else {
                timeline.push({
                    stage: 'packaging',
                    user: currentRole ? currentRole.name : "Unknown",
                    date: new Date().toISOString(),
                    action: `Packaged ${unitsPackaged} units - ${packagedProductType}`
                });
            }
            
            // Prepare update data
            const updateData = {
                packaging_date: document.getElementById('packagingDate').value,
                packaged_product_type: packagedProductType,
                units_packaged: unitsPackaged,
                units_1g: packagingDetails.units_1g,
                units_4g: packagingDetails.units_4g,
                total_grams_packaged: packagingDetails.total_grams,
                packaging_breakdown: packagingDetails.packaging_breakdown,
                wholesale_price: wholesalePrice,
                packaging_notes: document.getElementById('packagingNotes').value,
                packaging_user: currentRole ? currentRole.name : "Unknown",
                timeline: timeline
            };
            
            // If bulk sale, go to packaging status (testing queue) but will skip labeling after testing
            if (isBulkSale) {
                updateData.status = 'packaging'; // Goes to testing queue
                // Note: labels_applied will be set to true after testing is complete
            } else {
                // Normal packaging - goes to "complete" status waiting for labeling
                updateData.status = 'complete';
                updateData.completed_at = new Date().toISOString();
            }
            
            const { error } = await supabaseClient
                .from('wm_batches')
                .update(updateData)
                .eq('id', batchId);
            
            if (error) {
                console.error('Error updating batch:', error);
                alert('Error updating batch. Please try again.');
                return;
            }
            
            if (isBulkSale) {
                showCelebration({
                    emoji: 'ðŸ’°',
                    title: 'Bulk Sale Ready for Testing!',
                    message: `${batchId} is packaged and ready for testing!`,
                    stats: [
                        { value: `${totalGrams}g`, label: 'Total Weight' },
                        { value: packagedProductType, label: 'Product' }
                    ]
                });
            } else {
                showCelebration({
                    emoji: 'ðŸ“¦',
                    title: 'Packaging Complete!',
                    message: `${batchId} is packed and ready for labeling!`,
                    stats: [
                        { value: unitsPackaged, label: 'Units Packed' },
                        { value: packagedProductType, label: 'Product' }
                    ]
                });
            }

            document.getElementById('packagingForm').style.display = 'none';
            document.getElementById('packagingBatchSelect').value = '';
            document.getElementById('packagingNotes').value = '';
            document.getElementById('units1g').value = 0;
            document.getElementById('units4g').value = 0;
            document.getElementById('unitsPackaged').value = '';
            
            await loadBatches();
            populatePackagingSelect();
        }

        // Dashboard functions
        function updateDashboard() {
            document.getElementById('totalBatches').textContent = batches.length;
            document.getElementById('activeBatches').textContent = batches.filter(b => b.status !== 'complete').length;
            document.getElementById('completedBatches').textContent = batches.filter(b => b.status === 'complete').length;
            
            const totalGrams = batches.reduce((sum, b) => sum + (parseFloat(b.trim_weight) || 0), 0);
            document.getElementById('totalGramsIn').textContent = totalGrams.toFixed(0) + 'g';
            
            // Calculate total weight loss from bulk to labeled
            let totalWeightLoss = 0;
            let batchesWithDiscrepancy = 0;
            
            batches.forEach(batch => {
                if (batch.grams_labeled && batch.net_weight) {
                    const labeled = parseFloat(batch.grams_labeled);
                    const bulk = parseFloat(batch.net_weight);
                    const loss = bulk - labeled;
                    
                    if (loss > 0) {
                        totalWeightLoss += loss;
                        
                        // Count significant discrepancies (>5% or >5g)
                        const lossPercent = (loss / bulk) * 100;
                        if (lossPercent > 5 || loss > 5) {
                            batchesWithDiscrepancy++;
                        }
                    }
                }
            });
            
            // Update weight discrepancy card
            const discrepancyCard = document.getElementById('weightDiscrepancyCard');
            const weightLossElement = document.getElementById('totalWeightLoss');
            
            if (totalWeightLoss > 0) {
                discrepancyCard.style.display = 'block';
                weightLossElement.textContent = `${totalWeightLoss.toFixed(1)}g`;
                
                // Update label to show count if there are significant discrepancies
                const label = discrepancyCard.querySelector('.stat-label');
                if (batchesWithDiscrepancy > 0) {
                    label.innerHTML = `âš ï¸ Weight Loss (${batchesWithDiscrepancy} batches)`;
                    weightLossElement.style.color = 'var(--accent-orange)';
                } else {
                    label.innerHTML = 'âš ï¸ Weight Loss (Bulkâ†’Label)';
                    weightLossElement.style.color = 'var(--accent-blue)';
                }
            } else {
                discrepancyCard.style.display = 'none';
            }
            
            // Update personal workload stats
            updatePersonalWorkloadStats();
            
            // Update badge counts on navigation tabs
            updateBadgeCounts();

            // Load needs data for dashboard display
            if (document.getElementById('dashboardNeedsGrid')) {
                loadNeedsData();
            }
        }

        // Update badge counts on navigation tabs
        function updateBadgeCounts() {
            // Count batches at each stage (excluding intake)
            const counts = {
                extraction: batches.filter(b => b.status === 'intake').length, // Waiting for extraction
                finishing: batches.filter(b => b.status === 'extraction').length, // Waiting for post-extraction
                packaging: batches.filter(b => b.status === 'finishing').length, // Waiting for packaging
                testing: batches.filter(b => b.status === 'packaging' || (b.status === 'complete' && !b.test_thc_percent)).length,
                labeling: batches.filter(b => b.status === 'complete' && b.test_thc_percent && !b.labels_applied).length
            };
            
            // Update each badge
            Object.entries(counts).forEach(([stage, count]) => {
                const badge = document.getElementById(`badge-${stage}`);
                if (badge) {
                    badge.textContent = count;
                    if (count > 0) {
                        badge.classList.add('has-count');
                    } else {
                        badge.classList.remove('has-count');
                    }
                }
            });
        }

        // Personal Performance Stats Dashboard
        let currentPersonalPeriod = 'today';
        
        function updatePersonalStats(period = 'today') {
            currentPersonalPeriod = period;
            
            // Update button states
            document.querySelectorAll('.personal-time-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            const periodBtn = document.querySelector(`[data-period="${period}"]`);
            if (periodBtn) periodBtn.classList.add('active');
            
            if (!currentRole) {
                document.getElementById('personalStatsContent').innerHTML = '<p style="grid-column: 1/-1; text-align: center; color: var(--text-secondary);">Please login to see your stats</p>';
                document.getElementById('personalRecordsContent').innerHTML = '';
                return;
            }
            
            // Calculate date range
            const now = new Date();
            let startDate;
            
            switch(period) {
                case 'today':
                    startDate = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                    break;
                case 'week':
                    startDate = new Date(now);
                    startDate.setDate(now.getDate() - 7);
                    break;
                case 'month':
                    startDate = new Date(now);
                    startDate.setDate(now.getDate() - 30);
                    break;
                case 'all':
                default:
                    startDate = new Date(0); // Beginning of time
            }
            
            // Calculate stats
            const stats = calculatePersonalStats(currentRole.name, startDate);
            
            // Display stats
            displayPersonalStats(stats, period);
            displayPersonalRecords(currentRole.name);
        }
        
        function calculatePersonalStats(userName, startDate) {
            const stats = {
                unitsPackaged: 0,
                unitsLabeled: 0,
                gramsExtracted: 0,
                batchesFinished: 0,
                avgPackagingRate: 0,
                avgLabelingRate: 0
            };
            
            batches.forEach(batch => {
                // PACKAGING: Check packaging_user field (same as Performance tab uses)
                if (batch.packaging_user === userName && batch.packaging_date && batch.units_packaged) {
                    const packagingDate = new Date(batch.packaging_date);
                    if (packagingDate >= startDate) {
                        stats.unitsPackaged += parseInt(batch.units_packaged) || 0;
                    }
                }
                
                // EXTRACTION: Check extraction_user field first (most reliable)
                if (batch.extraction_user === userName && batch.status !== 'intake' && batch.trim_weight) {
                    // Check if extraction was done in the date range
                    let extractionDate = null;
                    if (batch.timeline && batch.timeline.length > 0) {
                        const extractionEvent = batch.timeline.find(e => 
                            e.stage === 'extraction' && e.user === userName
                        );
                        if (extractionEvent) {
                            extractionDate = new Date(extractionEvent.timestamp || extractionEvent.date);
                        }
                    }
                    
                    // If we found an extraction event in the date range, count it
                    if (extractionDate && extractionDate >= startDate) {
                        const grams = parseFloat(batch.trim_weight) || 0;
                        stats.gramsExtracted += grams;
                    }
                }
                
                // FINISHING: Check finishing_user field
                if (batch.finishing_user === userName && batch.status !== 'intake' && batch.status !== 'extraction') {
                    // Check if finishing was done in the date range
                    let finishingDate = null;
                    if (batch.timeline && batch.timeline.length > 0) {
                        const finishingEvent = batch.timeline.find(e => 
                            e.stage === 'finishing' && e.user === userName
                        );
                        if (finishingEvent) {
                            finishingDate = new Date(finishingEvent.timestamp || finishingEvent.date);
                        }
                    }
                    
                    // If we found a finishing event in the date range, count it
                    if (finishingDate && finishingDate >= startDate) {
                        stats.batchesFinished++;
                    }
                }
                
                // LABELING: Check timeline (same as before)
                if (batch.timeline && batch.timeline.length > 0) {
                    batch.timeline.forEach(event => {
                        if (!event.date && !event.timestamp) return;
                        if (!event.user || event.user !== userName) return;
                        
                        const eventDate = new Date(event.timestamp || event.date);
                        if (eventDate < startDate) return;
                        
                        // Labeling
                        if (event.stage === 'labeling' && event.action && 
                            (event.action.toLowerCase().includes('completed') || event.action.toLowerCase().includes('labeled')) &&
                            batch.units_packaged) {
                            stats.unitsLabeled += parseInt(batch.units_packaged) || 0;
                        }
                    });
                }
            });

            return stats;
        }
        
        function displayPersonalStats(stats, period) {
            const periodLabel = {
                'today': 'Today',
                'week': 'This Week', 
                'month': 'This Month',
                'all': 'All Time'
            }[period];
            
            const statName = `${currentRole.name}'s Performance - ${periodLabel}`;
            const personalStatEl = document.getElementById('personalStatName');
            const modalStatEl = document.getElementById('modalPersonalStatName');
            if (personalStatEl) personalStatEl.textContent = statName;
            if (modalStatEl) modalStatEl.textContent = statName;
            
            // Convert grams to pounds if over 454g (1 lb)
            const extractedDisplay = stats.gramsExtracted >= 454 
                ? `${(stats.gramsExtracted / 453.592).toFixed(1)} lbs`
                : `${stats.gramsExtracted.toFixed(0)}g`;
            
            const content = `
                <div class="stat-box">
                    <div class="stat-number">${stats.unitsPackaged.toLocaleString()}</div>
                    <div class="stat-label">ðŸ“¦ Units Packaged</div>
                </div>
                
                <div class="stat-box">
                    <div class="stat-number">${stats.unitsLabeled.toLocaleString()}</div>
                    <div class="stat-label">ðŸ·ï¸ Units Labeled</div>
                </div>
                
                <div class="stat-box">
                    <div class="stat-number">${extractedDisplay}</div>
                    <div class="stat-label">âš—ï¸ Trim Extracted</div>
                </div>
                
                <div class="stat-box">
                    <div class="stat-number">${stats.batchesFinished}</div>
                    <div class="stat-label">âœ¨ Batches Finished</div>
                </div>
                
                ${stats.avgPackagingRate > 0 ? `
                <div class="stat-box">
                    <div class="stat-number">${stats.avgPackagingRate}</div>
                    <div class="stat-label">ðŸ“Š Units/Hour (Packaging)</div>
                </div>
                ` : ''}
                
                ${stats.avgLabelingRate > 0 ? `
                <div class="stat-box">
                    <div class="stat-number">${stats.avgLabelingRate}</div>
                    <div class="stat-label">âš¡ Units/Hour (Labeling)</div>
                </div>
                ` : ''}
            `;
            
            document.getElementById('personalStatsContent').innerHTML = content;
        }
        
        // Open/close personal stats modal
        function openPersonalStatsModal() {
            if (!currentRole) {
                alert('Please login first to see your stats!');
                return;
            }

            document.getElementById('personalStatsModal').style.display = 'block';

            // Check if user is Drew (Sales) - show sales stats instead
            if (currentRole.name.includes('Drew') || currentRole.name.includes('Sales') || currentRole.name.includes('Ryan')) {
                showSalesWorkload();
            } else {
                populateWhatsNext();
                populateTodayProgress();
                updatePersonalStats('today');
            }
        }

        // Sales-specific workload view for Drew
        async function showSalesWorkload() {
            const modalName = document.getElementById('modalPersonalStatName');
            const whatsNextSection = document.getElementById('whatsNextSection');
            const todayProgressContent = document.getElementById('todayProgressContent');
            const personalStatsContent = document.getElementById('personalStatsContent');
            const myBatchesSection = document.getElementById('myBatchesSection');
            const personalRecords = document.getElementById('personalRecords');

            modalName.textContent = 'Sales Dashboard';

            // Show loading state
            whatsNextSection.innerHTML = `
                <h3 style="color: var(--accent-green); margin: 0 0 15px 0; font-size: 1.3rem;">ðŸ“Š Sales Overview</h3>
                <div style="text-align: center; padding: 20px; color: var(--text-secondary);">Loading sales data...</div>
            `;

            // Load LeafLink data
            await ensureLeafLinkData();

            // Get stats for different periods
            const monthStats = calculateSalesStats('month');
            const weekStats = calculateSalesStats('week');

            // Update What's Next section with sales summary
            whatsNextSection.innerHTML = `
                <h3 style="color: var(--accent-green); margin: 0 0 15px 0; font-size: 1.3rem;">ðŸ“Š This Month's Performance</h3>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px;">
                    <div style="background: linear-gradient(135deg, #1a1a2e, #16213e); padding: 20px; border-radius: 12px; text-align: center; border: 1px solid rgba(255,215,0,0.3);">
                        <div style="font-size: 2.5rem; font-weight: 700; color: #FFD700;">${monthStats.totalOrders}</div>
                        <div style="color: var(--text-secondary); font-size: 0.9rem;">Orders</div>
                        <div style="color: ${monthStats.ordersChange >= 0 ? 'var(--accent-green)' : 'var(--accent-red)'}; font-size: 0.8rem; margin-top: 5px;">
                            ${monthStats.ordersChange >= 0 ? 'â†‘' : 'â†“'} ${Math.abs(monthStats.ordersChange)}% vs last month
                        </div>
                    </div>
                    <div style="background: linear-gradient(135deg, #1a1a2e, #16213e); padding: 20px; border-radius: 12px; text-align: center; border: 1px solid rgba(16,185,129,0.3);">
                        <div style="font-size: 2.5rem; font-weight: 700; color: #10B981;">$${monthStats.totalDollars.toLocaleString('en-US', {minimumFractionDigits: 0, maximumFractionDigits: 0})}</div>
                        <div style="color: var(--text-secondary); font-size: 0.9rem;">Revenue</div>
                        <div style="color: ${monthStats.dollarsChange >= 0 ? 'var(--accent-green)' : 'var(--accent-red)'}; font-size: 0.8rem; margin-top: 5px;">
                            ${monthStats.dollarsChange >= 0 ? 'â†‘' : 'â†“'} ${Math.abs(monthStats.dollarsChange)}% vs last month
                        </div>
                    </div>
                    <div style="background: linear-gradient(135deg, #1a1a2e, #16213e); padding: 20px; border-radius: 12px; text-align: center; border: 1px solid rgba(191,0,255,0.3);">
                        <div style="font-size: 2.5rem; font-weight: 700; color: #BF00FF;">${monthStats.newShops.length}</div>
                        <div style="color: var(--text-secondary); font-size: 0.9rem;">New Shops</div>
                    </div>
                    <div style="background: linear-gradient(135deg, #1a1a2e, #16213e); padding: 20px; border-radius: 12px; text-align: center; border: 1px solid rgba(59,130,246,0.3);">
                        <div style="font-size: 2.5rem; font-weight: 700; color: #3B82F6;">${monthStats.uniqueCustomers}</div>
                        <div style="color: var(--text-secondary); font-size: 0.9rem;">Active Customers</div>
                    </div>
                </div>
            `;

            // Calculate payment stats
            const paymentStats = calculatePaymentStats(allLeafLinkOrders);

            // Today's Progress - Payment Status
            todayProgressContent.parentElement.querySelector('h3').innerHTML = 'ðŸ’° Payment Status';
            todayProgressContent.innerHTML = `
                <div style="background: var(--bg-tertiary); padding: 15px; border-radius: 8px; text-align: center; border-left: 3px solid var(--accent-green);">
                    <div style="font-size: 2rem; font-weight: 700; color: var(--accent-green);">${paymentStats.paidCount}</div>
                    <div style="color: var(--text-secondary); font-size: 0.85rem;">Paid</div>
                    <div style="color: var(--accent-green); font-size: 0.8rem;">$${paymentStats.paidTotal.toLocaleString('en-US', {minimumFractionDigits: 0, maximumFractionDigits: 0})}</div>
                </div>
                <div style="background: var(--bg-tertiary); padding: 15px; border-radius: 8px; text-align: center; border-left: 3px solid var(--accent-orange);">
                    <div style="font-size: 2rem; font-weight: 700; color: var(--accent-orange);">${paymentStats.unpaidCount}</div>
                    <div style="color: var(--text-secondary); font-size: 0.85rem;">Unpaid</div>
                    <div style="color: var(--accent-orange); font-size: 0.8rem;">$${paymentStats.unpaidTotal.toLocaleString('en-US', {minimumFractionDigits: 0, maximumFractionDigits: 0})}</div>
                </div>
                <div style="background: var(--bg-tertiary); padding: 15px; border-radius: 8px; text-align: center; border-left: 3px solid ${paymentStats.overdueCount > 0 ? 'var(--accent-red)' : 'var(--text-secondary)'};">
                    <div style="font-size: 2rem; font-weight: 700; color: ${paymentStats.overdueCount > 0 ? 'var(--accent-red)' : 'var(--text-secondary)'};">${paymentStats.overdueCount}</div>
                    <div style="color: var(--text-secondary); font-size: 0.85rem;">Overdue</div>
                    <div style="color: ${paymentStats.overdueCount > 0 ? 'var(--accent-red)' : 'var(--text-secondary)'}; font-size: 0.8rem;">$${paymentStats.overdueTotal.toLocaleString('en-US', {minimumFractionDigits: 0, maximumFractionDigits: 0})}</div>
                </div>
            `;

            // Hide production-specific sections
            document.querySelectorAll('.personal-time-btn').forEach(btn => btn.style.display = 'none');
            personalStatsContent.style.display = 'none';

            // Show overdue orders in myBatchesSection with expandable dropdown
            if (paymentStats.overdueCount > 0) {
                // Store data globally for sorting
                overduePaymentData = paymentStats.overdueOrders;
                // Sort by days overdue by default
                overduePaymentData.sort((a, b) => b.daysOverdue - a.daysOverdue);

                // Count critical (60+ days) and severe (30+ days)
                const criticalCount = overduePaymentData.filter(o => o.daysOverdue > 60).length;
                const severeCount = overduePaymentData.filter(o => o.daysOverdue > 30 && o.daysOverdue <= 60).length;

                myBatchesSection.style.display = 'block';
                myBatchesSection.innerHTML = `
                    <div onclick="toggleOverduePayments()" style="cursor: pointer; display: flex; justify-content: space-between; align-items: center; padding: 15px; background: linear-gradient(135deg, rgba(239, 68, 68, 0.2), rgba(239, 68, 68, 0.1)); border-radius: 12px; border: 1px solid rgba(239, 68, 68, 0.4);">
                        <div style="display: flex; align-items: center; gap: 15px;">
                            <span id="overdueArrow" style="font-size: 1.2rem; color: var(--accent-red);">â–¶</span>
                            <h3 style="color: var(--accent-red); margin: 0; font-size: 1.3rem;">âš ï¸ Accounts Receivable (${paymentStats.overdueCount})</h3>
                        </div>
                        <div style="display: flex; gap: 10px; align-items: center;">
                            ${criticalCount > 0 ? `<span style="background: #ff0000; color: white; padding: 4px 10px; border-radius: 15px; font-size: 0.8rem; font-weight: 600;">ðŸ”´ ${criticalCount} CRITICAL</span>` : ''}
                            ${severeCount > 0 ? `<span style="background: #ff6b00; color: white; padding: 4px 10px; border-radius: 15px; font-size: 0.8rem; font-weight: 600;">ðŸŸ  ${severeCount} SEVERE</span>` : ''}
                            <span style="color: var(--accent-red); font-weight: 700; font-size: 1.2rem;">${paymentStats.overdueTotal.toLocaleString('en-US', {minimumFractionDigits: 0, maximumFractionDigits: 0})}</span>
                        </div>
                    </div>

                    <div id="overduePaymentsContent" style="display: none; margin-top: 15px;">
                        <div style="display: flex; gap: 10px; margin-bottom: 15px; flex-wrap: wrap;">
                            <span style="color: var(--text-secondary); padding: 8px 0;">Sort by:</span>
                            <button class="overdue-sort-btn active" data-sort="daysOverdue" onclick="sortOverduePayments('daysOverdue')" style="background: rgba(239, 68, 68, 0.2); border: 1px solid var(--accent-red); color: var(--accent-red); padding: 8px 15px; border-radius: 20px; cursor: pointer; font-size: 0.9rem;">Days Overdue</button>
                            <button class="overdue-sort-btn" data-sort="amount" onclick="sortOverduePayments('amount')" style="background: transparent; border: 1px solid var(--border); color: var(--text-secondary); padding: 8px 15px; border-radius: 20px; cursor: pointer; font-size: 0.9rem;">Amount</button>
                            <button class="overdue-sort-btn" data-sort="customer" onclick="sortOverduePayments('customer')" style="background: transparent; border: 1px solid var(--border); color: var(--text-secondary); padding: 8px 15px; border-radius: 20px; cursor: pointer; font-size: 0.9rem;">Customer</button>
                            <button class="overdue-sort-btn" data-sort="dueDate" onclick="sortOverduePayments('dueDate')" style="background: transparent; border: 1px solid var(--border); color: var(--text-secondary); padding: 8px 15px; border-radius: 20px; cursor: pointer; font-size: 0.9rem;">Due Date</button>
                        </div>
                        <div id="overduePaymentsList" style="display: flex; flex-direction: column; gap: 10px; max-height: 400px; overflow-y: auto;">
                        </div>
                    </div>
                `;

                // Render the initial sorted list
                renderOverduePayments(overduePaymentData);
            } else {
                myBatchesSection.style.display = 'none';
            }

            // Show new shops celebration instead of personal records
            if (monthStats.newShops.length > 0) {
                personalRecords.innerHTML = `
                    <h3 style="color: #BF00FF; margin-bottom: 20px; text-align: center; font-size: 1.5rem;">ðŸŽŠ Welcome New Partners!</h3>
                    <div style="display: flex; flex-wrap: wrap; gap: 10px; justify-content: center;">
                        ${monthStats.newShops.map(shop => `
                            <div style="background: linear-gradient(135deg, rgba(191,0,255,0.2), rgba(59,130,246,0.2)); border: 1px solid rgba(191,0,255,0.4); padding: 12px 20px; border-radius: 25px; display: flex; align-items: center; gap: 10px;">
                                <span style="font-size: 1.3rem;">ðŸŽ‰</span>
                                <span style="font-weight: 600;">${shop.name}</span>
                            </div>
                        `).join('')}
                    </div>
                `;
            } else {
                personalRecords.innerHTML = `
                    <h3 style="color: var(--accent-purple); margin-bottom: 20px; text-align: center; font-size: 1.5rem;">ðŸŽ¯ Goals</h3>
                    <div style="text-align: center; color: var(--text-secondary); padding: 20px;">
                        No new shops this month yet - keep pushing!
                    </div>
                `;
            }
        }
        
        function populateWhatsNext() {
            const userName = currentRole.name;
            const whatsNextEl = document.getElementById('whatsNextContent');

            // Get priority scores for each batch based on needs
            function getNeedsPriority(batch) {
                if (!needsData || typeof needsData !== 'object') return 0;
                const category = getProductCategory(batch.product_made);
                if (!category || !needsData[category]) return 0;
                const strainType = (batch.strain_type || 'Hybrid').trim();
                const need = (needsData[category].needs || []).find(n => n.strainType === strainType);
                if (!need) return 0;
                return (need.varietiesNeeded * 10) + (need.qtyNeeded > 0 ? 5 : 0);
            }

            // Find batches waiting for this user, sorted by needs priority
            let availableBatches = [];
            let taskType = '';

            if (currentRole.access.includes('packaging')) {
                availableBatches = batches.filter(b => b.status === 'finishing' && !b.packaging_user);
                taskType = 'ðŸ“¦ Packaging';
            }
            if (availableBatches.length === 0 && currentRole.access.includes('labeling')) {
                availableBatches = batches.filter(b => b.status === 'packaging' && !b.labeling_user);
                taskType = 'ðŸ·ï¸ Labeling';
            }
            if (availableBatches.length === 0 && currentRole.access.includes('extraction')) {
                availableBatches = batches.filter(b => b.status === 'intake');
                taskType = 'âš—ï¸ Extraction';
            }
            if (availableBatches.length === 0 && currentRole.access.includes('finishing')) {
                availableBatches = batches.filter(b => b.status === 'extraction');
                taskType = 'ðŸ”¥ Finishing';
            }

            // Sort by needs priority (highest first)
            availableBatches.sort((a, b) => getNeedsPriority(b) - getNeedsPriority(a));

            const nextBatch = availableBatches[0];
            const priority = nextBatch ? getNeedsPriority(nextBatch) : 0;
            const isPriority = priority > 0;

            if (nextBatch) {
                const category = getProductCategory(nextBatch.product_made) || '';
                const strainType = nextBatch.strain_type || 'Hybrid';
                whatsNextEl.innerHTML = `
                    <div style="background: var(--bg-tertiary); padding: 20px; border-radius: 8px; border-left: 4px solid ${isPriority ? '#F59E0B' : 'var(--accent-green)'};">
                        <div style="font-size: 1.1rem; font-weight: 600; color: ${isPriority ? '#F59E0B' : 'var(--accent-green)'}; margin-bottom: 10px;">
                            ${taskType} ${isPriority ? 'â­ PRIORITY' : ''}
                        </div>
                        <div style="font-size: 1.3rem; font-weight: 700; color: var(--text-primary); font-family: 'Space Mono', monospace;">${nextBatch.id}</div>
                        <div style="color: var(--text-secondary); margin-top: 5px;">${nextBatch.strain || 'Unknown strain'} (${strainType})</div>
                        ${category ? `<div style="color: var(--text-secondary); margin-top: 5px;">${category}</div>` : ''}
                        ${isPriority ? `<div style="color: #F59E0B; margin-top: 8px; font-size: 0.9rem;">ðŸ”¥ High demand - prioritize this batch!</div>` : ''}
                        ${nextBatch.trim_weight ? `<div style="color: var(--text-secondary); margin-top: 5px;">${parseFloat(nextBatch.trim_weight).toFixed(0)}g trim</div>` : ''}
                    </div>
                    ${availableBatches.length > 1 ? `<div style="color: var(--text-secondary); margin-top: 10px; font-size: 0.85rem;">+ ${availableBatches.length - 1} more batches in queue</div>` : ''}
                `;
            } else {
                whatsNextEl.innerHTML = `
                    <div style="background: var(--bg-tertiary); padding: 20px; border-radius: 8px; text-align: center; color: var(--text-secondary);">
                        <div style="font-size: 2rem; margin-bottom: 10px;">ðŸŽ‰</div>
                        <div>All caught up! No batches waiting for you.</div>
                    </div>
                `;
            }
        }
        
        function populateTodayProgress() {
            const userName = currentRole.name;
            const today = new Date().toISOString().split('T')[0];
            const progressEl = document.getElementById('todayProgressContent');
            
            let packaged = 0;
            let labeled = 0;
            let extracted = 0;
            let finished = 0;
            
            batches.forEach(batch => {
                // Packaging
                if (batch.packaging_user === userName && batch.packaging_date) {
                    const date = new Date(batch.packaging_date).toISOString().split('T')[0];
                    if (date === today) packaged += parseInt(batch.units_packaged) || 0;
                }
                
                // Labeling
                if (batch.timeline) {
                    batch.timeline.forEach(event => {
                        if (event.user === userName && event.stage === 'labeling') {
                            const date = new Date(event.timestamp).toISOString().split('T')[0];
                            if (date === today) labeled += parseInt(batch.units_packaged) || 0;
                        }
                    });
                }
                
                // Extraction
                if (batch.timeline) {
                    const extractionEvent = batch.timeline.find(e => e.status === 'extraction' && e.user === userName);
                    if (extractionEvent) {
                        const date = new Date(extractionEvent.timestamp).toISOString().split('T')[0];
                        if (date === today) extracted++;
                    }
                }
                
                // Finishing
                if (batch.finishing_user === userName && batch.finishing_date) {
                    const date = new Date(batch.finishing_date).toISOString().split('T')[0];
                    if (date === today) finished++;
                }
            });
            
            let html = '';
            if (packaged > 0) {
                html += `<div style="background: var(--bg-tertiary); padding: 15px; border-radius: 8px; text-align: center;">
                    <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 5px;">ðŸ“¦ Packaged</div>
                    <div style="font-size: 2rem; font-weight: 700; color: var(--accent-purple);">${packaged}</div>
                </div>`;
            }
            if (labeled > 0) {
                html += `<div style="background: var(--bg-tertiary); padding: 15px; border-radius: 8px; text-align: center;">
                    <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 5px;">ðŸ·ï¸ Labeled</div>
                    <div style="font-size: 2rem; font-weight: 700; color: var(--accent-green);">${labeled}</div>
                </div>`;
            }
            if (extracted > 0) {
                html += `<div style="background: var(--bg-tertiary); padding: 15px; border-radius: 8px; text-align: center;">
                    <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 5px;">âš—ï¸ Extracted</div>
                    <div style="font-size: 2rem; font-weight: 700; color: var(--accent-orange);">${extracted}</div>
                </div>`;
            }
            if (finished > 0) {
                html += `<div style="background: var(--bg-tertiary); padding: 15px; border-radius: 8px; text-align: center;">
                    <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 5px;">ðŸ”¥ Finished</div>
                    <div style="font-size: 2rem; font-weight: 700; color: var(--accent-blue);">${finished}</div>
                </div>`;
            }
            
            if (html === '') {
                html = `<div style="background: var(--bg-tertiary); padding: 20px; border-radius: 8px; text-align: center; color: var(--text-secondary); grid-column: 1 / -1;">
                    No production completed yet today
                </div>`;
            }
            
            progressEl.innerHTML = html;
        }
        
        function closePersonalStatsModal() {
            document.getElementById('personalStatsModal').style.display = 'none';
        }

        // ==================== MATERIAL TYPE / LIVE RESIN WORKFLOW ====================
        function updateMaterialTypeUI() {
            // Check if any Live Resin product is selected
            const selectedProducts = Array.from(document.querySelectorAll('input[name="products"]:checked')).map(cb => cb.value);
            const isLiveResin = selectedProducts.some(p => p.includes('Live Resin'));

            const weightLabel = document.getElementById('weightLabel');
            const socksLabel = document.getElementById('socksLabel');
            const socksHelp = document.getElementById('socksHelp');

            if (isLiveResin) {
                weightLabel.textContent = 'Fresh Frozen Weight (grams)';
                socksLabel.textContent = 'Number of Bowls';
                socksHelp.textContent = 'How many bowls will this fresh frozen fill?';
            } else {
                weightLabel.textContent = 'Trim Weight (grams)';
                socksLabel.textContent = 'Number of Socks';
                socksHelp.textContent = 'How many socks is this trim packed into?';
            }
        }

        // Get expected yield based on material type
        function getExpectedYield(materialType) {
            // Fresh Frozen (Live Resin) = 3.5%, Trim (Standard BHO) = 13%
            return materialType === 'Fresh Frozen' ? 3.5 : 13;
        }


        // Split Live Resin batch into Carts and AIOs sub-batches
        async function splitLiveResinBatch() {
            const finishBatchSelect = document.getElementById('finishBatchSelect');
            const batchId = finishBatchSelect.value;
            if (!batchId) {
                alert('Please select a batch first');
                return;
            }

            const cartsWeight = parseFloat(document.getElementById('splitCartsWeight').value) || 0;
            const aiosWeight = parseFloat(document.getElementById('splitAIOsWeight').value) || 0;

            if (cartsWeight === 0 && aiosWeight === 0) {
                alert('Please enter weights for at least one product type');
                return;
            }

            // Get the parent batch
            const { data: parentBatch, error: fetchError } = await supabaseClient
                .from('wm_batches')
                .select('*')
                .eq('id', batchId)
                .single();

            if (fetchError || !parentBatch) {
                alert('Error fetching batch');
                return;
            }

            const subBatches = [];
            const batchBase = batchId.split('-').slice(0, 2).join('-');

            // Create Carts sub-batch
            if (cartsWeight > 0) {
                const cartsSubId = batchBase + '-CARTS';
                subBatches.push({
                    id: cartsSubId,
                    strain: parentBatch.strain,
                    strain_type: parentBatch.strain_type,
                    material_type: parentBatch.material_type || 'Fresh Frozen',
                    expected_yield: parentBatch.expected_yield || 3.5,
                    trim_weight: parentBatch.trim_weight,
                    net_weight_grams: cartsWeight,
                    extraction_output: cartsWeight,
                    planned_products: [{ type: 'Live Resin Carts' }],
                    cultivation_license: parentBatch.cultivation_license,
                    grower_name: parentBatch.grower_name,
                    metrc_tags: parentBatch.metrc_tags,
                    parent_batch_id: batchId,
                    is_sub_batch: true,
                    status: 'post_extraction',
                    timeline: [{
                        stage: 'split',
                        user: currentRole ? currentRole.name : "Unknown",
                        date: new Date().toISOString(),
                        action: 'Split from ' + batchId + ' for Live Resin Carts - ' + cartsWeight + 'g'
                    }],
                    created_at: new Date().toISOString()
                });
            }

            // Create AIOs sub-batch
            if (aiosWeight > 0) {
                const aiosSubId = batchBase + '-AIOs';
                subBatches.push({
                    id: aiosSubId,
                    strain: parentBatch.strain,
                    strain_type: parentBatch.strain_type,
                    material_type: parentBatch.material_type || 'Fresh Frozen',
                    expected_yield: parentBatch.expected_yield || 3.5,
                    trim_weight: parentBatch.trim_weight,
                    net_weight_grams: aiosWeight,
                    extraction_output: aiosWeight,
                    planned_products: [{ type: 'Live Resin AIOs' }],
                    cultivation_license: parentBatch.cultivation_license,
                    grower_name: parentBatch.grower_name,
                    metrc_tags: parentBatch.metrc_tags,
                    parent_batch_id: batchId,
                    is_sub_batch: true,
                    status: 'post_extraction',
                    timeline: [{
                        stage: 'split',
                        user: currentRole ? currentRole.name : "Unknown",
                        date: new Date().toISOString(),
                        action: 'Split from ' + batchId + ' for Live Resin AIOs - ' + aiosWeight + 'g'
                    }],
                    created_at: new Date().toISOString()
                });
            }

            // Insert sub-batches
            const { error: insertError } = await supabaseClient
                .from('wm_batches')
                .insert(subBatches);

            if (insertError) {
                console.error('Error creating sub-batches:', insertError);
                alert('Error creating sub-batches');
                return;
            }

            // Update parent batch status
            await supabaseClient
                .from('wm_batches')
                .update({
                    status: 'split',
                    net_weight_grams: (cartsWeight + aiosWeight),
                    timeline: [...(parentBatch.timeline || []), {
                        stage: 'split',
                        user: currentRole ? currentRole.name : "Unknown",
                        date: new Date().toISOString(),
                        action: 'Batch split into: ' + subBatches.map(b => b.id).join(', ')
                    }]
                })
                .eq('id', batchId);

            // Register sub-batches for RTA qualification tracking
            subBatches.forEach(sb => {
                const rtaType = sb.planned_products[0]?.type || 'BHO';
                registerQualificationBatch(rtaType, sb.id);
            });

            alert('âœ… Batch split successfully!\n\n' + subBatches.map(b => b.id + ' (' + b.net_weight_grams + 'g)').join('\n'));

            // Reset form
            document.getElementById('splitCartsWeight').value = '';
            document.getElementById('splitAIOsWeight').value = '';
            document.getElementById('splitBatchSection').style.display = 'none';

            // Refresh display
            loadBatches();
        }

        // Show/hide split section based on batch selection
        function checkShowSplitSection(batchId) {
            const splitSection = document.getElementById('splitBatchSection');
            if (!splitSection) return;

            const batch = batches.find(b => b.id === batchId);
            if (batch && (batch.material_type === 'Fresh Frozen' || isLiveResinBatch(batch))) {
                splitSection.style.display = 'block';
            } else {
                splitSection.style.display = 'none';
            }
        }

        // Check if batch is Live Resin
        function isLiveResinBatch(batch) {
            return batch.material_type === 'Fresh Frozen' ||
                   (batch.planned_products && batch.planned_products.includes('Live Resin'));
        }

        // ==================== COMPLIANCE ASSISTANT ====================
        // Full Colorado MED Rules Search (1 CCR 212-3) - Effective January 5, 2026

        let complianceData = null;
        let complianceLoading = false;

        async function loadComplianceData() {
            if (complianceData) return complianceData;
            if (complianceLoading) return null;

            complianceLoading = true;
            try {
                const response = await fetch('./compliance/compliance_rules.json');
                complianceData = await response.json();
                console.log('Loaded compliance data:', complianceData.ruleCount, 'rules');
                return complianceData;
            } catch (err) {
                console.error('Failed to load compliance data:', err);
                return null;
            } finally {
                complianceLoading = false;
            }
        }

        function openComplianceModal() {
            document.getElementById('complianceModal').style.display = 'block';
            document.getElementById('complianceSearchInput').value = '';
            document.getElementById('complianceResults').innerHTML = '<div style="text-align: center; color: var(--text-secondary); padding: 40px;"><div style="font-size: 3rem; margin-bottom: 15px;">ðŸ“š</div><p>Loading compliance database...</p></div>';

            // Pre-load the data
            loadComplianceData().then(data => {
                if (data) {
                    document.getElementById('complianceResults').innerHTML = '<div style="text-align: center; color: var(--text-secondary); padding: 40px;"><div style="font-size: 3rem; margin-bottom: 15px;">ðŸ“š</div><p>Search ' + data.ruleCount + ' Colorado MED rules or select a topic.</p><p style="font-size: 0.85rem; margin-top: 10px; color: var(--accent-green);">Full-text search across all 559 pages</p></div>';
                }
            });
        }

        function closeComplianceModal() {
            document.getElementById('complianceModal').style.display = 'none';
        }

        async function searchComplianceTopic(topic) {
            const topicMap = {
                'waste': ['3-900', '3-905', '3-910', '3-915', '3-920', '3-925', '3-930'],
                'metrc': ['3-800', '3-805', '3-810', '3-815', '3-820', '3-825'],
                'label': ['3-1000', '3-1005', '3-1010', '3-1015', '3-1020', '3-1025'],
                'security': ['3-305', '3-310', '3-315', '3-320', '3-325', '3-330'],
                'transport': ['3-1100', '3-1105', '3-1110', '3-1115'],
                'testing': ['3-600', '3-605', '3-610', '3-615', '3-620', '4-205', '4-210', '4-215', '4-220'],
                'reducedtesting': ['4-230']
            };

            const ruleNums = topicMap[topic];
            if (!ruleNums) return;

            const data = await loadComplianceData();
            if (!data) {
                document.getElementById('complianceResults').innerHTML = '<p style="color: var(--accent-red);">Failed to load compliance data.</p>';
                return;
            }

            let html = '<h3 style="color: var(--accent-green); margin: 0 0 20px 0;">' + topic.charAt(0).toUpperCase() + topic.slice(1) + ' Rules</h3>';

            ruleNums.forEach(num => {
                const ruleTexts = data.rules[num];
                if (ruleTexts && ruleTexts.length > 0) {
                    ruleTexts.forEach(text => {
                        const preview = text.length > 2000 ? text.substring(0, 2000) + '...' : text;
                        html += '<div class="compliance-result"><h4><span class="compliance-rule-num">' + num + '</span></h4><p>' + preview + '</p></div>';
                    });
                }
            });

            if (html.indexOf('compliance-result') === -1) {
                html += '<p style="color: var(--text-secondary);">No specific rules found for this topic in the database.</p>';
            }

            document.getElementById('complianceResults').innerHTML = html;
        }

        async function searchComplianceRules() {
            const query = document.getElementById('complianceSearchInput').value.toLowerCase().trim();
            if (!query) {
                alert('Please enter a search term');
                return;
            }

            document.getElementById('complianceResults').innerHTML = '<div style="text-align: center; padding: 40px;"><div class="spinner" style="border: 4px solid var(--border); border-top: 4px solid var(--accent-green); border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; margin: 0 auto;"></div><p style="color: var(--text-secondary); margin-top: 15px;">Searching ' + query + '...</p></div>';

            const data = await loadComplianceData();
            if (!data) {
                document.getElementById('complianceResults').innerHTML = '<p style="color: var(--accent-red);">Failed to load compliance data.</p>';
                return;
            }

            const results = [];
            const queryWords = query.split(/\s+/);

            // Search through chunks for context
            data.chunks.forEach((chunk, idx) => {
                const lowerText = chunk.text.toLowerCase();
                let matches = true;

                // Check if all query words are present
                for (const word of queryWords) {
                    if (!lowerText.includes(word)) {
                        matches = false;
                        break;
                    }
                }

                if (matches) {
                    // Find the best snippet around the match
                    const firstWordIdx = lowerText.indexOf(queryWords[0]);
                    const start = Math.max(0, firstWordIdx - 200);
                    const end = Math.min(chunk.text.length, firstWordIdx + 1500);
                    let snippet = chunk.text.substring(start, end);

                    if (start > 0) snippet = '...' + snippet;
                    if (end < chunk.text.length) snippet = snippet + '...';

                    // Highlight matches
                    queryWords.forEach(word => {
                        const regex = new RegExp('(' + word + ')', 'gi');
                        snippet = snippet.replace(regex, '<mark style="background: rgba(16, 185, 129, 0.3); padding: 2px 4px; border-radius: 3px;">$1</mark>');
                    });

                    results.push({
                        rules: chunk.rules,
                        snippet: snippet,
                        relevance: queryWords.filter(w => lowerText.includes(w)).length
                    });
                }
            });

            // Sort by relevance
            results.sort((a, b) => b.relevance - a.relevance);

            // Limit results
            const limitedResults = results.slice(0, 50);

            if (limitedResults.length === 0) {
                document.getElementById('complianceResults').innerHTML = '<div style="text-align: center; color: var(--text-secondary); padding: 40px;"><p>No results found for "<strong>' + query + '</strong>"</p><p style="font-size: 0.9rem; margin-top: 10px;">Try different keywords or check spelling</p></div>';
                return;
            }

            let html = '<p style="color: var(--text-secondary); margin-bottom: 20px;">Found <strong>' + results.length + '</strong> matches for "<strong>' + query + '</strong>"' + (results.length > 50 ? ' (showing first 50)' : '') + '</p>';

            limitedResults.forEach(result => {
                const ruleLabels = result.rules.length > 0 ? result.rules.map(r => '<span class="compliance-rule-num">' + r + '</span>').join(' ') : '<span style="color: var(--text-secondary);">General</span>';
                html += '<div class="compliance-result"><h4>' + ruleLabels + '</h4><p>' + result.snippet + '</p></div>';
            });

            document.getElementById('complianceResults').innerHTML = html;
        }
        
        // Inventory Management Functions
        // Pull Batch Functions
        
        function openPullBatchModal(machine) {
            currentPullMachine = machine;
            const machineName = machine === 'left' ? 'Left Machine' : 'Right Machine';
            document.getElementById('pullBatchModalTitle').textContent = `ðŸ«™ Pull Batch from ${machineName}`;
            
            // Get machine status from Supabase
            supabaseClient
                .from('wm_machine_status')
                .select('*')
                .eq('machine', machine)
                .single()
                .then(({ data: machineStatus, error }) => {
                    if (error) {
                        console.error('Error loading machine status:', error);
                        machineStatus = {};
                    }
                    
                    if (!machineStatus.pot_batch) {
                        alert('âš ï¸ No batch in pot!\n\nPlease load a batch in the pot first using the machine status button.');
                        return;
                    }
                    
                    // Parse pot ledger
                    let potLedger = machineStatus.pot_ledger || [];
                    if (typeof potLedger === 'string') {
                        try { potLedger = JSON.parse(potLedger); } catch(e) { potLedger = []; }
                    }

                    // Get batch info
                    const batch = batches.find(b => b.id == machineStatus.pot_batch);
                    if (batch) {
                        document.getElementById('pullBatchNumber').textContent = batch.id;
                        document.getElementById('pullBatchStrain').textContent = batch.strain || 'Unknown Strain';

                        // Calculate total trim weight from pot ledger
                        let totalTrimWeight = 0;
                        if (potLedger.length > 0) {
                            totalTrimWeight = potLedger.reduce((sum, p) => sum + (p.trim_weight || 0), 0);
                        }

                        // Calculate projected yield based on material type
                        const expectedYield = getExpectedYieldFromConfig(batch.material_type) / 100;
                        const projectedYield = totalTrimWeight * expectedYield;

                        document.getElementById('pullBatchTrimWeight').textContent = `${Math.round(totalTrimWeight)}g`;
                        document.getElementById('pullBatchProjectedYield').textContent = `${projectedYield.toFixed(1)}g`;

                        // Show pot contents with source breakdown
                        let runsText = `${machineStatus.pot_runs || 0} runs collected`;
                        if (potLedger.length > 0) {
                            const totalSocks = potLedger.reduce((sum, p) => sum + p.socks, 0);
                            runsText += ` â€¢ ${totalSocks} total socks`;
                            if (potLedger.length > 1) {
                                runsText += `\nðŸ“¦ Sources:\n`;
                                potLedger.forEach(p => {
                                    runsText += `  â€¢ ${p.batch_id}: ${p.socks} socks (${Math.round(p.trim_weight)}g) - ${p.metrc_tag || 'No tag'}\n`;
                                });
                            }
                        }
                        document.getElementById('pullBatchRuns').innerHTML = runsText.replace(/\n/g, '<br>');
                    }

                    // Clear form
                    document.getElementById('pullProductType').value = '';
                    document.getElementById('pullSlabs').value = '';
                    document.getElementById('pullBowls').value = '';
                    document.getElementById('pullNotes').value = '';
                    updatePullFields();
                    
                    document.getElementById('pullBatchModal').style.display = 'block';
                });
        }
        
        function closePullBatchModal() {
            document.getElementById('pullBatchModal').style.display = 'none';
            currentPullMachine = null;
        }
        
        function updatePullFields() {
            const productType = document.getElementById('pullProductType').value;
            
            document.getElementById('shatterFields').style.display = productType === 'shatter' ? 'block' : 'none';
            document.getElementById('waxFields').style.display = (productType === 'wax' || productType === 'sugar_wax' || productType === 'live_resin') ? 'block' : 'none';
        }
        
        function submitPullBatch() {
            if (!currentPullMachine) return;
            
            // Get machine status from Supabase
            supabaseClient
                .from('wm_machine_status')
                .select('*')
                .eq('machine', currentPullMachine)
                .single()
                .then(({ data: machineStatus, error }) => {
                    if (error || !machineStatus || !machineStatus.pot_batch) {
                        alert('No batch in pot!');
                        return;
                    }
                    
                    const productType = document.getElementById('pullProductType').value;
                    const slabs = parseInt(document.getElementById('pullSlabs').value) || 0;
                    const bowls = parseInt(document.getElementById('pullBowls').value) || 0;
                    const notes = document.getElementById('pullNotes').value;
                    
                    if (!productType) {
                        alert('Please select a product type');
                        return;
                    }
                    
                    if (productType === 'shatter' && slabs === 0) {
                        alert('Please enter the number of slabs');
                        return;
                    }
                    
                    if ((productType === 'wax' || productType === 'sugar_wax' || productType === 'live_resin') && bowls === 0) {
                        alert('Please enter the number of bowls');
                        return;
                    }
                    
                    // Get batch info
                    const batch = batches.find(b => b.id == machineStatus.pot_batch);
                    
                    if (!batch) {
                        alert('Batch not found!');
                        return;
                    }
                    
                    // Continue with the rest of the pull batch logic...
                    completePullBatch(batch, machineStatus, productType, slabs, bowls, notes);
                });
        }
        
        function completePullBatch(batch, machineStatus, productType, slabs, bowls, notes) {
            // Parse pot ledger for source contributions
            let potLedger = machineStatus.pot_ledger || [];
            if (typeof potLedger === 'string') {
                try { potLedger = JSON.parse(potLedger); } catch(e) { potLedger = []; }
            }

            // Create pull record
            const pullRecord = {
                batchId: machineStatus.pot_batch,
                batchNumber: batch.id,
                machine: currentPullMachine,
                productType: productType,
                slabs: slabs,
                bowls: bowls,
                runs: machineStatus.pot_runs || 0,
                notes: notes,
                timestamp: new Date().toISOString(),
                pulledBy: currentRole ? currentRole.name : 'Unknown',
                source_contributions: potLedger
            };

            // Save to localStorage
            const pullHistory = JSON.parse(localStorage.getItem('wm_pull_history') || '[]');
            pullHistory.push(pullRecord);
            localStorage.setItem('wm_pull_history', JSON.stringify(pullHistory));

            // Update batch status to 'extraction' (completing extraction phase)
            const productTypeText = productType === 'shatter' ? 'Shatter' : productType === 'wax' ? 'Wax' : productType === 'sugar_wax' ? 'Sugar Wax' : productType === 'live_resin' ? 'Live Resin Oil' : 'Unknown';
            const amountText = productType === 'shatter' ? `${slabs} slab(s)` : `${bowls} bowl(s)`;

            // Build source contributions summary for timeline
            let sourcesSummary = '';
            if (potLedger.length > 1) {
                sourcesSummary = ' | Sources: ' + potLedger.map(p => `${p.batch_id}(${p.socks}socks)`).join(', ');
            }

            // Always move to extraction status when pot is pulled
            // Remaining socks will still show in extraction queue based on socks_remaining > 0
            const socksRemaining = batch.socks_remaining ?? 0;

            const updatedBatch = {
                ...batch,
                status: 'extraction',
                extraction_method: 'BHO',
                product_type: productTypeText,
                product_made: productTypeText, // Also set product_made for finishing dropdown
                extraction_machine: currentPullMachine === 'left' ? 'Machine 1 (Left)' : 'Machine 2 (Right)',
                extraction_runs: machineStatus.pot_runs || 0,
                extraction_slabs: productType === 'shatter' ? slabs : null,
                extraction_bowls: (productType === 'wax' || productType === 'sugar_wax' || productType === 'live_resin') ? bowls : null,
                extraction_notes: notes,
                extraction_user: currentRole ? currentRole.name : 'Unknown',
                extraction_date: new Date().toISOString().split('T')[0],
                source_contributions: potLedger, // Save pot ledger as source contributions
                timeline: [
                    ...(batch.timeline || []),
                    {
                        timestamp: new Date().toISOString(),
                        stage: 'extraction',
                        user: currentRole ? currentRole.name : 'Unknown',
                        action: `Extraction completed - ${productTypeText} - ${amountText} - ${machineStatus.pot_runs || 0} runs - ${currentPullMachine === 'left' ? 'Machine 1 (Left)' : 'Machine 2 (Right)'}${sourcesSummary}`
                    }
                ]
            };
            
            // Update batch in Supabase
            supabaseClient
                .from('wm_batches')
                .update(updatedBatch)
                .eq('id', batch.id)
                .then(({ error, data }) => {
                    if (error) {
                        console.error('Error updating batch:', error);
                        console.error('Error details:', JSON.stringify(error, null, 2));
                        console.error('Batch data being sent:', updatedBatch);
                        alert(`Error completing extraction:\n\n${error.message || JSON.stringify(error)}\n\nCheck console for details.`);
                        return;
                    }
                    
                    // Clear pot in machine status in Supabase
                    const clearedPotStatus = {
                        machine: currentPullMachine,
                        pot_batch: null,
                        pot_runs: 0,
                        pot_ledger: [], // Clear the pot ledger
                        column_batch: machineStatus.column_batch, // Keep column A
                        column_b_batch: machineStatus.column_b_batch, // Keep column B
                        filter_clay: machineStatus.filter_clay, // Keep filter
                        filter_silica: machineStatus.filter_silica,
                        filter_runs: machineStatus.filter_runs,
                        last_updated: new Date().toISOString(),
                        updated_by: currentRole ? currentRole.name : 'Unknown'
                    };
                    
                    supabaseClient
                        .from('wm_machine_status')
                        .upsert(clearedPotStatus, { onConflict: 'machine' })
                        .then(() => {
                            // Reload batches and update displays
                            loadBatches();
                            updateMachineDisplays();
                            closePullBatchModal();

                            const statusMsg = socksRemaining > 0
                                ? `Batch moved to Post-Extraction.\nâš ï¸ ${socksRemaining} sock(s) remaining - still visible in extraction queue.`
                                : 'Batch moved to Post-Extraction.';
                            alert(`âœ… Extraction Complete!\n\n${batch.id}\n${productTypeText}: ${amountText}\n${machineStatus.pot_runs || 0} runs\n\n${statusMsg}\nPot has been emptied.`);
                        });
                });
        }

        // ==========================================
        // Extraction Queue & Column Loading Functions
        // ==========================================

        function populateExtractionQueue() {
            const queueEl = document.getElementById('extractionQueueList');
            if (!queueEl) return;

            // Get batches with socks remaining (intake status OR any status with socks left)
            const queueBatches = batches.filter(b => {
                // Always show intake batches with socks
                if (b.status === 'intake') {
                    if (b.socks_total != null && b.socks_remaining === 0) return false;
                    return true;
                }
                // Also show batches at other statuses if they still have socks remaining
                if (b.socks_total != null && b.socks_remaining > 0) return true;
                return false;
            });

            if (queueBatches.length === 0) {
                queueEl.innerHTML = `<div style="text-align: center; color: var(--text-secondary); padding: 20px;">
                    No batches waiting for extraction
                </div>`;
                return;
            }

            queueEl.innerHTML = queueBatches.map(batch => {
                const socksRemaining = batch.socks_remaining ?? batch.socks_total ?? null;
                const socksTotal = batch.socks_total ?? null;
                const hasSocks = socksTotal !== null;
                const sockDisplay = hasSocks ? `${socksRemaining}/${socksTotal}` : 'Not set';
                const sockColor = !hasSocks ? 'var(--accent-red)' :
                                  socksRemaining === 1 ? 'var(--accent-orange)' : 'var(--accent-green)';
                const rolloverWarning = socksRemaining === 1 ? ' âš ï¸' : '';

                return `<div style="background: var(--bg-secondary); padding: 12px; border-radius: 8px; margin-bottom: 10px; border-left: 4px solid ${sockColor};">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <div style="font-weight: 700; font-family: 'Space Mono', monospace;">${batch.id}</div>
                            <div style="font-size: 0.85rem; color: var(--text-secondary);">${batch.strain} â€¢ ${batch.material_agreement}</div>
                            <div style="font-size: 0.8rem; color: var(--text-secondary);">${batch.cultivation_license || batch.grower_name || ''}</div>
                        </div>
                        <div style="text-align: right;">
                            <div style="font-size: 1.2rem; font-weight: 700; color: ${sockColor};">
                                ðŸ§¦ ${sockDisplay}${rolloverWarning}
                            </div>
                            <button class="btn" style="padding: 5px 10px; font-size: 0.75rem; background: var(--accent-blue);" onclick="editBatchSocks('${batch.id}', ${socksTotal || 0})">
                                Edit Socks
                            </button>
                        </div>
                    </div>
                </div>`;
            }).join('');
        }

        async function editBatchSocks(batchId, currentSocks) {
            const newSocks = prompt(`Enter number of socks for ${batchId}:`, currentSocks || '');
            if (newSocks === null) return;

            const socksNum = parseInt(newSocks);
            if (isNaN(socksNum) || socksNum < 1) {
                alert('Please enter a valid number of socks (1 or more)');
                return;
            }

            const batch = batches.find(b => b.id === batchId);
            if (!batch) return;

            const trimPerSock = batch.trim_weight / socksNum;
            const socksUsed = (batch.socks_total || 0) - (batch.socks_remaining || 0);
            const socksRemaining = Math.max(0, socksNum - socksUsed);

            const { error } = await supabaseClient
                .from('wm_batches')
                .update({
                    socks_total: socksNum,
                    socks_remaining: socksRemaining,
                    trim_per_sock: trimPerSock
                })
                .eq('id', batchId);

            if (error) {
                console.error('Error updating socks:', error);
                alert('Error updating socks. Please try again.');
                return;
            }

            await loadBatches();
            populateExtractionQueue();
            alert(`âœ… ${batchId} updated to ${socksNum} socks`);
        }

        // ==========================================
        // Machine Status Tracking
        // ==========================================

        function generateMachineColumns(machineKey) {
            const container = document.getElementById('machineColumnsContainer');
            if (!container) return;

            // Find machine config
            const machineConfig = CONFIG.machines.find(m => {
                const key = (m.position?.toLowerCase() || m.name.toLowerCase()).replace(/[^a-z0-9]/g, '');
                return key === machineKey;
            }) || CONFIG.machines[0] || CONFIG_DEFAULTS.machines[0];

            const config = machineConfig.config || {};
            console.log("Machine config for", machineKey, ":", {
                machineType: machineConfig.machine_type,
                config: config,
                second_wash: config.second_wash,
                second_wash_type: typeof config.second_wash,
                second_sift: config.second_sift,
                second_sift_type: typeof config.second_sift
            });
            const numColumns = config.columns || 6;
            const machineType = machineConfig.machine_type || 'bho';

            // Generate columns HTML based on machine type
            let columnsHtml = '';

            if (machineType === 'bho') {
                // For BHO, show columns A-F based on config (2-6 columns)
                const columnLabels = ['A', 'B', 'C', 'D', 'E', 'F'];
                const colCount = Math.min(6, Math.max(2, numColumns));
                for (let i = 0; i < colCount; i++) {
                    const col = columnLabels[i];
                    columnsHtml += generateColumnHtml(col, 'machineColumn' + col + 'Batch');
                }
            } else if (machineType === 'rosin') {
                // Rosin washer - show wash stages
                columnsHtml += '<div style="background: rgba(59, 130, 246, 0.1); border-left: 4px solid var(--accent-blue); padding: 20px; border-radius: 8px; margin-bottom: 20px;">';
                columnsHtml += '<h3 style="color: var(--accent-blue); margin: 0 0 15px 0;">ðŸ«§ Wash 1</h3>';
                columnsHtml += '<div class="form-group"><label>Batch</label><select id="rosinWash1Batch"><option value="">Empty</option></select></div>';
                columnsHtml += '</div>';
                if (config.second_wash === true) {
                    columnsHtml += '<div style="background: rgba(59, 130, 246, 0.1); border-left: 4px solid var(--accent-blue); padding: 20px; border-radius: 8px; margin-bottom: 20px;">';
                    columnsHtml += '<h3 style="color: var(--accent-blue); margin: 0 0 15px 0;">ðŸ«§ Wash 2</h3>';
                    columnsHtml += '<div class="form-group"><label>Batch</label><select id="rosinWash2Batch"><option value="">Empty</option></select></div>';
                    columnsHtml += '</div>';
                }
            } else if (machineType === 'resinator') {
                // Resinator - process large batch in multiple barrel loads
                columnsHtml += '<div style="background: rgba(147, 51, 234, 0.1); border-left: 4px solid var(--accent-purple); padding: 20px; border-radius: 8px; margin-bottom: 20px;">';
                columnsHtml += '<h3 style="color: var(--accent-purple); margin: 0 0 15px 0;">ðŸ“¦ Batch Selection</h3>';
                columnsHtml += '<div class="form-group"><label>Batch to Process</label><select id="resinatorBatch" onchange="updateResinatorBatchInfo()"><option value="">Select Batch...</option></select></div>';
                columnsHtml += '<div id="batchRemainingDisplay" style="padding: 12px; background: var(--bg-tertiary); border-radius: 8px; margin-top: 10px; display: none;">';
                columnsHtml += '<div style="display: flex; justify-content: space-between; margin-bottom: 8px;"><span>Remaining to Run:</span><strong id="batchRemainingWeight">0g</strong></div>';
                columnsHtml += '<div style="display: flex; justify-content: space-between; color: var(--text-secondary); font-size: 0.9rem;"><span>Trim for Socks:</span><strong id="batchTrimForSocks">0g</strong></div>';
                columnsHtml += '</div>';
                columnsHtml += '</div>';

                // Current Barrel Load
                columnsHtml += '<div id="barrelLoadSection" style="background: rgba(59, 130, 246, 0.1); border-left: 4px solid var(--accent-blue); padding: 20px; border-radius: 8px; margin-bottom: 20px;">';
                columnsHtml += '<h3 style="color: var(--accent-blue); margin: 0 0 15px 0;">ðŸ¥ Current Barrel Load</h3>';
                columnsHtml += '<div class="form-group"><label>Material in Barrel (g)</label><input type="number" id="resinatorInputWeight" step="0.1" placeholder="Weight loaded in barrel"></div>';
                columnsHtml += '<div class="form-grid" style="margin-top: 15px;">';
                columnsHtml += '<div class="form-group"><label>1st Sift Hash (g)</label><input type="number" id="resinatorSift1Output" step="0.1" placeholder="First pass yield"></div>';
                columnsHtml += '<div class="form-group"><label>2nd Sift Hash (g)</label><input type="number" id="resinatorSift2Output" step="0.1" placeholder="Second pass (optional)"></div>';
                columnsHtml += '</div>';
                columnsHtml += '<button type="button" class="btn" style="background: var(--accent-blue); width: 100%; padding: 12px; margin-top: 15px;" onclick="completeBarrelRun()">âœ… Complete Barrel Run</button>';
                columnsHtml += '</div>';

                // Session totals - First sift vs Second sift
                columnsHtml += '<div id="siftTotalsDisplay" style="background: var(--bg-tertiary); padding: 15px; border-radius: 8px; margin-bottom: 20px;">';
                columnsHtml += '<h4 style="margin: 0 0 15px 0;">ðŸ“Š Session Totals</h4>';
                columnsHtml += '<div id="siftTotalsContent">';
                columnsHtml += '<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; text-align: center;">';
                columnsHtml += '<div style="background: rgba(16, 185, 129, 0.2); padding: 15px; border-radius: 8px;"><div style="font-size: 0.85rem; color: var(--text-secondary);">1st Sift Total</div><div id="totalFirstSift" style="font-size: 1.5rem; font-weight: 700; color: var(--accent-green);">0g</div></div>';
                columnsHtml += '<div style="background: rgba(245, 158, 11, 0.2); padding: 15px; border-radius: 8px;"><div style="font-size: 0.85rem; color: var(--text-secondary);">2nd Sift Total</div><div id="totalSecondSift" style="font-size: 1.5rem; font-weight: 700; color: var(--accent-orange);">0g</div></div>';
                columnsHtml += '</div>';
                columnsHtml += '<div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--border);"><div style="display: flex; justify-content: space-between;"><span>Total Material Processed:</span><strong id="totalProcessed">0g</strong></div>';
                columnsHtml += '<div style="display: flex; justify-content: space-between; margin-top: 5px;"><span>Barrel Runs:</span><strong id="totalRuns">0</strong></div></div>';
                columnsHtml += '</div></div>';

                // Run history
                columnsHtml += '<div id="runHistorySection" style="background: var(--bg-secondary); padding: 15px; border-radius: 8px; margin-bottom: 20px; display: none;">';
                columnsHtml += '<h4 style="margin: 0 0 10px 0;">ðŸ“‹ Run History</h4>';
                columnsHtml += '<div id="runHistoryContent" style="max-height: 200px; overflow-y: auto;"></div>';
                columnsHtml += '</div>';

                // Complete batch button
                columnsHtml += '<button type="button" class="btn" style="background: var(--accent-green); width: 100%; padding: 12px;" onclick="completeResinatorBatch()">âœ… Complete Batch & Start Next</button>';
            }

            // Add columns configured count display
            if (machineType === 'bho') {
                columnsHtml = '<div style="text-align: center; padding: 10px; background: var(--bg-tertiary); border-radius: 8px; margin-bottom: 15px; color: var(--text-secondary);">' +
                    '<strong>' + numColumns + ' Columns</strong> | ' + (config.socks_per_run || 6) + ' socks per run</div>' + columnsHtml;
            }

            container.innerHTML = columnsHtml;

            return machineConfig;
        }

        function generateColumnHtml(col, selectId) {
            return '<div style="background: rgba(59, 130, 246, 0.1); border-left: 4px solid var(--accent-blue); padding: 20px; border-radius: 8px; margin-bottom: 20px;">' +
                '<h3 style="color: var(--accent-blue); margin: 0 0 15px 0;">ðŸ“¦ Column ' + col + '</h3>' +
                '<div class="form-grid">' +
                    '<div class="form-group">' +
                        '<label>Primary Batch</label>' +
                        '<select id="' + selectId + '" onchange="updateColumnSockUI(\'' + col + '\')">' +
                            '<option value="">Empty / Not Loaded</option>' +
                        '</select>' +
                    '</div>' +
                    '<div class="form-group">' +
                        '<label>Socks</label>' +
                        '<select id="machineColumn' + col + 'Socks" onchange="updateColumnSockUI(\'' + col + '\')">' +
                            '<option value="0">0</option>' +
                            '<option value="1">1</option>' +
                            '<option value="2">2</option>' +
                        '</select>' +
                    '</div>' +
                '</div>' +
                '<div id="column' + col + 'SecondSock" style="display: none; margin-top: 15px; padding-top: 15px; border-top: 1px dashed var(--border);">' +
                    '<div class="form-grid">' +
                        '<div class="form-group">' +
                            '<label style="color: var(--accent-orange);">+ Second Sock From</label>' +
                            '<select id="machineColumn' + col + 'SecondBatch">' +
                                '<option value="">None</option>' +
                            '</select>' +
                        '</div>' +
                    '</div>' +
                '</div>' +
                '<button type="button" class="btn" style="background: var(--accent-orange); width: 100%; padding: 12px; margin-top: 15px;" onclick="runColumnToPot(\'' + col + '\')">' +
                    'âš—ï¸ Run Column ' + col + ' to Pot' +
                '</button>' +
            '</div>';
        }

        // Open component selector - for now, opens the full machine modal
        function openComponentSelector(machineKey, component) {
            // Just open the machine modal for now - can be enhanced later for quick selection
            openMachineModal(machineKey);
        }

        // Open Pull Batch modal from within the machine modal
        function openPullBatchFromModal() {
            if (!currentMachine) return;
            // Close the machine modal first
            document.getElementById('machineModal').style.display = 'none';
            // Then open the pull batch modal
            openPullBatchModal(currentMachine);
        }

        function openMachineModal(machine) {
            currentMachine = machine;

            // Generate columns based on machine config
            const machineConfig = generateMachineColumns(machine);
            const machineName = machineConfig?.name || (machine === 'left' ? 'Left Machine' : 'Right Machine');
            const machineType = machineConfig?.machine_type || 'bho';
            const icon = machineType === 'bho' ? 'âš—ï¸' : machineType === 'rosin' ? 'ðŸ«§' : 'ðŸŒ€';
            document.getElementById('machineModalTitle').textContent = icon + ' ' + machineName;

            // Show/hide sections based on machine type
            const potSection = document.getElementById('machinePotSection');
            const filterSection = document.getElementById('machineFilterSection');
            const formButtons = document.getElementById('machineFormButtons');
            if (potSection) potSection.style.display = (machineType === 'bho' || machineType === 'rosin') ? 'block' : 'none';
            if (filterSection) filterSection.style.display = machineType === 'bho' ? 'block' : 'none';
            if (formButtons) formButtons.style.display = machineType === 'resinator' ? 'none' : 'grid';

            // Load machine status - from localStorage in demo mode, Supabase otherwise
            const loadStatus = DEMO_MODE
                ? Promise.resolve({ data: demoGetMachineStatus(machine), error: null })
                : supabaseClient.from('wm_machine_status').select('*').eq('machine', machine).single();

            loadStatus.then(({ data: machineStatus, error }) => {
                    if (error && !DEMO_MODE) {
                        console.error('Error loading machine status:', error);
                        machineStatus = {};
                    }
                    machineStatus = machineStatus || {};

                    // Store current machine status for later use
                    window.currentMachineStatus = machineStatus;

                    // Populate batch dropdowns with sock counts (for BHO machines)
                    // Dynamically handle columns A-F
                    const columnLabels = ['A', 'B', 'C', 'D', 'E', 'F'];
                    columnLabels.forEach(col => {
                        const columnSelect = document.getElementById('machineColumn' + col + 'Batch');
                        const secondBatchSelect = document.getElementById('machineColumn' + col + 'SecondBatch');
                        const socksSelect = document.getElementById('machineColumn' + col + 'Socks');

                        if (columnSelect) {
                            // Clear and repopulate with sock counts
                            columnSelect.innerHTML = '<option value="">Empty / Not Loaded</option>';
                            if (secondBatchSelect) secondBatchSelect.innerHTML = '<option value="">None</option>';

                            batches.forEach(batch => {
                                // Show intake batches OR any batch with socks remaining
                                const hasSocksRemaining = batch.socks_total != null && batch.socks_remaining > 0;
                                if (batch.status === 'intake' || hasSocksRemaining) {
                                    // Skip batches with 0 socks remaining
                                    if (batch.socks_total != null && batch.socks_remaining === 0) return;
                                    const socksRemaining = batch.socks_remaining ?? batch.socks_total ?? '?';
                                    const socksTotal = batch.socks_total ?? '?';
                                    const statusLabel = batch.status !== 'intake' ? ` [${batch.status}]` : '';
                                    const sockDisplay = `(${socksRemaining}/${socksTotal} socks)${statusLabel}`;
                                    const option = `<option value="${batch.id}">${batch.id} - ${batch.strain} ${sockDisplay}</option>`;
                                    columnSelect.innerHTML += option;
                                    if (secondBatchSelect) secondBatchSelect.innerHTML += option;
                                }
                            });

                            // Set current values from machine status
                            const colKey = col.toLowerCase();
                            // Handle legacy format (column_batch for A, column_b_batch for B) and new format
                            const batchKey = col === 'A' ? 'column_batch' : `column_${colKey}_batch`;
                            const socksKey = `column_${colKey}_socks`;
                            const secondBatchKey = `column_${colKey}_second_batch`;

                            columnSelect.value = machineStatus[batchKey] || '';
                            if (socksSelect) socksSelect.value = machineStatus[socksKey] || 0;
                            if (secondBatchSelect) secondBatchSelect.value = machineStatus[secondBatchKey] || '';
                        }
                    });

                    // Set pot batch (hidden input and display)
                    const potBatchId = machineStatus.pot_batch || '';
                    document.getElementById('machinePotBatch').value = potBatchId;
                    if (potBatchId) {
                        const potBatch = batches.find(b => b.id === potBatchId);
                        document.getElementById('machinePotBatchDisplay').value = potBatch ?
                            `${potBatchId} - ${potBatch.strain}` : potBatchId;
                    } else {
                        document.getElementById('machinePotBatchDisplay').value = '';
                    }

                    document.getElementById('machinePotRuns').value = machineStatus.pot_runs || 0;

                    // Show/hide Pull Batch button based on pot status
                    const pullBatchBtn = document.getElementById('modalPullBatchBtn');
                    if (pullBatchBtn) {
                        pullBatchBtn.style.display = potBatchId ? 'block' : 'none';
                    }

                    document.getElementById('machineFilterClay').value = machineStatus.filter_clay || '';
                    document.getElementById('machineFilterSilica').value = machineStatus.filter_silica || '';
                    document.getElementById('machineFilterRuns').value = machineStatus.filter_runs || '';

                    // Handle secondary sock selectors visibility and trigger UI updates (for BHO machines)
                    columnLabels.forEach(col => {
                        const colKey = col.toLowerCase();
                        const secondSockDiv = document.getElementById('column' + col + 'SecondSock');
                        if (secondSockDiv) secondSockDiv.style.display = 'none';

                        // Trigger UI update for each column if batch is set
                        const batchKey = col === 'A' ? 'column_batch' : `column_${colKey}_batch`;
                        if (machineStatus[batchKey]) {
                            setTimeout(() => updateColumnSockUI(col), 100);
                        }
                    });

                    // Display pot ledger
                    displayPotLedger(machineStatus);

                    // Populate resinator batch dropdown - only show pre-sift batches
                    const resinatorBatchSelect = document.getElementById('resinatorBatch');
                    if (resinatorBatchSelect) {
                        resinatorBatchSelect.innerHTML = '<option value="">Select Batch...</option>';
                        batches.forEach(batch => {
                            // Only show intake batches with pre_sift: yes and remaining trim
                            if (batch.status === 'intake' && batch.pre_sift === 'yes' && (batch.trim_weight || 0) > 0) {
                                const option = `<option value="${batch.id}">${batch.id} - ${batch.strain} (${batch.trim_weight || 0}g)</option>`;
                                resinatorBatchSelect.innerHTML += option;
                            }
                        });

                        // Restore saved batch selection
                        if (machineStatus.current_batch) {
                            resinatorBatchSelect.value = machineStatus.current_batch;
                        }

                        // Update batch info display and totals
                        setTimeout(() => {
                            updateResinatorBatchInfo();
                            updateResinatorTotals();
                        }, 100);
                    }

                    document.getElementById('machineModal').style.display = 'block';
                });
        }

        function displayPotLedger(machineStatus) {
            const potLedgerDisplay = document.getElementById('potLedgerDisplay');
            let potLedger = machineStatus?.pot_ledger || [];
            if (typeof potLedger === 'string') {
                try { potLedger = JSON.parse(potLedger); } catch(e) { potLedger = []; }
            }

            if (potLedger.length === 0) {
                potLedgerDisplay.style.display = 'none';
                return;
            }

            const totalSocks = potLedger.reduce((sum, p) => sum + p.socks, 0);
            let html = `<div style="font-weight: 700; margin-bottom: 8px;">ðŸ“¦ Pot Contents (${totalSocks} socks total):</div>`;
            potLedger.forEach(p => {
                const percentage = ((p.socks / totalSocks) * 100).toFixed(0);
                html += `<div style="padding: 4px 0; border-bottom: 1px solid var(--border);">
                    <strong>${p.batch_id}</strong> - ${p.strain || 'Unknown'}: ${p.socks} socks (${percentage}%) â€¢ ${Math.round(p.trim_weight)}g
                    <div style="font-size: 0.8rem; color: var(--text-secondary);">Tag: ${p.metrc_tag || 'Not set'}</div>
                </div>`;
            });
            potLedgerDisplay.innerHTML = html;
            potLedgerDisplay.style.display = 'block';
        }

        function displaySiftTotals(machineStatus) {
            const display = document.getElementById('siftTotalsDisplay');
            const content = document.getElementById('siftTotalsContent');
            if (!display || !content) return;

            const siftLedger = machineStatus?.sift_ledger || [];
            if (siftLedger.length === 0) {
                display.style.display = 'none';
                return;
            }

            let totalInput = 0;
            let totalOutput = 0;
            let html = '';

            siftLedger.forEach(entry => {
                totalInput += entry.input_weight || 0;
                totalOutput += entry.output_weight || 0;
                const yieldPct = entry.input_weight > 0 ? ((entry.output_weight / entry.input_weight) * 100).toFixed(1) : 0;
                html += `<div style="padding: 8px 0; border-bottom: 1px solid var(--border);">
                    <strong>${entry.batch_id}</strong> - Sift ${entry.sift_number}: ${entry.input_weight}g â†’ ${entry.output_weight}g hash (${yieldPct}% yield)
                </div>`;
            });

            const totalYield = totalInput > 0 ? ((totalOutput / totalInput) * 100).toFixed(1) : 0;
            html += `<div style="padding: 12px 0; font-weight: 700; color: var(--accent-green);">
                Total: ${totalInput.toFixed(1)}g input â†’ ${totalOutput.toFixed(1)}g hash (${totalYield}% yield)
            </div>`;

            content.innerHTML = html;
            display.style.display = 'block';
        }

        function updateResinatorBatchInfo() {
            const batchSelect = document.getElementById('resinatorBatch');
            const remainingDisplay = document.getElementById('batchRemainingDisplay');
            const remainingWeight = document.getElementById('batchRemainingWeight');
            const trimForSocks = document.getElementById('batchTrimForSocks');

            if (!batchSelect) return;

            const batchId = batchSelect.value;
            if (!batchId) {
                if (remainingDisplay) remainingDisplay.style.display = 'none';
                return;
            }

            const batch = batches.find(b => b.id === batchId);
            if (batch && remainingDisplay && remainingWeight) {
                // Calculate remaining to run = original trim minus total input processed
                const status = window.currentMachineStatus || {};
                let siftLedger = status.sift_ledger || [];
                if (typeof siftLedger === 'string') {
                    try { siftLedger = JSON.parse(siftLedger); } catch(e) { siftLedger = []; }
                }

                // Sum up input weights for this batch from the ledger
                const totalInputProcessed = siftLedger
                    .filter(r => r.batch_id === batchId)
                    .reduce((sum, r) => sum + (r.input_weight || 0), 0);

                // Original trim = current trim_weight + total sift collected (since sift reduces trim_weight)
                const totalSiftCollected = siftLedger
                    .filter(r => r.batch_id === batchId)
                    .reduce((sum, r) => sum + (r.first_sift || 0) + (r.second_sift || 0), 0);

                const originalTrim = (batch.trim_weight || 0) + totalSiftCollected;
                const remainingToRun = Math.max(0, originalTrim - totalInputProcessed);
                const trimForSocksWeight = batch.trim_weight || 0;

                remainingWeight.textContent = `${remainingToRun.toFixed(0)}g`;
                if (trimForSocks) trimForSocks.textContent = `${trimForSocksWeight.toFixed(0)}g`;
                remainingDisplay.style.display = 'block';

                // Store current batch in status
                window.currentMachineStatus = window.currentMachineStatus || {};
                window.currentMachineStatus.current_batch = batchId;
            }
        }

        function completeBarrelRun() {
            const batchSelect = document.getElementById('resinatorBatch');
            const inputWeightEl = document.getElementById('resinatorInputWeight');
            const sift1OutputEl = document.getElementById('resinatorSift1Output');
            const sift2OutputEl = document.getElementById('resinatorSift2Output');

            if (!batchSelect || !inputWeightEl) {
                alert('Error: Form elements not found');
                return;
            }

            const batchId = batchSelect.value;
            const inputWeight = parseFloat(inputWeightEl.value) || 0;
            const sift1Output = parseFloat(sift1OutputEl?.value) || 0;
            const sift2Output = parseFloat(sift2OutputEl?.value) || 0;

            if (!batchId) {
                alert('Please select a batch to process');
                return;
            }
            if (inputWeight <= 0) {
                alert('Please enter the material weight loaded in the barrel');
                return;
            }
            if (sift1Output <= 0 && sift2Output <= 0) {
                alert('Please enter at least one sift yield');
                return;
            }

            const batch = batches.find(b => b.id === batchId);
            const totalOutput = sift1Output + sift2Output;
            const yieldPct = ((totalOutput / inputWeight) * 100).toFixed(1);

            let confirmMsg = `Complete Barrel Run?\n\nBatch: ${batchId} - ${batch?.strain || 'Unknown'}\nInput: ${inputWeight}g\n`;
            if (sift1Output > 0) confirmMsg += `1st Sift: ${sift1Output}g\n`;
            if (sift2Output > 0) confirmMsg += `2nd Sift: ${sift2Output}g\n`;
            confirmMsg += `Total Yield: ${totalOutput}g (${yieldPct}%)`;

            if (!confirm(confirmMsg)) {
                return;
            }

            // Get current sift ledger
            const currentStatus = window.currentMachineStatus || {};
            let siftLedger = currentStatus.sift_ledger || [];
            if (typeof siftLedger === 'string') {
                try { siftLedger = JSON.parse(siftLedger); } catch(e) { siftLedger = []; }
            }

            // Add run to ledger
            siftLedger.push({
                batch_id: batchId,
                strain: batch?.strain || '',
                input_weight: inputWeight,
                first_sift: sift1Output,
                second_sift: sift2Output,
                timestamp: new Date().toISOString()
            });

            // Update machine status
            window.currentMachineStatus = window.currentMachineStatus || {};
            window.currentMachineStatus.current_batch = batchId;
            window.currentMachineStatus.sift_ledger = siftLedger;

            // Update batch - subtract sift output from trim_weight (hash comes from the trim)
            const newTrimWeight = Math.max(0, (batch?.trim_weight || 0) - totalOutput);
            const newSiftWeight = (batch?.sift_weight || 0) + totalOutput;

            const batchUpdatePromise = DEMO_MODE
                ? demoUpdateBatch(batchId, { trim_weight: newTrimWeight, sift_weight: newSiftWeight })
                : supabaseClient.from('wm_batches').update({ trim_weight: newTrimWeight, sift_weight: newSiftWeight }).eq('id', batchId);

            batchUpdatePromise.then(() => {
                if (batch) {
                    batch.trim_weight = newTrimWeight;
                    batch.sift_weight = newSiftWeight;
                }
            });

            // Auto-save machine status
            const statusData = {
                machine: currentMachine,
                current_batch: batchId,
                sift_ledger: siftLedger,
                last_updated: new Date().toISOString(),
                updated_by: currentRole ? currentRole.name : 'Unknown'
            };

            const savePromise = DEMO_MODE
                ? demoSaveMachineStatus(currentMachine, { ...window.currentMachineStatus, ...statusData })
                : supabaseClient.from('wm_machine_status').upsert(statusData, { onConflict: 'machine' });

            savePromise.then(({ error }) => {
                if (error) {
                    console.error('Error saving run:', error);
                    alert('Error saving run data');
                    return;
                }

                // Clear input fields for next run
                if (inputWeightEl) inputWeightEl.value = '';
                if (sift1OutputEl) sift1OutputEl.value = '';
                if (sift2OutputEl) sift2OutputEl.value = '';

                // Update displays
                updateResinatorTotals(siftLedger);
                updateResinatorBatchInfo();

                // Calculate remaining to run through resinator
                let updatedLedger = window.currentMachineStatus?.sift_ledger || [];
                const totalInputProcessed = updatedLedger
                    .filter(r => r.batch_id === batchId)
                    .reduce((sum, r) => sum + (r.input_weight || 0), 0);
                const totalSiftCollected = updatedLedger
                    .filter(r => r.batch_id === batchId)
                    .reduce((sum, r) => sum + (r.first_sift || 0) + (r.second_sift || 0), 0);
                const originalTrim = newTrimWeight + totalSiftCollected;
                const remainingToRun = Math.max(0, originalTrim - totalInputProcessed);

                alert(`âœ… Barrel run complete!\n\n${totalOutput}g hash collected (${yieldPct}% yield)\n\nRemaining to run: ${remainingToRun.toFixed(0)}g\nTrim for socks: ${newTrimWeight.toFixed(0)}g`);
            });
        }

        function updateResinatorTotals(siftLedger) {
            if (!siftLedger) {
                const status = window.currentMachineStatus || {};
                siftLedger = status.sift_ledger || [];
                if (typeof siftLedger === 'string') {
                    try { siftLedger = JSON.parse(siftLedger); } catch(e) { siftLedger = []; }
                }
            }

            const totalFirstSift = siftLedger.reduce((sum, r) => sum + (r.first_sift || 0), 0);
            const totalSecondSift = siftLedger.reduce((sum, r) => sum + (r.second_sift || 0), 0);
            const totalProcessed = siftLedger.reduce((sum, r) => sum + (r.input_weight || 0), 0);
            const totalRuns = siftLedger.length;

            // Update display elements
            const el1 = document.getElementById('totalFirstSift');
            const el2 = document.getElementById('totalSecondSift');
            const elProcessed = document.getElementById('totalProcessed');
            const elRuns = document.getElementById('totalRuns');

            if (el1) el1.textContent = `${totalFirstSift.toFixed(1)}g`;
            if (el2) el2.textContent = `${totalSecondSift.toFixed(1)}g`;
            if (elProcessed) elProcessed.textContent = `${totalProcessed.toFixed(0)}g`;
            if (elRuns) elRuns.textContent = totalRuns;

            // Update run history
            const historySection = document.getElementById('runHistorySection');
            const historyContent = document.getElementById('runHistoryContent');
            if (historySection && historyContent && siftLedger.length > 0) {
                historySection.style.display = 'block';
                let html = '';
                siftLedger.forEach((run, i) => {
                    const yields = [];
                    if (run.first_sift > 0) yields.push(`1st: ${run.first_sift}g`);
                    if (run.second_sift > 0) yields.push(`2nd: ${run.second_sift}g`);
                    html += `<div style="padding: 8px 0; border-bottom: 1px solid var(--border); font-size: 0.9rem;">
                        <strong>Run ${i + 1}</strong> - ${run.batch_id}: ${run.input_weight}g â†’ ${yields.join(', ')}
                    </div>`;
                });
                historyContent.innerHTML = html;
            }
        }

        function completeResinatorBatch() {
            const batchSelect = document.getElementById('resinatorBatch');
            const batchId = batchSelect?.value;

            if (!batchId) {
                alert('No batch selected.');
                return;
            }

            // Get session totals for this batch
            const status = window.currentMachineStatus || {};
            let siftLedger = status.sift_ledger || [];
            if (typeof siftLedger === 'string') {
                try { siftLedger = JSON.parse(siftLedger); } catch(e) { siftLedger = []; }
            }

            const batchRuns = siftLedger.filter(r => r.batch_id === batchId);
            if (batchRuns.length === 0) {
                alert('No runs recorded for this batch. Complete at least one barrel run first.');
                return;
            }

            const totalFirstSift = batchRuns.reduce((sum, r) => sum + (r.first_sift || 0), 0);
            const totalSecondSift = batchRuns.reduce((sum, r) => sum + (r.second_sift || 0), 0);
            const totalProcessed = batchRuns.reduce((sum, r) => sum + (r.input_weight || 0), 0);
            const batch = batches.find(b => b.id === batchId);

            const summary = `Complete batch ${batchId}?\n\n` +
                `Strain: ${batch?.strain || 'Unknown'}\n` +
                `Barrel Runs: ${batchRuns.length}\n` +
                `Material Processed: ${totalProcessed.toFixed(0)}g\n` +
                `1st Sift Total: ${totalFirstSift.toFixed(1)}g\n` +
                `2nd Sift Total: ${totalSecondSift.toFixed(1)}g\n` +
                `Total Hash: ${(totalFirstSift + totalSecondSift).toFixed(1)}g\n\n` +
                `Trim for Socks: ${batch?.trim_weight?.toFixed(0) || 0}g`;

            if (!confirm(summary)) {
                return;
            }

            // Create sub-batches for sift output
            const subBatchesCreated = [];
            const now = new Date().toISOString();

            // A-Sift sub-batch (1st sift / higher quality)
            if (totalFirstSift > 0) {
                const aSiftBatch = {
                    id: `${batchId}-A-Sift`,
                    strain: batch?.strain || 'Unknown',
                    partner: batch?.partner || 'Unknown',
                    status: 'sift_complete',
                    material_type: 'Dry Sift',
                    sift_weight: totalFirstSift,
                    trim_weight: 0,
                    socks_total: 0,
                    socks_remaining: 0,
                    parent_batch: batchId,
                    sift_grade: 'A',
                    metrc_source_tag: batch?.metrc_source_tag || '',
                    pre_sift: 'no',
                    created_at: now,
                    notes: `A-grade sift from ${batchRuns.length} barrel run(s)`
                };
                subBatchesCreated.push(aSiftBatch);
            }

            // B-Sift sub-batch (2nd sift / higher yield)
            if (totalSecondSift > 0) {
                const bSiftBatch = {
                    id: `${batchId}-B-Sift`,
                    strain: batch?.strain || 'Unknown',
                    partner: batch?.partner || 'Unknown',
                    status: 'sift_complete',
                    material_type: 'Dry Sift',
                    sift_weight: totalSecondSift,
                    trim_weight: 0,
                    socks_total: 0,
                    socks_remaining: 0,
                    parent_batch: batchId,
                    sift_grade: 'B',
                    metrc_source_tag: batch?.metrc_source_tag || '',
                    pre_sift: 'no',
                    created_at: now,
                    notes: `B-grade sift from ${batchRuns.length} barrel run(s)`
                };
                subBatchesCreated.push(bSiftBatch);
            }

            // Save sub-batches
            const createSubBatches = async () => {
                if (DEMO_MODE) {
                    // Add to local batches array for demo mode
                    subBatchesCreated.forEach(sb => batches.push(sb));
                    return { error: null };
                } else {
                    // Insert into Supabase
                    const { error } = await supabaseClient.from('wm_batches').insert(subBatchesCreated);
                    if (!error) {
                        // Also add to local batches array
                        subBatchesCreated.forEach(sb => batches.push(sb));
                    }
                    return { error };
                }
            };

            createSubBatches().then(({ error }) => {
                if (error) {
                    console.error('Error creating sub-batches:', error);
                    alert('Warning: Sub-batches could not be saved to database. Check console for details.');
                }

                // Clear session data but keep ledger history for records
                window.currentMachineStatus = window.currentMachineStatus || {};
                window.currentMachineStatus.sift_ledger = [];
                window.currentMachineStatus.current_batch = null;

                // Clear form
                const inputWeightEl = document.getElementById('resinatorInputWeight');
                const sift1OutputEl = document.getElementById('resinatorSift1Output');
                const sift2OutputEl = document.getElementById('resinatorSift2Output');
                const historySection = document.getElementById('runHistorySection');
                const remainingDisplay = document.getElementById('batchRemainingDisplay');

                if (batchSelect) batchSelect.value = '';
                if (inputWeightEl) inputWeightEl.value = '';
                if (sift1OutputEl) sift1OutputEl.value = '';
                if (sift2OutputEl) sift2OutputEl.value = '';
                if (historySection) historySection.style.display = 'none';
                if (remainingDisplay) remainingDisplay.style.display = 'none';

                // Reset totals display
                updateResinatorTotals([]);

                // Save cleared machine state
                const clearedStatus = {
                    machine: currentMachine,
                    current_batch: null,
                    sift_ledger: [],
                    last_updated: new Date().toISOString(),
                    updated_by: currentRole ? currentRole.name : 'Unknown'
                };

                const savePromise = DEMO_MODE
                    ? demoSaveMachineStatus(currentMachine, clearedStatus)
                    : supabaseClient.from('wm_machine_status').upsert(clearedStatus, { onConflict: 'machine' });

                savePromise.then(() => {
                    const subBatchList = subBatchesCreated.map(sb => `  â€¢ ${sb.id}: ${sb.sift_weight.toFixed(1)}g`).join('\n');
                    alert(`âœ… Batch ${batchId} complete!\n\nSub-batches created:\n${subBatchList}\n\nReady for next batch.`);

                    // Refresh the extraction queue to show new sub-batches
                    populateExtractionQueue();
                });
            });
        }

        function updateColumnSockUI(column) {
            // Dynamic element IDs for any column A-F
            const batchSelect = document.getElementById('machineColumn' + column + 'Batch');
            const socksSelect = document.getElementById('machineColumn' + column + 'Socks');
            const secondSockDiv = document.getElementById('column' + column + 'SecondSock');
            const secondBatchSelect = document.getElementById('machineColumn' + column + 'SecondBatch');

            // Null safety check
            if (!batchSelect || !socksSelect) return;

            const batchId = batchSelect.value;
            const sockCount = parseInt(socksSelect.value) || 0;

            if (!batchId) {
                socksSelect.value = '0';
                if (secondSockDiv) secondSockDiv.style.display = 'none';
                return;
            }

            const batch = batches.find(b => b.id === batchId);

            // When batch is selected and socks not yet chosen, default to max available (up to 2)
            if (batch && sockCount === 0) {
                const remaining = batch.socks_remaining ?? batch.socks_total ?? 2;
                socksSelect.value = Math.min(2, remaining).toString();
            }

            // Re-read sock count after potential default setting
            const actualSockCount = parseInt(socksSelect.value) || 0;

            // Show second sock selector when exactly 1 sock is selected
            if (actualSockCount === 1 && batch && secondSockDiv && secondBatchSelect) {
                secondSockDiv.style.display = 'block';
                populateCompatibleBatches(secondBatchSelect, batch, batchId);
            } else {
                if (secondSockDiv) secondSockDiv.style.display = 'none';
                if (secondBatchSelect) secondBatchSelect.value = '';
            }
        }

        function populateCompatibleBatches(selectElement, primaryBatch, excludeBatchId) {
            // Mixing rules:
            // - Wholesale can mix with any Wholesale
            // - 50-50 Split can only mix with same partner (cultivation license)
            // - Custom Buyback can only mix with same partner

            selectElement.innerHTML = '<option value="">None (leave empty)</option>';

            batches.forEach(b => {
                if (b.id === excludeBatchId) return; // Skip primary batch
                if (b.status !== 'intake') return; // Only intake batches

                const hasSocksData = b.socks_remaining !== undefined || b.socks_total !== undefined;
                const socksRemaining = b.socks_remaining ?? b.socks_total ?? 2;
                if (socksRemaining < 1) return; // Need at least 1 sock

                let canMix = false;
                const primaryAgreement = primaryBatch.material_agreement || '';
                const batchAgreement = b.material_agreement || '';

                // Wholesale can mix with any Wholesale
                if (primaryAgreement === 'Wholesale' && batchAgreement === 'Wholesale') {
                    canMix = true;
                }
                // Percentage Split and Per Gram can only mix with same partner
                else if (primaryAgreement === batchAgreement &&
                         primaryBatch.partner === b.partner) {
                    canMix = true;
                }

                if (canMix) {
                    const sockDisplay = hasSocksData ? `(${socksRemaining} socks left)` : '';
                    selectElement.innerHTML += `<option value="${b.id}">${b.id} - ${b.strain} ${sockDisplay}</option>`;
                }
            });
        }

        function runColumnToPot(column) {
            // Get socks from the specified column (A-F) with dynamic element IDs
            const batchEl = document.getElementById('machineColumn' + column + 'Batch');
            const socksEl = document.getElementById('machineColumn' + column + 'Socks');
            const secondBatchEl = document.getElementById('machineColumn' + column + 'SecondBatch');

            // If elements don't exist, can't proceed
            if (!batchEl || !socksEl) {
                alert(`Error: Column ${column} form elements not found. Please refresh the page.`);
                return;
            }

            const columnBatch = batchEl.value;
            const columnSocks = parseInt(socksEl.value) || 0;
            const columnSecondBatch = secondBatchEl ? secondBatchEl.value : '';

            // Build list of contributions for this column
            let contributions = [];

            // Primary batch
            if (columnBatch && columnSocks > 0) {
                contributions.push({ batchId: columnBatch, socks: columnSocks === 1 && columnSecondBatch ? 1 : columnSocks });
            }

            // Second sock from different batch
            if (columnSocks === 1 && columnSecondBatch) {
                contributions.push({ batchId: columnSecondBatch, socks: 1 });
            }

            if (contributions.length === 0) {
                alert(`No socks loaded in Column ${column}! Load a batch first.`);
                return;
            }

            // Confirm run
            let confirmMsg = `âš—ï¸ Run Column ${column} to Pot?\n\nThis will process:\n`;
            contributions.forEach(c => {
                const batch = batches.find(b => b.id === c.batchId);
                confirmMsg += `â€¢ ${c.socks} sock(s) from ${c.batchId} - ${batch?.strain || 'Unknown'}\n`;
            });

            if (!confirm(confirmMsg)) return;

            // Get current pot ledger
            const currentStatus = window.currentMachineStatus || {};
            let potLedger = currentStatus.pot_ledger || [];
            if (typeof potLedger === 'string') {
                try { potLedger = JSON.parse(potLedger); } catch(e) { potLedger = []; }
            }

            // Track socks to decrement from each batch
            let socksToDecrement = {};

            // Add contributions to pot ledger
            contributions.forEach(c => {
                const batch = batches.find(b => b.id === c.batchId);
                if (!batch) return;

                const trimPerSock = batch.trim_per_sock || (batch.trim_weight / (batch.socks_total || 1));
                const trimWeight = trimPerSock * c.socks;

                // Check if batch already in ledger
                const existingEntry = potLedger.find(p => p.batch_id === c.batchId);
                if (existingEntry) {
                    existingEntry.socks += c.socks;
                    existingEntry.trim_weight += trimWeight;
                } else {
                    potLedger.push({
                        batch_id: c.batchId,
                        metrc_tag: batch.metrc_source_tag || '',
                        socks: c.socks,
                        trim_weight: trimWeight,
                        cultivation_license: batch.partner || '',
                        material_agreement: batch.material_agreement || '',
                        strain: batch.strain || ''
                    });
                }

                // Track socks to decrement
                socksToDecrement[c.batchId] = (socksToDecrement[c.batchId] || 0) + c.socks;
            });

            // Determine majority batch for pot_batch
            let majorityBatchId = '';
            let maxSocks = 0;
            potLedger.forEach(p => {
                if (p.socks > maxSocks) {
                    maxSocks = p.socks;
                    majorityBatchId = p.batch_id;
                }
            });

            // Update UI
            document.getElementById('machinePotBatch').value = majorityBatchId;
            const majorityBatch = batches.find(b => b.id === majorityBatchId);
            document.getElementById('machinePotBatchDisplay').value = majorityBatch ?
                `${majorityBatchId} - ${majorityBatch.strain}` : majorityBatchId;

            // Increment pot runs
            const currentRuns = parseInt(document.getElementById('machinePotRuns').value) || 0;
            document.getElementById('machinePotRuns').value = currentRuns + 1;

            console.log('runColumnToPot - majorityBatchId:', majorityBatchId, 'newRuns:', currentRuns + 1, 'potLedger:', potLedger);

            // Update current machine status with new ledger
            window.currentMachineStatus = window.currentMachineStatus || {};
            window.currentMachineStatus.pot_ledger = potLedger;

            console.log('runColumnToPot - window.currentMachineStatus.pot_ledger set to:', window.currentMachineStatus.pot_ledger);

            // Update pot ledger display
            displayPotLedger({ pot_ledger: potLedger });

            // Clear the column that was run
            if (batchEl) batchEl.value = '';
            if (socksEl) socksEl.value = '0';
            if (secondBatchEl) secondBatchEl.value = '';
            const secondSockDiv = document.getElementById('column' + column + 'SecondSock');
            if (secondSockDiv) secondSockDiv.style.display = 'none';

            // Decrement socks from batches in database (skip in demo mode)
            const decrementPromises = Object.entries(socksToDecrement).map(([batchId, sockCount]) => {
                const batch = batches.find(b => b.id === batchId);
                if (!batch) return Promise.resolve();

                const currentRemaining = batch.socks_remaining ?? batch.socks_total ?? 0;
                const newRemaining = Math.max(0, currentRemaining - sockCount);

                // Update local cache
                batch.socks_remaining = newRemaining;

                // In demo mode, just update local cache, don't touch database
                if (DEMO_MODE) return Promise.resolve();

                return supabaseClient
                    .from('wm_batches')
                    .update({ socks_remaining: newRemaining })
                    .eq('id', batchId);
            });

            // Calculate total trim for this run
            const runTrimWeight = contributions.reduce((sum, c) => {
                const batch = batches.find(b => b.id === c.batchId);
                if (!batch) return sum;
                const trimPerSock = batch.trim_per_sock || (batch.trim_weight / (batch.socks_total || 1));
                return sum + (trimPerSock * c.socks);
            }, 0);

            // Log extraction run for performance tracking
            const extractionRun = {
                timestamp: new Date().toISOString(),
                user: currentRole ? currentRole.name : 'Unknown',
                machine: currentMachine,
                column: column,
                trimWeight: runTrimWeight,
                socks: contributions.reduce((sum, c) => sum + c.socks, 0),
                batches: contributions.map(c => c.batchId)
            };

            // Store in localStorage for performance tracking
            const extractionRuns = JSON.parse(localStorage.getItem('wm_extraction_runs') || '[]');
            extractionRuns.push(extractionRun);
            localStorage.setItem('wm_extraction_runs', JSON.stringify(extractionRuns));
            console.log('Logged extraction run:', extractionRun);

            Promise.all(decrementPromises).then(() => {
                // Auto-save pot status to database (so it persists if modal is closed)
                const potRuns = parseInt(document.getElementById('machinePotRuns').value) || 0;

                // In demo mode, save to localStorage instead of database
                if (DEMO_MODE) {
                    const demoStatus = demoGetMachineStatus(currentMachine);
                    demoStatus.pot_batch = majorityBatchId;
                    demoStatus.pot_runs = potRuns;
                    demoStatus.pot_ledger = potLedger;
                    return demoSaveMachineStatus(currentMachine, demoStatus);
                }

                return supabaseClient
                    .from('wm_machine_status')
                    .upsert({
                        machine: currentMachine,
                        pot_batch: majorityBatchId,
                        pot_runs: potRuns,
                        pot_ledger: potLedger,
                        last_updated: new Date().toISOString(),
                        updated_by: currentRole ? currentRole.name : 'Unknown'
                    }, { onConflict: 'machine' });
            }).then(() => {
                // Refresh extraction queue and column dropdowns
                populateExtractionQueue();
                refreshColumnDropdowns();

                // Auto-save machine status (skip in demo mode - already saved above)
                if (DEMO_MODE) {
                    updateMachineDisplays(); // Refresh the machine cards
                    alert(`âœ… Column ${column} run added to pot! (Demo Mode)`);
                    return;
                }

                autoSaveMachineStatus().then(() => {
                    updateMachineDisplays(); // Refresh the machine cards
                    alert(`âœ… Column ${column} run added to pot and saved!`);
                }).catch(err => {
                    console.error('Error auto-saving machine status:', err);
                    alert(`âœ… Column ${column} run added to pot!\nâš ï¸ Auto-save failed - click "Save Status" manually.`);
                });
            }).catch(err => {
                console.error('Error updating machine status:', err);
                alert('âš ï¸ Run added to pot but error saving. Check console.');
            });
        }

        // Auto-save machine status without closing modal
        async function autoSaveMachineStatus() {
            if (!currentMachine) {
                console.error('autoSaveMachineStatus: No currentMachine set');
                return;
            }

            const potBatch = document.getElementById('machinePotBatch').value;
            const potRuns = parseInt(document.getElementById('machinePotRuns').value) || 0;
            const potLedger = window.currentMachineStatus?.pot_ledger || [];

            console.log('autoSaveMachineStatus - potBatch:', potBatch, 'potRuns:', potRuns, 'potLedger:', potLedger);

            // Dynamically get column values for A-F
            const columnLabels = ['A', 'B', 'C', 'D', 'E', 'F'];
            const columnData = {};
            columnLabels.forEach(col => {
                const colKey = col.toLowerCase();
                const batchEl = document.getElementById('machineColumn' + col + 'Batch');
                const socksEl = document.getElementById('machineColumn' + col + 'Socks');
                const secondEl = document.getElementById('machineColumn' + col + 'SecondBatch');

                if (batchEl) {
                    const batchKey = col === 'A' ? 'column_batch' : `column_${colKey}_batch`;
                    const socksKey = `column_${colKey}_socks`;
                    const secondKey = `column_${colKey}_second_batch`;

                    columnData[batchKey] = batchEl.value || '';
                    columnData[socksKey] = socksEl ? (parseInt(socksEl.value) || 0) : 0;
                    columnData[secondKey] = secondEl ? secondEl.value : '';
                }
            });

            const machineStatus = {
                machine: currentMachine,
                ...columnData,
                pot_batch: potBatch,
                pot_runs: potRuns,
                pot_ledger: potLedger,
                filter_clay: parseFloat(document.getElementById('machineFilterClay').value) || 0,
                filter_silica: parseFloat(document.getElementById('machineFilterSilica').value) || 0,
                filter_runs: parseInt(document.getElementById('machineFilterRuns').value) || 0,
                last_updated: new Date().toISOString(),
                updated_by: currentRole ? currentRole.name : 'Unknown'
            };

            console.log('autoSaveMachineStatus - saving:', machineStatus);

            // In demo mode, save to localStorage instead
            if (DEMO_MODE) {
                demoSaveMachineStatus(currentMachine, machineStatus);
                console.log('autoSaveMachineStatus - saved to demo storage');
                updateMachineDisplays();
                return;
            }

            const { error } = await supabaseClient
                .from('wm_machine_status')
                .upsert(machineStatus, { onConflict: 'machine' });

            if (error) {
                console.error('autoSaveMachineStatus - error:', error);
                throw error;
            }

            console.log('autoSaveMachineStatus - saved successfully');

            // Update displays
            updateMachineDisplays();
        }

        function refreshColumnDropdowns() {
            // Dynamically refresh all columns A-F
            const columnLabels = ['A', 'B', 'C', 'D', 'E', 'F'];
            const savedSelections = {};

            // Save current selections for all columns
            columnLabels.forEach(col => {
                const select = document.getElementById('machineColumn' + col + 'Batch');
                if (select) savedSelections[col] = select.value;
            });

            // Build options HTML once
            let optionsHtml = '<option value="">Empty / Not Loaded</option>';
            batches.forEach(batch => {
                // Show intake batches OR any batch with socks remaining
                const hasSocksRemaining = batch.socks_total != null && batch.socks_remaining > 0;
                if (batch.status === 'intake' || hasSocksRemaining) {
                    // Skip batches with 0 socks remaining
                    if (batch.socks_total != null && batch.socks_remaining === 0) return;
                    const socksRemaining = batch.socks_remaining ?? batch.socks_total ?? '?';
                    const socksTotal = batch.socks_total ?? '?';
                    const statusLabel = batch.status !== 'intake' ? ` [${batch.status}]` : '';
                    const sockDisplay = `(${socksRemaining}/${socksTotal} socks)${statusLabel}`;
                    optionsHtml += `<option value="${batch.id}">${batch.id} - ${batch.strain} ${sockDisplay}</option>`;
                }
            });

            // Update all column dropdowns
            columnLabels.forEach(col => {
                const select = document.getElementById('machineColumn' + col + 'Batch');
                const secondSelect = document.getElementById('machineColumn' + col + 'SecondBatch');
                if (select) {
                    select.innerHTML = optionsHtml;
                    select.value = savedSelections[col] || '';
                    if (!select.value) select.selectedIndex = 0;
                }
                if (secondSelect) {
                    secondSelect.innerHTML = '<option value="">None</option>' + optionsHtml.replace('<option value="">Empty / Not Loaded</option>', '');
                }
            });
        }

        function closeMachineModal() {
            document.getElementById('machineModal').style.display = 'none';
            currentMachine = null;
        }
        
        function saveMachineStatus() {
            if (!currentMachine) return;

            // Dynamically get column values for A-F
            const columnLabels = ['A', 'B', 'C', 'D', 'E', 'F'];
            const columnData = {};
            columnLabels.forEach(col => {
                const colKey = col.toLowerCase();
                const batchEl = document.getElementById('machineColumn' + col + 'Batch');
                const socksEl = document.getElementById('machineColumn' + col + 'Socks');
                const secondEl = document.getElementById('machineColumn' + col + 'SecondBatch');

                if (batchEl) {
                    // Use legacy key names for A (column_batch) to maintain backwards compatibility
                    const batchKey = col === 'A' ? 'column_batch' : `column_${colKey}_batch`;
                    const socksKey = `column_${colKey}_socks`;
                    const secondKey = `column_${colKey}_second_batch`;

                    columnData[batchKey] = batchEl.value || '';
                    columnData[socksKey] = socksEl ? (parseInt(socksEl.value) || 0) : 0;
                    columnData[secondKey] = secondEl ? secondEl.value : '';
                }
            });

            const potBatch = document.getElementById('machinePotBatch').value;
            const potRuns = parseInt(document.getElementById('machinePotRuns').value) || 0;
            const filterClay = parseFloat(document.getElementById('machineFilterClay').value) || 0;
            const filterSilica = parseFloat(document.getElementById('machineFilterSilica').value) || 0;
            const filterRuns = parseInt(document.getElementById('machineFilterRuns').value) || 0;

            // Preserve pot_ledger from current status
            const currentStatus = window.currentMachineStatus || {};
            let potLedger = currentStatus.pot_ledger || [];

            const machineStatus = {
                machine: currentMachine,
                ...columnData,
                pot_batch: potBatch,
                pot_runs: potRuns,
                pot_ledger: potLedger,
                filter_clay: filterClay,
                filter_silica: filterSilica,
                filter_runs: filterRuns,
                last_updated: new Date().toISOString(),
                updated_by: currentRole ? currentRole.name : 'Unknown'
            };

            // In demo mode, save to localStorage instead
            if (DEMO_MODE) {
                demoSaveMachineStatus(currentMachine, machineStatus);
                updateMachineDisplays();
                closeMachineModal();
                alert(`âœ… Machine Status Saved! (Demo Mode)`);
                return;
            }

            // Save to Supabase
            supabaseClient
                .from('wm_machine_status')
                .upsert(machineStatus, { onConflict: 'machine' })
                .then(({ error }) => {
                    if (error) {
                        console.error('Error saving machine status:', error);
                        alert('Error saving machine status. Please try again.');
                        return;
                    }

                    updateMachineDisplays();
                    closeMachineModal();

                    // Find machine name from config for the alert
                    const machineInfo = CONFIG.machines.find(m => {
                        const key = (m.position?.toLowerCase() || m.name.toLowerCase()).replace(/[^a-z0-9]/g, '');
                        return key === currentMachine;
                    });
                    const machineName = machineInfo?.name || (currentMachine === 'left' ? 'Left' : currentMachine === 'right' ? 'Right' : currentMachine);
                    alert(`âœ… ${machineName} Status Saved!`);
                });
        }
        
        function clearMachineStatus() {
            if (!currentMachine) return;

            // Get current pot ledger to restore socks
            const currentStatus = window.currentMachineStatus || {};
            let potLedger = currentStatus.pot_ledger || [];
            if (typeof potLedger === 'string') {
                try { potLedger = JSON.parse(potLedger); } catch(e) { potLedger = []; }
            }

            // Check if there's anything in the pot to clear
            if (potLedger.length === 0) {
                alert('The pot is already empty.');
                return;
            }

            // Build confirmation message - only about pot contents
            let confirmMsg = `Clear the pot and return socks to their batches?\n\nâš ï¸ The following socks will be returned:`;
            potLedger.forEach(entry => {
                const batch = batches.find(b => b.id === entry.batch_id);
                confirmMsg += `\nâ€¢ ${entry.socks} sock(s) â†’ ${entry.batch_id} (${batch?.strain || 'Unknown'})`;
            });

            if (!confirm(confirmMsg)) {
                return;
            }

            // Restore socks to batches from pot_ledger
            const restorePromises = potLedger.map(entry => {
                // Skip demo batches when not in demo mode (and vice versa)
                const isDemoBatch = entry.batch_id?.startsWith('DEMO-');
                if (isDemoBatch && !DEMO_MODE) {
                    console.log('Skipping demo batch restore in regular mode:', entry.batch_id);
                    return Promise.resolve();
                }
                if (!isDemoBatch && DEMO_MODE) {
                    console.log('Skipping real batch restore in demo mode:', entry.batch_id);
                    return Promise.resolve();
                }

                const batch = batches.find(b => b.id === entry.batch_id);
                if (!batch) return Promise.resolve();

                const currentRemaining = batch.socks_remaining ?? 0;
                const newRemaining = currentRemaining + entry.socks;

                // Update local cache
                batch.socks_remaining = newRemaining;

                // In demo mode, just update local cache
                if (DEMO_MODE) return Promise.resolve();

                return supabaseClient
                    .from('wm_batches')
                    .update({ socks_remaining: newRemaining })
                    .eq('id', entry.batch_id);
            });

            // Only clear pot-related fields, preserve columns and filter
            const potClearStatus = {
                machine: currentMachine,
                pot_batch: null,
                pot_runs: 0,
                pot_ledger: [],
                last_updated: new Date().toISOString(),
                updated_by: currentRole ? currentRole.name : 'Unknown'
            };

            // Helper to clear pot form elements only
            const clearPotElements = () => {
                const clearEl = (id, val = '') => {
                    const el = document.getElementById(id);
                    if (el) el.value = val;
                };
                const hideEl = (id) => {
                    const el = document.getElementById(id);
                    if (el) el.style.display = 'none';
                };

                // Only clear pot-related elements
                clearEl('machinePotBatch');
                clearEl('machinePotBatchDisplay');
                clearEl('machinePotRuns');
                hideEl('potLedgerDisplay');

                // Update cached machine status - only clear pot fields
                if (window.currentMachineStatus) {
                    window.currentMachineStatus.pot_batch = null;
                    window.currentMachineStatus.pot_runs = 0;
                    window.currentMachineStatus.pot_ledger = [];
                }

                // Hide pull batch button since pot is now empty
                const pullBatchBtn = document.getElementById('modalPullBatchBtn');
                if (pullBatchBtn) pullBatchBtn.style.display = 'none';

                // Refresh displays and dropdowns
                updateMachineDisplays();
                refreshColumnDropdowns();
                populateExtractionQueue();

                // Get machine name for alert
                const machineInfo = CONFIG.machines.find(m => {
                    const key = (m.position?.toLowerCase() || m.name.toLowerCase()).replace(/[^a-z0-9]/g, '');
                    return key === currentMachine;
                });
                const machineName = machineInfo?.name || currentMachine;
                alert(`âœ… ${machineName} pot cleared! Socks returned to batches.${DEMO_MODE ? ' (Demo Mode)' : ''}`);
            };

            // Wait for sock restoration, then clear pot status only
            Promise.all(restorePromises).then(() => {
                // In demo mode, update localStorage (preserve other fields)
                if (DEMO_MODE) {
                    const existingStatus = demoGetMachineStatus(currentMachine) || {};
                    demoSaveMachineStatus(currentMachine, { ...existingStatus, ...potClearStatus });
                    clearPotElements();
                    return Promise.resolve();
                }

                // Use update instead of upsert to only modify pot fields
                return supabaseClient
                    .from('wm_machine_status')
                    .update(potClearStatus)
                    .eq('machine', currentMachine)
                    .then((result) => {
                        if (result?.error) {
                            console.error('Error clearing pot in DB:', result.error);
                            alert('Error clearing pot in database. Check console.');
                            return;
                        }
                        console.log('Pot cleared in database, updating UI...');
                        clearPotElements();
                    });
            }).catch(err => {
                console.error('Error during clear:', err);
                alert('Error clearing pot. Check console.');
            });
        }
        
        function updateMachineDisplays() {
            supabaseClient
                .from('wm_machine_status')
                .select('*')
                .then(({ data: machineStatuses, error }) => {
                    if (error) {
                        console.error('Error loading machine statuses:', error);
                        return;
                    }

                    // Get machine keys from CONFIG (or use defaults)
                    const machines = (CONFIG.machines.length > 0 ? CONFIG.machines : CONFIG_DEFAULTS.machines);
                    const machineKeys = machines.map(m => (m.position?.toLowerCase() || m.name.toLowerCase()).replace(/[^a-z0-9]/g, ''));

                    machineKeys.forEach(machineKey => {
                        // In demo mode, use demo data from localStorage instead
                        let machineStatus;
                        if (DEMO_MODE) {
                            machineStatus = demoGetMachineStatus(machineKey) || {};
                        } else {
                            machineStatus = machineStatuses.find(m => m.machine === machineKey) || {};
                        }

                        // Update all columns A-F dynamically
                        const columnLabels = ['A', 'B', 'C', 'D', 'E', 'F'];
                        columnLabels.forEach(col => {
                            const colEl = document.getElementById(`${machineKey}Col${col}Strain`);
                            const colBtn = document.getElementById(`${machineKey}Col${col}Btn`);
                            if (colEl) {
                                const colKey = col.toLowerCase();
                                // Handle legacy format (column_batch for A) and new format
                                const batchKey = col === 'A' ? 'column_batch' : `column_${colKey}_batch`;
                                const batchId = machineStatus[batchKey];
                                if (batchId) {
                                    const batch = batches.find(b => b.id == batchId);
                                    // Show strain name - truncate only if very long
                                    const strainName = batch?.strain || 'Loaded';
                                    colEl.textContent = strainName.length > 12 ? strainName.substring(0, 11) + 'â€¦' : strainName;
                                    if (colBtn) colBtn.style.background = 'linear-gradient(145deg, rgba(59,130,246,0.5) 0%, rgba(59,130,246,0.25) 100%)';
                                } else {
                                    colEl.textContent = '-';
                                    if (colBtn) colBtn.style.background = 'linear-gradient(145deg, rgba(59,130,246,0.25) 0%, rgba(59,130,246,0.1) 100%)';
                                }
                            }
                        });

                        // Update Pot button
                        const potStrainEl = document.getElementById(`${machineKey}PotStrain`);
                        const potRunsEl = document.getElementById(`${machineKey}PotRuns`);
                        const potYieldEl = document.getElementById(`${machineKey}PotYield`);
                        const potBtn = document.getElementById(`${machineKey}PotBtn`);
                        if (potStrainEl) {
                            if (machineStatus.pot_batch) {
                                const batch = batches.find(b => b.id == machineStatus.pot_batch);
                                potStrainEl.textContent = batch?.strain || machineStatus.pot_batch;
                                if (potRunsEl) potRunsEl.textContent = machineStatus.pot_runs ? `${machineStatus.pot_runs} runs` : '';

                                // Calculate predicted yield from pot_ledger
                                if (potYieldEl) {
                                    let potLedger = machineStatus.pot_ledger || [];
                                    if (typeof potLedger === 'string') {
                                        try { potLedger = JSON.parse(potLedger); } catch(e) { potLedger = []; }
                                    }
                                    if (potLedger.length > 0) {
                                        let totalPredictedYield = 0;
                                        potLedger.forEach(entry => {
                                            const entryBatch = batches.find(b => b.id === entry.batch_id);
                                            const trimWeight = entry.trim_weight || 0;
                                            const yieldPct = (entryBatch?.expected_yield || 13) / 100;
                                            totalPredictedYield += trimWeight * yieldPct;
                                        });
                                        potYieldEl.textContent = `~${totalPredictedYield.toFixed(0)}g`;
                                    } else {
                                        potYieldEl.textContent = '';
                                    }
                                }
                                if (potBtn) potBtn.style.background = 'linear-gradient(145deg, rgba(147,51,234,0.45) 0%, rgba(147,51,234,0.2) 100%)';
                            } else {
                                potStrainEl.textContent = 'Empty';
                                if (potRunsEl) potRunsEl.textContent = '';
                                if (potYieldEl) potYieldEl.textContent = '';
                                if (potBtn) potBtn.style.background = 'linear-gradient(145deg, rgba(147,51,234,0.3) 0%, rgba(147,51,234,0.1) 100%)';
                            }
                        }

                        // Update Filter button
                        const filterRunsEl = document.getElementById(`${machineKey}FilterRuns`);
                        const filterBtn = document.getElementById(`${machineKey}FilterBtn`);
                        if (filterRunsEl) {
                            const runs = machineStatus.filter_runs || 0;
                            filterRunsEl.textContent = runs;
                            if (filterBtn) {
                                if (runs > 0) {
                                    filterBtn.style.background = 'linear-gradient(145deg, rgba(16,185,129,0.4) 0%, rgba(16,185,129,0.2) 100%)';
                                } else {
                                    filterBtn.style.background = 'linear-gradient(145deg, rgba(16,185,129,0.25) 0%, rgba(16,185,129,0.1) 100%)';
                                }
                            }
                        }

                        // Update resinator sift displays
                        const sift1El = document.getElementById(`${machineKey}Sift1`);
                        const sift2El = document.getElementById(`${machineKey}Sift2`);
                        if (sift1El || sift2El) {
                            // This is a resinator - show sift totals
                            let siftLedger = machineStatus.sift_ledger || [];
                            if (typeof siftLedger === 'string') {
                                try { siftLedger = JSON.parse(siftLedger); } catch(e) { siftLedger = []; }
                            }

                            if (siftLedger.length > 0) {
                                const totalOutput = siftLedger.reduce((sum, s) => sum + (s.output_weight || 0), 0);
                                const siftCount = siftLedger.length;
                                if (sift1El) sift1El.textContent = `${totalOutput.toFixed(1)}g (${siftCount} runs)`;
                            } else {
                                if (sift1El) sift1El.textContent = 'Empty';
                            }
                            if (sift2El && !machineStatus.sift_ledger) sift2El.textContent = 'Empty';
                        }
                    });
                });
        }
        
        // Supplies Modal
        function openSuppliesModal() {
            supabaseClient
                .from('wm_inventory')
                .select('*')
                .then(({ data: inventory, error }) => {
                    if (error) {
                        console.error('Error loading inventory:', error);
                        return;
                    }
                    
                    const butane = inventory.find(i => i.supply_type === 'butane');
                    const nitrogen = inventory.find(i => i.supply_type === 'nitrogen');
                    
                    // Update displays in modal
                    document.getElementById('modalButaneDisplay').textContent = butane ? `${parseFloat(butane.current_level).toFixed(1)} lbs` : '0.0 lbs';
                    document.getElementById('modalNitrogenDisplay').textContent = nitrogen ? `${parseFloat(nitrogen.current_level).toFixed(1)}` : '0.0';
                    
                    // Clear input fields
                    document.getElementById('modalWithdrawButane').value = '';
                    document.getElementById('modalWithdrawNitrogen').value = '';
                    
                    document.getElementById('suppliesModal').style.display = 'block';
                });
        }
        
        function closeSuppliesModal() {
            document.getElementById('suppliesModal').style.display = 'none';
        }
        
        function withdrawButaneFromModal() {
            const withdrawAmount = parseFloat(document.getElementById('modalWithdrawButane').value);
            
            if (!withdrawAmount || withdrawAmount <= 0) {
                alert('Please enter an amount to withdraw');
                return;
            }
            
            supabaseClient
                .from('wm_inventory')
                .select('*')
                .eq('supply_type', 'butane')
                .single()
                .then(({ data: butaneRecord, error }) => {
                    if (error) {
                        console.error('Error loading butane inventory:', error);
                        return;
                    }
                    
                    const currentButane = parseFloat(butaneRecord.current_level) || 0;
                    
                    if (withdrawAmount > currentButane) {
                        if (!confirm(`âš ï¸ Warning: You're withdrawing ${withdrawAmount.toFixed(1)} lbs but only ${currentButane.toFixed(1)} lbs are in the bulk tank.\n\nContinue anyway?`)) {
                            return;
                        }
                    }
                    
                    const newButane = currentButane - withdrawAmount;
                    
                    // Update inventory in Supabase
                    supabaseClient
                        .from('wm_inventory')
                        .update({
                            current_level: newButane,
                            last_updated: new Date().toISOString(),
                            updated_by: currentRole ? currentRole.name : 'Unknown'
                        })
                        .eq('supply_type', 'butane')
                        .then(({ error: updateError }) => {
                            if (updateError) {
                                console.error('Error updating butane:', updateError);
                                return;
                            }
                            
                            // Save transaction
                            supabaseClient
                                .from('wm_inventory_transactions')
                                .insert({
                                    supply_type: 'butane',
                                    transaction_type: 'withdraw',
                                    amount: withdrawAmount,
                                    previous_level: currentButane,
                                    new_level: newButane,
                                    notes: `Withdrew ${withdrawAmount.toFixed(1)} lbs`,
                                    timestamp: new Date().toISOString(),
                                    user_name: currentRole ? currentRole.name : 'Unknown'
                                })
                                .then(() => {
                                    document.getElementById('modalWithdrawButane').value = '';
                                    document.getElementById('modalButaneDisplay').textContent = `${newButane.toFixed(1)} lbs`;
                                    updateSuppliesButton();
                                    
                                    alert(`âœ… Withdrawn!\n\n${withdrawAmount.toFixed(1)} lbs butane removed\nRemaining: ${newButane.toFixed(1)} lbs`);
                                });
                        });
                });
        }
        
        function withdrawNitrogenFromModal() {
            const withdrawAmount = parseFloat(document.getElementById('modalWithdrawNitrogen').value);
            
            if (!withdrawAmount || withdrawAmount <= 0) {
                alert('Please enter an amount to withdraw');
                return;
            }
            
            supabaseClient
                .from('wm_inventory')
                .select('*')
                .eq('supply_type', 'nitrogen')
                .single()
                .then(({ data: nitrogenRecord, error }) => {
                    if (error) {
                        console.error('Error loading nitrogen inventory:', error);
                        return;
                    }
                    
                    const currentNitrogen = parseFloat(nitrogenRecord.current_level) || 0;
                    
                    if (withdrawAmount > currentNitrogen) {
                        if (!confirm(`âš ï¸ Warning: You're withdrawing ${withdrawAmount.toFixed(1)} tank(s) but only ${currentNitrogen.toFixed(1)} remain.\n\nContinue anyway?`)) {
                            return;
                        }
                    }
                    
                    const newNitrogen = currentNitrogen - withdrawAmount;
                    
                    // Update inventory in Supabase
                    supabaseClient
                        .from('wm_inventory')
                        .update({
                            current_level: newNitrogen,
                            last_updated: new Date().toISOString(),
                            updated_by: currentRole ? currentRole.name : 'Unknown'
                        })
                        .eq('supply_type', 'nitrogen')
                        .then(({ error: updateError }) => {
                            if (updateError) {
                                console.error('Error updating nitrogen:', updateError);
                                return;
                            }
                            
                            // Save transaction
                            supabaseClient
                                .from('wm_inventory_transactions')
                                .insert({
                                    supply_type: 'nitrogen',
                                    transaction_type: 'withdraw',
                                    amount: withdrawAmount,
                                    previous_level: currentNitrogen,
                                    new_level: newNitrogen,
                                    notes: `Withdrew ${withdrawAmount.toFixed(1)} tank(s)`,
                                    timestamp: new Date().toISOString(),
                                    user_name: currentRole ? currentRole.name : 'Unknown'
                                })
                                .then(() => {
                                    document.getElementById('modalWithdrawNitrogen').value = '';
                                    document.getElementById('modalNitrogenDisplay').textContent = `${newNitrogen.toFixed(1)}`;
                                    updateSuppliesButton();
                                    
                                    alert(`âœ… Withdrawn!\n\n${withdrawAmount.toFixed(1)} nitrogen tank(s) removed\nRemaining: ${newNitrogen.toFixed(1)} tanks`);
                                });
                        });
                });
        }
        
        // Butane Modals
        function openAddButaneModal() {
            document.getElementById('butaneShipmentAmount').value = '';
            document.getElementById('butaneShipmentNotes').value = '';
            document.getElementById('addShipmentModal').style.display = 'block';
        }
        
        function closeAddButaneModal() {
            document.getElementById('addShipmentModal').style.display = 'none';
        }
        
        function addButaneShipment() {
            const addAmount = parseFloat(document.getElementById('butaneShipmentAmount').value);
            const notes = document.getElementById('butaneShipmentNotes').value;
            
            if (!addAmount || addAmount <= 0) {
                alert('Please enter a valid amount');
                return;
            }
            
            supabaseClient
                .from('wm_inventory')
                .select('*')
                .eq('supply_type', 'butane')
                .single()
                .then(({ data: butaneRecord, error }) => {
                    if (error) {
                        console.error('Error loading butane inventory:', error);
                        return;
                    }
                    
                    const currentButane = parseFloat(butaneRecord.current_level) || 0;
                    const newButane = currentButane + addAmount;
                    
                    // Update inventory in Supabase
                    supabaseClient
                        .from('wm_inventory')
                        .update({
                            current_level: newButane,
                            last_updated: new Date().toISOString(),
                            updated_by: currentRole ? currentRole.name : 'Unknown'
                        })
                        .eq('supply_type', 'butane')
                        .then(({ error: updateError }) => {
                            if (updateError) {
                                console.error('Error updating butane:', updateError);
                                return;
                            }
                            
                            // Save transaction
                            supabaseClient
                                .from('wm_inventory_transactions')
                                .insert({
                                    supply_type: 'butane',
                                    transaction_type: 'add',
                                    amount: addAmount,
                                    previous_level: currentButane,
                                    new_level: newButane,
                                    notes: notes || `Added ${addAmount.toFixed(1)} lbs shipment`,
                                    timestamp: new Date().toISOString(),
                                    user_name: currentRole ? currentRole.name : 'Unknown'
                                })
                                .then(() => {
                                    // Update all displays
                                    if (document.getElementById('modalButaneDisplay')) {
                                        document.getElementById('modalButaneDisplay').textContent = `${newButane.toFixed(1)} lbs`;
                                    }
                                    updateSuppliesButton();
                                    closeAddButaneModal();
                                    
                                    alert(`âœ… Shipment Added!\n\n${addAmount.toFixed(1)} lbs butane added\nNew Total: ${newButane.toFixed(1)} lbs`);
                                });
                        });
                });
        }
        
        function openEditButaneModal() {
            supabaseClient
                .from('wm_inventory')
                .select('*')
                .eq('supply_type', 'butane')
                .single()
                .then(({ data: butaneRecord, error }) => {
                    if (error) {
                        console.error('Error loading butane inventory:', error);
                        return;
                    }
                    
                    const currentButane = parseFloat(butaneRecord.current_level) || 0;
                    document.getElementById('editButaneCurrentDisplay').textContent = `${currentButane.toFixed(1)} lbs`;
                    document.getElementById('butaneSetAmount').value = '';
                    document.getElementById('butaneSetNotes').value = '';
                    document.getElementById('editBulkModal').style.display = 'block';
                });
        }
        
        function closeEditButaneModal() {
            document.getElementById('editBulkModal').style.display = 'none';
        }
        
        function setButaneWeight() {
            const setAmount = parseFloat(document.getElementById('butaneSetAmount').value);
            const notes = document.getElementById('butaneSetNotes').value;
            
            if (!setAmount && setAmount !== 0) {
                alert('Please enter a valid amount');
                return;
            }
            
            if (!notes.trim()) {
                alert('Please provide a reason for this manual change');
                return;
            }
            
            supabaseClient
                .from('wm_inventory')
                .select('*')
                .eq('supply_type', 'butane')
                .single()
                .then(({ data: butaneRecord, error }) => {
                    if (error) {
                        console.error('Error loading butane inventory:', error);
                        return;
                    }
                    
                    const currentButane = parseFloat(butaneRecord.current_level) || 0;
                    
                    // Update inventory in Supabase
                    supabaseClient
                        .from('wm_inventory')
                        .update({
                            current_level: setAmount,
                            last_updated: new Date().toISOString(),
                            updated_by: currentRole ? currentRole.name : 'Unknown'
                        })
                        .eq('supply_type', 'butane')
                        .then(({ error: updateError }) => {
                            if (updateError) {
                                console.error('Error updating butane:', updateError);
                                return;
                            }
                            
                            // Save transaction
                            supabaseClient
                                .from('wm_inventory_transactions')
                                .insert({
                                    supply_type: 'butane',
                                    transaction_type: 'edit',
                                    amount: setAmount - currentButane,
                                    previous_level: currentButane,
                                    new_level: setAmount,
                                    notes: `Manual adjustment: ${notes}`,
                                    timestamp: new Date().toISOString(),
                                    user_name: currentRole ? currentRole.name : 'Unknown'
                                })
                                .then(() => {
                                    // Update all displays
                                    if (document.getElementById('modalButaneDisplay')) {
                                        document.getElementById('modalButaneDisplay').textContent = `${setAmount.toFixed(1)} lbs`;
                                    }
                                    updateSuppliesButton();
                                    closeEditButaneModal();
                                    
                                    alert(`âœ… Butane Updated!\n\nManually set to ${setAmount.toFixed(1)} lbs (was ${currentButane.toFixed(1)} lbs)\n\nReason: ${notes}`);
                                });
                        });
                });
        }
        
        // Nitrogen Modals
        function openAddNitrogenModal() {
            document.getElementById('nitrogenShipmentAmount').value = '';
            document.getElementById('nitrogenShipmentNotes').value = '';
            document.getElementById('addNitrogenModal').style.display = 'block';
        }
        
        function closeAddNitrogenModal() {
            document.getElementById('addNitrogenModal').style.display = 'none';
        }
        
        function addNitrogenShipment() {
            const addAmount = parseFloat(document.getElementById('nitrogenShipmentAmount').value);
            const notes = document.getElementById('nitrogenShipmentNotes').value;
            
            if (!addAmount || addAmount <= 0) {
                alert('Please enter a valid amount');
                return;
            }
            
            supabaseClient
                .from('wm_inventory')
                .select('*')
                .eq('supply_type', 'nitrogen')
                .single()
                .then(({ data: nitrogenRecord, error }) => {
                    if (error) {
                        console.error('Error loading nitrogen inventory:', error);
                        return;
                    }
                    
                    const currentNitrogen = parseFloat(nitrogenRecord.current_level) || 0;
                    const newNitrogen = currentNitrogen + addAmount;
                    
                    // Update inventory in Supabase
                    supabaseClient
                        .from('wm_inventory')
                        .update({
                            current_level: newNitrogen,
                            last_updated: new Date().toISOString(),
                            updated_by: currentRole ? currentRole.name : 'Unknown'
                        })
                        .eq('supply_type', 'nitrogen')
                        .then(({ error: updateError }) => {
                            if (updateError) {
                                console.error('Error updating nitrogen:', updateError);
                                return;
                            }
                            
                            // Save transaction
                            supabaseClient
                                .from('wm_inventory_transactions')
                                .insert({
                                    supply_type: 'nitrogen',
                                    transaction_type: 'add',
                                    amount: addAmount,
                                    previous_level: currentNitrogen,
                                    new_level: newNitrogen,
                                    notes: notes || `Added ${addAmount.toFixed(1)} tank(s)`,
                                    timestamp: new Date().toISOString(),
                                    user_name: currentRole ? currentRole.name : 'Unknown'
                                })
                                .then(() => {
                                    // Update all displays
                                    if (document.getElementById('modalNitrogenDisplay')) {
                                        document.getElementById('modalNitrogenDisplay').textContent = `${newNitrogen.toFixed(1)}`;
                                    }
                                    updateSuppliesButton();
                                    closeAddNitrogenModal();
                                    
                                    alert(`âœ… Tanks Added!\n\n${addAmount.toFixed(1)} nitrogen tank(s) added\nNew Total: ${newNitrogen.toFixed(1)} tanks`);
                                });
                        });
                });
        }
        
        function openEditNitrogenModal() {
            supabaseClient
                .from('wm_inventory')
                .select('*')
                .eq('supply_type', 'nitrogen')
                .single()
                .then(({ data: nitrogenRecord, error }) => {
                    if (error) {
                        console.error('Error loading nitrogen inventory:', error);
                        return;
                    }
                    
                    const currentNitrogen = parseFloat(nitrogenRecord.current_level) || 0;
                    document.getElementById('editNitrogenCurrentDisplay').textContent = `${currentNitrogen.toFixed(1)} tanks`;
                    document.getElementById('nitrogenSetAmount').value = '';
                    document.getElementById('nitrogenSetNotes').value = '';
                    document.getElementById('editNitrogenModal').style.display = 'block';
                });
        }
        
        function closeEditNitrogenModal() {
            document.getElementById('editNitrogenModal').style.display = 'none';
        }
        
        function setNitrogenAmount() {
            const setAmount = parseFloat(document.getElementById('nitrogenSetAmount').value);
            const notes = document.getElementById('nitrogenSetNotes').value;
            
            if (!setAmount && setAmount !== 0) {
                alert('Please enter a valid amount');
                return;
            }
            
            if (!notes.trim()) {
                alert('Please provide a reason for this manual change');
                return;
            }
            
            supabaseClient
                .from('wm_inventory')
                .select('*')
                .eq('supply_type', 'nitrogen')
                .single()
                .then(({ data: nitrogenRecord, error }) => {
                    if (error) {
                        console.error('Error loading nitrogen inventory:', error);
                        return;
                    }
                    
                    const currentNitrogen = parseFloat(nitrogenRecord.current_level) || 0;
                    
                    // Update inventory in Supabase
                    supabaseClient
                        .from('wm_inventory')
                        .update({
                            current_level: setAmount,
                            last_updated: new Date().toISOString(),
                            updated_by: currentRole ? currentRole.name : 'Unknown'
                        })
                        .eq('supply_type', 'nitrogen')
                        .then(({ error: updateError }) => {
                            if (updateError) {
                                console.error('Error updating nitrogen:', updateError);
                                return;
                            }
                            
                            // Save transaction
                            supabaseClient
                                .from('wm_inventory_transactions')
                                .insert({
                                    supply_type: 'nitrogen',
                                    transaction_type: 'edit',
                                    amount: setAmount - currentNitrogen,
                                    previous_level: currentNitrogen,
                                    new_level: setAmount,
                                    notes: `Manual adjustment: ${notes}`,
                                    timestamp: new Date().toISOString(),
                                    user_name: currentRole ? currentRole.name : 'Unknown'
                                })
                                .then(() => {
                                    // Update all displays
                                    if (document.getElementById('modalNitrogenDisplay')) {
                                        document.getElementById('modalNitrogenDisplay').textContent = `${setAmount.toFixed(1)}`;
                                    }
                                    updateSuppliesButton();
                                    closeEditNitrogenModal();
                                    
                                    alert(`âœ… Nitrogen Updated!\n\nManually set to ${setAmount.toFixed(1)} tanks (was ${currentNitrogen.toFixed(1)})\n\nReason: ${notes}`);
                                });
                        });
                });
        }
        
        // Company Production Summary (respects time range)
        function updateCompanyProductionSummary(timeRange = 30) {
            const now = new Date();
            const rangeStart = getPerformanceRangeStart(timeRange);
            
            // Display time range
            const periodEl = document.getElementById('companyPeriodRange');
            if (periodEl) {
                const startStr = rangeStart.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                const endStr = now.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
                periodEl.textContent = `${startStr} - ${endStr}`;
            }
            
            let trimExtracted = 0;
            let trimBatches = 0;
            let finishedWeight = 0;
            let finishedBatches = 0;
            let packaged = 0;
            let packagedWeight = 0;
            let labeled = 0;
            let labeledWeight = 0;
            
            batches.forEach(batch => {
                // Check extraction completed in range (from timeline)
                if (batch.timeline && batch.timeline.length > 0) {
                    const extractionEvent = batch.timeline.find(event => {
                        if (event.status === 'extraction' && event.timestamp) {
                            const eventDate = new Date(event.timestamp);
                            return eventDate >= rangeStart && eventDate <= now;
                        }
                        return false;
                    });
                    
                    if (extractionEvent) {
                        trimExtracted += parseFloat(batch.trim_weight) || 0;
                        trimBatches++;
                    }
                }
                
                // Check finishing completed in range
                if (batch.finishing_date) {
                    const finishingDate = new Date(batch.finishing_date);
                    if (finishingDate >= rangeStart && finishingDate <= now) {
                        finishedWeight += parseFloat(batch.final_weight) || parseFloat(batch.net_weight) || 0;
                        finishedBatches++;
                    }
                }
                
                // Check packaging done in range
                if (batch.packaging_date) {
                    const packagingDate = new Date(batch.packaging_date);
                    if (packagingDate >= rangeStart && packagingDate <= now && batch.units_packaged) {
                        packaged += parseInt(batch.units_packaged) || 0;
                        packagedWeight += parseFloat(batch.net_weight) || 0;
                    }
                }
                
                // Check labeling done in range (from timeline)
                if (batch.timeline && batch.timeline.length > 0) {
                    const labelingEvent = batch.timeline.find(event => {
                        if ((event.stage === 'labeling' || event.status === 'complete') && event.timestamp) {
                            const eventDate = new Date(event.timestamp);
                            if (eventDate >= rangeStart && eventDate <= now) {
                                const action = (event.action || event.note || '').toLowerCase();
                                return action.includes('label') || action.includes('complet');
                            }
                        }
                        return false;
                    });
                    
                    if (labelingEvent && batch.units_packaged) {
                        labeled += parseInt(batch.units_packaged) || 0;
                        labeledWeight += parseFloat(batch.grams_labeled) || 0;
                    }
                }
            });
            
            // Update displays
            document.getElementById('companyTrimExtracted').textContent = `${trimExtracted.toLocaleString()}g`;
            document.getElementById('companyTrimBatches').textContent = `${trimBatches} batch${trimBatches !== 1 ? 'es' : ''}`;
            
            document.getElementById('companyFinished').textContent = `${finishedWeight.toLocaleString()}g`;
            document.getElementById('companyFinishedBatches').textContent = `${finishedBatches} batch${finishedBatches !== 1 ? 'es' : ''}`;
            
            document.getElementById('companyPackaged').textContent = packaged.toLocaleString();
            document.getElementById('companyPackagedWeight').textContent = `${packagedWeight.toLocaleString()}g total`;
            
            document.getElementById('companyLabeled').textContent = labeled.toLocaleString();
            document.getElementById('companyLabeledWeight').textContent = `${labeledWeight.toLocaleString()}g total`;
        }
        
        // Today's Production Summary
        function updateTodayProduction() {
            // Use local Colorado time instead of UTC
            const now = new Date();
            const localDate = new Date(now.getTime() - (now.getTimezoneOffset() * 60000));
            const today = localDate.toISOString().split('T')[0]; // YYYY-MM-DD format in local time
            
            // Display today's date
            const dateEl = document.getElementById('todayDate');
            if (dateEl) {
                dateEl.textContent = new Date().toLocaleDateString('en-US', { 
                    weekday: 'long', 
                    month: 'long', 
                    day: 'numeric' 
                });
            }
            
            let trimExtracted = 0;
            let trimBatches = 0;
            let finishedWeight = 0;
            let finishedBatches = 0;
            let packaged = 0;
            let packagedWeight = 0;
            let labeled = 0;
            let labeledWeight = 0;
            
            batches.forEach(batch => {
                // Check extraction completed today (from timeline)
                if (batch.timeline && batch.timeline.length > 0) {
                    const extractionEvent = batch.timeline.find(event => {
                        if (event.status === 'extraction' && event.timestamp) {
                            const eventTime = new Date(event.timestamp);
                            const localEventDate = new Date(eventTime.getTime() - (eventTime.getTimezoneOffset() * 60000));
                            const eventDate = localEventDate.toISOString().split('T')[0];
                            return eventDate === today;
                        }
                        return false;
                    });
                    
                    if (extractionEvent) {
                        trimExtracted += parseFloat(batch.trim_weight) || 0;
                        trimBatches++;
                    }
                }
                
                // Check finishing completed today
                if (batch.finishing_date) {
                    const finishTime = new Date(batch.finishing_date);
                    const localFinishDate = new Date(finishTime.getTime() - (finishTime.getTimezoneOffset() * 60000));
                    const finishingDate = localFinishDate.toISOString().split('T')[0];
                    if (finishingDate === today) {
                        finishedWeight += parseFloat(batch.final_weight) || parseFloat(batch.net_weight) || 0;
                        finishedBatches++;
                    }
                }
                
                // Check packaging done today
                if (batch.packaging_date) {
                    const packTime = new Date(batch.packaging_date);
                    const localPackDate = new Date(packTime.getTime() - (packTime.getTimezoneOffset() * 60000));
                    const packagingDate = localPackDate.toISOString().split('T')[0];
                    if (packagingDate === today && batch.units_packaged) {
                        packaged += parseInt(batch.units_packaged) || 0;
                        packagedWeight += parseFloat(batch.net_weight) || 0;
                    }
                }
                
                // Check labeling done today (from timeline)
                if (batch.timeline && batch.timeline.length > 0) {
                    const labelingEvent = batch.timeline.find(event => {
                        if ((event.stage === 'labeling' || event.status === 'complete') && event.timestamp) {
                            const eventTime = new Date(event.timestamp);
                            const localEventDate = new Date(eventTime.getTime() - (eventTime.getTimezoneOffset() * 60000));
                            const eventDate = localEventDate.toISOString().split('T')[0];
                            if (eventDate === today) {
                                const action = (event.action || event.note || '').toLowerCase();
                                return action.includes('label') || action.includes('complet');
                            }
                        }
                        return false;
                    });
                    
                    if (labelingEvent && batch.units_packaged) {
                        labeled += parseInt(batch.units_packaged) || 0;
                        labeledWeight += parseFloat(batch.grams_labeled) || 0;
                    }
                }
            });
            
            // Update displays
            document.getElementById('todayTrimExtracted').textContent = `${trimExtracted.toFixed(0)}g`;
            document.getElementById('todayTrimBatches').textContent = `${trimBatches} batch${trimBatches !== 1 ? 'es' : ''}`;
            
            document.getElementById('todayFinished').textContent = `${finishedWeight.toFixed(0)}g`;
            document.getElementById('todayFinishedBatches').textContent = `${finishedBatches} batch${finishedBatches !== 1 ? 'es' : ''}`;
            
            document.getElementById('todayPackaged').textContent = packaged.toLocaleString();
            document.getElementById('todayPackagedWeight').textContent = `${packagedWeight.toFixed(0)}g total`;
            
            document.getElementById('todayLabeled').textContent = labeled.toLocaleString();
            document.getElementById('todayLabeledWeight').textContent = `${labeledWeight.toFixed(0)}g total`;
        }
        
        // Login Activity Tracker
        function updateLoginTracker() {
            const now = new Date();
            const twentyFourHoursAgo = new Date(now.getTime() - (24 * 60 * 60 * 1000));
            const thirtyMinutesAgo = new Date(now.getTime() - (30 * 60 * 1000));
            
            // Get recent logins (last 24 hours)
            supabaseClient
                .from('wm_login_history')
                .select('*')
                .gte('login_time', twentyFourHoursAgo.toISOString())
                .order('login_time', { ascending: false })
                .limit(10)
                .then(({ data: logins, error }) => {
                    if (error) {
                        console.error('Error loading login history:', error);
                        return;
                    }
                    
                    // Find currently active users (logged in within 30 min and no logout)
                    const activeUsers = logins.filter(login => {
                        const loginTime = new Date(login.login_time);
                        return loginTime >= thirtyMinutesAgo && !login.logout_time;
                    });
                    
                    // Display active users
                    const activeUsersEl = document.getElementById('activeUsers');
                    if (activeUsers.length === 0) {
                        activeUsersEl.innerHTML = '<div style="color: var(--text-secondary); font-style: italic;">No active users</div>';
                    } else {
                        const uniqueUsers = [...new Set(activeUsers.map(u => u.user_name))];
                        activeUsersEl.innerHTML = uniqueUsers.map(name => {
                            const userLogin = activeUsers.find(u => u.user_name === name);
                            const loginTime = new Date(userLogin.login_time);
                            const minutesAgo = Math.floor((now - loginTime) / 1000 / 60);
                            const timeText = minutesAgo < 1 ? 'just now' : `${minutesAgo}m ago`;
                            return `<div style="padding: 5px 0; border-bottom: 1px solid var(--border);">
                                <strong>${name}</strong> <span style="color: var(--text-secondary); font-size: 0.85rem;">(${timeText})</span>
                            </div>`;
                        }).join('');
                    }
                    
                    // Display recent logins
                    const recentLoginsEl = document.getElementById('recentLogins');
                    if (logins.length === 0) {
                        recentLoginsEl.innerHTML = '<div style="color: var(--text-secondary); font-style: italic;">No recent logins</div>';
                    } else {
                        recentLoginsEl.innerHTML = logins.map(login => {
                            const loginTime = new Date(login.login_time);
                            const timeStr = loginTime.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });
                            const dateStr = loginTime.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                            
                            let sessionInfo = '';
                            if (login.logout_time) {
                                const duration = login.session_duration;
                                const hours = Math.floor(duration / 60);
                                const mins = duration % 60;
                                const durationStr = hours > 0 ? `${hours}h ${mins}m` : `${mins}m`;
                                sessionInfo = `<span style="color: var(--text-secondary);">(${durationStr})</span>`;
                            } else {
                                sessionInfo = '<span style="color: var(--accent-green);">â—</span>';
                            }
                            
                            return `<div style="padding: 5px 0; border-bottom: 1px solid var(--border); display: flex; justify-content: space-between;">
                                <div><strong>${login.user_name}</strong></div>
                                <div style="color: var(--text-secondary); font-size: 0.85rem;">${dateStr} ${timeStr} ${sessionInfo}</div>
                                <div style="color: var(--text-tertiary); font-size: 0.75rem;">${login.ip_address || ''}</div>
                            </div>`;
                        }).join('');
                    }
                });
        }
        
        // Login History Modal functions
        function openLoginHistoryModal() {
            document.getElementById('loginHistoryModal').style.display = 'block';
            loadLoginHistory();
        }

        function closeLoginHistoryModal() {
            document.getElementById('loginHistoryModal').style.display = 'none';
        }

        // LeafLink Approvals Modal functions
        function openLeafLinkApprovalsModal() {
            document.getElementById('leaflinkApprovalsModal').style.display = 'block';
            renderLeafLinkApprovalQueue();
        }

        function closeLeafLinkApprovalsModal() {
            document.getElementById('leaflinkApprovalsModal').style.display = 'none';
        }

        async function loadLoginHistory() {
            const contentEl = document.getElementById('loginHistoryContent');
            contentEl.innerHTML = 'Loading...';

            try {
                const sevenDaysAgo = new Date();
                sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);

                const { data: logins, error } = await supabaseClient
                    .from('wm_login_history')
                    .select('*')
                    .gte('login_time', sevenDaysAgo.toISOString())
                    .order('login_time', { ascending: false })
                    .limit(50);

                if (error) throw error;

                if (!logins || logins.length === 0) {
                    contentEl.innerHTML = '<div style="text-align: center; color: var(--text-secondary); padding: 40px;">No login records found</div>';
                    return;
                }

                contentEl.innerHTML = `
                    <table style="width: 100%; border-collapse: collapse;">
                        <thead>
                            <tr style="background: var(--bg-tertiary);">
                                <th style="padding: 12px; text-align: left; border-bottom: 2px solid var(--border);">User</th>
                                <th style="padding: 12px; text-align: left; border-bottom: 2px solid var(--border);">Login Time</th>
                                <th style="padding: 12px; text-align: left; border-bottom: 2px solid var(--border);">IP Address</th>
                                <th style="padding: 12px; text-align: left; border-bottom: 2px solid var(--border);">Session</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${logins.map(login => {
                                const loginTime = new Date(login.login_time);
                                const dateStr = loginTime.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                                const timeStr = loginTime.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });

                                let sessionInfo = '';
                                if (login.logout_time) {
                                    // Logged out - show session duration
                                    const duration = login.session_duration || 0;
                                    const hours = Math.floor(duration / 60);
                                    const mins = duration % 60;
                                    sessionInfo = hours > 0 ? `${hours}h ${mins}m` : `${mins}m`;
                                } else if (login.last_activity) {
                                    // Check how recent the activity was
                                    const lastActive = new Date(login.last_activity);
                                    const minutesAgo = Math.floor((Date.now() - lastActive.getTime()) / 60000);

                                    if (minutesAgo < 2) {
                                        sessionInfo = '<span style="color: var(--accent-green);">ðŸŸ¢ Active Now</span>';
                                    } else if (minutesAgo < 60) {
                                        sessionInfo = `<span style="color: var(--accent-orange);">ðŸŸ¡ Idle ${minutesAgo}m</span>`;
                                    } else {
                                        const hoursAgo = Math.floor(minutesAgo / 60);
                                        sessionInfo = `<span style="color: var(--text-secondary);">ðŸ’¤ Idle ${hoursAgo}h</span>`;
                                    }
                                } else {
                                    // No activity data yet - show as potentially idle
                                    const loginTime = new Date(login.login_time);
                                    const minutesSinceLogin = Math.floor((Date.now() - loginTime.getTime()) / 60000);
                                    if (minutesSinceLogin < 5) {
                                        sessionInfo = '<span style="color: var(--accent-green);">ðŸŸ¢ Just logged in</span>';
                                    } else {
                                        sessionInfo = '<span style="color: var(--text-secondary);">â“ Unknown</span>';
                                    }
                                }

                                return `
                                    <tr style="border-bottom: 1px solid var(--border);">
                                        <td style="padding: 12px;"><strong>${login.user_name}</strong></td>
                                        <td style="padding: 12px;">${dateStr} ${timeStr}</td>
                                        <td style="padding: 12px; font-family: monospace; font-size: 0.9rem;">${login.ip_address || '-'}</td>
                                        <td style="padding: 12px;">${sessionInfo}</td>
                                    </tr>
                                `;
                            }).join('')}
                        </tbody>
                    </table>
                `;
            } catch (err) {
                console.error('Error loading login history:', err);
                contentEl.innerHTML = '<div style="color: var(--accent-red); text-align: center; padding: 40px;">Error loading login history</div>';
            }
        }

        // Update button display on extraction page
        function updateSuppliesButton() {
            supabaseClient
                .from('wm_inventory')
                .select('*')
                .then(({ data: inventory, error }) => {
                    if (error) {
                        console.error('Error loading inventory:', error);
                        return;
                    }
                    
                    const butane = inventory.find(i => i.supply_type === 'butane');
                    const nitrogen = inventory.find(i => i.supply_type === 'nitrogen');
                    
                    const btnButane = document.getElementById('btnButaneDisplay');
                    const btnNitrogen = document.getElementById('btnNitrogenDisplay');
                    
                    if (btnButane && butane) {
                        btnButane.textContent = `${parseFloat(butane.current_level).toFixed(1)} lbs`;
                    }
                    
                    if (btnNitrogen && nitrogen) {
                        btnNitrogen.textContent = `${parseFloat(nitrogen.current_level).toFixed(1)} tanks`;
                    }
                });
        }
        
        // Helper function to save transactions
        function saveTransaction(type, action, previousAmount, newAmount, withdraw, add, notes) {
            const transactionKey = type === 'butane' ? 'wm_gas_transactions' : 'wm_nitrogen_transactions';
            const transactions = JSON.parse(localStorage.getItem(transactionKey) || '[]');
            
            transactions.push({
                timestamp: new Date().toISOString(),
                user: currentRole ? currentRole.name : 'Unknown',
                action: action,
                previousAmount: previousAmount,
                newAmount: newAmount,
                withdraw: withdraw,
                add: add,
                notes: notes
            });
            
            localStorage.setItem(transactionKey, JSON.stringify(transactions));
        }
        
        
        // Old functions - redirect to new ones
        function openGasModal() {
            // No longer used - interface is now inline
        }
        
        function closeGasModal() {
            // No longer used
        }
        
        // Inventory Management Functions (Redirect to gas modal)
        function openInventoryModal() {
            openGasModal();
        }
        
        function closeInventoryModal() {
            document.getElementById('inventoryModal').style.display = 'none';
        }
        
        function displayPersonalRecords(userName) {
            // Find best days
            const dailyStats = {};
            
            batches.forEach(batch => {
                // PACKAGING: Use packaging_user and packaging_date
                if (batch.packaging_user === userName && batch.packaging_date && batch.units_packaged) {
                    const date = batch.packaging_date;
                    if (!dailyStats[date]) {
                        dailyStats[date] = { packaged: 0, labeled: 0, extracted: 0 };
                    }
                    dailyStats[date].packaged += parseInt(batch.units_packaged) || 0;
                }
                
                // EXTRACTION: Use extraction_user and look for extraction timeline entry
                if (batch.extraction_user === userName && batch.trim_weight && batch.timeline) {
                    const extractionEvent = batch.timeline.find(e => 
                        e.stage === 'extraction' && e.user === userName
                    );
                    if (extractionEvent) {
                        const eventDate = new Date(extractionEvent.timestamp || extractionEvent.date);
                        const date = eventDate.toISOString().split('T')[0];
                        if (!dailyStats[date]) {
                            dailyStats[date] = { packaged: 0, labeled: 0, extracted: 0 };
                        }
                        dailyStats[date].extracted += parseFloat(batch.trim_weight) || 0;
                    }
                }
                
                // LABELING: Check timeline
                (batch.timeline || []).forEach(entry => {
                    if (!entry.date && !entry.timestamp) return;
                    if (!entry.user || entry.user !== userName) return;
                    if (!entry.action) return;
                    
                    const eventDate = new Date(entry.timestamp || entry.date);
                    const date = eventDate.toISOString().split('T')[0];
                    
                    if (!dailyStats[date]) {
                        dailyStats[date] = { packaged: 0, labeled: 0, extracted: 0 };
                    }
                    
                    const actionLower = entry.action.toLowerCase();
                    
                    if (entry.stage === 'labeling' && (actionLower.includes('labeled') || actionLower.includes('completed'))) {
                        dailyStats[date].labeled += parseInt(batch.units_packaged) || 0;
                    }
                });
            });
            
            // Find best records
            let bestPackaging = { date: '', units: 0 };
            let bestLabeling = { date: '', units: 0 };
            let bestExtraction = { date: '', grams: 0 };
            
            Object.entries(dailyStats).forEach(([date, stats]) => {
                if (stats.packaged > bestPackaging.units) {
                    bestPackaging = { date, units: stats.packaged };
                }
                if (stats.labeled > bestLabeling.units) {
                    bestLabeling = { date, units: stats.labeled };
                }
                if (stats.extracted > bestExtraction.grams) {
                    bestExtraction = { date, grams: stats.extracted };
                }
            });
            
            // Convert extraction grams to pounds if appropriate
            const extractedDisplay = bestExtraction.grams >= 454 
                ? `${(bestExtraction.grams / 453.592).toFixed(1)} lbs`
                : `${bestExtraction.grams.toFixed(0)}g`;
            
            const content = `
                ${bestPackaging.units > 0 ? `
                <div class="record-box">
                    <div style="font-size: 1.8rem; font-weight: 700; color: var(--accent-green); margin-bottom: 5px;">
                        ${bestPackaging.units} units
                    </div>
                    <div style="color: var(--text-secondary); font-size: 0.9rem;">
                        ðŸ“¦ Best Packaging Day
                    </div>
                    <div style="color: var(--text-secondary); font-size: 0.85rem; margin-top: 5px;">
                        ${new Date(bestPackaging.date).toLocaleDateString()}
                    </div>
                </div>
                ` : ''}
                
                ${bestLabeling.units > 0 ? `
                <div class="record-box" style="border-left-color: var(--accent-blue);">
                    <div style="font-size: 1.8rem; font-weight: 700; color: var(--accent-blue); margin-bottom: 5px;">
                        ${bestLabeling.units} units
                    </div>
                    <div style="color: var(--text-secondary); font-size: 0.9rem;">
                        ðŸ·ï¸ Best Labeling Day
                    </div>
                    <div style="color: var(--text-secondary); font-size: 0.85rem; margin-top: 5px;">
                        ${new Date(bestLabeling.date).toLocaleDateString()}
                    </div>
                </div>
                ` : ''}
                
                ${bestExtraction.grams > 0 ? `
                <div class="record-box" style="border-left-color: var(--accent-purple);">
                    <div style="font-size: 1.8rem; font-weight: 700; color: var(--accent-purple); margin-bottom: 5px;">
                        ${extractedDisplay}
                    </div>
                    <div style="color: var(--text-secondary); font-size: 0.9rem;">
                        âš—ï¸ Best Extraction Day
                    </div>
                    <div style="color: var(--text-secondary); font-size: 0.85rem; margin-top: 5px;">
                        ${new Date(bestExtraction.date).toLocaleDateString()}
                    </div>
                </div>
                ` : ''}
            `;
            
            document.getElementById('personalRecordsContent').innerHTML = content || '<p style="text-align: center; color: var(--text-secondary);">No records yet - start tracking your work!</p>';
        }

        // Feature #2: Personal Dashboard Quick Stats
        // Feature #2: Personal Dashboard Quick Stats (Workload Summary)
        function updatePersonalWorkloadStats() {
            const statsGrid = document.getElementById('personalStatsGrid');
            const statsTitle = document.getElementById('personalStatsTitle');
            
            if (!currentRole) {
                statsGrid.innerHTML = '<p style="color: var(--text-secondary); grid-column: 1/-1;">Login to see your personal workload</p>';
                statsTitle.textContent = 'Your Workload';
                return;
            }
            
            statsTitle.textContent = `${currentRole.name}'s Workload`;
            
            // Count batches at each stage
            const waitingExtraction = batches.filter(b => b.status === 'intake' && !(b.socks_total != null && b.socks_remaining === 0)).length;
            const waitingFinishing = batches.filter(b => b.status === 'extraction').length;
            const waitingPackaging = batches.filter(b => b.status === 'finishing').length;
            const waitingTesting = batches.filter(b => b.status === 'packaging' || (b.status === 'complete' && !b.test_thc_percent)).length;
            const waitingLabeling = batches.filter(b => b.status === 'complete' && b.test_thc_percent && !b.labels_applied).length;
            const paused = batches.filter(b => b.extraction_paused || b.packaging_paused || b.labeling_paused).length;
            
            const stats = [
                { label: 'Waiting Extraction', count: waitingExtraction, icon: 'âš—ï¸', color: 'var(--accent-orange)' },
                { label: 'Waiting Post-Extraction', count: waitingFinishing, icon: 'âœ¨', color: 'var(--accent-purple)' },
                { label: 'Waiting Packaging', count: waitingPackaging, icon: 'ðŸ“¦', color: 'var(--accent-blue)' },
                { label: 'Waiting Testing', count: waitingTesting, icon: 'ðŸ§ª', color: 'var(--accent-green)' },
                { label: 'Ready to Label', count: waitingLabeling, icon: 'ðŸ·ï¸', color: 'var(--accent-purple)' },
                { label: 'Paused (Need Attention)', count: paused, icon: 'â¸ï¸', color: '#ff9800' }
            ];
            
            statsGrid.innerHTML = stats.map(s => `
                <div style="background: var(--bg-tertiary); padding: 15px; border-radius: 8px; border-left: 4px solid ${s.color};">
                    <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 5px;">${s.icon} ${s.label}</div>
                    <div style="font-size: 2rem; font-weight: 700; color: ${s.count > 0 ? s.color : 'var(--text-secondary)'};">${s.count}</div>
                </div>
            `).join('');
        }

        // Feature #1: Enhanced Batch Search with Filtering
        function addDropdownSearchFilters() {
            // Add search to extraction dropdown
            addSearchToDropdown('extractionBatchSelect', 'extraction');
            // Add search to packaging dropdown
            addSearchToDropdown('packagingBatchSelect', 'packaging');
            // Add search to finishing dropdown
            addSearchToDropdown('finishingBatchSelect', 'finishing');
            // Add search to labeling dropdown
            addSearchToDropdown('labelingBatchSelect', 'labeling');
        }

        function addSearchToDropdown(selectId, stage) {
            const select = document.getElementById(selectId);
            if (!select) return;
            
            // Create search input
            const searchWrapper = document.createElement('div');
            searchWrapper.style.cssText = 'position: relative; margin-bottom: 10px;';
            
            const searchInput = document.createElement('input');
            searchInput.type = 'text';
            searchInput.placeholder = 'ðŸ” Search batch ID or strain...';
            searchInput.style.cssText = 'width: 100%; padding: 10px; background: var(--bg-secondary); border: 2px solid var(--border); border-radius: 8px; color: var(--text-primary); font-size: 0.95rem;';
            
            // Insert before dropdown
            select.parentNode.insertBefore(searchWrapper, select);
            searchWrapper.appendChild(searchInput);
            
            // Filter dropdown on search
            searchInput.addEventListener('input', function() {
                const searchTerm = this.value.toLowerCase();
                const options = select.querySelectorAll('option');
                
                options.forEach(opt => {
                    if (opt.value === '') {
                        opt.style.display = '';
                        return;
                    }
                    
                    const text = opt.textContent.toLowerCase();
                    opt.style.display = text.includes(searchTerm) ? '' : 'none';
                });
            });
        }

        // Feature #3: Batch Timeline Visual Progress Viewer
        function showBatchTimeline(batchId) {
            const batch = batches.find(b => b.id === batchId);
            if (!batch) return;
            
            const stages = [
                { name: 'Intake', status: 'intake', icon: 'ðŸ“¥', completed: batch.intake_date },
                { name: 'Extraction', status: 'extraction', icon: 'âš—ï¸', completed: batch.extraction_user, paused: batch.extraction_paused },
                { name: 'Post-Extraction', status: 'finishing', icon: 'âœ¨', completed: batch.finishing_user },
                { name: 'Packaging', status: 'packaging', icon: 'ðŸ“¦', completed: batch.packaging_user, paused: batch.packaging_paused },
                { name: 'Testing', status: 'testing', icon: 'ðŸ§ª', completed: batch.test_thc_percent },
                { name: 'Labeling', status: 'complete', icon: 'ðŸ·ï¸', completed: batch.labels_applied, paused: batch.labeling_paused }
            ];
            
            let currentStageIndex = stages.findIndex(s => s.status === batch.status);
            if (currentStageIndex === -1) currentStageIndex = stages.length - 1;
            
            return stages.map((stage, index) => {
                let statusIcon, statusColor, statusText;
                
                if (index < currentStageIndex) {
                    statusIcon = 'âœ…';
                    statusColor = 'var(--accent-green)';
                    statusText = 'Complete';
                } else if (index === currentStageIndex) {
                    if (stage.paused) {
                        statusIcon = 'â¸ï¸';
                        statusColor = '#ff9800';
                        statusText = 'Paused';
                    } else {
                        statusIcon = 'ðŸ”„';
                        statusColor = 'var(--accent-blue)';
                        statusText = 'In Progress';
                    }
                } else {
                    statusIcon = 'â³';
                    statusColor = 'var(--text-secondary)';
                    statusText = 'Waiting';
                }
                
                return `
                    <div style="display: flex; align-items: center; gap: 10px; padding: 8px; background: ${index === currentStageIndex ? 'rgba(59, 130, 246, 0.1)' : 'transparent'}; border-radius: 6px;">
                        <div style="font-size: 1.5rem;">${stage.icon}</div>
                        <div style="flex: 1;">
                            <div style="font-weight: 600;">${stage.name}</div>
                            <div style="font-size: 0.85rem; color: ${statusColor};">${statusIcon} ${statusText}</div>
                        </div>
                    </div>
                `;
            }).join('<div style="width: 2px; height: 15px; background: var(--border); margin-left: 23px;"></div>');
        }

        // Feature #4: Auto-Calculate Yield Percentage with Alerts
        function calculateYield(batch) {
            if (!batch.trim_weight) return null;
            
            // Prioritize grams_labeled (actual sellable weight after labeling) over final_weight (post-extraction)
            const finalWeight = batch.grams_labeled ? parseFloat(batch.grams_labeled) : 
                                batch.final_weight ? parseFloat(batch.final_weight) : null;
            
            if (!finalWeight) return null;
            
            const trimWeight = parseFloat(batch.trim_weight);
            
            if (trimWeight === 0) return null;
            
            const yieldPercent = (finalWeight / trimWeight) * 100;
            const expectedYield = batch.expected_yield || getExpectedYield(batch.material_type) || 13;
            const variance = yieldPercent - expectedYield;
            
            return {
                actual: yieldPercent,
                expected: expectedYield,
                variance: variance,
                status: variance < -3 ? 'low' : (variance > 3 ? 'high' : 'normal')
            };
        }

        function displayYieldAlert(batch, yieldData) {
            if (!yieldData) return '';
            
            let alertHTML = '';
            let statusIcon, statusColor, statusText;
            
            if (yieldData.status === 'low') {
                statusIcon = 'âš ï¸';
                statusColor = '#f44336';
                statusText = 'Low Yield Alert';
            } else if (yieldData.status === 'high') {
                statusIcon = 'ðŸŽ‰';
                statusColor = 'var(--accent-green)';
                statusText = 'Excellent Yield';
            } else {
                statusIcon = 'âœ…';
                statusColor = 'var(--accent-blue)';
                statusText = 'Normal Yield';
            }
            
            return `
                <div style="background: rgba(${statusColor === '#f44336' ? '244, 67, 54' : '59, 130, 246'}, 0.1); padding: 12px; border-radius: 8px; border-left: 4px solid ${statusColor}; margin-top: 10px;">
                    <div style="font-weight: 600; color: ${statusColor}; margin-bottom: 5px;">${statusIcon} ${statusText}</div>
                    <div style="font-size: 1.6rem; font-weight: 700; color: ${statusColor};">
                        ${yieldData.actual.toFixed(1)}% Yield
                    </div>
                </div>
            `;
        }

        // Feature #8: End-of-Day Report Generator
        function generateDailyReport() {
            const today = new Date().toISOString().split('T')[0];
            
            // Filter batches with activity today
            const todaysBatches = batches.filter(b => {
                const timeline = b.timeline || [];
                return timeline.some(t => t.date && t.date.startsWith(today));
            });
            
            // Count by stage
            const extracted = todaysBatches.filter(b => 
                (b.timeline || []).some(t => t.stage === 'extraction' && t.date.startsWith(today))
            ).length;
            
            const packaged = todaysBatches.filter(b => 
                (b.timeline || []).some(t => t.stage === 'packaging' && t.date.startsWith(today) && t.action.toLowerCase().includes('packaged'))
            ).length;
            
            const labeled = todaysBatches.filter(b => 
                (b.timeline || []).some(t => t.stage === 'labeling' && t.date.startsWith(today))
            ).length;
            
            // Employee performance
            const employeeActivity = {};
            todaysBatches.forEach(b => {
                (b.timeline || []).forEach(t => {
                    if (!t.date || !t.date.startsWith(today)) return;
                    if (!employeeActivity[t.user]) {
                        employeeActivity[t.user] = { extracted: 0, packaged: 0, labeled: 0 };
                    }
                    if (t.stage === 'extraction') employeeActivity[t.user].extracted++;
                    if (t.stage === 'packaging' && t.action.toLowerCase().includes('packaged')) employeeActivity[t.user].packaged++;
                    if (t.stage === 'labeling') employeeActivity[t.user].labeled++;
                });
            });
            
            return {
                date: today,
                batches: todaysBatches.length,
                extracted,
                packaged,
                labeled,
                employees: employeeActivity
            };
        }

        // Recalculate trim weight allocations for all existing sub-batches
        async function recalculateAllSubBatchYields() {
            if (!confirm('This will recalculate trim weight allocations for all sub-batches based on actual yields.\n\nThis affects yield calculations in the dashboard and analytics.\n\nContinue?')) {
                return;
            }
            
            // Find all parent batches that have been split
            const parentBatches = batches.filter(b => b.status === 'split');
            
            if (parentBatches.length === 0) {
                alert('No split batches found. Nothing to recalculate.');
                return;
            }
            
            let updatedCount = 0;
            let errorCount = 0;
            const updates = [];
            
            for (const parent of parentBatches) {
                // Find all sub-batches for this parent
                const subBatches = batches.filter(b => b.parent_batch_id === parent.id && b.is_sub_batch);
                
                if (subBatches.length === 0) continue;
                
                // Calculate total final weight across all sub-batches
                // Prioritize grams_labeled (actual sellable) over final_weight (post-extraction)
                const totalFinalWeight = subBatches.reduce((sum, sub) => {
                    const weight = sub.grams_labeled ? parseFloat(sub.grams_labeled) : parseFloat(sub.final_weight) || 0;
                    return sum + weight;
                }, 0);
                
                if (totalFinalWeight === 0) continue;
                
                // Calculate overall yield from parent trim to total sub-batch output
                const parentTrimWeight = parseFloat(parent.trim_weight) || 0;
                if (parentTrimWeight === 0) continue;
                
                const overallYieldPercent = (totalFinalWeight / parentTrimWeight) * 100;
                
                // Update each sub-batch with proportional trim weight
                for (const subBatch of subBatches) {
                    // Use grams_labeled if available, otherwise final_weight
                    const subFinalWeight = subBatch.grams_labeled ? parseFloat(subBatch.grams_labeled) : parseFloat(subBatch.final_weight) || 0;
                    if (subFinalWeight === 0) continue;
                    
                    // Back-calculate trim weight: if yield is 18% and final is 50g, trim = 50/0.18 = 277.8g
                    const newTrimWeight = overallYieldPercent > 0 
                        ? (subFinalWeight / overallYieldPercent) * 100
                        : 0;
                    
                    // Only update if different
                    if (Math.abs(newTrimWeight - (parseFloat(subBatch.trim_weight) || 0)) > 0.1) {
                        updates.push({
                            id: subBatch.id,
                            oldTrim: parseFloat(subBatch.trim_weight) || 0,
                            newTrim: newTrimWeight,
                            finalWeight: subFinalWeight,
                            yieldPercent: overallYieldPercent,
                            usedLabeledWeight: !!subBatch.grams_labeled
                        });
                        
                        // Update in database
                        const { error } = await supabaseClient
                            .from('wm_batches')
                            .update({
                                trim_weight: newTrimWeight,
                                intake_notes: (subBatch.intake_notes || '') + `\n[Yield recalculated: ${newTrimWeight.toFixed(1)}g trim for ${subFinalWeight.toFixed(1)}g ${subBatch.grams_labeled ? 'labeled' : 'bulk'} weight at ${overallYieldPercent.toFixed(2)}%]`
                            })
                            .eq('id', subBatch.id);
                        
                        if (error) {
                            console.error(`Error updating ${subBatch.id}:`, error);
                            errorCount++;
                        } else {
                            updatedCount++;
                        }
                    }
                }
            }
            
            if (updates.length === 0) {
                alert('All sub-batches already have correct trim allocations. Nothing to update.');
                return;
            }
            
            // Reload batches to reflect changes
            await loadBatches();
            
            // Show detailed report
            const reportDetails = updates.map(u => 
                `${u.id}: ${u.oldTrim.toFixed(1)}g â†’ ${u.newTrim.toFixed(1)}g trim (${u.finalWeight.toFixed(1)}g @ ${u.yieldPercent.toFixed(2)}%)`
            ).join('\n');
            
            alert(`âœ… Sub-Batch Yield Recalculation Complete!\n\nUpdated: ${updatedCount} batches\nErrors: ${errorCount}\n\nDetails:\n${reportDetails.substring(0, 500)}${reportDetails.length > 500 ? '\n...(truncated)' : ''}`);
        }

        function showDailyReportPopup() {
            const report = generateDailyReport();
            
            let employeeReport = Object.entries(report.employees).map(([name, stats]) => 
                `${name}: ${stats.extracted} extracted, ${stats.packaged} packaged, ${stats.labeled} labeled`
            ).join('\n');
            
            alert(`ðŸ“Š Daily Production Report
            
Date: ${report.date}

Summary:
â€¢ ${report.batches} batches with activity today
â€¢ ${report.extracted} batches extracted
â€¢ ${report.packaged} batches packaged  
â€¢ ${report.labeled} batches labeled

Employee Activity:
${employeeReport || 'No activity recorded today'}
            `);
        }


        function renderBatches(filter = 'all', searchTerm = '') {
            const container = document.getElementById('batchesList');
            let filteredBatches = batches;
            
            if (filter !== 'all') {
                if (filter === 'extraction') {
                    // Show batches waiting for extraction (at intake status)
                    filteredBatches = batches.filter(b => b.status === 'intake');
                } else if (filter === 'finishing') {
                    // Show batches waiting for post-extraction (at extraction status)
                    filteredBatches = batches.filter(b => b.status === 'extraction');
                } else if (filter === 'packaging') {
                    // Show batches waiting for packaging (at finishing status)
                    filteredBatches = batches.filter(b => b.status === 'finishing');
                } else if (filter === 'testing') {
                    // Show batches waiting for testing (at packaging status or complete without test results)
                    filteredBatches = batches.filter(b => 
                        b.status === 'packaging' || 
                        (b.status === 'complete' && !b.test_thc_percent)
                    );
                } else if (filter === 'labeling') {
                    // Show batches waiting for labeling (complete with test results but not labeled)
                    filteredBatches = batches.filter(b => 
                        b.status === 'complete' && 
                        b.test_thc_percent && 
                        !b.labels_applied
                    );
                } else if (filter === 'complete') {
                    // Show fully completed batches
                    filteredBatches = batches.filter(b => 
                        b.status === 'complete' && 
                        b.labels_applied
                    );
                } else if (filter === 'intake') {
                    // Show just intake (newly created batches)
                    filteredBatches = batches.filter(b => b.status === 'intake');
                } else {
                    // Fallback to status filter
                    filteredBatches = batches.filter(b => b.status === filter);
                }
            }
            
            if (searchTerm) {
                filteredBatches = filteredBatches.filter(b => 
                    b.id.toLowerCase().includes(searchTerm.toLowerCase()) ||
                    b.strain.toLowerCase().includes(searchTerm.toLowerCase())
                );
            }
            
            container.innerHTML = filteredBatches.map(batch => `
                <div class="batch-item">
                    <div style="display: flex; align-items: center; gap: 12px; flex-wrap: wrap; padding: 5px 0;">
                        <div class="batch-id" style="font-weight: 700; min-width: 90px;">${batch.id}</div>
                        <div class="batch-status status-${batch.status}" style="font-size: 0.7rem; padding: 2px 8px;">${batch.status.toUpperCase()}</div>
                        <div style="font-size: 1.2rem; font-weight: 700;">${batch.strain}</div>
                        <span style="color: var(--text-secondary); font-size: 0.85rem;">(${batch.strain_type})</span>
                        ${batch.final_weight ? `<div><strong>${batch.net_weight || batch.final_weight}g</strong></div>` : ''}
                        ${batch.final_weight && batch.trim_weight ? `<div style="font-weight: 700; color: ${((parseFloat(batch.final_weight) / parseFloat(batch.trim_weight)) * 100) < 15 ? '#f44336' : (((parseFloat(batch.final_weight) / parseFloat(batch.trim_weight)) * 100) > 21 ? 'var(--accent-green)' : 'var(--accent-blue)')};">${((parseFloat(batch.final_weight) / parseFloat(batch.trim_weight)) * 100).toFixed(1)}%</div>` : ''}
                        <div style="color: var(--text-secondary);">Trim: ${batch.trim_weight}g</div>
                        ${batch.grams_labeled ? `<div style="color: var(--text-secondary);">Lab: ${batch.grams_labeled}g</div>` : ''}
                        ${batch.is_sub_batch ? `<div style="color: var(--accent-purple); font-size: 0.8rem;">ðŸ”—${batch.parent_batch_id}</div>` : ''}

                        <div style="margin-left: auto; display: flex; align-items: center; gap: 6px;">
                            ${currentRole && currentRole.canEditBatches ? `
                                <button class="btn" style="background: var(--accent-orange); padding: 8px 14px; font-size: 1rem;" onclick="event.stopPropagation(); openEditBatch('${batch.id}')">âœï¸</button>
                                ${batch.is_sub_batch ? `
                                    <button class="btn" style="background: var(--accent-red); padding: 8px 14px; font-size: 1rem;" onclick="event.stopPropagation(); deleteSubBatch('${batch.id}')">ðŸ—‘ï¸</button>
                                ` : `
                                    <button class="btn" style="background: var(--accent-green); padding: 8px 14px; font-size: 1rem;" onclick="event.stopPropagation(); openCreateSubBatch('${batch.id}')">âž•</button>
                                    <button class="btn" style="background: #ef4444; padding: 8px 14px; font-size: 1rem;" onclick="event.stopPropagation(); openDeleteBatchModal('${batch.id}')">ðŸ—‘ï¸</button>
                                `}
                            ` : ''}
                            <span onclick="toggleBatchTimeline('${batch.id}')" style="cursor: pointer; color: var(--accent-blue); padding: 3px 6px;" id="timeline-toggle-${batch.id}">â–¼</span>
                        </div>
                    </div>

                    <div class="batch-details" style="display: none;">
                        ${batch.is_sub_batch ? `
                            <div class="batch-detail" style="background: rgba(147, 51, 234, 0.1); border-left: 3px solid var(--accent-purple); padding: 8px; border-radius: 4px; grid-column: 1/-1;">
                                <div class="batch-detail-label">ðŸ”— Sub-Batch Of</div>
                                <div class="batch-detail-value">${batch.parent_batch_id}</div>
                            </div>
                        ` : ''}
                        <div class="batch-detail" style="grid-column: 1/-1;">
                            <div class="batch-detail-value" style="font-size: 1.4rem; font-weight: 700;">${batch.strain} <span style="font-weight: 400; font-size: 0.9rem; color: var(--text-secondary);">(${batch.strain_type})</span></div>
                        </div>
                        ${batch.final_weight ? `
                            <div class="batch-detail">
                                <div class="batch-detail-label">Net Wt</div>
                                <div class="batch-detail-value" style="font-weight: 600;">${batch.net_weight || batch.final_weight}g</div>
                            </div>
                            <div class="batch-detail">
                                <div class="batch-detail-label">Yield</div>
                                <div class="batch-detail-value" style="font-weight: 700; font-size: 1.1rem; color: ${((parseFloat(batch.final_weight) / parseFloat(batch.trim_weight)) * 100) < 15 ? '#f44336' : (((parseFloat(batch.final_weight) / parseFloat(batch.trim_weight)) * 100) > 21 ? 'var(--accent-green)' : 'var(--accent-blue)')};">${((parseFloat(batch.final_weight) / parseFloat(batch.trim_weight)) * 100).toFixed(1)}%</div>
                            </div>
                        ` : ''}
                        <div class="batch-detail">
                            <div class="batch-detail-label">Trim</div>
                            <div class="batch-detail-value">${batch.trim_weight}g</div>
                        </div>
                        ${batch.grams_labeled ? `
                            <div class="batch-detail">
                                <div class="batch-detail-label">Labeled</div>
                                <div class="batch-detail-value">${batch.grams_labeled}g</div>
                            </div>
                        ` : ''}
                        ${(() => {
                            // Calculate weight discrepancy between bulk and labeled weight
                            if (batch.grams_labeled && batch.net_weight) {
                                const labeled = parseFloat(batch.grams_labeled);
                                const bulk = parseFloat(batch.net_weight);
                                const discrepancy = bulk - labeled;
                                const discrepancyPercent = (discrepancy / bulk) * 100;
                                
                                // Show alert if discrepancy is > 5% or > 5g
                                if (Math.abs(discrepancyPercent) > 5 || Math.abs(discrepancy) > 5) {
                                    const isHigh = discrepancyPercent > 0;
                                    const icon = isHigh ? 'âš ï¸' : 'âœ…';
                                    const color = isHigh ? 'var(--accent-orange)' : 'var(--accent-green)';
                                    const bgColor = isHigh ? 'rgba(245, 158, 11, 0.1)' : 'rgba(16, 185, 129, 0.1)';
                                    
                                    return `
                                        <div style="grid-column: 1/-1; background: ${bgColor}; padding: 10px; border-radius: 8px; border-left: 4px solid ${color}; margin-top: 5px;">
                                            <div style="font-weight: 600; color: ${color}; font-size: 0.9rem; margin-bottom: 3px;">
                                                ${icon} Weight Discrepancy
                                            </div>
                                            <div style="font-size: 0.85rem; color: var(--text-secondary);">
                                                Lost: ${discrepancy.toFixed(1)}g (${discrepancyPercent.toFixed(1)}%) between bulk and labeled
                                            </div>
                                            ${batch.weight_discrepancy !== undefined ? `
                                                <div style="font-size: 0.8rem; color: var(--text-secondary); margin-top: 3px; font-style: italic;">
                                                    Note: ${batch.discrepancy_accepted ? 'Discrepancy noted and accepted' : 'Discrepancy recorded'}
                                                </div>
                                            ` : ''}
                                        </div>
                                    `;
                                }
                            }
                            return '';
                        })()}
                        ${batch.units_packaged ? `
                            <div class="batch-detail">
                                <div class="batch-detail-label">Units Packaged</div>
                                <div class="batch-detail-value">${batch.units_packaged} units${batch.packaging_breakdown ? ` (${batch.packaging_breakdown})` : ''}</div>
                            </div>
                        ` : ''}
                        <!-- Comprehensive Batch Tracking Section -->
                        <div style="grid-column: 1/-1; margin-top: 15px;">
                            <!-- Current Stage Badge -->
                            <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 15px; padding-bottom: 15px; border-bottom: 2px solid var(--accent-purple);">
                                <span style="font-size: 1.1rem; color: var(--text-secondary);">Current Stage:</span>
                                <span style="font-size: 1.2rem; font-weight: 700; padding: 8px 20px; border-radius: 25px; text-transform: uppercase; background: ${batch.status === 'complete' ? 'var(--accent-green)' : batch.status === 'intake' ? 'var(--accent-blue)' : batch.status === 'extraction' ? 'var(--accent-purple)' : batch.status === 'finishing' ? 'var(--accent-orange)' : 'var(--accent-yellow)'}; color: white;">
                                    ${batch.status === 'intake' ? 'ðŸ“¥ Intake' : batch.status === 'extraction' ? 'âš—ï¸ Extraction' : batch.status === 'finishing' ? 'âœ¨ Finishing' : batch.status === 'packaging' ? 'ðŸ“¦ Packaging' : batch.status === 'testing' ? 'ðŸ§ª Testing' : batch.status === 'labeling' ? 'ðŸ·ï¸ Labeling' : batch.status === 'complete' ? 'âœ… Complete' : batch.status}
                                </span>
                            </div>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">

                                <!-- INTAKE LABEL CARD -->
                                <div style="background: var(--bg-secondary); border-radius: 16px; padding: 20px; box-shadow: 0 4px 6px rgba(0,0,0,0.3); border-left: 4px solid var(--accent-blue);">
                                    <div style="font-weight: 700; color: var(--accent-blue); font-size: 1.3rem; margin-bottom: 15px; display: flex; align-items: center; gap: 10px;"><span style="font-size: 1.5rem;">ðŸ“¥</span> INTAKE DATA</div>
                                    <div style="font-size: 1.1rem; line-height: 2;">
                                        <div style="margin-bottom: 6px;"><strong>Batch ID:</strong> <span style="font-family: monospace; background: var(--bg-tertiary); padding: 2px 6px; border-radius: 4px;">${batch.id}</span></div>
                                        <div style="margin-bottom: 6px;"><strong>Strain:</strong> ${batch.strain} <span style="color: var(--text-secondary);">(${batch.strain_type})</span></div>
                                        <div style="margin-bottom: 6px;"><strong>Trim Weight:</strong> ${batch.trim_weight || 0}g</div>
                                        <div style="margin-bottom: 6px;"><strong>Socks:</strong> ${batch.socks_total || 'N/A'} total${batch.socks_remaining != null ? ' (' + batch.socks_remaining + ' remaining)' : ''}</div>
                                        <div style="margin-bottom: 6px;"><strong>Intake Date:</strong> ${batch.intake_date ? new Date(batch.intake_date).toLocaleDateString() : 'N/A'}</div>
                                        <div style="margin-bottom: 6px;"><strong>Grower:</strong> ${batch.grower_name || 'N/A'}</div>
                                        <div style="margin-bottom: 6px;"><strong>License (403):</strong> <span style="font-family: monospace;">${batch.cultivation_license || 'N/A'}</span></div>
                                        <div style="margin-bottom: 6px;"><strong>Agreement:</strong> ${batch.material_agreement || 'N/A'}</div>
                                        <div style="margin-bottom: 6px;"><strong>Planned Products:</strong> ${batch.planned_products && batch.planned_products.length > 0 ? batch.planned_products.join(', ') : 'N/A'}</div>
                                        <div style="margin-bottom: 6px;"><strong>METRC Source Tags:</strong></div>
                                        <div style="font-family: monospace; font-size: 0.8rem; background: var(--bg-tertiary); padding: 8px; border-radius: 6px; word-break: break-all;">${batch.metrc_tags || 'None assigned'}</div>
                                        ${batch.intake_notes ? '<div style="margin-top: 8px;"><strong>Intake Notes:</strong> <span style="color: var(--text-secondary);">' + batch.intake_notes + '</span></div>' : ''}
                                    </div>
                                </div>

                                <!-- POST-PRODUCTION LABEL CARD -->
                                <div style="background: var(--bg-secondary); border-radius: 16px; padding: 20px; box-shadow: 0 4px 6px rgba(0,0,0,0.3); border-left: 4px solid var(--accent-green);">
                                    <div style="font-weight: 700; color: var(--accent-green); font-size: 1.3rem; margin-bottom: 15px; display: flex; align-items: center; gap: 10px;"><span style="font-size: 1.5rem;">ðŸ“¤</span> POST-PRODUCTION DATA</div>
                                    <div style="font-size: 1.1rem; line-height: 2;">
                                        <div style="margin-bottom: 6px;"><strong>Status:</strong> <span style="text-transform: uppercase; font-weight: 600; color: ${batch.status === 'complete' ? 'var(--accent-green)' : batch.status === 'extraction' ? 'var(--accent-blue)' : 'var(--accent-yellow)'};">${batch.status}</span></div>
                                        <div style="margin-bottom: 6px;"><strong>Final Weight:</strong> ${batch.final_weight || 'Not yet'}${batch.final_weight ? 'g' : ''}</div>
                                        <div style="margin-bottom: 6px;"><strong>Sample Weight:</strong> ${batch.sample_weight || 0}g</div>
                                        <div style="margin-bottom: 6px;"><strong>Net Weight:</strong> ${batch.net_weight || 'N/A'}${batch.net_weight ? 'g' : ''}</div>
                                        <div style="margin-bottom: 6px;"><strong>Product Type:</strong> ${batch.product_type || 'N/A'}</div>
                                        <div style="margin-bottom: 6px;"><strong>Extraction Date:</strong> ${batch.extraction_date ? new Date(batch.extraction_date).toLocaleDateString() : 'Not yet'}</div>
                                        <div style="margin-bottom: 6px;"><strong>Units Packaged:</strong> ${batch.units_packaged || 'N/A'}${batch.packaging_breakdown ? ' (' + batch.packaging_breakdown + ')' : ''}</div>
                                        ${batch.parent_batch_id ? '<div style="margin-bottom: 6px;"><strong>Parent Batch:</strong> <span style="font-family: monospace; background: rgba(147, 51, 234, 0.2); padding: 2px 6px; border-radius: 4px;">' + batch.parent_batch_id + '</span></div>' : ''}
                                        ${batch.extraction_notes ? '<div style="margin-top: 8px;"><strong>Extraction Notes:</strong> <span style="color: var(--text-secondary);">' + batch.extraction_notes + '</span></div>' : ''}
                                        ${batch.finishing_notes ? '<div style="margin-top: 4px;"><strong>Finishing Notes:</strong> <span style="color: var(--text-secondary);">' + batch.finishing_notes + '</span></div>' : ''}
                                    </div>
                                </div>
                            </div>

                            <!-- SOURCE CONTRIBUTIONS - Full Width -->
                            ${(() => {
                                let sourceContributions = batch.source_contributions || [];
                                if (typeof sourceContributions === 'string') {
                                    try { sourceContributions = JSON.parse(sourceContributions); } catch(e) { sourceContributions = []; }
                                }
                                if (sourceContributions.length > 0) {
                                    let rows = sourceContributions.map(s =>
                                        '<tr style="border-bottom: 1px solid var(--border-color);">' +
                                        '<td style="padding: 6px; font-family: monospace;">' + s.batch_id + '</td>' +
                                        '<td style="padding: 6px;">' + (s.trim_weight ? s.trim_weight + 'g' : s.socks + ' socks') + '</td>' +
                                        '<td style="padding: 6px; font-family: monospace; font-size: 0.8rem;">' + (s.metrc_tag || 'N/A') + '</td>' +
                                        '</tr>'
                                    ).join('');
                                    return '<div style="margin-top: 15px; background: rgba(147, 51, 234, 0.1); border: 2px solid var(--accent-purple); border-radius: 12px; padding: 15px;">' +
                                        '<div style="font-weight: 700; color: var(--accent-purple); margin-bottom: 10px;">ðŸ”— SOURCE CONTRIBUTIONS (Combined From)</div>' +
                                        '<table style="width: 100%; font-size: 0.85rem; border-collapse: collapse;">' +
                                        '<thead><tr style="background: var(--bg-tertiary);"><th style="padding: 8px; text-align: left;">Source Batch</th><th style="padding: 8px; text-align: left;">Amount Used</th><th style="padding: 8px; text-align: left;">METRC Tag</th></tr></thead>' +
                                        '<tbody>' + rows + '</tbody></table></div>';
                                }
                                return '';
                            })()}
                        </div>
                    </div>

                                        <div class="timeline" id="timeline-${batch.id}" style="display: none;">
                        <!-- Activity History Dropdown -->
                        <div style="margin-top: 10px;">
                            <div onclick="this.nextElementSibling.style.display = this.nextElementSibling.style.display === 'none' ? 'block' : 'none'; this.querySelector('.arrow').textContent = this.nextElementSibling.style.display === 'none' ? 'â–¶' : 'â–¼';"
                                 style="background: var(--bg-secondary); padding: 15px 20px; border-radius: 12px; cursor: pointer; display: flex; align-items: center; gap: 12px; font-size: 1.2rem; font-weight: 600; color: var(--accent-blue); box-shadow: 0 2px 4px rgba(0,0,0,0.2);">
                                <span class="arrow">â–¶</span> ðŸ“ Activity History (${(batch.timeline || []).length} entries)
                            </div>
                            <div style="display: none; background: var(--bg-tertiary); border-radius: 0 0 12px 12px; padding: 15px; margin-top: 2px;">
                                ${(batch.timeline || []).length > 0 ? (batch.timeline || []).map(t =>
                                    '<div style="padding: 12px; border-bottom: 1px solid var(--border-color); font-size: 1rem;">' +
                                    '<div><strong style="color: var(--accent-purple);">' + t.user + '</strong> - ' + t.action + '</div>' +
                                    '<div style="color: var(--text-secondary); font-size: 0.95rem; margin-top: 4px;">' + new Date(t.date).toLocaleString() + '</div>' +
                                    '</div>'
                                ).join('') : '<div style="padding: 12px; color: var(--text-secondary);">No activity recorded yet</div>'}
                            </div>
                        </div>
                    </div>
                    
                </div>
            `).join('');
        }

        // Filter buttons
        document.querySelectorAll('.filter-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                
                const filter = this.dataset.filter;
                const searchTerm = document.getElementById('searchBatches').value;
                renderBatches(filter, searchTerm);
            });
        });

        // Search
        document.getElementById('searchBatches').addEventListener('input', function() {
            const activeFilter = document.querySelector('.filter-btn.active').dataset.filter;
            renderBatches(activeFilter, this.value);
        });

        // Toggle batch timeline visibility
        function toggleBatchTimeline(batchId) {
            const timeline = document.getElementById(`timeline-${batchId}`);
            const toggle = document.getElementById(`timeline-toggle-${batchId}`);
            const batchItem = toggle.closest('.batch-item');
            const batchDetails = batchItem ? batchItem.querySelector('.batch-details') : null;

            if (timeline.style.display === 'none') {
                timeline.style.display = 'block';
                if (batchDetails) batchDetails.style.display = 'grid';
                toggle.textContent = 'Hide Details â–²';
            } else {
                timeline.style.display = 'none';
                if (batchDetails) batchDetails.style.display = 'none';
                toggle.textContent = 'â–¼';
            }
        }

        function initializeApp() {
            document.querySelectorAll('input[type="date"]').forEach(input => {
                if (!input.value) {
                    input.value = new Date().toISOString().split('T')[0];
                }
            });
            
            document.getElementById('batchId').value = `WM-${batchCounter}`;
            
            // Add pre-sift change handler to highlight hash products
            const preSiftSelect = document.getElementById('preSift');
            if (preSiftSelect) {
                preSiftSelect.addEventListener('change', function() {
                    const brickHashLabel = document.getElementById('brickHash')?.parentElement;
                    const hashHitsLabel = document.getElementById('hashHits')?.parentElement;
                    
                    if (this.value === 'yes') {
                        // Highlight hash products as required
                        if (brickHashLabel) {
                            brickHashLabel.style.background = 'rgba(245, 158, 11, 0.2)';
                            brickHashLabel.style.border = '2px solid var(--accent-orange)';
                            brickHashLabel.style.borderRadius = '8px';
                            brickHashLabel.style.padding = '8px';
                        }
                        if (hashHitsLabel) {
                            hashHitsLabel.style.background = 'rgba(245, 158, 11, 0.2)';
                            hashHitsLabel.style.border = '2px solid var(--accent-orange)';
                            hashHitsLabel.style.borderRadius = '8px';
                            hashHitsLabel.style.padding = '8px';
                        }
                    } else {
                        // Remove highlighting
                        if (brickHashLabel) {
                            brickHashLabel.style.background = '';
                            brickHashLabel.style.border = '';
                            brickHashLabel.style.padding = '';
                        }
                        if (hashHitsLabel) {
                            hashHitsLabel.style.background = '';
                            hashHitsLabel.style.border = '';
                            hashHitsLabel.style.padding = '';
                        }
                    }
                });
            }
        }

        // Testing functions
        function populateTestingSelect() {
            const select = document.getElementById('testingBatchSelect');
            // Show batches that are finishing or complete, but NOT yet labeled
            const testableBatches = batches.filter(b =>
                (b.status === 'finishing' || b.status === 'complete') && !b.labeling_date
            );

            select.innerHTML = '<option value="">Select a batch...</option>';
            testableBatches.forEach(batch => {
                let statusIcon = '';
                if (batch.test_results_received_date) {
                    statusIcon = 'âœ“ '; // Has results
                } else if (batch.test_submitted_date) {
                    statusIcon = 'ðŸ“¤ '; // Submitted to lab
                } else if (batch.ready_for_testing_date) {
                    statusIcon = 'âœ… '; // Ready for testing
                }
                select.innerHTML += `<option value="${batch.id}">${statusIcon}${batch.id} - ${batch.strain} - ${batch.product_made}</option>`;
            });
        }

        document.getElementById('testingBatchSelect').addEventListener('change', function() {
            const form = document.getElementById('testingForm');
            form.style.display = this.value ? 'block' : 'none';
            
            if (this.value) {
                const batch = batches.find(b => b.id === this.value);
                
                // Display current batch ID
                document.getElementById('currentBatchIdDisplay').textContent = batch.id;
                
                // Calculate trim used for this batch
                let trimUsedInfo = '';
                if (batch.is_sub_batch && batch.parent_batch_id) {
                    // Sub-batch: calculate proportional trim used
                    const parentBatch = batches.find(b => b.id === batch.parent_batch_id);
                    if (parentBatch) {
                        const parentTrimWeight = parseFloat(parentBatch.adjusted_trim_weight || parentBatch.trim_weight || 0);
                        const thisBatchWeight = parseFloat(batch.final_weight || batch.net_weight || 0);

                        // Calculate total output from ALL batches sharing this parent's trim
                        // This includes the parent (if it has output) and all sub-batches
                        const allSiblings = batches.filter(b => b.parent_batch_id === batch.parent_batch_id);
                        let totalFamilyOutput = allSiblings.reduce((sum, b) =>
                            sum + parseFloat(b.final_weight || b.net_weight || 0), 0);

                        // Also add parent's own output if it has one (some parents keep output)
                        const parentOutput = parseFloat(parentBatch.final_weight || parentBatch.net_weight || 0);
                        // Only add parent if it's not also a sub-batch (to avoid double counting)
                        if (parentOutput > 0 && !parentBatch.is_sub_batch) {
                            // Check if parent still has its own separate output
                            const parentHasOwnProduct = parentBatch.product_made && allSiblings.length > 0;
                            if (parentHasOwnProduct) {
                                totalFamilyOutput += parentOutput;
                            } else if (allSiblings.length === 0) {
                                // No sub-batches, use parent output
                                totalFamilyOutput = parentOutput;
                            }
                        }

                        // If no family output calculated, fall back to parent output
                        if (totalFamilyOutput === 0) {
                            totalFamilyOutput = parentOutput;
                        }

                        if (totalFamilyOutput > 0) {
                            const trimUsed = (thisBatchWeight / totalFamilyOutput) * parentTrimWeight;
                            const yieldPercent = trimUsed > 0 ? (thisBatchWeight / trimUsed) * 100 : 0;
                            trimUsedInfo = `
                                <div style="background: rgba(59, 130, 246, 0.15); padding: 15px; border-radius: 8px; margin: 10px 0; border-left: 4px solid var(--accent-blue);">
                                    <p style="margin: 0 0 8px 0;"><strong style="color: var(--accent-blue);">ðŸ“Š Calculated Trim (Sub-Batch)</strong></p>
                                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                                        <div>
                                            <span style="color: var(--text-secondary); font-size: 0.85rem;">Trim Used:</span><br>
                                            <strong style="font-size: 1.3rem; color: var(--accent-green);">${trimUsed.toFixed(1)}g</strong>
                                        </div>
                                        <div>
                                            <span style="color: var(--text-secondary); font-size: 0.85rem;">Yield:</span><br>
                                            <strong style="font-size: 1.3rem; color: var(--accent-purple);">${yieldPercent.toFixed(2)}%</strong>
                                        </div>
                                    </div>
                                    <p style="margin: 10px 0 0 0; font-size: 0.85rem; color: var(--text-secondary);">
                                        Sub-batch of <strong>${parentBatch.id}</strong> â€¢ ${parentTrimWeight.toFixed(1)}g total trim Ã· ${totalFamilyOutput.toFixed(1)}g total output
                                    </p>
                                </div>
                            `;
                        }
                    }
                } else if (batch.extraction_method === 'Dry Sift') {
                    // Sift batch: the sift weight IS the trim used
                    trimUsedInfo = `
                        <div style="background: rgba(16, 185, 129, 0.15); padding: 12px; border-radius: 8px; margin: 10px 0; border-left: 4px solid var(--accent-green);">
                            <strong>Trim Used:</strong> <span style="font-size: 1.2rem; font-weight: 700; color: var(--accent-green);">${batch.trim_weight}g</span> (dry sift)
                        </div>
                    `;
                } else {
                    // Check if this batch has sub-batches (parent batch)
                    const subBatches = batches.filter(b => b.parent_batch_id === batch.id);
                    const trimWeight = parseFloat(batch.adjusted_trim_weight || batch.trim_weight || 0);
                    const finalWeight = parseFloat(batch.final_weight || batch.net_weight || 0);

                    if (subBatches.length > 0 && finalWeight > 0) {
                        // Parent batch with sub-batches - calculate proportional trim
                        const totalSubBatchOutput = subBatches.reduce((sum, b) =>
                            sum + parseFloat(b.final_weight || b.net_weight || 0), 0);
                        const totalFamilyOutput = finalWeight + totalSubBatchOutput;
                        const trimUsed = totalFamilyOutput > 0 ? (finalWeight / totalFamilyOutput) * trimWeight : trimWeight;
                        const yieldPercent = trimUsed > 0 ? (finalWeight / trimUsed) * 100 : 0;

                        trimUsedInfo = `
                            <div style="background: rgba(245, 158, 11, 0.15); padding: 15px; border-radius: 8px; margin: 10px 0; border-left: 4px solid var(--accent-orange);">
                                <p style="margin: 0 0 8px 0;"><strong style="color: var(--accent-orange);">ðŸ“Š Calculated Trim (Has ${subBatches.length} Sub-Batch${subBatches.length > 1 ? 'es' : ''})</strong></p>
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                                    <div>
                                        <span style="color: var(--text-secondary); font-size: 0.85rem;">Trim Used (this batch):</span><br>
                                        <strong style="font-size: 1.3rem; color: var(--accent-green);">${trimUsed.toFixed(1)}g</strong>
                                    </div>
                                    <div>
                                        <span style="color: var(--text-secondary); font-size: 0.85rem;">Yield:</span><br>
                                        <strong style="font-size: 1.3rem; color: var(--accent-purple);">${yieldPercent.toFixed(2)}%</strong>
                                    </div>
                                </div>
                                <p style="margin: 10px 0 0 0; font-size: 0.85rem; color: var(--text-secondary);">
                                    Total trim: ${trimWeight.toFixed(1)}g â€¢ Total output (all batches): ${totalFamilyOutput.toFixed(1)}g
                                </p>
                            </div>
                        `;
                    } else {
                        // Regular batch without sub-batches
                        const yieldPercent = trimWeight > 0 ? (finalWeight / trimWeight) * 100 : 0;

                        trimUsedInfo = `
                            <div style="background: rgba(16, 185, 129, 0.15); padding: 12px; border-radius: 8px; margin: 10px 0; border-left: 4px solid var(--accent-green);">
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <div>
                                        <strong>Trim Used:</strong> <span style="font-size: 1.2rem; font-weight: 700; color: var(--accent-green);">${trimWeight.toFixed(1)}g</span>${batch.adjusted_trim_weight ? ' <span style="color: var(--text-secondary);">(after sift)</span>' : ''}
                                    </div>
                                    <div>
                                        <strong>Yield:</strong> <span style="font-size: 1.2rem; font-weight: 700; color: var(--accent-purple);">${yieldPercent.toFixed(2)}%</span>
                                    </div>
                                </div>
                            </div>
                        `;
                    }
                }
                
                // Parse source contributions if they exist
                let sourceContributions = batch.source_contributions || [];
                if (typeof sourceContributions === 'string') {
                    try { sourceContributions = JSON.parse(sourceContributions); } catch(e) { sourceContributions = []; }
                }

                // Build source contributions HTML for METRC
                let sourceContributionsHtml = '';
                if (sourceContributions.length > 1) {
                    const totalSocks = sourceContributions.reduce((sum, p) => sum + p.socks, 0);
                    const totalTrimFromSources = sourceContributions.reduce((sum, p) => sum + (parseFloat(p.trim_weight) || 0), 0);
                    sourceContributionsHtml = `
                        <div style="background: rgba(239, 68, 68, 0.15); padding: 15px; border-radius: 8px; margin: 15px 0; border: 2px solid var(--accent-red);">
                            <p style="margin: 0 0 10px 0;"><strong style="color: var(--accent-red);">âš ï¸ MIXED SOURCE BATCH - PARTIAL TAGS</strong></p>
                            <p style="margin: 0 0 15px 0; font-size: 0.9rem; color: var(--text-secondary);">
                                This batch used trim from multiple source tags. Only a portion of each tag's trim was used.
                            </p>
                            <div style="background: var(--bg-secondary); padding: 12px; border-radius: 8px; margin-bottom: 12px;">
                                <strong>Total Trim Used:</strong> <span style="font-size: 1.2rem; font-weight: 700; color: var(--accent-orange);">${totalTrimFromSources.toFixed(1)}g</span> from ${sourceContributions.length} sources
                            </div>
                            ${sourceContributions.map(p => {
                                const percentage = ((p.socks / totalSocks) * 100).toFixed(1);
                                const trimUsed = parseFloat(p.trim_weight) || 0;
                                return `<div style="background: var(--bg-tertiary); padding: 12px; border-radius: 6px; margin: 8px 0;">
                                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                        <div>
                                            <span style="background: var(--accent-orange); color: white; padding: 2px 8px; border-radius: 4px; font-size: 0.75rem; font-weight: 700;">PARTIAL</span>
                                            <strong style="margin-left: 8px;">${p.batch_id}</strong> â€¢ ${p.strain || 'Unknown'}
                                        </div>
                                        <div style="text-align: right;">
                                            <span style="color: var(--accent-purple); font-weight: 700;">${percentage}%</span>
                                        </div>
                                    </div>
                                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; font-size: 0.9rem;">
                                        <div>
                                            <span style="color: var(--text-secondary);">METRC Tag:</span><br>
                                            <strong style="font-family: 'Space Mono', monospace; color: var(--accent-blue);">${p.metrc_tag || 'Not set'}</strong>
                                        </div>
                                        <div>
                                            <span style="color: var(--text-secondary);">Trim Used:</span><br>
                                            <strong style="color: var(--accent-green);">${trimUsed.toFixed(1)}g</strong> <span style="color: var(--text-secondary);">(${p.socks} socks)</span>
                                        </div>
                                    </div>
                                </div>`;
                            }).join('')}
                            <p style="margin: 12px 0 0 0; padding: 10px; background: rgba(59, 130, 246, 0.15); border-radius: 6px; font-size: 0.85rem; color: var(--text-secondary);">
                                <strong style="color: var(--accent-blue);">ðŸ“‹ METRC Instructions:</strong> Pull the exact trim weight shown above from each source tag when creating this batch.
                            </p>
                        </div>
                    `;
                } else if (sourceContributions.length === 1) {
                    // Single source but from pot ledger - show trim used
                    const p = sourceContributions[0];
                    const trimUsed = parseFloat(p.trim_weight) || 0;
                    sourceContributionsHtml = `
                        <div style="background: rgba(16, 185, 129, 0.15); padding: 15px; border-radius: 8px; margin: 15px 0; border-left: 4px solid var(--accent-green);">
                            <p style="margin: 0 0 10px 0;"><strong style="color: var(--accent-green);">ðŸ·ï¸ Source Tag (Calculated Trim):</strong></p>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                                <div>
                                    <span style="color: var(--text-secondary); font-size: 0.85rem;">METRC Tag:</span><br>
                                    <strong style="font-family: 'Space Mono', monospace; font-size: 1.1rem; color: var(--accent-blue);">${p.metrc_tag || 'Not set'}</strong>
                                </div>
                                <div>
                                    <span style="color: var(--text-secondary); font-size: 0.85rem;">Trim Used:</span><br>
                                    <strong style="font-size: 1.1rem; color: var(--accent-green);">${trimUsed.toFixed(1)}g</strong>
                                </div>
                            </div>
                        </div>
                    `;
                }

                // Show current batch info
                const details = `
                    <p><strong>Strain:</strong> ${batch.strain} (${batch.strain_type})</p>
                    <p><strong>Product:</strong> ${batch.product_made}</p>
                    <p><strong>Net Weight:</strong> ${batch.net_weight || batch.final_weight || 'N/A'}g</p>
                    ${trimUsedInfo}
                    <div style="background: rgba(245, 158, 11, 0.2); padding: 12px; border-radius: 8px; margin: 10px 0; border-left: 4px solid var(--accent-orange);">
                        <p style="margin: 0;"><strong style="color: var(--accent-orange);">ðŸ“‹ METRC Tags:</strong> <span style="font-family: 'Space Mono', monospace; font-size: 1.1rem; font-weight: 700;">${batch.metrc_tags && batch.metrc_tags.trim() !== '' ? batch.metrc_tags : 'Not entered at intake'}</span></p>
                    </div>
                    ${sourceContributionsHtml}
                    <p><strong>Cultivation License:</strong> ${batch.cultivation_license}</p>
                    <p><strong>Grower:</strong> ${batch.grower_name || 'N/A'}</p>
                    <p><strong>Status:</strong> ${batch.status}</p>
                    ${batch.test_submitted_date ? `<p><strong>Previously Submitted:</strong> ${batch.test_submitted_date}</p>` : ''}
                    ${batch.is_rta === 'yes' ? `<p style="color: var(--accent-green);"><strong>âœ“ RTA Full Panel</strong></p>` : ''}
                `;
                document.getElementById('testBatchDetails').innerHTML = details;
                
                // Auto-populate product name with current strain + product type
                // User can modify if they want to rename for wholesale variety
                const defaultProductName = batch.final_product_name || `${batch.strain} ${batch.product_made}`;
                document.getElementById('finalProductName').value = defaultProductName;
                
                // Auto-populate strain type from batch, but allow redesignation
                const strainType = batch.final_strain_type || batch.strain_type;
                
                // Show Dealer's Choice alert if this batch was marked as such
                const dealersChoiceAlert = document.getElementById('dealersChoiceAlert');
                if (batch.strain_type === "Dealer's Choice") {
                    dealersChoiceAlert.style.display = 'block';
                    // Default to Hybrid for Dealer's Choice, but user can select anything
                    document.getElementById('finalStrainType').value = 'Hybrid';
                } else {
                    dealersChoiceAlert.style.display = 'none';
                    document.getElementById('finalStrainType').value = strainType;
                }
                
                // Pre-fill if test results already exist
                if (batch.test_submitted_date) {
                    document.getElementById('testSubmittedDate').value = batch.test_submitted_date || '';
                    document.getElementById('testExpirationDate').value = batch.test_expiration_date || '';
                    document.getElementById('metrcLast4').value = ''; // Clear - batch ID already set
                    document.getElementById('newBatchId').value = ''; // Always clear - this is for reassignment
                    document.getElementById('testThcPercent').value = batch.test_thc_percent || '';
                    document.getElementById('testCbdPercent').value = batch.test_cbd_percent || '';
                    document.getElementById('isRTA').value = batch.is_rta || 'no';
                    document.getElementById('testResultsNotes').value = batch.test_results_notes || '';
                    // Load saved product name, consistency, and strain type
                    document.getElementById('finalProductName').value = batch.strain || '';
                    if (batch.product_made) {
                        document.getElementById('finalConsistency').value = batch.product_made;
                    }
                    document.getElementById('finalStrainType').value = batch.strain_type || 'Hybrid';
                    // Trigger batch ID generation in case user wants to reassign
                    generateBatchId();
                } else {
                    // Clear form
                    document.getElementById('testSubmittedDate').value = '';
                    document.getElementById('testExpirationDate').value = '';
                    document.getElementById('metrcLast4').value = '';
                    document.getElementById('newBatchId').value = '';
                    document.getElementById('testThcPercent').value = '';
                    document.getElementById('testCbdPercent').value = '';
                    document.getElementById('isRTA').value = 'no';
                    document.getElementById('testResultsNotes').value = '';
                    // Pre-populate finalize fields from batch data
                    document.getElementById('finalProductName').value = batch.strain || '';
                    document.getElementById('finalConsistency').value = batch.product_made || '';
                    document.getElementById('finalStrainType').value = batch.strain_type || 'Hybrid';
                    // Reset button text
                    document.getElementById('markReadyForTestingBtn').innerHTML = '<span>âœ“</span> Mark as Extraction Complete (Ready for Testing)';
                }

                // Update ready for testing status UI
                updateReadyForTestingUI(batch);
            }

            // Check RTA status after loading
            checkRTAStatus();
        });

        // Auto-generate batch ID from expiration date and METRC tag last 4
        function generateBatchId() {
            const expirationDate = document.getElementById('testExpirationDate').value;
            const metrcLast4 = document.getElementById('metrcLast4').value.trim();
            
            if (expirationDate && metrcLast4 && metrcLast4.length === 4) {
                // Parse date string directly to avoid timezone issues
                // Date format from input is YYYY-MM-DD
                const dateParts = expirationDate.split('-');
                const month = parseInt(dateParts[1], 10); // Remove leading zero
                const day = parseInt(dateParts[2], 10);   // Remove leading zero
                
                const batchId = `${month}.${day}.${metrcLast4}`;
                document.getElementById('newBatchId').value = batchId;
            } else {
                document.getElementById('newBatchId').value = '';
            }
        }

        // Add event listeners for auto-generation
        document.getElementById('testExpirationDate').addEventListener('change', generateBatchId);
        document.getElementById('metrcLast4').addEventListener('input', generateBatchId);


        // ==================== RTA QUALIFICATION SYSTEM ====================
        // Colorado MED Rule 4-230: Reduced Testing Allowance

        // RTA status per product type - cached locally, synced with Supabase
        let rtaStatusCache = null;

        function getRTAStatus() {
            if (rtaStatusCache) return rtaStatusCache;
            const stored = localStorage.getItem('wm_rta_status');
            if (stored) {
                rtaStatusCache = JSON.parse(stored);
                return rtaStatusCache;
            }
            return {
                'BHO': { status: 'none', consecutivePasses: 0, qualificationStart: null, qualificationDeadline: null, rtaStart: null, rtaExpires: null, lastTestDate: null, nextTestDue: null, history: [], pendingBatches: [] },
                'Live Resin Carts': { status: 'none', consecutivePasses: 0, qualificationStart: null, qualificationDeadline: null, rtaStart: null, rtaExpires: null, lastTestDate: null, nextTestDue: null, history: [], pendingBatches: [] },
                'Live Resin AIOs': { status: 'none', consecutivePasses: 0, qualificationStart: null, qualificationDeadline: null, rtaStart: null, rtaExpires: null, lastTestDate: null, nextTestDue: null, history: [], pendingBatches: [] },
                'Brick Hash': { status: 'none', consecutivePasses: 0, qualificationStart: null, qualificationDeadline: null, rtaStart: null, rtaExpires: null, lastTestDate: null, nextTestDue: null, history: [], pendingBatches: [] }
            };
        }

        function saveRTAStatus(status) {
            rtaStatusCache = status;
            localStorage.setItem('wm_rta_status', JSON.stringify(status));
            saveRTAToSupabase(status);
        }

        async function loadRTAFromSupabase() {
            try {
                const { data, error } = await supabaseClient
                    .from('wm_rta_status')
                    .select('*');
                if (error) throw error;
                if (data && data.length > 0) {
                    const status = {};
                    data.forEach(row => {
                        status[row.product_type] = {
                            status: row.status || 'none',
                            consecutivePasses: row.consecutive_passes || 0,
                            qualificationStart: row.qualification_start,
                            qualificationDeadline: row.qualification_deadline,
                            rtaStart: row.rta_start,
                            rtaExpires: row.rta_expires,
                            lastTestDate: row.last_test_date,
                            nextTestDue: row.next_test_due,
                            pendingBatches: row.pending_batches || [],
                            history: row.history || []
                        };
                    });
                    rtaStatusCache = status;
                    localStorage.setItem('wm_rta_status', JSON.stringify(status));
                    console.log('RTA status loaded from Supabase');
                    renderRTAQuickStatus();
                }
            } catch (err) {
                console.error('Error loading RTA from Supabase:', err);
            }
        }

        async function saveRTAToSupabase(status) {
            try {
                for (const [productType, data] of Object.entries(status)) {
                    await supabaseClient
                        .from('wm_rta_status')
                        .upsert({
                            product_type: productType,
                            status: data.status,
                            consecutive_passes: data.consecutivePasses,
                            qualification_start: data.qualificationStart,
                            qualification_deadline: data.qualificationDeadline,
                            rta_start: data.rtaStart,
                            rta_expires: data.rtaExpires,
                            last_test_date: data.lastTestDate,
                            next_test_due: data.nextTestDue,
                            pending_batches: data.pendingBatches || [],
                            history: data.history || [],
                            updated_at: new Date().toISOString()
                        }, { onConflict: 'product_type' });
                }
            } catch (err) {
                console.error('Error saving RTA to Supabase:', err);
            }
        }

        // Determine RTA product type from batch data
        function getRTAProductType(batch) {
            const productMade = batch.product_made || '';
            const plannedProducts = batch.planned_products || [];
            const firstPlanned = plannedProducts[0]?.type || '';

            // Check for Live Resin products first
            if (productMade.includes('Live Resin Carts') || firstPlanned.includes('Live Resin Carts')) {
                return 'Live Resin Carts';
            }
            if (productMade.includes('Live Resin AIOs') || firstPlanned.includes('Live Resin AIOs')) {
                return 'Live Resin AIOs';
            }
            if (productMade.includes('Brick Hash') || firstPlanned.includes('Brick Hash')) {
                return 'Brick Hash';
            }
            // Default to BHO for standard products (Wax, Shatter, Sugar Wax)
            return 'BHO';
        }

        // Register a batch created during qualification period
        function registerQualificationBatch(productType, batchId) {
            const rtaStatus = getRTAStatus();
            const typeStatus = rtaStatus[productType];
            if (!typeStatus) return;

            // Only track if in qualifying or reauthorizing
            if (typeStatus.status === 'qualifying' || typeStatus.status === 'reauthorizing') {
                if (!typeStatus.pendingBatches) typeStatus.pendingBatches = [];
                if (!typeStatus.pendingBatches.includes(batchId)) {
                    typeStatus.pendingBatches.push(batchId);
                    saveRTAStatus(rtaStatus);
                    console.log('Registered batch ' + batchId + ' for RTA qualification');
                }
            }
        }

        // Get count of untested batches during qualification
        function getUntestedBatchCount(productType) {
            const rtaStatus = getRTAStatus();
            const typeStatus = rtaStatus[productType];
            if (!typeStatus || !typeStatus.pendingBatches) return 0;
            return typeStatus.pendingBatches.length;
        }



        // Show/hide test result dropdown based on RTA selection
        function updateTestResultVisibility() {
            const isRTA = document.getElementById('isRTA').value;
            const resultGroup = document.getElementById('testResultGroup');
            if (resultGroup) {
                resultGroup.style.display = isRTA === 'yes' ? 'block' : 'none';
            }
        }

        // Record a full panel test result
        function recordRTAResult(productType, batchId, result, testDate) {
            const rtaStatus = getRTAStatus();
            const typeStatus = rtaStatus[productType];
            if (!typeStatus) return;

            // Remove from pending batches if present
            if (typeStatus.pendingBatches && batchId !== 'manual') {
                typeStatus.pendingBatches = typeStatus.pendingBatches.filter(b => b !== batchId);
            }

            // Add to history
            typeStatus.history.push({
                batchId: batchId,
                result: result,
                date: testDate || new Date().toISOString()
            });

            if (result === 'pass') {
                typeStatus.consecutivePasses++;

                // Check if just started qualifying
                if (typeStatus.status === 'none' && typeStatus.consecutivePasses === 1) {
                    typeStatus.status = 'qualifying';
                    typeStatus.qualificationStart = new Date().toISOString();
                }

                                // Show progress - user must manually complete qualification after 4-week period
                const requiredPasses = typeStatus.status === 'reauthorizing' ? 5 : 4;
                const pendingCount = (typeStatus.pendingBatches || []).length;

                if (typeStatus.status === 'qualifying' || typeStatus.status === 'reauthorizing') {
                    let msg = 'âœ“ Test PASSED!\n\n' + productType + ': ' + typeStatus.consecutivePasses + '/' + requiredPasses + ' passes';
                    if (pendingCount > 0) {
                        msg += '\nâš ï¸ ' + pendingCount + ' batches still need testing';
                    } else if (typeStatus.consecutivePasses >= requiredPasses) {
                        msg += '\n\nâœ“ Ready to complete!\nClick Manage â†’ Complete button';
                    }
                    alert(msg);
                } else if (typeStatus.status === 'reauthorizing') {
                    // Failed during reauthorization - lose RTA completely
                    typeStatus.status = 'none';
                    typeStatus.consecutivePasses = 0;
                    typeStatus.rtaStart = null;
                    typeStatus.rtaExpires = null;
                    alert('ðŸš¨ RTA LOST\n\n' + productType + ' failed during reauthorization.\nYou must start over with 4 consecutive passing batches.');
                } else {
                    // Failed during initial qualification
                    typeStatus.status = 'none';
                    typeStatus.consecutivePasses = 0;
                    typeStatus.qualificationStart = null;
                }
            }

            saveRTAStatus(rtaStatus);
            renderRTAQualificationStatus();
        }

                // Complete RTA qualification (call after 4-week period)
        function completeRTAQualification(productType) {
            const rtaStatus = getRTAStatus();
            const typeStatus = rtaStatus[productType];
            if (!typeStatus) return;

            const requiredPasses = typeStatus.status === 'reauthorizing' ? 5 : 4;
            const pendingCount = (typeStatus.pendingBatches || []).length;

            if (typeStatus.consecutivePasses < requiredPasses) {
                alert('âŒ Cannot complete qualification\n\n' + productType + ' needs ' + requiredPasses + ' passes.\nCurrent: ' + typeStatus.consecutivePasses);
                return;
            }

            if (pendingCount > 0) {
                alert('âŒ Cannot complete qualification\n\n' + productType + ' has ' + pendingCount + ' untested batches.');
                return;
            }

            const now = new Date();
            typeStatus.status = 'active';
            typeStatus.rtaStart = now.toISOString();
            const expires = new Date(now);
            expires.setFullYear(expires.getFullYear() + 1);
            typeStatus.rtaExpires = expires.toISOString();

            typeStatus.lastTestDate = now.toISOString();
            const nextDue = new Date(now);
            nextDue.setDate(nextDue.getDate() + 30);
            typeStatus.nextTestDue = nextDue.toISOString();
            typeStatus.qualificationDeadline = null;
            typeStatus.consecutivePasses = 0;

            saveRTAStatus(rtaStatus);
            renderRTAQualificationStatus();
            renderRTAManagerContent();
            renderRTAQuickStatus();
            closeRTAManager();

            alert('ðŸŽ‰ RTA QUALIFIED!\n\n' + productType + ' certified for 1 year!\n\nExpires: ' + expires.toLocaleDateString() + '\nNext 30-day test: ' + nextDue.toLocaleDateString());
        }

// Start qualification period for a product type
        function startRTAQualification(productType) {
            const rtaStatus = getRTAStatus();
            if (rtaStatus[productType]) {
                const now = new Date();
                const deadline = new Date(now);
                deadline.setDate(deadline.getDate() + 28); // 4 weeks

                rtaStatus[productType].status = 'qualifying';
                rtaStatus[productType].consecutivePasses = 0;
                rtaStatus[productType].qualificationStart = now.toISOString();
                rtaStatus[productType].qualificationDeadline = deadline.toISOString();
                saveRTAStatus(rtaStatus);
                renderRTAQualificationStatus();
                closeRTAManager();
                alert('Started RTA qualification for ' + productType + '\n\nâœ“ 4-week window started\nâœ“ All batches must be FULL PANEL tested\nâœ“ Need 4 consecutive passes to qualify\n\nDeadline: ' + deadline.toLocaleDateString());
            }
        }

        // Check if product type is in qualification period (requires full panel)
        function requiresFullPanel(productType) {
            const rtaStatus = getRTAStatus();
            const typeStatus = rtaStatus[productType];
            if (!typeStatus) return false;
            return typeStatus.status === 'qualifying' || typeStatus.status === 'reauthorizing';
        }

        // Render RTA qualification status in testing tab
        function renderRTAQualificationStatus() {
            const container = document.getElementById('rtaStatusCards');
            if (!container) return;

            const rtaStatus = getRTAStatus();
            const today = new Date();

            let html = '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 15px;">';

            Object.entries(rtaStatus).forEach(([productType, status]) => {
                let statusColor, statusText, statusIcon, details;

                switch (status.status) {
                    case 'active':
                        const expires = new Date(status.rtaExpires);
                        const daysLeft = Math.floor((expires - today) / (1000 * 60 * 60 * 24));
                        statusColor = daysLeft < 30 ? 'var(--accent-orange)' : 'var(--accent-green)';
                        statusIcon = 'âœ“';
                        statusText = 'RTA Active';
                        details = daysLeft < 0 ? 'EXPIRED!' : 'Expires: ' + expires.toLocaleDateString() + ' (' + daysLeft + ' days)';
                        break;
                    case 'qualifying':
                        statusColor = 'var(--accent-blue)';
                        statusIcon = 'ðŸ”„';
                        statusText = 'Qualifying';
                        details = status.consecutivePasses + '/4 passes' + (status.pendingBatches && status.pendingBatches.length > 0 ? ' âš ï¸ ' + status.pendingBatches.length + ' untested' : '');
                        break;
                    case 'reauthorizing':
                        statusColor = 'var(--accent-orange)';
                        statusIcon = 'âš ï¸';
                        statusText = 'Reauthorizing';
                        details = status.consecutivePasses + '/5 passes' + (status.pendingBatches && status.pendingBatches.length > 0 ? ' âš ï¸ ' + status.pendingBatches.length + ' untested' : '');
                        break;
                    default:
                        statusColor = 'var(--text-secondary)';
                        statusIcon = 'â—‹';
                        statusText = 'No RTA';
                        details = 'Not started';
                }

                html += `
                    <div style="background: var(--bg-secondary); padding: 15px; border-radius: 10px; border-left: 4px solid ${statusColor};">
                        <div style="font-size: 0.8rem; color: var(--text-secondary); margin-bottom: 5px;">${productType}</div>
                        <div style="font-size: 1.1rem; font-weight: 700; color: ${statusColor}; margin-bottom: 5px;">${statusIcon} ${statusText}</div>
                        <div style="font-size: 0.85rem; color: var(--text-secondary);">${details}</div>
                    </div>
                `;
            });

            html += '</div>';
            container.innerHTML = html;
        }

        // Open RTA Manager modal
        
        // Render quick status boxes in Testing tab
        function renderRTAQuickStatus() {
            const container = document.getElementById('rtaQuickStatus');
            if (!container) return;

            const rtaStatus = getRTAStatus();
            const today = new Date();

            let html = '';
            Object.entries(rtaStatus).forEach(([productType, status]) => {
                let color, icon, label, sublabel = '';

                switch (status.status) {
                    case 'active':
                        const expires = new Date(status.rtaExpires);
                        const daysLeft = Math.floor((expires - today) / (1000 * 60 * 60 * 24));
                        const nextTest = status.nextTestDue ? new Date(status.nextTestDue) : null;
                        const testDaysLeft = nextTest ? Math.floor((nextTest - today) / (1000 * 60 * 60 * 24)) : null;

                        if (daysLeft < 30) {
                            color = 'var(--accent-orange)';
                            icon = 'âš ï¸';
                            label = 'Recert Soon';
                            sublabel = daysLeft + 'd left';
                        } else if (testDaysLeft !== null && testDaysLeft <= 7) {
                            color = 'var(--accent-orange)';
                            icon = 'ðŸ”„';
                            label = 'Test Due';
                            sublabel = testDaysLeft <= 0 ? 'OVERDUE' : testDaysLeft + 'd';
                        } else {
                            color = 'var(--accent-green)';
                            icon = 'âœ“';
                            label = 'Active';
                            sublabel = daysLeft + 'd left';
                        }
                        break;
                    case 'qualifying':
                        const deadline = status.qualificationDeadline ? new Date(status.qualificationDeadline) : null;
                        const qualDays = deadline ? Math.floor((deadline - today) / (1000 * 60 * 60 * 24)) : null;
                        const qPending = (status.pendingBatches || []).length;
                        const readyToComplete = status.consecutivePasses >= 4 && qPending === 0;

                        if (readyToComplete) {
                            color = 'var(--accent-green)';
                            icon = 'âœ“';
                            label = 'Ready!';
                            sublabel = 'Click Manage';
                        } else {
                            color = 'var(--accent-blue)';
                            icon = 'ðŸ”„';
                            label = status.consecutivePasses + '/4';
                            sublabel = qPending > 0 ? qPending + ' pending' : (qualDays ? qualDays + 'd left' : 'Testing');
                        }
                        break;
                    case 'reauthorizing':
                        color = 'var(--accent-orange)';
                        icon = 'âš ï¸';
                        label = status.consecutivePasses + '/5';
                        sublabel = 'Reauth';
                        break;
                    default:
                        color = 'var(--text-secondary)';
                        icon = 'â—‹';
                        label = 'None';
                        sublabel = 'Not Started';
                }

                html += `
                    <div style="background: var(--bg-secondary); padding: 10px; border-radius: 8px; border-left: 3px solid ${color}; text-align: center;">
                        <div style="font-size: 0.7rem; color: var(--text-secondary); margin-bottom: 3px;">${productType}</div>
                        <div style="font-size: 1rem; font-weight: 700; color: ${color};">${icon} ${label}</div>
                        <div style="font-size: 0.7rem; color: var(--text-secondary);">${sublabel}</div>
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        function openRTAManager() {
            renderRTAQualificationStatus();
            renderRTAManagerContent();
            checkRTAStatus();
            renderRTAQuickStatus();
            document.getElementById('rtaManagerModal').style.display = 'block';
        }

        function closeRTAManager() {
            document.getElementById('rtaManagerModal').style.display = 'none';
        }

        // Render RTA Manager content
        function renderRTAManagerContent() {
            const container = document.getElementById('rtaManagerContent');
            if (!container) return;

            const rtaStatus = getRTAStatus();
            const today = new Date();

            let html = '';

            Object.entries(rtaStatus).forEach(([productType, status]) => {
                let statusBadge, actionButtons;

                switch (status.status) {
                    case 'active':
                        const expires = new Date(status.rtaExpires);
                        const daysLeft = Math.floor((expires - today) / (1000 * 60 * 60 * 24));
                        statusBadge = `<span style="background: var(--accent-green); color: white; padding: 3px 10px; border-radius: 12px; font-size: 0.8rem;">âœ“ Active - ${daysLeft} days left</span>`;
                        actionButtons = `<button class="btn" style="padding: 5px 10px; font-size: 0.85rem; background: var(--accent-red);" onclick="simulateFailure('${productType}')">Record Failed Test</button>`;
                        break;
                    case 'qualifying':
                        const pendingCount = status.pendingBatches ? status.pendingBatches.length : 0;
                        statusBadge = `<span style="background: var(--accent-blue); color: white; padding: 3px 10px; border-radius: 12px; font-size: 0.8rem;">ðŸ”„ Qualifying: ${status.consecutivePasses}/4</span>${pendingCount > 0 ? ` <span style="background: var(--accent-orange); color: white; padding: 3px 10px; border-radius: 12px; font-size: 0.8rem;">âš ï¸ ${pendingCount} untested batches</span>` : ''}`;
                        const pendingList = status.pendingBatches && status.pendingBatches.length > 0
                            ? '<div style="margin-top: 10px; padding: 10px; background: rgba(255,165,0,0.1); border-radius: 8px; border-left: 3px solid var(--accent-orange);"><strong>âš ï¸ Untested batches:</strong><br>' + status.pendingBatches.join(', ') + '</div>'
                            : '';
                        actionButtons = `
                            <button class="btn" style="padding: 5px 10px; font-size: 0.85rem; background: var(--accent-green);" onclick="recordRTAResult('${productType}', 'manual', 'pass')">+ Record Pass</button>
                            <button class="btn" style="padding: 5px 10px; font-size: 0.85rem; background: var(--accent-red);" onclick="recordRTAResult('${productType}', 'manual', 'fail')">Record Fail</button>
                            ${pendingList}
                        `;
                        break;
                    case 'reauthorizing':
                        statusBadge = `<span style="background: var(--accent-orange); color: white; padding: 3px 10px; border-radius: 12px; font-size: 0.8rem;">âš ï¸ Reauth: ${status.consecutivePasses}/5</span>`;
                        actionButtons = `
                            <button class="btn" style="padding: 5px 10px; font-size: 0.85rem; background: var(--accent-green);" onclick="recordRTAResult('${productType}', 'manual', 'pass')">+ Record Pass</button>
                            <button class="btn" style="padding: 5px 10px; font-size: 0.85rem; background: var(--accent-red);" onclick="recordRTAResult('${productType}', 'manual', 'fail')">Record Fail</button>
                        `;
                        break;
                    default:
                        statusBadge = `<span style="background: var(--bg-tertiary); color: var(--text-secondary); padding: 3px 10px; border-radius: 12px; font-size: 0.8rem;">â—‹ Not Started</span>`;
                        actionButtons = `<button class="btn" style="padding: 5px 10px; font-size: 0.85rem; background: var(--accent-purple);" onclick="startRTAQualification('${productType}')">Start Qualification</button>`;
                }

                html += `
                    <div style="background: var(--bg-tertiary); padding: 15px; border-radius: 10px; margin-bottom: 15px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <h4 style="margin: 0; color: var(--text-primary);">${productType}</h4>
                            ${statusBadge}
                        </div>
                        <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                            ${actionButtons}
                        </div>
                        ${status.history && status.history.length > 0 ? `
                            <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid var(--bg-secondary);">
                                <div style="font-size: 0.8rem; color: var(--text-secondary);">Recent: ${status.history.slice(-3).map(h =>
                                    '<span style="color: ' + (h.result === 'pass' ? 'var(--accent-green)' : 'var(--accent-red)') + ';">' + (h.result === 'pass' ? 'âœ“' : 'âœ—') + '</span>'
                                ).join(' ')}</div>
                            </div>
                        ` : ''}
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        // Simulate a failure for active RTA (for manual tracking)
        function simulateFailure(productType) {
            if (confirm('Record a FAILED full panel test for ' + productType + '?\n\nThis will require 5 consecutive passing batches to reauthorize.')) {
                recordRTAResult(productType, 'manual-fail', 'fail');
                renderRTAManagerContent();
            }
        }

        // Reset all RTA status
        function resetAllRTA() {
            if (confirm('âš ï¸ Reset ALL RTA status?\n\nThis will clear all qualification progress and history.')) {
                localStorage.removeItem('wm_rta_status');
                renderRTAQualificationStatus();
                renderRTAManagerContent();
                alert('All RTA status has been reset.');
            }
        }

        // Initialize RTA status display on page load
        document.addEventListener('DOMContentLoaded', function() {
            setTimeout(async () => {
                await loadRTAFromSupabase();
                renderRTAQuickStatus();
            }, 1000);
        });

        // Check RTA status and show reminder if needed - BY EXTRACTION METHOD
        function checkRTAStatus() {
            const rtaBatches = batches.filter(b => b.is_rta === 'yes' && b.test_submitted_date);
            
            const today = new Date();
            
            // Track BHO and Brick Hash/Dry Sift separately
            const bhoRTAs = rtaBatches.filter(b => b.extraction_method === 'BHO' && !isLiveResinBatch(b));
            const hashRTAs = rtaBatches.filter(b => b.extraction_method === 'Dry Sift' || b.extraction_method === 'Brick Hash');

            // Live Resin Carts and AIOs tracked separately
            const cartsRTAs = rtaBatches.filter(b => {
                const products = b.planned_products || [];
                const productMade = (b.product_made || '').toLowerCase();
                return isLiveResinBatch(b) && (
                    products.some(p => (p.type || p).toLowerCase().includes('cart')) ||
                    productMade.includes('cart') ||
                    productMade === 'live resin oil'
                );
            });

            const aiosRTAs = rtaBatches.filter(b => {
                const products = b.planned_products || [];
                const productMade = (b.product_made || '').toLowerCase();
                return isLiveResinBatch(b) && (
                    products.some(p => (p.type || p).toLowerCase().includes('aio') || (p.type || p).toLowerCase().includes('all-in-one')) ||
                    productMade.includes('aio') ||
                    productMade.includes('all-in-one') ||
                    productMade.includes('all in one')
                );
            });
            
            let reminderHTML = '<div style="display: grid; gap: 15px;">';
            
            // Check BHO RTA Status
            reminderHTML += checkMethodRTA(bhoRTAs, 'BHO (Wax/Shatter/Sugar)', today);
            
            // Check Hash RTA Status
            reminderHTML += checkMethodRTA(hashRTAs, 'Brick Hash / Dry Sift', today);

            // Check Live Resin Carts RTA Status
            reminderHTML += checkMethodRTA(cartsRTAs, 'Live Resin Carts', today);

            // Check Live Resin AIOs RTA Status
            reminderHTML += checkMethodRTA(aiosRTAs, 'Live Resin AIOs', today);
            
            reminderHTML += '</div>';
            
            document.getElementById('rtaReminder').innerHTML = reminderHTML;
        }
        
        function checkMethodRTA(rtaBatches, methodName, today) {
            if (rtaBatches.length === 0) {
                return `
                    <div style="background: rgba(239, 68, 68, 0.2); border: 2px solid var(--accent-red); padding: 20px; border-radius: 10px;">
                        <h3 style="color: var(--accent-red); margin-bottom: 10px;">âš ï¸ ${methodName} - No RTA Submitted</h3>
                        <p style="color: var(--text-primary);">You must submit at least one RTA full panel per month for ${methodName}.</p>
                    </div>
                `;
            }
            
            // Get most recent RTA for this method
            rtaBatches.sort((a, b) => new Date(b.test_submitted_date) - new Date(a.test_submitted_date));
            const lastRTA = rtaBatches[0];
            const lastRTADate = new Date(lastRTA.test_submitted_date);
            
            // Check if next RTA is due (30 days)
            const nextRTADue = new Date(lastRTADate);
            nextRTADue.setDate(nextRTADue.getDate() + 30);
            
            const daysUntilDue = Math.floor((nextRTADue - today) / (1000 * 60 * 60 * 24));
            
            if (daysUntilDue < 0) {
                // Overdue
                return `
                    <div style="background: rgba(239, 68, 68, 0.2); border: 2px solid var(--accent-red); padding: 20px; border-radius: 10px;">
                        <h3 style="color: var(--accent-red); margin-bottom: 10px;">ðŸš¨ ${methodName} RTA OVERDUE!</h3>
                        <p style="color: var(--text-primary); margin-bottom: 10px;">Last RTA: ${lastRTA.id} (${lastRTADate.toLocaleDateString()}) - ${Math.abs(daysUntilDue)} days overdue</p>
                        <p style="color: var(--text-primary); font-weight: 700;">Submit new ${methodName} RTA immediately!</p>
                    </div>
                `;
            } else if (daysUntilDue <= 7) {
                // Due soon
                return `
                    <div style="background: rgba(245, 158, 11, 0.2); border: 2px solid var(--accent-orange); padding: 20px; border-radius: 10px;">
                        <h3 style="color: var(--accent-orange); margin-bottom: 10px;">âš ï¸ ${methodName} RTA Due Soon</h3>
                        <p style="color: var(--text-primary); margin-bottom: 10px;">Last RTA: ${lastRTA.id} (${lastRTADate.toLocaleDateString()})</p>
                        <p style="color: var(--text-primary); font-weight: 700;">Next ${methodName} RTA due in ${daysUntilDue} days (${nextRTADue.toLocaleDateString()})</p>
                    </div>
                `;
            } else {
                // All good
                return `
                    <div style="background: rgba(16, 185, 129, 0.2); border: 2px solid var(--accent-green); padding: 20px; border-radius: 10px;">
                        <h3 style="color: var(--accent-green); margin-bottom: 10px;">âœ“ ${methodName} RTA: Current</h3>
                        <p style="color: var(--text-primary); margin-bottom: 10px;">Last RTA: ${lastRTA.id} (${lastRTADate.toLocaleDateString()})</p>
                        <p style="color: var(--text-primary);">Next due: ${nextRTADue.toLocaleDateString()} (${daysUntilDue} days)</p>
                    </div>
                `;
            }
        }

        // Mark batch as extraction complete / ready for testing
        async function markReadyForTesting() {
            try {
            if (!currentRole) {
                alert('Please select a user first!');
                return;
            }

            const batchId = document.getElementById('testingBatchSelect').value;
            const batch = batches.find(b => b.id === batchId);

            if (!batch) {
                alert('Please select a batch first!');
                return;
            }

            // Get form values
            const finalProductName = document.getElementById('finalProductName').value.trim();
            const finalConsistency = document.getElementById('finalConsistency').value;
            const finalStrainType = document.getElementById('finalStrainType').value;
            const newBatchId = document.getElementById('newBatchId').value.trim();

            // Check if already marked by looking at timeline
            const hasExtractionComplete = batch.timeline?.some(t => t.stage === 'ready_for_testing' || t.stage === 'product_update');
            const isUpdate = hasExtractionComplete || batch.test_submitted_date;

            // Validate required fields
            if (!finalProductName) {
                alert('Please enter a product name.');
                return;
            }
            if (!finalConsistency) {
                alert('Please select a product type.');
                return;
            }

            // Check if batch ID is changing
            let batchIdChanged = false;
            let oldBatchId = batchId;
            if (newBatchId && newBatchId !== batchId) {
                const existingBatch = batches.find(b => b.id === newBatchId);
                if (existingBatch) {
                    alert(`Error: Batch ID "${newBatchId}" already exists. Please use a different ID.`);
                    return;
                }
                batchIdChanged = true;
            }

            // Build confirmation message
            let confirmMsg = isUpdate
                ? `Update product info for batch ${batchId}?\n\n`
                : `Finalize batch ${batchId} as Extraction Complete?\n\n`;
            confirmMsg += `Product Name: ${finalProductName}\n`;
            confirmMsg += `Consistency: ${finalConsistency}\n`;
            confirmMsg += `Strain Type: ${finalStrainType}\n`;
            if (batchIdChanged) {
                confirmMsg += `\nNEW BATCH ID: ${newBatchId}\n`;
            }
            if (!isUpdate) {
                confirmMsg += `\nThis marks the batch as ready for lab submission.`;
            }

            if (!confirm(confirmMsg)) return;

            const now = new Date().toISOString();

            // Build timeline notes
            const strainTypeNote = batch.strain_type !== finalStrainType ? ` | Redesignated: ${batch.strain_type} â†’ ${finalStrainType}` : '';
            const batchIdNote = batchIdChanged ? ` | Batch ID: ${oldBatchId} â†’ ${newBatchId}` : '';

            // Add timeline entry
            const timeline = batch.timeline || [];
            const timelineAction = isUpdate
                ? `Updated product info - ${finalProductName} (${finalConsistency})${strainTypeNote}${batchIdNote}`
                : `Extraction Complete - ${finalProductName} (${finalConsistency})${strainTypeNote}${batchIdNote}`;
            timeline.push({
                stage: isUpdate ? 'product_update' : 'ready_for_testing',
                user: currentRole.name,
                date: now,
                action: timelineAction
            });

            // Build update object - use existing columns that we know exist
            const updates = {
                strain: finalProductName,        // Save product name to strain column
                product_made: finalConsistency,  // Use existing product_made column
                strain_type: finalStrainType,    // Use existing strain_type column
                timeline: timeline
                // Don't change status - batch stays in its current workflow stage
            };


            // Handle batch ID change
            if (batchIdChanged) {
                // Delete old record and insert new one with new ID
                const { error: deleteError } = await supabaseClient
                    .from('wm_batches')
                    .delete()
                    .eq('id', oldBatchId);

                if (deleteError) {
                    console.error('Error deleting old batch:', deleteError);
                    alert('Error updating batch ID. Please try again.');
                    return;
                }

                // Create new record with new ID
                const newBatchData = { ...batch, ...updates, id: newBatchId };
                delete newBatchData.created_at; // Let Supabase handle this

                const { error: insertError } = await supabaseClient
                    .from('wm_batches')
                    .insert(newBatchData);

                if (insertError) {
                    console.error('Error creating new batch:', insertError);
                    alert('Error creating batch with new ID. Please try again.');
                    return;
                }

                // Update local array
                const batchIndex = batches.findIndex(b => b.id === oldBatchId);
                if (batchIndex !== -1) {
                    batches[batchIndex] = { ...batch, ...updates, id: newBatchId };
                }

                // Update dropdown
                populateTestingSelect();
                document.getElementById('testingBatchSelect').value = newBatchId;
                document.getElementById('currentBatchIdDisplay').textContent = newBatchId;

            } else {
                // Simple update
                const { error } = await supabaseClient
                    .from('wm_batches')
                    .update(updates)
                    .eq('id', batchId);

                if (error) {
                    console.error('Error marking ready for testing:', error);
                    alert(`Error updating batch: ${error.message}`);
                    return;
                }

                // Update local batch
                Object.assign(batch, updates);
            }

            // Update UI
            const updatedBatch = batches.find(b => b.id === (batchIdChanged ? newBatchId : batchId));
            updateReadyForTestingUI(updatedBatch);

            // Refresh the batch details display
            refreshBatchDetails(updatedBatch);

            const successMsg = isUpdate
                ? `Product info updated for ${batchIdChanged ? newBatchId : batchId}!\n\n${finalProductName} (${finalConsistency})`
                : `Batch ${batchIdChanged ? newBatchId : batchId} finalized!\n\n${finalProductName} (${finalConsistency})\nReady for lab submission.`;
            alert(successMsg);

            } catch (err) {
                console.error('Exception in markReadyForTesting:', err);
                alert('Error: ' + err.message);
            }
        }

        // Update the ready for testing UI based on batch status
        function updateReadyForTestingUI(batch) {
            const statusDiv = document.getElementById('readyForTestingStatus');
            const btn = document.getElementById('markReadyForTestingBtn');

            // Check timeline for extraction complete entry
            const extractionCompleteEntry = batch.timeline?.find(t => t.stage === 'ready_for_testing' || t.stage === 'product_update');

            if (extractionCompleteEntry) {
                const readyDate = new Date(extractionCompleteEntry.date);
                statusDiv.innerHTML = `
                    <div style="background: rgba(34, 197, 94, 0.2); border: 2px solid #22c55e; padding: 15px; border-radius: 8px;">
                        <strong style="color: #22c55e; font-size: 1.1rem;">âœ“ Extraction Complete - Ready for Testing</strong>
                        <div style="margin-top: 10px; display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px;">
                            <p style="margin: 0; color: var(--text-primary);"><strong>Product Type:</strong> ${batch.product_made || 'N/A'}</p>
                            <p style="margin: 0; color: var(--text-primary);"><strong>Strain Type:</strong> ${batch.strain_type}</p>
                            <p style="margin: 0; color: var(--text-secondary); font-size: 0.9rem;">By ${extractionCompleteEntry.user || 'Unknown'} on ${readyDate.toLocaleDateString()}</p>
                        </div>
                        <button type="button" onclick="editFinalizeInfo()" style="margin-top: 12px; background: rgba(245, 158, 11, 0.3); color: var(--accent-orange); border: 1px solid var(--accent-orange); padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 0.9rem;">
                            Edit Product Info
                        </button>
                    </div>
                `;
                btn.style.display = 'none';
            } else if (batch.test_submitted_date) {
                statusDiv.innerHTML = `
                    <div style="background: rgba(59, 130, 246, 0.2); border: 2px solid #3b82f6; padding: 15px; border-radius: 8px;">
                        <strong style="color: #3b82f6; font-size: 1.1rem;">ðŸ“¤ Submitted to Lab</strong>
                        <div style="margin-top: 10px; display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px;">
                            <p style="margin: 0; color: var(--text-primary);"><strong>Product Type:</strong> ${batch.product_made || 'N/A'}</p>
                            <p style="margin: 0; color: var(--text-primary);"><strong>Submitted:</strong> ${new Date(batch.test_submitted_date).toLocaleDateString()}</p>
                        </div>
                        <button type="button" onclick="editFinalizeInfo()" style="margin-top: 12px; background: rgba(245, 158, 11, 0.3); color: var(--accent-orange); border: 1px solid var(--accent-orange); padding: 8px 16px; border-radius: 6px; cursor: pointer; font-size: 0.9rem;">
                            Edit Product Info
                        </button>
                    </div>
                `;
                btn.style.display = 'none';
            } else {
                statusDiv.innerHTML = '';
                btn.style.display = 'flex';
            }
        }

        // Allow editing finalize info even after marked
        function editFinalizeInfo() {
            const btn = document.getElementById('markReadyForTestingBtn');
            btn.style.display = 'flex';
            btn.innerHTML = '<span>ðŸ’¾</span> Update Product Info';
        }

        // Refresh the batch details display after update
        function refreshBatchDetails(batch) {
            // Calculate trim info
            let trimUsedInfo = '';
            if (batch.is_sub_batch && batch.parent_batch_id) {
                const parentBatch = batches.find(b => b.id === batch.parent_batch_id);
                if (parentBatch) {
                    const parentTrimWeight = parseFloat(parentBatch.adjusted_trim_weight || parentBatch.trim_weight || 0);
                    const parentTotalOutput = parseFloat(parentBatch.final_weight || parentBatch.net_weight || 0);
                    const thisBatchWeight = parseFloat(batch.final_weight || batch.net_weight || 0);
                    if (parentTotalOutput > 0) {
                        const trimUsed = (thisBatchWeight / parentTotalOutput) * parentTrimWeight;
                        const yieldPercent = (thisBatchWeight / trimUsed) * 100;
                        trimUsedInfo = `<p><strong>Trim Used:</strong> ${trimUsed.toFixed(1)}g</p><p><strong>Yield %:</strong> ${yieldPercent.toFixed(2)}%</p>`;
                    }
                }
            } else {
                const trimWeight = parseFloat(batch.adjusted_trim_weight || batch.trim_weight || 0);
                const finalWeight = parseFloat(batch.final_weight || batch.net_weight || 0);
                const yieldPercent = trimWeight > 0 ? (finalWeight / trimWeight) * 100 : 0;
                trimUsedInfo = `<p><strong>Trim Used:</strong> ${trimWeight.toFixed(1)}g</p><p><strong>Yield %:</strong> ${yieldPercent.toFixed(2)}%</p>`;
            }

            const details = `
                <p><strong>Strain:</strong> ${batch.strain} (${batch.strain_type})</p>
                <p><strong>Product:</strong> ${batch.product_made || 'N/A'}</p>
                <p><strong>Net Weight:</strong> ${batch.net_weight || batch.final_weight || 'N/A'}g</p>
                ${trimUsedInfo}
                <div style="background: rgba(245, 158, 11, 0.2); padding: 12px; border-radius: 8px; margin: 10px 0; border-left: 4px solid var(--accent-orange);">
                    <p style="margin: 0;"><strong style="color: var(--accent-orange);">ðŸ“‹ METRC Tags:</strong> <span style="font-family: 'Space Mono', monospace; font-size: 1.1rem; font-weight: 700;">${batch.metrc_tags && batch.metrc_tags.trim() !== '' ? batch.metrc_tags : 'Not entered at intake'}</span></p>
                </div>
                <p><strong>Cultivation License:</strong> ${batch.cultivation_license}</p>
                <p><strong>Grower:</strong> ${batch.grower_name || 'N/A'}</p>
                <p><strong>Status:</strong> ${batch.status}</p>
                ${batch.test_submitted_date ? `<p><strong>Previously Submitted:</strong> ${batch.test_submitted_date}</p>` : ''}
            `;
            document.getElementById('testBatchDetails').innerHTML = details;
        }

        async function submitTestResults() {
            if (!currentRole) {
                alert('Please select a user first!');
                return;
            }

            const batchId = document.getElementById('testingBatchSelect').value;
            const batch = batches.find(b => b.id === batchId);
            
            if (!batch) return;
            
            const thcPercent = parseFloat(document.getElementById('testThcPercent').value) || null;
            const cbdPercent = parseFloat(document.getElementById('testCbdPercent').value) || null;
            const isRTA = document.getElementById('isRTA').value;
            const submittedDate = document.getElementById('testSubmittedDate').value;
            const expirationDate = document.getElementById('testExpirationDate').value;
            const newBatchId = document.getElementById('newBatchId').value.trim();
            const finalProductName = document.getElementById('finalProductName').value.trim();
            const finalStrainType = document.getElementById('finalStrainType').value;
            
            if (!finalProductName) {
                alert('Please enter a product name for this batch.');
                return;
            }
            
            // Check if new batch ID is being assigned
            let batchIdChanged = false;
            let oldBatchId = batchId;
            if (newBatchId && newBatchId !== batchId) {
                // Verify new batch ID doesn't already exist
                const existingBatch = batches.find(b => b.id === newBatchId);
                if (existingBatch) {
                    alert(`Error: Batch ID "${newBatchId}" already exists in the system. Please choose a different ID.`);
                    return;
                }
                
                const confirmChange = confirm(
                    `âš ï¸ BATCH ID REASSIGNMENT\n\n` +
                    `Current ID: ${oldBatchId}\n` +
                    `New ID: ${newBatchId}\n\n` +
                    `This will permanently change the batch ID in the system.\n\n` +
                    `Continue?`
                );
                
                if (!confirmChange) return;
                
                batchIdChanged = true;
            }
            
            // Show redesignation note in timeline if strain type changed
            const strainTypeNote = batch.strain_type !== finalStrainType ? ` | Redesignated: ${batch.strain_type} â†’ ${finalStrainType}` : '';
            const batchIdNote = batchIdChanged ? ` | Batch ID reassigned: ${oldBatchId} â†’ ${newBatchId}` : '';
            
            const timeline = batch.timeline || [];
            const resultsText = thcPercent !== null ? `THC ${thcPercent}%, CBD ${cbdPercent || 0}%` : 'Test submitted - results pending';
            timeline.push({
                stage: 'testing',
                user: currentRole ? currentRole.name : "Unknown",
                date: new Date().toISOString(),
                action: `${resultsText}${isRTA === 'yes' ? ' - RTA FULL PANEL' : ''} | Named: ${finalProductName}${strainTypeNote}${batchIdNote}`
            });
            
            // Build update object - only include fields that exist in database
            const updates = {
                test_submitted_date: submittedDate,
                test_expiration_date: expirationDate,
                test_thc_percent: thcPercent,
                test_cbd_percent: cbdPercent,
                is_rta: isRTA,
                test_results_notes: document.getElementById('testResultsNotes').value || null,
                timeline: timeline
            };
            
            // Update the batch strain name and strain_type to reflect the final product
            // This makes batch IDs display the actual wholesale product name
            updates.strain = finalProductName;
            updates.strain_type = finalStrainType;
            
            // Store product info in notes for now until we add columns
            const productInfo = `\n\n[PRODUCT INFO]\nOriginal Strain: ${batch.strain}\nOriginal Type: ${batch.strain_type}\nFinal Name: ${finalProductName}\nFinal Type: ${finalStrainType}`;
            updates.test_results_notes = (updates.test_results_notes || '') + productInfo;
            
            // If this is a bulk sale, mark as complete and skip labeling
            if (batch.packaged_product_type === 'Bulk Sale') {
                updates.status = 'complete';
                updates.labels_applied = true;
                updates.labeling_date = new Date().toISOString().split('T')[0];
                updates.labeling_user = currentRole ? currentRole.name : "Unknown";
                updates.labeling_notes = 'Bulk sale - labeling not required';
                updates.completed_at = new Date().toISOString();
                timeline.push({
                    stage: 'complete',
                    user: currentRole ? currentRole.name : "Unknown",
                    date: new Date().toISOString(),
                    action: 'Bulk sale completed after testing - labeling skipped'
                });
                updates.timeline = timeline;
            }
            
            // If batch ID is being changed, we need to handle it specially
            if (batchIdChanged) {
                // Add new batch ID to updates
                updates.id = newBatchId;
                
                // First, insert a new record with the new ID
                const { error: insertError } = await supabaseClient
                    .from('wm_batches')
                    .insert({
                        ...batch,
                        ...updates,
                        id: newBatchId
                    });
                
                if (insertError) {
                    console.error('Error creating new batch with new ID:', insertError);
                    alert('Error reassigning batch ID. Please try again.');
                    return;
                }
                
                // Then delete the old record
                const { error: deleteError } = await supabaseClient
                    .from('wm_batches')
                    .delete()
                    .eq('id', oldBatchId);
                
                if (deleteError) {
                    console.error('Error deleting old batch record:', deleteError);
                    alert('Warning: New batch created but old batch could not be removed. You may need to manually delete batch ' + oldBatchId);
                }
            } else {
                // Normal update without ID change
                const { error } = await supabaseClient
                    .from('wm_batches')
                    .update(updates)
                    .eq('id', batchId);
                
                if (error) {
                    console.error('Error updating test results:', error);
                    alert('Error saving test results. Please try again.');
                    return;
                }
            }
            
            const lidColor = finalStrainType === 'Indica' ? 'Blue' : finalStrainType === 'Sativa' ? 'Red' : 'Green';
            const resultsInfo = thcPercent !== null ? `\nTHC: ${thcPercent}% | CBD: ${cbdPercent || 0}%` : '\nTest submitted - awaiting results';
            const finalBatchId = batchIdChanged ? newBatchId : batchId;
            const batchChangeMsg = batchIdChanged ? `\nâœ“ Batch ID changed: ${oldBatchId} â†’ ${newBatchId}` : '';
            alert(`Test results saved for ${finalBatchId}!${batchChangeMsg}\n\nProduct Name: ${finalProductName}\nStrain Type: ${finalStrainType} (${lidColor} Lid)${strainTypeNote ? '\nâœ“ Strain type redesignated' : ''}${resultsInfo}\n${isRTA === 'yes' ? 'âœ“ RTA Full Panel' : 'Standard Potency'}\nExpires: ${expirationDate}`);
            
            document.getElementById('testingForm').style.display = 'none';
            document.getElementById('testingBatchSelect').value = '';
            
            await loadBatches();
            populateTestingSelect();
            checkRTAStatus();
        }

        // Toggle connection type UI
        function toggleConnectionType() {
            const type = document.getElementById('connectionType').value;
            document.getElementById('networkIPGroup').style.display = type === 'network' ? 'block' : 'none';
            document.getElementById('networkPortGroup').style.display = type === 'network' ? 'block' : 'none';
        }

        function savePrintSettings() {
            const printServerURL = document.getElementById('printServerURL').value;
            if (printServerURL) {
                localStorage.setItem('printServerURL', printServerURL);
                alert('Print server settings saved!\n\nMake sure the print server is running on that computer.');
            } else {
                localStorage.setItem('printServerURL', 'http://localhost:3000/print');
                alert('Using default localhost print server.');
            }
        }

        function populateLabelingSelect() {
            const select = document.getElementById('labelingBatchSelect');
            // Show batches that are complete and have test results, but haven't been labeled yet
            const labelableBatches = batches.filter(b =>
                b.status === 'complete' &&
                b.test_thc_percent &&
                !b.labels_applied
            );

            select.innerHTML = '<option value="">Select a batch...</option>';
            labelableBatches.forEach(batch => {
                const pauseIndicator = batch.labeling_paused ? ' â¸ï¸ PAUSED' : '';
                const workerIndicator = batch.labeling_user ? ` â–¶ ${batch.labeling_user.split(' ')[0]}` : '';
                select.innerHTML += `<option value="${batch.id}">${batch.id} - ${batch.strain} - ${batch.packaged_product_type} (${batch.units_packaged} units)${workerIndicator}${pauseIndicator}</option>`;
            });
            
            // Load saved settings
            const savedURL = localStorage.getItem('printServerURL');
            if (savedURL) {
                document.getElementById('printServerURL').value = savedURL;
            }
        }

        document.getElementById('labelingBatchSelect').addEventListener('change', function() {
            const form = document.getElementById('labelingForm');
            form.style.display = this.value ? 'block' : 'none';
            
            if (this.value) {
                const batch = batches.find(b => b.id === this.value);
                displayLabelPreview(batch);
                
                // Initialize weight verification if elements exist
                const gramsLabeledInput = document.getElementById('gramsLabeled');
                const expectedWeightEl = document.getElementById('expectedWeight');
                const actualWeightEl = document.getElementById('actualWeight');
                
                if (gramsLabeledInput && expectedWeightEl && actualWeightEl) {
                    gramsLabeledInput.value = '';
                    document.getElementById('acceptDiscrepancy').checked = false;
                    document.getElementById('discrepancyAlert').style.display = 'none';
                    
                    const expectedGrams = parseFloat(batch.total_grams_packaged) || 0;
                    expectedWeightEl.textContent = expectedGrams.toFixed(1) + 'g';
                    actualWeightEl.textContent = '-';
                }
                
                // Update pause button visibility
                updatePauseButtons();
            }
        });

        // Real-time weight comparison for labeling
        const gramsLabeledInput = document.getElementById('gramsLabeled');
        if (gramsLabeledInput) {
            gramsLabeledInput.addEventListener('input', function() {
                const batchId = document.getElementById('labelingBatchSelect').value;
                const batch = batches.find(b => b.id === batchId);
                if (!batch) return;
                
                const gramsLabeled = parseFloat(this.value) || 0;
                const expectedGrams = parseFloat(batch.total_grams_packaged) || 0;
                
                const actualWeightEl = document.getElementById('actualWeight');
                if (actualWeightEl) {
                    actualWeightEl.textContent = gramsLabeled.toFixed(1) + 'g';
                }
                
                // Check for discrepancy (more than 2% difference)
                const discrepancy = Math.abs(gramsLabeled - expectedGrams);
                const percentDiff = expectedGrams > 0 ? (discrepancy / expectedGrams) * 100 : 0;
                
                const discrepancyAlert = document.getElementById('discrepancyAlert');
                if (discrepancyAlert) {
                    if (percentDiff > 2 && gramsLabeled > 0) {
                        discrepancyAlert.style.display = 'block';
                        document.getElementById('discrepancyDetails').innerHTML = `
                            <div>Expected: <strong>${expectedGrams.toFixed(1)}g</strong></div>
                            <div>Actual: <strong>${gramsLabeled.toFixed(1)}g</strong></div>
                            <div style="color: var(--accent-orange); font-weight: 700;">Difference: ${discrepancy.toFixed(1)}g (${percentDiff.toFixed(1)}%)</div>
                        `;
                    } else {
                        discrepancyAlert.style.display = 'none';
                        const acceptCheckbox = document.getElementById('acceptDiscrepancy');
                        if (acceptCheckbox) acceptCheckbox.checked = false;
                    }
                }
            });
        }


        function displayLabelPreview(batch) {
            const preview = document.getElementById('labelPreview');
            preview.innerHTML = `
                <div>
                    <div style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 5px;">PRODUCT</div>
                    <div style="font-weight: 700;">${batch.packaged_product_type}</div>
                </div>
                <div>
                    <div style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 5px;">STRAIN</div>
                    <div style="font-weight: 700;">${batch.strain}</div>
                </div>
                <div>
                    <div style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 5px;">BATCH ID</div>
                    <div style="font-weight: 700; color: var(--accent-purple);">${batch.id}</div>
                </div>
                <div>
                    <div style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 5px;">THC</div>
                    <div style="font-weight: 700; color: var(--accent-green);">${batch.test_thc_percent}%</div>
                </div>
                <div>
                    <div style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 5px;">CBD</div>
                    <div style="font-weight: 700;">${batch.test_cbd_percent || 0}%</div>
                </div>
                <div>
                    <div style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 5px;">EXPIRES</div>
                    <div style="font-weight: 700;">${batch.test_expiration_date ? new Date(batch.test_expiration_date).toLocaleDateString() : 'N/A'}</div>
                </div>
                <div>
                    <div style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 5px;">UNITS</div>
                    <div style="font-weight: 700;">${batch.units_packaged}</div>
                </div>
                ${batch.packaging_breakdown ? `
                <div>
                    <div style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 5px;">SIZES</div>
                    <div style="font-weight: 700;">${batch.packaging_breakdown}</div>
                </div>
                ` : ''}
            `;
        }

        // Open printable label popup
        function openPrintableLabels() {
            const batchId = document.getElementById('labelingBatchSelect').value;
            const batch = batches.find(b => b.id === batchId);
            
            if (!batch) {
                alert('Please select a batch first');
                return;
            }
            
            const quantity = batch.units_packaged || 1;
            
            // Format expiration date
            let expDate = 'N/A';
            if (batch.test_expiration_date) {
                const d = new Date(batch.test_expiration_date);
                expDate = `${d.getMonth() + 1}/${d.getDate()}/${d.getFullYear().toString().slice(-2)}`;
            }
            
            // Determine net weight
            let netWeight = '1 GRAM';
            if (batch.packaged_product_type.includes('4g')) {
                netWeight = '4 GRAM';
            } else if (batch.packaged_product_type.includes('0.5')) {
                netWeight = '0.5 GRAM';
            }
            
            const thc = parseFloat(batch.test_thc_percent) || 0;
            const cbd = parseFloat(batch.test_cbd_percent) || 0;
            const cultivationLicense = batch.cultivation_license || '403R-01007';
            const extractionLicense = '404R-00016';
            
            // Create labels array
            let labelsHTML = '';
            for (let i = 0; i < quantity; i++) {
                labelsHTML += `
                    <div class="label">
                        <div class="product-type">${batch.packaged_product_type.toUpperCase()}</div>
                        <div class="strain">${batch.strain.toUpperCase()}</div>
                        <div class="cannabinoids">
                            <div class="cannabinoid-box">
                                <div>TOTAL THC: ${thc.toFixed(1)}%</div>
                                <div>TOTAL CBD: ${cbd.toFixed(1)}%</div>
                            </div>
                        </div>
                        <div class="licenses">
                            <div>CULTIVATED BY ${cultivationLicense}</div>
                            <div>EXTRACTED BY ${extractionLicense}</div>
                        </div>
                        <div class="warnings">
                            <div>INTENDED USE: INHALED PRODUCT.</div>
                            <div>NOT APPROVED BY THE FDA.</div>
                        </div>
                        <div class="net-weight">NET WEIGHT: ${netWeight}</div>
                        <div class="serving">SERVING SIZE: â€¢</div>
                        <div class="batch-id">BATCH ${batch.id}</div>
                        <div class="expiration">USE BY ${expDate}</div>
                    </div>
                `;
            }
            
            // Create popup window
            const popup = window.open('', 'PrintLabels', 'width=800,height=600');
            popup.document.write(`
<!DOCTYPE html>
<html>
<head>
    <title>Print Labels - ${batch.id}</title>
    <style>
        @media print {
            @page {
                size: 1.77in 1.77in;
                margin: 0;
            }
            body {
                margin: 0;
                padding: 0;
            }
            .no-print {
                display: none;
            }
            .label {
                page-break-after: always;
                page-break-inside: avoid;
            }
        }
        
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f0f0f0;
        }
        
        .no-print {
            background: white;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .no-print h1 {
            margin: 0 0 10px 0;
            color: #333;
        }
        
        .no-print button {
            background: #9333ea;
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 16px;
            border-radius: 6px;
            cursor: pointer;
            margin-right: 10px;
        }
        
        .no-print button:hover {
            background: #7c2db8;
        }
        
        .labels-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, 1.77in);
            gap: 20px;
            justify-content: center;
        }
        
        .label {
            width: 1.77in;
            height: 1.77in;
            border: 2px solid #333;
            border-radius: 50%;
            background: white;
            padding: 8px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            position: relative;
        }
        
        .product-type {
            font-size: 9pt;
            font-weight: bold;
            margin-bottom: 2px;
        }
        
        .strain {
            font-size: 14pt;
            font-weight: bold;
            margin-bottom: 4px;
            line-height: 1.1;
        }
        
        .cannabinoid-box {
            border: 2px solid #000;
            padding: 4px 8px;
            margin: 4px 0;
            font-size: 6pt;
            font-weight: bold;
        }
        
        .licenses {
            font-size: 5pt;
            margin: 4px 0;
            line-height: 1.3;
        }
        
        .warnings {
            font-size: 4.5pt;
            margin: 3px 0;
            line-height: 1.2;
        }
        
        .net-weight {
            font-size: 6pt;
            font-weight: bold;
            margin: 3px 0;
        }
        
        .serving {
            font-size: 6pt;
            margin: 2px 0;
        }
        
        .batch-id {
            font-size: 7pt;
            font-weight: bold;
            margin: 3px 0;
        }
        
        .expiration {
            font-size: 6pt;
            margin-top: 2px;
        }
    </style>
</head>
<body>
    <div class="no-print">
        <h1>Print Labels for ${batch.id}</h1>
        <p>Quantity: ${quantity} labels</p>
        <button onclick="window.print()">ðŸ–¨ï¸ Print Labels</button>
        <button onclick="window.close()">Close</button>
    </div>
    
    <div class="labels-container">
        ${labelsHTML}
    </div>
</body>
</html>
            `);
            popup.document.close();
        }

        function generateZPL(batch) {
            // Generate ZPL (Zebra Programming Language) code for CIRCULAR label
            const labelSize = document.getElementById('labelSize').value;
            
            // Circular label dimensions (in dots at 203dpi)
            const sizes = {
                '1.0': { diameter: 203 },   // 1.0" circle
                '1.5': { diameter: 305 },   // 1.5" circle
                '2.0': { diameter: 406 }    // 2.0" circle
            };
            
            const size = sizes[labelSize] || sizes['1.5'];
            const centerX = Math.floor(size.diameter / 2);
            
            // Format product type for label
            const productType = batch.packaged_product_type.toUpperCase().replace('WAX/SUGAR', 'WAX');
            
            // Format expiration date as M.D.YY (like 3.6.26)
            let expDate = 'N/A';
            if (batch.test_expiration_date) {
                const d = new Date(batch.test_expiration_date);
                expDate = `${d.getMonth() + 1}.${d.getDate()}.${d.getFullYear().toString().slice(-2)}`;
            }
            
            // Get THC and CBD percentages
            const thc = parseFloat(batch.test_thc_percent) || 0;
            const cbd = parseFloat(batch.test_cbd_percent) || 0;
            
            // Determine net weight based on product type
            let netWeight = '1 GRAM';
            if (batch.packaged_product_type.includes('4g')) {
                netWeight = '4 GRAM';
            } else if (batch.packaged_product_type.includes('0.5')) {
                netWeight = '0.5 GRAM';
            }
            
            // Get cultivation license from batch (403R)
            const cultivationLicense = batch.cultivation_license || '403R-01007';
            
            // White Mousse extraction license (404R)
            const extractionLicense = '404R-00016';
            
            // ZPL for 45mm circular label matching Canva design
            const diameter = 360;  // 45mm at 203dpi
            const center = 180;
            const zpl = `^XA
^MMT
^PW${diameter}
^LL${diameter}
^LS0
^LT-100

~SD20

^CF0,22
^FO${center},35^FB${diameter},1,0,C^FD${productType}^FS

^CF0,40
^FO${center},60^FB${diameter},2,0,C^FD${batch.strain.toUpperCase()}^FS

^FO${center - 100},110^GB200,40,3^FS
^CF0,14
^FO${center},118^FB${diameter},1,0,C^FDTOTAL THC: ${thc.toFixed(1)}%^FS
^FO${center},133^FB${diameter},1,0,C^FDTOTAL CBD: ${cbd.toFixed(1)}%^FS

^CF0,11
^FO${center},165^FB${diameter},1,0,C^FDCULTIVATED BY ${cultivationLicense}^FS
^FO${center},180^FB${diameter},1,0,C^FDEXTRACTED BY ${extractionLicense}^FS

^CF0,10
^FO${center},198^FB${diameter},1,0,C^FDINTENDED USE: INHALED PRODUCT.^FS
^FO${center},210^FB${diameter},1,0,C^FDNOT APPROVED BY THE FDA.^FS

^CF0,12
^FO${center},228^FB${diameter},1,0,C^FDNET WEIGHT: ${netWeight}^FS

^CF0,12
^FO${center},245^FB${diameter},1,0,C^FDSERVING SIZE: ^FS
^FO${center + 40},243^GC6,6,B^FS

^CF0,16
^FO${center},265^FB${diameter},1,0,C^FDBATCH ${batch.id}^FS

^CF0,12
^FO${center},285^FB${diameter},1,0,C^FDUSE BY ${expDate}^FS

^XZ`;
            
            document.getElementById('zplPreview').textContent = zpl;
            return zpl;
        }

        async function testPrinterConnection() {
            const connectionType = document.getElementById('connectionType').value;
            const statusDiv = document.getElementById('printerStatus');
            
            if (connectionType === 'network') {
                const ip = document.getElementById('printerIP').value;
                const port = document.getElementById('printerPort').value;
                
                if (!ip) {
                    alert('Please enter printer IP address');
                    return;
                }
                
                // Save settings
                localStorage.setItem('zebraPrinterIP', ip);
                localStorage.setItem('zebraPrinterPort', port);
                
                statusDiv.innerHTML = `
                    <div style="background: rgba(59, 130, 246, 0.2); border: 2px solid var(--accent-blue); padding: 20px; border-radius: 10px;">
                        <h3 style="color: var(--accent-blue); margin-bottom: 10px;">ðŸ“¡ Network Printer Setup</h3>
                        <p style="color: var(--text-primary); margin-bottom: 10px;">To print directly to network printer at ${ip}:${port}, you need:</p>
                        <ol style="color: var(--text-primary); margin-left: 20px;">
                            <li><strong>Zebra Browser Print</strong> - Free software from Zebra
                                <br><a href="https://www.zebra.com/us/en/support-downloads/software/printer-software/browser-print.html" target="_blank" style="color: var(--accent-blue);">Download here</a>
                            </li>
                            <li><strong>Or download ZPL</strong> and send file to printer manually</li>
                        </ol>
                        <p style="color: var(--text-primary); margin-top: 15px;">IP saved: <strong>${ip}:${port}</strong></p>
                    </div>
                `;
            } else {
                // USB mode
                localStorage.setItem('zebraConnectionType', 'usb');
                
                statusDiv.innerHTML = `
                    <div style="background: rgba(16, 185, 129, 0.2); border: 2px solid var(--accent-green); padding: 20px; border-radius: 10px;">
                        <h3 style="color: var(--accent-green); margin-bottom: 10px;">ðŸ”Œ USB Connection Mode</h3>
                        <p style="color: var(--text-primary); margin-bottom: 10px;"><strong>Setup Steps:</strong></p>
                        <ol style="color: var(--text-primary); margin-left: 20px;">
                            <li>Connect ZT230 to computer via USB</li>
                            <li>Install <strong>Zebra Browser Print</strong> - <a href="https://www.zebra.com/us/en/support-downloads/software/printer-software/browser-print.html" target="_blank" style="color: var(--accent-blue);">Download here</a></li>
                            <li>Browser Print will auto-detect your USB printer</li>
                            <li>Click "Print Labels" and they'll go straight to your ZT230!</li>
                        </ol>
                        <p style="color: var(--text-primary); margin-top: 15px;"><strong>Mode saved:</strong> USB Direct Connection</p>
                    </div>
                `;
            }
        }

        async function printLabels() {
            const batchId = document.getElementById('labelingBatchSelect').value;
            const batch = batches.find(b => b.id === batchId);

            if (!batch) {
                alert('Please select a batch first');
                return;
            }

            const quantity = parseInt(document.getElementById('labelQuantity').value) || 1;
            const labelsPerUnit = parseInt(document.getElementById('labelsPerUnit').value) || 1;
            const totalLabels = quantity * labelsPerUnit;

            const zpl = generateZPL(batch);
            
            // Generate ZPL with multiple copies
            let fullZPL = '';
            for (let i = 0; i < totalLabels; i++) {
                fullZPL += zpl + '\n';
            }
            
            // Try print server first (works from mobile!)
            const printServerURL = localStorage.getItem('printServerURL') || 'http://localhost:3000/print';

            try {
                const response = await fetch(printServerURL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ zpl: fullZPL })
                });

                if (response.ok) {
                    alert(`âœ“ Sent ${totalLabels} labels to printer!`);
                    return;
                }
            } catch (error) {
                // Print server not available, try Browser Print
            }

            // Fallback to Browser Print
            if (window.BrowserPrint) {
                try {
                    const printer = await window.BrowserPrint.getDefaultDevice('printer');

                    printer.send(fullZPL, undefined, (error) => {
                        if (error) {
                            console.error('Print error:', error);
                            alert('Print failed. Use "Download ZPL" button instead.');
                        } else {
                            alert(`âœ“ Sent ${totalLabels} labels to printer!`);
                        }
                    });
                } catch (error) {
                    console.error('Browser Print error:', error);
                    alert('Printing not available.\n\nOptions:\n1. Start print server (see setup docs)\n2. Use "Download ZPL" button');
                }
            } else {
                alert('Print server not running and Browser Print not installed.\n\nUse "Download ZPL" button to print manually.');
            }
        }

        function downloadZPL() {
            const batchId = document.getElementById('labelingBatchSelect').value;
            const batch = batches.find(b => b.id === batchId);

            if (!batch) {
                alert('Please select a batch first');
                return;
            }

            const quantity = parseInt(document.getElementById('labelQuantity').value) || 1;
            const labelsPerUnit = parseInt(document.getElementById('labelsPerUnit').value) || 1;
            const totalLabels = quantity * labelsPerUnit;

            const zpl = generateZPL(batch);

            // Generate ZPL file with multiple copies
            let fullZPL = '';
            for (let i = 0; i < totalLabels; i++) {
                fullZPL += zpl + '\n';
            }

            try {
                // Create download
                const blob = new Blob([fullZPL], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `${batch.id}_labels_${totalLabels}x.zpl`;
                link.click();

                alert(`Downloaded ZPL file for ${totalLabels} labels!\n\nSend this file to your Zebra printer using:\n- Zebra Setup Utilities â†’ Send File\n- Or drag file to printer in Setup Utilities`);
            } catch (error) {
                console.error('Download error:', error);
                alert('Error creating download.');
            }
        }

        // Start labeling (marks batch as in-progress)
        async function startLabeling() {
            if (!currentRole) {
                alert('Please login first!');
                return;
            }
            
            const batchId = document.getElementById('labelingBatchSelect').value;
            const batch = batches.find(b => b.id === batchId);
            
            if (!batch) return;
            
            const confirmation = confirm(
                `Mark batch ${batchId} as STARTED labeling?\n\n` +
                `This will:\n` +
                `â€¢ Add "Labeling Started" to timeline\n` +
                `â€¢ Keep status as "complete" (not yet labeled)\n` +
                `â€¢ Allow you to finish later\n\n` +
                `You can skip this and go straight to "Complete Labeling" for single sessions.`
            );
            
            if (!confirmation) return;
            
            const timeline = batch.timeline || [];
            timeline.push({
                stage: 'labeling',
                user: currentRole ? currentRole.name : "Unknown",
                date: new Date().toISOString(),
                action: 'Labeling started'
            });
            
            const { error } = await supabaseClient
                .from('wm_batches')
                .update({
                    labeling_notes: document.getElementById('labelingNotes').value || null,
                    timeline: timeline
                })
                .eq('id', batchId);
            
            if (error) {
                console.error('Error marking batch as started:', error);
                alert('Error updating batch. Please try again.');
                return;
            }
            
            alert(`âœ… Batch ${batchId} marked as labeling in progress!\n\n` +
                  `Started by: ${currentRole.name}\n\n` +
                  `This batch will remain in the dropdown until you click "Complete Labeling".`);
            
            // Refresh batch data but keep form open and batch selected
            await loadBatches();
            populateLabelingSelect();
            
            // Re-select the batch
            document.getElementById('labelingBatchSelect').value = batchId;
            document.getElementById('labelingForm').style.display = 'block';
            
            // Re-populate the label preview since batch was reselected
            const updatedBatch = batches.find(b => b.id === batchId);
            if (updatedBatch) {
                displayLabelPreview(updatedBatch);
                
                // Reinitialize weight verification
                const gramsLabeledInput = document.getElementById('gramsLabeled');
                const expectedWeightEl = document.getElementById('expectedWeight');
                if (gramsLabeledInput && expectedWeightEl) {
                    const expectedGrams = parseFloat(updatedBatch.total_grams_packaged) || 0;
                    expectedWeightEl.textContent = expectedGrams.toFixed(1) + 'g';
                }
            }
        }

        // Toggle pause/resume for labeling
        async function togglePauseLabeling() {
            if (!currentRole) {
                alert('Please select a user first!');
                return;
            }

            const batchId = document.getElementById('labelingBatchSelect').value;
            const batch = batches.find(b => b.id === batchId);
            
            if (!batch) {
                alert('Please select a batch first!');
                return;
            }
            
            const isPaused = batch.labeling_paused || false;
            const action = isPaused ? 'RESUME' : 'PAUSE';
            const actionVerb = isPaused ? 'Resumed' : 'Paused';
            
            const confirmation = confirm(
                `${action} labeling for batch ${batchId}?\n\n` +
                `This will:\n` +
                `â€¢ Add "${actionVerb}" to timeline\n` +
                `â€¢ ${isPaused ? 'Allow work to continue' : 'Temporarily stop work'}\n` +
                `â€¢ Keep batch in labeling stage`
            );
            
            if (!confirmation) return;
            
            const timeline = batch.timeline || [];
            timeline.push({
                stage: 'labeling',
                user: currentRole ? currentRole.name : "Unknown",
                date: new Date().toISOString(),
                action: `Labeling ${actionVerb.toLowerCase()}`
            });
            
            const { error } = await supabaseClient
                .from('wm_batches')
                .update({
                    labeling_paused: !isPaused,
                    timeline: timeline
                })
                .eq('id', batchId);
            
            if (error) {
                console.error('Error toggling pause:', error);
                alert('Error updating batch. Please try again.');
                return;
            }
            
            alert(`âœ… Labeling ${actionVerb.toLowerCase()} for batch ${batchId}!\n\n` +
                  `${isPaused ? 'Work can continue.' : 'Work temporarily stopped.'}\n` +
                  `${actionVerb} by: ${currentRole.name}`);
            
            await loadBatches();
            populateLabelingSelect();
            // Keep the batch selected
            document.getElementById('labelingBatchSelect').value = batchId;
            document.getElementById('labelingBatchSelect').dispatchEvent(new Event('change'));
        }

        async function markAsLabeled() {
            if (!currentRole) {
                alert('Please login first!');
                return;
            }
            
            const batchId = document.getElementById('labelingBatchSelect').value;
            const batch = batches.find(b => b.id === batchId);
            
            if (!batch) {
                alert('Please select a batch first');
                return;
            }
            
            // Use units packaged as the quantity (no separate labelQuantity input anymore)
            const quantity = batch.units_packaged || 0;
            
            // Check if weight verification fields exist
            const gramsLabeledInput = document.getElementById('gramsLabeled');
            let gramsLabeled = null;
            let discrepancyData = null;
            
            if (gramsLabeledInput) {
                gramsLabeled = parseFloat(gramsLabeledInput.value);
                
                if (!gramsLabeled || gramsLabeled <= 0) {
                    alert('Please enter the total grams labeled');
                    return;
                }
                
                // Check for discrepancy
                const expectedGrams = parseFloat(batch.total_grams_packaged) || 0;
                const discrepancy = Math.abs(gramsLabeled - expectedGrams);
                const percentDiff = expectedGrams > 0 ? (discrepancy / expectedGrams) * 100 : 0;
                
                // If discrepancy > 2%, require acceptance
                if (percentDiff > 2) {
                    const acceptCheckbox = document.getElementById('acceptDiscrepancy');
                    if (!acceptCheckbox || !acceptCheckbox.checked) {
                        alert('âš ï¸ Weight discrepancy detected!\n\nYou must check the box to verify and accept the discrepancy before proceeding.');
                        return;
                    }
                    discrepancyData = { discrepancy, percentDiff };
                }
            }
            
            const confirmMsg = gramsLabeled 
                ? `Mark ${batchId} as labeled?\n\nGrams Labeled: ${gramsLabeled.toFixed(1)}g\nUnits: ${quantity}`
                : `Mark ${batchId} as labeled?\n\n${quantity} units`;
                
            if (!confirm(confirmMsg)) {
                return;
            }
            
            const timeline = batch.timeline || [];
            timeline.push({
                stage: 'labeling',
                timestamp: new Date().toISOString(),
                user: currentRole ? currentRole.name : "Unknown",
                action: gramsLabeled ? `Labeled ${quantity} units - ${gramsLabeled.toFixed(1)}g total` : `Labeled ${quantity} units`
            });
            
            const updateData = {
                labels_applied: true,
                labeling_date: new Date().toISOString().split('T')[0],
                labeling_user: currentRole ? currentRole.name : "Unknown",
                labels_applied_quantity: quantity,
                labeling_notes: document.getElementById('labelingNotes').value || null,
                timeline: timeline
            };
            
            // Add weight data if verified
            if (gramsLabeled) {
                updateData.grams_labeled = gramsLabeled;
                if (discrepancyData) {
                    updateData.weight_discrepancy = discrepancyData.discrepancy;
                    updateData.discrepancy_accepted = true;
                }
            }
            
            const { error } = await supabaseClient
                .from('wm_batches')
                .update(updateData)
                .eq('id', batchId);
            
            if (error) {
                console.error('Error marking as labeled:', error);
                alert('Error saving labeling status. Please try again.');
                return;
            }

            // Print labeling completion label
            printLabelingCompletionLabel(batch, currentRole ? currentRole.name : 'Unknown');

            // Queue for LeafLink approval (skip buyback batches)
            let leafLinkMsg = '';
            if (batch.material_agreement !== 'Custom Buyback') {
                await queueForLeafLinkApproval({
                    ...batch,
                    grams_labeled: gramsLabeled || batch.grams_labeled
                });
                leafLinkMsg = 'ðŸ“‹ Queued for LeafLink approval';
            } else {
                leafLinkMsg = '(Buyback - not listed)';
            }

            showCelebration({
                emoji: 'ðŸ†',
                title: 'Batch Complete!',
                message: `${batchId} is fully labeled and ready for sale! ${leafLinkMsg}`,
                stats: [
                    { value: quantity, label: 'Labels Applied' },
                    { value: gramsLabeled ? `${gramsLabeled.toFixed(1)}g` : batch.product_made || 'N/A', label: gramsLabeled ? 'Total Weight' : 'Product' }
                ],
                confettiCount: 80
            });

            document.getElementById('labelingForm').style.display = 'none';
            document.getElementById('labelingBatchSelect').value = '';
            document.getElementById('labelingNotes').value = '';
            
            await loadBatches();
            populateLabelingSelect();
        }

        // Analytics functions
        let currentAnalyticsFilter = 'all';

        // Waste Log Functions
        function getNextTuesday(fromDate) {
            const date = new Date(fromDate);
            const dayOfWeek = date.getDay();
            const daysUntilTuesday = (2 - dayOfWeek + 7) % 7 || 7;
            date.setDate(date.getDate() + daysUntilTuesday);
            return date;
        }
        
        function calculateWasteWeight(batch) {
            const trimWeight = parseFloat(batch.trim_weight) || 0;
            
            // If we have actual yield data, calculate real waste
            if (batch.crude_weight || batch.final_weight || batch.grams_labeled) {
                const actualYield = parseFloat(batch.grams_labeled) || parseFloat(batch.final_weight) || parseFloat(batch.crude_weight) || 0;
                return Math.max(0, trimWeight - actualYield);
            }
            
            // Otherwise use 90% estimate
            return trimWeight * 0.90;
        }
        
        function isWasteEstimated(batch) {
            return !(batch.crude_weight || batch.final_weight || batch.grams_labeled);
        }
        
        function renderWasteLog() {
            const tbody = document.getElementById('wasteLogTableBody');
            if (!tbody) return;
            
            // Get batches that have been extracted (have extraction_date)
            const extractedStatuses = ['extraction', 'finishing', 'packaging', 'completed'];
            const wasteBatches = batches.filter(b => (b.extraction_date || extractedStatuses.includes(b.status)) && !b.is_sub_batch);
            
            if (wasteBatches.length === 0) {
                tbody.innerHTML = '<tr><td colspan="9" style="padding: 40px; text-align: center; color: var(--text-secondary);">No waste records found</td></tr>';
                updateWasteStats([]);
                return;
            }
            
            // Sort by extraction date descending
            wasteBatches.sort((a, b) => new Date(b.extraction_date) - new Date(a.extraction_date));
            
            let html = '';
            wasteBatches.forEach(batch => {
                const wasteWeight = calculateWasteWeight(batch);
                const isEstimate = isWasteEstimated(batch);
                const disposalDate = getNextTuesday(batch.extraction_date);
                const isPastDue = disposalDate < new Date();
                
                html += '<tr style="border-bottom: 1px solid var(--border);">';
                html += '<td style="padding: 12px; color: var(--accent-purple); font-weight: 600;">' + batch.id + '</td>';
                html += '<td style="padding: 12px; color: var(--text-primary);">' + batch.strain + '</td>';
                html += '<td style="padding: 12px; text-align: right; color: var(--text-secondary);">' + parseFloat(batch.trim_weight).toFixed(1) + 'g</td>';
                html += '<td style="padding: 12px; text-align: right; font-weight: 600; color: ' + (isEstimate ? 'var(--accent-orange)' : 'var(--accent-green)') + ';">' + wasteWeight.toFixed(1) + 'g' + '</td>';
                html += '<td style="padding: 12px; text-align: center; color: var(--text-secondary);">' + new Date(batch.extraction_date).toLocaleDateString() + '</td>';
                html += '<td style="padding: 12px; text-align: center; font-weight: 600; color: ' + (isPastDue ? 'var(--accent-red)' : 'var(--accent-blue)') + ';">' + disposalDate.toLocaleDateString() + '</td>';
                html += '<td style="padding: 12px; text-align: center; color: var(--accent-purple);">' + (batch.metrc_tags || '--') + '</td>';
                html += '<td style="padding: 12px; text-align: center; color: var(--text-secondary);">Filter Media</td>';
                html += '<td style="padding: 12px; text-align: center; color: var(--text-secondary);">Waste Management</td>';
                html += '</tr>';
            });
            
            tbody.innerHTML = html;
            updateWasteStats(wasteBatches);
        }
        
        function updateWasteStats(wasteBatches) {
            let totalWaste = 0;
            let pendingCount = 0;
            let nextDisposal = null;
            const today = new Date();
            
            wasteBatches.forEach(batch => {
                const wasteWeight = calculateWasteWeight(batch);
                totalWaste += wasteWeight;
                
                const disposalDate = getNextTuesday(batch.extraction_date);
                if (disposalDate >= today) {
                    pendingCount++;
                    if (!nextDisposal || disposalDate < nextDisposal) {
                        nextDisposal = disposalDate;
                    }
                }
            });
            
            document.getElementById('wastePendingCount').textContent = pendingCount;
            document.getElementById('wasteTotalWeight').textContent = totalWaste.toFixed(1) + 'g';
            document.getElementById('wasteNextDisposal').textContent = nextDisposal ? nextDisposal.toLocaleDateString() : '--';
        }
        
        function exportWasteLog() {
            const extractedStatuses = ['extraction', 'finishing', 'packaging', 'completed'];
            const wasteBatches = batches.filter(b => (b.extraction_date || extractedStatuses.includes(b.status)) && !b.is_sub_batch);
            if (wasteBatches.length === 0) { alert('No waste records to export'); return; }
            wasteBatches.sort((a, b) => new Date(b.extraction_date) - new Date(a.extraction_date));
            let csv = 'Batch ID,Strain,Trim Weight (g),Waste Weight (g),Extraction Date,Disposal Date,METRC Tag,Mixed With,Disposal Facility\n';
            wasteBatches.forEach(batch => {
                const wasteWeight = calculateWasteWeight(batch);
                const disposalDate = getNextTuesday(batch.extraction_date);
                csv += '"' + batch.id + '","' + batch.strain + '",' + parseFloat(batch.trim_weight).toFixed(1) + ',' + wasteWeight.toFixed(1) + ',"' + new Date(batch.extraction_date).toLocaleDateString() + '","' + disposalDate.toLocaleDateString() + '","' + (batch.metrc_tags || '') + '","Filter Media","Waste Management"\n';
            });
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'waste_log_' + new Date().toISOString().split('T')[0] + '.csv';
            a.click();
            URL.revokeObjectURL(url);
        }



        function updateAnalytics() {
            const completedBatches = batches.filter(b => b.status === 'complete');
            
            if (completedBatches.length === 0) {
                document.getElementById('avgYield').textContent = '0%';
                document.getElementById('avgThc').textContent = '0%';
                document.getElementById('avgProcessingTime').textContent = '0d';
                document.getElementById('avgCostPerGram').textContent = '$0';
                document.getElementById('completedBatchesGrid').innerHTML = '<p style="padding: 40px; text-align: center; color: var(--text-secondary); grid-column: 1 / -1;">No completed batches yet</p>';
                return;
            }
            
            // Calculate summary stats
            let totalYield = 0, yieldCount = 0;
            let totalThc = 0, thcCount = 0;
            let totalProcessingDays = 0, timeCount = 0;
            let totalCostPerGram = 0, costCount = 0;
            
            completedBatches.forEach(b => {
                // Yield - use grams_labeled (actual sellable weight) instead of net_weight
                if (b.trim_weight && b.grams_labeled) {
                    totalYield += (parseFloat(b.grams_labeled) / parseFloat(b.trim_weight)) * 100;
                    yieldCount++;
                }
                // THC
                if (b.test_thc_percent) {
                    totalThc += parseFloat(b.test_thc_percent);
                    thcCount++;
                }
                // Processing time
                if (b.intake_date && b.finishing_date) {
                    const days = (new Date(b.finishing_date) - new Date(b.intake_date)) / (1000 * 60 * 60 * 24);
                    totalProcessingDays += days;
                    timeCount++;
                }
                // Cost per gram - use grams_labeled (actual sellable weight) instead of net_weight
                if (b.material_cost && b.grams_labeled) {
                    totalCostPerGram += parseFloat(b.material_cost) / parseFloat(b.grams_labeled);
                    costCount++;
                }
            });
            
            document.getElementById('avgYield').textContent = yieldCount > 0 ? (totalYield / yieldCount).toFixed(2) + '%' : '0%';
            document.getElementById('avgThc').textContent = thcCount > 0 ? (totalThc / thcCount).toFixed(2) + '%' : '0%';
            document.getElementById('avgProcessingTime').textContent = timeCount > 0 ? (totalProcessingDays / timeCount).toFixed(1) + 'd' : '0d';
            document.getElementById('avgCostPerGram').textContent = costCount > 0 ? '$' + (totalCostPerGram / costCount).toFixed(2) : '$0';
            
            filterAnalytics(currentAnalyticsFilter);
        }
        
        function filterAnalytics(filter) {
            currentAnalyticsFilter = filter;
            
            // Update active button
            document.querySelectorAll('[data-filter-analytics]').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.filterAnalytics === filter);
            });
            
            let filteredBatches = batches.filter(b => b.status === 'complete');
            
            const now = new Date();
            const thisMonthStart = new Date(now.getFullYear(), now.getMonth(), 1);
            const lastMonthStart = new Date(now.getFullYear(), now.getMonth() - 1, 1);
            const lastMonthEnd = new Date(now.getFullYear(), now.getMonth(), 0);
            
            if (filter === 'thisMonth') {
                filteredBatches = filteredBatches.filter(b => new Date(b.finishing_date) >= thisMonthStart);
            } else if (filter === 'lastMonth') {
                filteredBatches = filteredBatches.filter(b => {
                    const finishDate = new Date(b.finishing_date);
                    return finishDate >= lastMonthStart && finishDate <= lastMonthEnd;
                });
            }
            
            renderBatchCards(filteredBatches);
        }
        
        function renderBatchCards(completedBatches) {
            const container = document.getElementById('completedBatchesGrid');
            
            if (completedBatches.length === 0) {
                container.innerHTML = '<p style="padding: 40px; text-align: center; color: var(--text-secondary); grid-column: 1 / -1;">No batches for this period</p>';
                return;
            }
            
            container.innerHTML = completedBatches.map(batch => {
                return `
                    <div class="batch-card" onclick="showBatchDetails('${batch.id}')" style="cursor: pointer; transition: all 0.2s; background: var(--bg-secondary); padding: 20px; border-radius: 12px; border: 2px solid var(--border);">
                        <div style="text-align: center;">
                            <div style="font-family: 'Space Mono', monospace; font-size: 1.3rem; font-weight: 700; color: var(--accent-green); margin-bottom: 8px;">${batch.id}</div>
                            <div style="color: var(--text-primary); font-size: 1rem; font-weight: 600;">${batch.strain}</div>
                            <div style="margin-top: 8px; padding: 4px 12px; background: rgba(147, 51, 234, 0.2); border-radius: 12px; font-size: 0.85rem; color: var(--accent-purple); display: inline-block;">
                                ${batch.strain_type}
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
            
            // Add hover effect via CSS
            document.querySelectorAll('.batch-card').forEach(card => {
                card.addEventListener('mouseenter', function() {
                    this.style.transform = 'translateY(-4px)';
                    this.style.boxShadow = '0 8px 24px rgba(147, 51, 234, 0.3)';
                    this.style.borderColor = 'var(--accent-purple)';
                });
                card.addEventListener('mouseleave', function() {
                    this.style.transform = 'translateY(0)';
                    this.style.boxShadow = 'none';
                    this.style.borderColor = 'var(--border)';
                });
            });
        }

        function showBatchDetails(batchId) {
            const batch = batches.find(b => b.id === batchId);
            if (!batch) return;
            
            // Update modal title
            document.getElementById('modalBatchId').textContent = batch.id;
            
            // Batch Overview Cards
            const overview = `
                <div style="background: var(--bg-secondary); padding: 15px; border-radius: 10px; border-left: 4px solid var(--accent-green);">
                    <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 5px;">Strain</div>
                    <div style="font-size: 1.1rem; font-weight: 700;">${batch.strain}</div>
                    <div style="font-size: 0.9rem; color: var(--accent-purple);">${batch.strain_type}</div>
                </div>
                <div style="background: var(--bg-secondary); padding: 15px; border-radius: 10px; border-left: 4px solid var(--accent-blue);">
                    <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 5px;">Product Made</div>
                    <div style="font-size: 1.1rem; font-weight: 700;">${batch.product_made || 'N/A'}</div>
                </div>
                <div style="background: var(--bg-secondary); padding: 15px; border-radius: 10px; border-left: 4px solid var(--accent-orange);">
                    <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 5px;">Grower</div>
                    <div style="font-size: 1.1rem; font-weight: 700;">${batch.grower_name || 'N/A'}</div>
                    <div style="font-size: 0.9rem; color: var(--accent-orange);">${batch.cultivation_license}</div>
                </div>
            `;
            document.getElementById('modalBatchOverview').innerHTML = overview;

            // Batch Tracking Details
            let sourceInfo = '';
            if (batch.source_contributions && batch.source_contributions.length > 0) {
                const sources = typeof batch.source_contributions === 'string' ? JSON.parse(batch.source_contributions) : batch.source_contributions;
                sourceInfo = sources.map(s => `${s.batch_id} (${s.trim_weight || s.socks}${s.trim_weight ? 'g' : ' socks'}${s.metrc_tag ? ' - ' + s.metrc_tag : ''})`).join(', ');
            }
            const allNotes = [batch.intake_notes, batch.extraction_notes, batch.finishing_notes, batch.packaging_notes, batch.labeling_notes].filter(n => n).join(' | ');
            const tracking = `
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                    <div><strong>Status:</strong> <span style="color: var(--accent-green); text-transform: uppercase;">${batch.status}</span></div>
                    <div><strong>Socks:</strong> ${batch.socks_remaining != null ? batch.socks_remaining + '/' + batch.socks_total + ' remaining' : 'N/A'}</div>
                    <div><strong>METRC Tags:</strong> <span style="font-family: monospace;">${batch.metrc_tags || 'None'}</span></div>
                    <div><strong>Grow License:</strong> ${batch.cultivation_license || 'N/A'}</div>
                </div>
                ${batch.parent_batch_id ? '<p style="margin-top: 15px;"><strong>Parent Batch:</strong> ' + batch.parent_batch_id + '</p>' : ''}
                ${sourceInfo ? '<p style="margin-top: 10px;"><strong>Source Contributions:</strong> ' + sourceInfo + '</p>' : ''}
                ${allNotes ? '<div style="margin-top: 15px; padding: 10px; background: var(--bg-secondary); border-radius: 8px;"><strong>Notes:</strong> ' + allNotes + '</div>' : ''}
            `;
            document.getElementById('modalTracking').innerHTML = tracking;
            
            // Processing Timeline
            const intakeDate = new Date(batch.intake_date);
            
            // Derive extraction date from timeline completion
            let extractionDate = null;
            if (batch.timeline && batch.timeline.length > 0) {
                const extractionComplete = batch.timeline.find(t => 
                    t.stage === 'extraction' && t.timestamp
                );
                if (extractionComplete) {
                    extractionDate = new Date(extractionComplete.timestamp);
                }
            }
            
            const finishingDate = batch.finishing_date ? new Date(batch.finishing_date) : null;
            const packagingDate = batch.packaging_date ? new Date(batch.packaging_date) : null;
            const testingDate = batch.test_results_received_date ? new Date(batch.test_results_received_date) : null;
            const labelingDate = batch.labeling_date ? new Date(batch.labeling_date) : null;
            
            const totalDays = finishingDate ? ((finishingDate - intakeDate) / (1000 * 60 * 60 * 24)).toFixed(1) : 'N/A';
            const extractionDays = extractionDate && intakeDate ? ((extractionDate - intakeDate) / (1000 * 60 * 60 * 24)).toFixed(1) : 'N/A';
            const finishingDays = finishingDate && extractionDate ? ((finishingDate - extractionDate) / (1000 * 60 * 60 * 24)).toFixed(1) : 'N/A';
            
            // Helper function to format time in hours/minutes
            function formatDuration(minutes) {
                if (!minutes || minutes < 0) return 'N/A';
                const hours = Math.floor(minutes / 60);
                const mins = Math.round(minutes % 60);
                if (hours > 0) {
                    return mins > 0 ? `${hours}h ${mins}m` : `${hours}h`;
                }
                return `${mins}m`;
            }
            
            // Calculate stage durations from timeline
            let extractionTime = null;
            let finishingTime = null;
            let packagingTime = null;
            let testingTime = null;
            let labelingTime = null;
            
            if (batch.timeline && batch.timeline.length > 0) {
                // Find extraction start and complete
                const extractionStart = batch.timeline.find(t => 
                    t.action && (t.action.toLowerCase().includes('processing started') || t.action.toLowerCase().includes('extraction started'))
                );
                const extractionComplete = batch.timeline.find(t => 
                    (t.stage === 'extraction' || t.stage === 'finishing') && 
                    t.action && 
                    (t.action.toLowerCase().includes('completed') || t.action.toLowerCase().includes('extracted'))
                );
                
                if (extractionStart && extractionComplete) {
                    const startTime = new Date(extractionStart.date || extractionStart.timestamp);
                    const endTime = new Date(extractionComplete.date || extractionComplete.timestamp);
                    extractionTime = (endTime - startTime) / (1000 * 60); // minutes
                }
                
                // Find finishing/post-extraction start and complete (if exists)
                const finishingStart = batch.timeline.find(t => 
                    t.action && (t.action.toLowerCase().includes('post-processing started') || t.action.toLowerCase().includes('finishing started'))
                );
                const finishingComplete = batch.timeline.find(t => 
                    t.stage === 'finishing' && 
                    t.action && 
                    (t.action.toLowerCase().includes('finishing completed') || t.action.toLowerCase().includes('post-extraction completed'))
                );
                
                if (finishingStart && finishingComplete) {
                    const startTime = new Date(finishingStart.date || finishingStart.timestamp);
                    const endTime = new Date(finishingComplete.date || finishingComplete.timestamp);
                    finishingTime = (endTime - startTime) / (1000 * 60); // minutes
                }
                
                // Find packaging start and complete
                const packagingStart = batch.timeline.find(t =>
                    t.action && t.action.toLowerCase().includes('packaging started')
                );
                const packagingComplete = batch.timeline.find(t =>
                    t.stage === 'packaging' &&
                    t.action &&
                    (t.action.toLowerCase().includes('packaged') || t.action.includes('Packaging completed'))
                );

                if (packagingStart && packagingComplete) {
                    const startTime = new Date(packagingStart.date || packagingStart.timestamp);
                    const endTime = new Date(packagingComplete.date || packagingComplete.timestamp);
                    let totalTime = (endTime - startTime) / (1000 * 60); // minutes

                    // Subtract paused time
                    const packagingPauses = batch.timeline.filter(t => t.action && t.action.toLowerCase().includes('packaging paused'));
                    const packagingResumes = batch.timeline.filter(t => t.action && t.action.toLowerCase().includes('packaging resumed'));
                    for (let i = 0; i < Math.min(packagingPauses.length, packagingResumes.length); i++) {
                        const pauseTime = new Date(packagingPauses[i].date || packagingPauses[i].timestamp);
                        const resumeTime = new Date(packagingResumes[i].date || packagingResumes[i].timestamp);
                        if (resumeTime > pauseTime) {
                            totalTime -= (resumeTime - pauseTime) / (1000 * 60);
                        }
                    }
                    packagingTime = Math.max(0, totalTime);
                }
                
                // Find testing start and complete (test submitted to results received)
                const testSubmitted = batch.timeline.find(t => 
                    t.action && (t.action.toLowerCase().includes('test submitted') || t.action.toLowerCase().includes('submitted for testing'))
                );
                const testComplete = batch.timeline.find(t => 
                    t.action && (t.action.toLowerCase().includes('test results') || t.action.toLowerCase().includes('results received'))
                );
                
                if (testSubmitted && testComplete) {
                    const startTime = new Date(testSubmitted.date || testSubmitted.timestamp);
                    const endTime = new Date(testComplete.date || testComplete.timestamp);
                    testingTime = (endTime - startTime) / (1000 * 60); // minutes
                }
                
                // Find labeling start and complete
                const labelingStart = batch.timeline.find(t =>
                    t.action && t.action.toLowerCase().includes('labeling started')
                );
                const labelingComplete = batch.timeline.find(t =>
                    t.stage === 'labeling' &&
                    (t.action && t.action.toLowerCase().includes('labeled') || t.timestamp)
                );

                if (labelingStart && labelingComplete) {
                    const startTime = new Date(labelingStart.date || labelingStart.timestamp);
                    const endTime = new Date(labelingComplete.date || labelingComplete.timestamp);
                    let totalTime = (endTime - startTime) / (1000 * 60); // minutes

                    // Subtract paused time
                    const labelingPauses = batch.timeline.filter(t => t.action && t.action.toLowerCase().includes('labeling paused'));
                    const labelingResumes = batch.timeline.filter(t => t.action && t.action.toLowerCase().includes('labeling resumed'));
                    for (let i = 0; i < Math.min(labelingPauses.length, labelingResumes.length); i++) {
                        const pauseTime = new Date(labelingPauses[i].date || labelingPauses[i].timestamp);
                        const resumeTime = new Date(labelingResumes[i].date || labelingResumes[i].timestamp);
                        if (resumeTime > pauseTime) {
                            totalTime -= (resumeTime - pauseTime) / (1000 * 60);
                        }
                    }
                    labelingTime = Math.max(0, totalTime);
                }
            }
            
            const timeline = `
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px;">
                    <div style="text-align: center; padding: 15px; background: var(--bg-secondary); border-radius: 10px;">
                        <div style="font-size: 2rem; margin-bottom: 5px;">ðŸ“¥</div>
                        <div style="font-size: 0.85rem; color: var(--text-secondary);">Intake</div>
                        <div style="font-weight: 700;">${intakeDate.toLocaleDateString()}</div>
                    </div>
                    ${extractionDate ? `
                    <div style="text-align: center; padding: 15px; background: var(--bg-secondary); border-radius: 10px;">
                        <div style="font-size: 2rem; margin-bottom: 5px;">âš—ï¸</div>
                        <div style="font-size: 0.85rem; color: var(--text-secondary);">Extraction</div>
                        <div style="font-weight: 700;">${extractionDate.toLocaleDateString()}</div>
                        ${extractionTime ? `<div style="font-size: 0.9rem; color: var(--accent-green); font-weight: 700; margin-top: 5px;">â±ï¸ ${formatDuration(extractionTime)}</div>` : ''}
                    </div>` : ''}
                    ${finishingDate ? `
                    <div style="text-align: center; padding: 15px; background: var(--bg-secondary); border-radius: 10px;">
                        <div style="font-size: 2rem; margin-bottom: 5px;">âœ¨</div>
                        <div style="font-size: 0.85rem; color: var(--text-secondary);">Finishing</div>
                        <div style="font-weight: 700;">${finishingDate.toLocaleDateString()}</div>
                        ${finishingTime ? `<div style="font-size: 0.9rem; color: var(--accent-green); font-weight: 700; margin-top: 5px;">â±ï¸ ${formatDuration(finishingTime)}</div>` : ''}
                    </div>` : ''}
                    ${packagingDate ? `
                    <div style="text-align: center; padding: 15px; background: var(--bg-secondary); border-radius: 10px;">
                        <div style="font-size: 2rem; margin-bottom: 5px;">ðŸ“¦</div>
                        <div style="font-size: 0.85rem; color: var(--text-secondary);">Packaged</div>
                        <div style="font-weight: 700;">${packagingDate.toLocaleDateString()}</div>
                        ${packagingTime ? `<div style="font-size: 0.9rem; color: var(--accent-green); font-weight: 700; margin-top: 5px;">â±ï¸ ${formatDuration(packagingTime)}</div>` : ''}
                    </div>` : ''}
                    ${testingDate ? `
                    <div style="text-align: center; padding: 15px; background: var(--bg-secondary); border-radius: 10px;">
                        <div style="font-size: 2rem; margin-bottom: 5px;">ðŸ§ª</div>
                        <div style="font-size: 0.85rem; color: var(--text-secondary);">Testing</div>
                        <div style="font-weight: 700;">${testingDate.toLocaleDateString()}</div>
                        ${testingTime ? `<div style="font-size: 0.9rem; color: var(--accent-green); font-weight: 700; margin-top: 5px;">â±ï¸ ${formatDuration(testingTime)}</div>` : ''}
                    </div>` : ''}
                    ${labelingDate ? `
                    <div style="text-align: center; padding: 15px; background: var(--bg-secondary); border-radius: 10px;">
                        <div style="font-size: 2rem; margin-bottom: 5px;">ðŸ·ï¸</div>
                        <div style="font-size: 0.85rem; color: var(--text-secondary);">Labeled</div>
                        <div style="font-weight: 700;">${labelingDate.toLocaleDateString()}</div>
                        ${labelingTime ? `<div style="font-size: 0.9rem; color: var(--accent-green); font-weight: 700; margin-top: 5px;">â±ï¸ ${formatDuration(labelingTime)}</div>` : ''}
                    </div>` : ''}
                </div>
                <div style="text-align: center; margin-top: 20px; padding: 15px; background: rgba(16, 185, 129, 0.2); border-radius: 10px;">
                    <div style="font-size: 1.6rem; font-weight: 700; color: var(--accent-green);">Total Processing Time</div>
                    <div style="font-size: 1.8rem; font-weight: 700; color: var(--accent-green);">${totalDays} days</div>
                </div>
            `;
            document.getElementById('modalTimeline').innerHTML = timeline;
            
            // Economics
            const trimWeight = parseFloat(batch.trim_weight || 0);
            const netWeight = parseFloat(batch.net_weight || 0);
            const gramsLabeled = parseFloat(batch.grams_labeled || 0);
            
            // Use grams_labeled for yield if available, otherwise fall back to net_weight
            const finalWeight = gramsLabeled > 0 ? gramsLabeled : netWeight;
            const yield_percent = trimWeight > 0 ? ((finalWeight / trimWeight) * 100).toFixed(2) : 0;
            
            const materialCost = parseFloat(batch.material_cost || 0);
            const costPerGram = finalWeight > 0 ? (materialCost / finalWeight).toFixed(2) : 0;
            const costPerUnit = batch.units_packaged > 0 ? (materialCost / batch.units_packaged).toFixed(2) : 0;
            
            const economics = `
                <p><strong>Trim Used:</strong> ${trimWeight}g</p>
                <p><strong>Final Net Weight:</strong> ${netWeight}g</p>
                ${gramsLabeled > 0 ? `<p><strong>Labeled Weight:</strong> ${gramsLabeled}g</p>` : ''}
                <p style="color: var(--accent-green); font-size: 1.2rem; font-weight: 700; margin: 10px 0;"><strong>Yield:</strong> ${yield_percent}%</p>
                <p><strong>Material Cost:</strong> $${materialCost.toFixed(2)}</p>
                <p><strong>Cost Per Gram:</strong> $${costPerGram}</p>
                ${batch.units_packaged ? `<p><strong>Cost Per Unit:</strong> $${costPerUnit}</p>` : ''}
            `;
            document.getElementById('modalEconomics').innerHTML = economics;
            
            // Testing Results
            const testing = `
                <p><strong>THC:</strong> <span style="color: var(--accent-green); font-size: 1.3rem; font-weight: 700;">${batch.test_thc_percent || 'N/A'}${batch.test_thc_percent ? '%' : ''}</span></p>
                <p><strong>CBD:</strong> ${batch.test_cbd_percent || 0}%</p>
                ${batch.is_rta === 'yes' ? '<p style="color: var(--accent-green);"><strong>âœ“ RTA Full Panel</strong></p>' : '<p style="color: var(--text-secondary);">Standard Potency Test</p>'}
                ${batch.test_expiration_date ? `<p><strong>Expires:</strong> ${new Date(batch.test_expiration_date).toLocaleDateString()}</p>` : ''}
            `;
            document.getElementById('modalTesting').innerHTML = testing;
            
            // Production
            const production = `
                <p><strong>Units Packaged:</strong> ${batch.units_packaged || 'N/A'}</p>
                ${batch.packaging_breakdown ? `<p><strong>Breakdown:</strong> ${batch.packaging_breakdown}</p>` : ''}
                <p><strong>Extraction Method:</strong> ${batch.extraction_method || 'N/A'}</p>
                <p><strong>Material Agreement:</strong> ${batch.material_agreement || 'N/A'}</p>
                ${batch.metrc_tags ? `<p style="margin-top: 10px;"><strong>METRC Tags:</strong><br><span style="font-family: 'Space Mono', monospace; font-size: 0.9rem;">${batch.metrc_tags}</span></p>` : ''}
            `;
            document.getElementById('modalProduction').innerHTML = production;
            
            // Team Members
            const teamMembers = {};
            if (batch.timeline) {
                batch.timeline.forEach(entry => {
                    if (entry.user && entry.user !== 'Unknown') {
                        if (!teamMembers[entry.user]) {
                            teamMembers[entry.user] = [];
                        }
                        teamMembers[entry.user].push(entry.stage);
                    }
                });
            }
            
            const team = Object.keys(teamMembers).length > 0 ? Object.keys(teamMembers).map(user => `
                <div style="display: inline-block; margin: 5px 10px 5px 0; padding: 10px 15px; background: var(--bg-secondary); border-radius: 8px; border-left: 4px solid var(--accent-blue);">
                    <div style="font-weight: 700;">${user}</div>
                    <div style="font-size: 0.85rem; color: var(--text-secondary);">${[...new Set(teamMembers[user])].join(', ')}</div>
                </div>
            `).join('') : '<p style="color: var(--text-secondary);">No team members recorded</p>';
            
            document.getElementById('modalTeam').innerHTML = team;
            
            // Show modal
            document.getElementById('batchDetailsModal').style.display = 'block';
        }

        function closeBatchDetails() {
            document.getElementById('batchDetailsModal').style.display = 'none';
        }

        // Close modal when clicking outside
        document.getElementById('batchDetailsModal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeBatchDetails();
            }
        });

        // Performance Analytics
        document.getElementById('performanceFilter')?.addEventListener('change', function() {
            renderPerformanceAnalytics();
        });

        // Save and load targets
        function saveTargets() {
            const targets = {
                packaging: parseFloat(document.getElementById('targetPackagingUnits')?.value) || 200,
                labeling: parseFloat(document.getElementById('targetLabelingUnits')?.value) || 300,
                extractionTrim: parseFloat(document.getElementById('targetExtractionTrim')?.value) || 11200
            };
            localStorage.setItem('productionTargets', JSON.stringify(targets));
        }

        function loadTargets() {
            const saved = localStorage.getItem('productionTargets');
            if (saved) {
                const targets = JSON.parse(saved);
                if (document.getElementById('targetUnitsPerDay')) {
                    document.getElementById('targetUnitsPerDay').value = targets.unitsPerDay || 800;
                    document.getElementById('targetExtractionTrim').value = targets.extractionTrim || 11200;
                }
            }
            // Combined units target (packaging + labeling = 800/day total)
            const defaults = { unitsPerDay: 800, extractionTrim: 11200 };
            const result = saved ? JSON.parse(saved) : defaults;
            // Ensure unitsPerDay exists (migration from old format)
            if (!result.unitsPerDay) {
                result.unitsPerDay = 800;
            }
            return result;
        }


        // Denver timezone helper - converts to Mountain Time
        function getDenverDate(date = new Date()) {
            return new Date(date.toLocaleString('en-US', { timeZone: 'America/Denver' }));
        }

        function getDenverMidnight(date = new Date()) {
            const denver = getDenverDate(date);
            denver.setHours(0, 0, 0, 0);
            return denver;
        }

        // Helper to calculate date range start (handles 'Today' correctly with Denver midnight)
        function getPerformanceRangeStart(timeRange) {
            const now = getDenverDate();
            if (timeRange === 1) {
                // Today: start at midnight Denver time
                return getDenverMidnight();
            }
            // Other ranges: subtract days from Denver time
            return new Date(now.getTime() - (timeRange * 24 * 60 * 60 * 1000));
        }

        function renderPerformanceAnalytics() {
            const filter = document.getElementById('performanceFilter')?.value || 'all';
            const viewMode = document.getElementById('performanceViewMode')?.value || 'overview';
            const timeRange = parseInt(document.getElementById('performanceTimeRange')?.value) || 30;
            const statsContainer = document.getElementById('performanceStats');
            const companySummary = document.getElementById('companySummary');
            const staffingContainer = document.getElementById('staffingRecommendations');
            const capacityContainer = document.getElementById('capacityPlanning');
            const logContainer = document.getElementById('activityLog');
            
            if (!statsContainer) return;
            
            // Update today's production summary
            updateTodayProduction();
            
            // Update company production summary based on time range
            updateCompanyProductionSummary(timeRange);
            
            // Update login tracker
            updateLoginTracker();

            const targets = loadTargets();
            
            // Calculate date range
            const now = new Date();
            const rangeStart = getPerformanceRangeStart(timeRange);
            
            // Build employee production data from batches
            const employeeData = {};
            const dailyProduction = {}; // For trend analysis
            
            batches.forEach(batch => {
                // Track packaging production
                if (batch.packaging_user && batch.packaging_date && batch.units_packaged) {
                    const packagingDate = new Date(batch.packaging_date);
                    if (packagingDate >= rangeStart) {
                        const user = batch.packaging_user;
                        if (!employeeData[user]) {
                            employeeData[user] = {
                                name: user,
                                packaging: { units: 0, batches: 0, byProduct: {}, dates: [] },
                                labeling: { units: 0, batches: 0, dates: [] },
                                extraction: { batches: 0, runs: 0, trimWeight: 0, dates: [] },
                                daysActive: new Set()
                            };
                        }
                        
                        employeeData[user].packaging.units += batch.units_packaged;
                        employeeData[user].packaging.batches += 1;
                        employeeData[user].packaging.dates.push(packagingDate);
                        employeeData[user].daysActive.add(packagingDate.toDateString());
                        
                        // Track by product type
                        const productType = batch.packaged_product_type || 'Unknown';
                        if (!employeeData[user].packaging.byProduct[productType]) {
                            employeeData[user].packaging.byProduct[productType] = 0;
                        }
                        employeeData[user].packaging.byProduct[productType] += batch.units_packaged;
                        
                        // Daily production tracking
                        const dateKey = packagingDate.toDateString();
                        if (!dailyProduction[dateKey]) dailyProduction[dateKey] = { packaging: 0, labeling: 0 };
                        dailyProduction[dateKey].packaging += batch.units_packaged;
                    }
                }
                
                // Track labeling production (from timeline)
                if (batch.timeline && batch.timeline.length > 0) {
                    batch.timeline.forEach(event => {
                        const eventDate = new Date(event.timestamp || event.date);
                        
                        // Labeling completion
                        if (event.stage === 'labeling' && 
                            event.action && 
                            (event.action.toLowerCase().includes('completed') || event.action.toLowerCase().includes('labeled')) &&
                            eventDate >= rangeStart &&
                            batch.units_packaged) {
                            
                            const user = event.user;
                            if (!employeeData[user]) {
                                employeeData[user] = {
                                    name: user,
                                    packaging: { units: 0, batches: 0, byProduct: {}, dates: [] },
                                    labeling: { units: 0, batches: 0, dates: [] },
                                    extraction: { batches: 0, runs: 0, trimWeight: 0, dates: [] },
                                    daysActive: new Set()
                                };
                            }
                            
                            employeeData[user].labeling.units += batch.units_packaged;
                            employeeData[user].labeling.batches += 1;
                            employeeData[user].labeling.dates.push(eventDate);
                            employeeData[user].daysActive.add(eventDate.toDateString());
                            
                            const dateKey = eventDate.toDateString();
                            if (!dailyProduction[dateKey]) dailyProduction[dateKey] = { packaging: 0, labeling: 0 };
                            dailyProduction[dateKey].labeling += batch.units_packaged;
                        }
                        
                        // Extraction completion - check multiple formats
                        const isExtractionComplete1 = (
                            (event.stage === 'extraction' && event.action && event.action.toLowerCase().includes('completed')) ||
                            (event.stage === 'ready_for_testing' && event.action && event.action.includes('Extraction Complete'))
                        );
                        if (isExtractionComplete1 && eventDate >= rangeStart) {
                            
                            const user = event.user;
                            if (!employeeData[user]) {
                                employeeData[user] = {
                                    name: user,
                                    packaging: { units: 0, batches: 0, byProduct: {}, dates: [] },
                                    labeling: { units: 0, batches: 0, dates: [] },
                                    extraction: { batches: 0, runs: 0, trimWeight: 0, dates: [] },
                                    daysActive: new Set()
                                };
                            }
                            
                            employeeData[user].extraction.batches += 1;
                            // Track runs from extraction_runs field
                            if (batch.extraction_runs) {
                                employeeData[user].extraction.runs += parseInt(batch.extraction_runs);
                            }
                            // Track trim weight processed
                            if (batch.trim_weight) {
                                employeeData[user].extraction.trimWeight += parseFloat(batch.trim_weight);
                            }
                            employeeData[user].extraction.dates.push(eventDate);
                            employeeData[user].daysActive.add(eventDate.toDateString());
                        }
                        
                        // Finishing completion - count as active day
                        if (event.stage === 'finishing' && 
                            event.action && 
                            event.action.toLowerCase().includes('completed') &&
                            eventDate >= rangeStart) {
                            
                            const user = event.user;
                            if (!employeeData[user]) {
                                employeeData[user] = {
                                    name: user,
                                    packaging: { units: 0, batches: 0, byProduct: {}, dates: [] },
                                    labeling: { units: 0, batches: 0, dates: [] },
                                    extraction: { batches: 0, runs: 0, trimWeight: 0, dates: [] },
                                    daysActive: new Set()
                                };
                            }
                            employeeData[user].daysActive.add(eventDate.toDateString());
                        }
                    });
                }
            });
            
            // Add extraction runs from localStorage (actual column runs)
            const extractionRuns = JSON.parse(localStorage.getItem('wm_extraction_runs') || '[]');
            extractionRuns.forEach(run => {
                const runDate = new Date(run.timestamp);
                if (runDate < rangeStart) return;

                const user = run.user;
                if (!employeeData[user]) {
                    employeeData[user] = {
                        name: user,
                        packaging: { units: 0, batches: 0, byProduct: {}, dates: [] },
                        labeling: { units: 0, batches: 0, dates: [] },
                        extraction: { batches: 0, runs: 0, trimWeight: 0, dates: [] },
                        daysActive: new Set()
                    };
                }

                employeeData[user].extraction.runs += 1;
                employeeData[user].extraction.trimWeight += run.trimWeight || 0;
                employeeData[user].extraction.dates.push(runDate);
                employeeData[user].daysActive.add(runDate.toDateString());
            });

            // Calculate per-day averages for each employee
            Object.values(employeeData).forEach(emp => {
                const daysActive = emp.daysActive.size;
                emp.daysActiveCount = daysActive;
                // Combined units (packaging + labeling)
                emp.totalUnits = emp.packaging.units + emp.labeling.units;
                emp.unitsPerDay = daysActive > 0 ? (emp.totalUnits / daysActive).toFixed(0) : 0;
                emp.packaging.perDay = daysActive > 0 ? (emp.packaging.units / daysActive).toFixed(1) : 0;
                emp.labeling.perDay = daysActive > 0 ? (emp.labeling.units / daysActive).toFixed(1) : 0;
                emp.extraction.perDay = daysActive > 0 ? (emp.extraction.trimWeight / daysActive).toFixed(0) : 0;
            });
            
            // Filter data if needed
            const displayData = filter === 'all' 
                ? Object.values(employeeData) 
                : Object.values(employeeData).filter(e => e.name === filter);
            
            // Render company-wide summary (removed - now using separate function)
            
            // Render employee cards
            renderEmployeeCards(employeeData, timeRange);
            
            // Render individual employee cards based on view mode (legacy)
            if (displayData.length === 0) {
                statsContainer.innerHTML = '<p style="text-align: center; color: var(--text-secondary); padding: 40px;">No production data found for this period</p>';
            } else {
                const sortedEmployees = displayData.sort((a, b) => {
                    if (viewMode === 'packaging') return b.packaging.units - a.packaging.units;
                    if (viewMode === 'labeling') return b.labeling.units - a.labeling.units;
                    if (viewMode === 'extraction') return b.extraction.batches - a.extraction.batches;
                    return (b.packaging.units + b.labeling.units) - (a.packaging.units + a.labeling.units);
                });
                
                statsContainer.innerHTML = sortedEmployees.map(emp => {
                    // Determine current task status for this employee
                    let currentTask = null;
                    batches.forEach(batch => {
                        // Check packaging in progress - status stays as 'finishing' while packaging
                        if (batch.status === 'finishing') {
                            const hasStarted = batch.timeline && batch.timeline.some(t =>
                                t.action && t.action.toLowerCase().includes('packaging started') &&
                                t.user === emp.name);
                            const hasCompleted = batch.timeline && batch.timeline.some(t =>
                                t.stage === 'packaging' && t.action &&
                                (t.action.toLowerCase().includes('packaged') || t.action.includes('Packaging completed')));

                            if (hasStarted && !hasCompleted) {
                                currentTask = {
                                    type: 'packaging',
                                    batchId: batch.id,
                                    strain: batch.strain || batch.strain_name || 'Unknown',
                                    paused: batch.packaging_paused || false
                                };
                            }
                        }
                        // Check labeling in progress - status is 'complete' while labeling
                        if (batch.status === 'complete') {
                            const hasStarted = batch.timeline && batch.timeline.some(t =>
                                t.action && t.action.toLowerCase().includes('labeling started') &&
                                t.user === emp.name);
                            const hasCompleted = batch.timeline && batch.timeline.some(t =>
                                t.stage === 'labeling' && t.action && t.action.toLowerCase().includes('labeled'));

                            if (hasStarted && !hasCompleted) {
                                currentTask = {
                                    type: 'labeling',
                                    batchId: batch.id,
                                    strain: batch.strain || batch.strain_name || 'Unknown',
                                    paused: batch.labeling_paused || false
                                };
                            }
                        }
                    });

                    // Combined units target (packaging + labeling = 800/day total)
                    const unitsTarget = (targets.unitsPerDay || 800) * emp.daysActiveCount;
                    const totalUnits = emp.packaging.units + emp.labeling.units;
                    const unitsPct = unitsTarget > 0 ? ((totalUnits / unitsTarget) * 100).toFixed(0) : 0;
                    const extractionTrimTarget = (targets.extractionTrim || 11200) * emp.daysActiveCount;
                    const extractionPct = extractionTrimTarget > 0 ? ((emp.extraction.trimWeight / extractionTrimTarget) * 100).toFixed(0) : 0;
                    
                    // Determine performance color
                    const getPerformanceColor = (pct) => {
                        if (pct >= 90) return 'var(--accent-green)';
                        if (pct >= 70) return 'var(--accent-blue)';
                        if (pct >= 50) return 'var(--accent-orange)';
                        return 'var(--accent-red)';
                    };
                    
                    let detailSection = '';
                    
                    if (viewMode === 'overview' || viewMode === 'packaging') {
                        const productBreakdown = Object.entries(emp.packaging.byProduct)
                            .sort((a, b) => b[1] - a[1])
                            .map(([product, units]) => `
                                <div style="display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid var(--border);">
                                    <span>${product}</span>
                                    <span style="font-weight: 700; font-family: 'Space Mono', monospace;">${units} units</span>
                                </div>
                            `).join('');
                        
                        detailSection += `
                            <div style="background: var(--bg-primary); padding: 20px; border-radius: 12px; margin-top: 15px;">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                                    <h4 style="color: var(--accent-blue); font-size: 1.1rem;">ðŸ“¦ Packaging Performance</h4>
                                    <span style="font-size: 1.5rem; font-weight: 700; color: ${getPerformanceColor(unitsPct)};">${unitsPct}%</span>
                                </div>
                                
                                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px; margin-bottom: 15px;">
                                    <div style="text-align: center; padding: 15px; background: var(--bg-secondary); border-radius: 8px;">
                                        <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 5px;">Total Units</div>
                                        <div style="font-size: 2rem; font-weight: 700; color: var(--accent-blue);">${emp.packaging.units.toLocaleString()}</div>
                                    </div>
                                    <div style="text-align: center; padding: 15px; background: var(--bg-secondary); border-radius: 8px;">
                                        <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 5px;">Per Day</div>
                                        <div style="font-size: 2rem; font-weight: 700; color: var(--accent-green);">${emp.packaging.perDay}</div>
                                    </div>
                                    <div style="text-align: center; padding: 15px; background: var(--bg-secondary); border-radius: 8px;">
                                        <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 5px;">Batches</div>
                                        <div style="font-size: 2rem; font-weight: 700; color: var(--accent-purple);">${emp.packaging.batches}</div>
                                    </div>
                                </div>
                                
                                ${Object.keys(emp.packaging.byProduct).length > 0 ? `
                                    <div style="border-top: 2px solid var(--border); padding-top: 15px;">
                                        <h5 style="margin-bottom: 10px; color: var(--text-secondary); font-size: 0.9rem;">By Product Type:</h5>
                                        ${productBreakdown}
                                    </div>
                                ` : ''}
                                
                                <div style="margin-top: 15px; padding: 12px; background: var(--bg-secondary); border-radius: 8px; border-left: 4px solid ${getPerformanceColor(unitsPct)};">
                                    <div style="display: flex; justify-content: space-between; align-items: center;">
                                        <span style="color: var(--text-secondary);">Target: ${targets.unitsPerDay || 800}/day Ã— ${emp.daysActiveCount} days</span>
                                        <span style="font-weight: 700;">${emp.packaging.units} / ${unitsTarget}</span>
                                    </div>
                                </div>
                            </div>
                        `;
                    }
                    
                    if (viewMode === 'overview' || viewMode === 'labeling') {
                        detailSection += `
                            <div style="background: var(--bg-primary); padding: 20px; border-radius: 12px; margin-top: 15px;">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                                    <h4 style="color: var(--accent-green); font-size: 1.1rem;">ðŸ·ï¸ Labeling Performance</h4>
                                    <span style="font-size: 1.5rem; font-weight: 700; color: ${getPerformanceColor(unitsPct)};">${unitsPct}%</span>
                                </div>
                                
                                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px; margin-bottom: 15px;">
                                    <div style="text-align: center; padding: 15px; background: var(--bg-secondary); border-radius: 8px;">
                                        <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 5px;">Total Units</div>
                                        <div style="font-size: 2rem; font-weight: 700; color: var(--accent-green);">${emp.labeling.units.toLocaleString()}</div>
                                    </div>
                                    <div style="text-align: center; padding: 15px; background: var(--bg-secondary); border-radius: 8px;">
                                        <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 5px;">Per Day</div>
                                        <div style="font-size: 2rem; font-weight: 700; color: var(--accent-blue);">${emp.labeling.perDay}</div>
                                    </div>
                                    <div style="text-align: center; padding: 15px; background: var(--bg-secondary); border-radius: 8px;">
                                        <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 5px;">Batches</div>
                                        <div style="font-size: 2rem; font-weight: 700; color: var(--accent-purple);">${emp.labeling.batches}</div>
                                    </div>
                                </div>
                                
                                <div style="margin-top: 15px; padding: 12px; background: var(--bg-secondary); border-radius: 8px; border-left: 4px solid ${getPerformanceColor(unitsPct)};">
                                    <div style="display: flex; justify-content: space-between; align-items: center;">
                                        <span style="color: var(--text-secondary);">Target: ${targets.unitsPerDay || 800}/day Ã— ${emp.daysActiveCount} days</span>
                                        <span style="font-weight: 700;">${emp.labeling.units} / ${unitsTarget}</span>
                                    </div>
                                </div>
                            </div>
                        `;
                    }
                    
                    if (viewMode === 'overview' || viewMode === 'extraction') {
                        detailSection += `
                            <div style="background: var(--bg-primary); padding: 20px; border-radius: 12px; margin-top: 15px;">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                                    <h4 style="color: var(--accent-orange); font-size: 1.1rem;">ðŸ§ª Extraction Performance</h4>
                                    <span style="font-size: 1.5rem; font-weight: 700; color: ${getPerformanceColor(extractionPct)};">${extractionPct}%</span>
                                </div>
                                
                                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px; margin-bottom: 15px;">
                                    <div style="text-align: center; padding: 15px; background: var(--bg-secondary); border-radius: 8px;">
                                        <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 5px;">Batches</div>
                                        <div style="font-size: 2rem; font-weight: 700; color: var(--accent-orange);">${emp.extraction.batches}</div>
                                    </div>
                                    <div style="text-align: center; padding: 15px; background: var(--bg-secondary); border-radius: 8px;">
                                        <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 5px;">Total Runs</div>
                                        <div style="font-size: 2rem; font-weight: 700; color: var(--accent-blue);">${emp.extraction.runs}</div>
                                    </div>
                                    <div style="text-align: center; padding: 15px; background: var(--bg-secondary); border-radius: 8px;">
                                        <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 5px;">Trim (g)</div>
                                        <div style="font-size: 2rem; font-weight: 700; color: var(--accent-green);">${emp.extraction.trimWeight.toFixed(0)}</div>
                                    </div>
                                </div>
                                
                                <div style="margin-top: 15px; padding: 12px; background: var(--bg-secondary); border-radius: 8px; border-left: 4px solid ${getPerformanceColor(extractionPct)};">
                                    <div style="display: flex; justify-content: space-between; align-items: center;">
                                        <span style="color: var(--text-secondary);">Trim Target: ${targets.extractionTrim || 11200}g/day Ã— ${emp.daysActiveCount} days</span>
                                        <span style="font-weight: 700;">${emp.extraction.trimWeight.toFixed(0)}g / ${extractionTrimTarget.toFixed(0)}g</span>
                                    </div>
                                </div>
                            </div>
                        `;
                    }
                    
                    return `
                        <div style="background: var(--bg-tertiary); padding: 25px; border-radius: 15px; border: 2px solid var(--border); margin-bottom: 25px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                                <div>
                                    <h3 style="font-size: 1.8rem; margin-bottom: 5px; color: var(--accent-purple);">
                                        ${emp.name}
                                        ${(() => {
                                            // Find PIN for this employee
                                            const roleEntry = Object.entries(ROLES).find(([key, role]) => role.name === emp.name);
                                            return roleEntry ? ` - PIN: ${roleEntry[1].pin}` : '';
                                        })()}
                                    </h3>
                                    <p style="color: var(--text-secondary); font-size: 0.95rem;">Active ${emp.daysActiveCount} of ${timeRange} days</p>
                                    ${currentTask ? `
                                    <div style="margin-top: 8px; display: inline-flex; align-items: center; gap: 8px; padding: 6px 12px; border-radius: 20px; font-size: 0.85rem; font-weight: 600;
                                        background: ${currentTask.paused ? 'rgba(255, 107, 0, 0.2)' : 'rgba(57, 255, 20, 0.2)'};
                                        border: 1px solid ${currentTask.paused ? 'var(--accent-orange)' : 'var(--accent-green)'};
                                        color: ${currentTask.paused ? 'var(--accent-orange)' : 'var(--accent-green)'};">
                                        <span style="font-size: 1rem;">${currentTask.paused ? 'â¸ï¸' : currentTask.type === 'packaging' ? 'ðŸ“¦' : 'ðŸ·ï¸'}</span>
                                        <span>${currentTask.paused ? 'PAUSED' : 'WORKING'}: ${currentTask.type === 'packaging' ? 'Packaging' : 'Labeling'} ${currentTask.strain}</span>
                                    </div>
                                    ` : ''}
                                </div>
                                <div style="text-align: right;">
                                    <div style="font-family: 'Space Mono', monospace; font-size: 2.5rem; font-weight: 700; color: var(--accent-green);">${(emp.packaging.units + emp.labeling.units).toLocaleString()}</div>
                                    <div style="color: var(--text-secondary); font-size: 0.9rem;">Total Units</div>
                                </div>
                            </div>
                            
                            ${detailSection}
                        </div>
                    `;
                }).join('');
            }
            
            // Staffing recommendations (only show when viewing all employees)
            if (staffingContainer && filter === 'all') {
                const totalPackaging = Object.values(employeeData).reduce((sum, e) => sum + e.packaging.units, 0);
                const totalLabeling = Object.values(employeeData).reduce((sum, e) => sum + e.labeling.units, 0);
                const avgDailyPackaging = totalPackaging / timeRange;
                const avgDailyLabeling = totalLabeling / timeRange;
                const activeEmployees = Object.keys(employeeData).length;
                
                const packagingCapacity = activeEmployees * targets.packaging;
                const labelingCapacity = activeEmployees * targets.labeling;
                
                const packagingUtilization = packagingCapacity > 0 ? ((avgDailyPackaging / packagingCapacity) * 100).toFixed(0) : 0;
                const labelingUtilization = labelingCapacity > 0 ? ((avgDailyLabeling / labelingCapacity) * 100).toFixed(0) : 0;
                
                // Calculate needed employees to meet different inventory targets
                const inventoryTargets = [500, 1000, 1500, 2000];
                
                staffingContainer.innerHTML = `
                    <div style="background: var(--bg-tertiary); padding: 25px; border-radius: 15px; border: 2px solid var(--accent-green);">
                        <h3 style="color: var(--accent-green); margin-bottom: 20px; font-size: 1.4rem;">ðŸŽ¯ Capacity & Staffing Analysis</h3>
                        
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin-bottom: 25px;">
                            <div style="background: var(--bg-primary); padding: 20px; border-radius: 12px;">
                                <div style="font-size: 0.9rem; color: var(--text-secondary); margin-bottom: 10px;">Packaging Capacity Utilization</div>
                                <div style="font-size: 2.5rem; font-weight: 700; color: ${packagingUtilization >= 80 ? 'var(--accent-red)' : packagingUtilization >= 60 ? 'var(--accent-orange)' : 'var(--accent-green)'};">${packagingUtilization}%</div>
                                <div style="font-size: 0.85rem; color: var(--text-secondary); margin-top: 8px;">${avgDailyPackaging.toFixed(0)} / ${packagingCapacity} units per day</div>
                            </div>
                            
                            <div style="background: var(--bg-primary); padding: 20px; border-radius: 12px;">
                                <div style="font-size: 0.9rem; color: var(--text-secondary); margin-bottom: 10px;">Labeling Capacity Utilization</div>
                                <div style="font-size: 2.5rem; font-weight: 700; color: ${labelingUtilization >= 80 ? 'var(--accent-red)' : labelingUtilization >= 60 ? 'var(--accent-orange)' : 'var(--accent-green)'};">${labelingUtilization}%</div>
                                <div style="font-size: 0.85rem; color: var(--text-secondary); margin-top: 8px;">${avgDailyLabeling.toFixed(0)} / ${labelingCapacity} units per day</div>
                            </div>
                        </div>
                        
                        <div style="background: var(--bg-primary); padding: 20px; border-radius: 12px;">
                            <h4 style="margin-bottom: 15px; color: var(--accent-blue);">Staffing to Meet Daily Production Targets:</h4>
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                                ${inventoryTargets.map(target => {
                                    const packagingNeeded = Math.ceil(target / targets.packaging);
                                    const labelingNeeded = Math.ceil(target / targets.labeling);
                                    const maxNeeded = Math.max(packagingNeeded, labelingNeeded);
                                    const diff = maxNeeded - activeEmployees;
                                    
                                    return `
                                        <div style="background: var(--bg-secondary); padding: 15px; border-radius: 8px; border-left: 4px solid ${diff > 0 ? 'var(--accent-orange)' : 'var(--accent-green)'};">
                                            <div style="font-weight: 700; font-size: 1.3rem; margin-bottom: 8px; color: var(--accent-purple);">${target} units/day</div>
                                            <div style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 5px;">Packaging: ${packagingNeeded} employees</div>
                                            <div style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 10px;">Labeling: ${labelingNeeded} employees</div>
                                            <div style="font-weight: 600; color: ${diff > 0 ? 'var(--accent-orange)' : 'var(--accent-green)'};">
                                                ${diff > 0 ? `Need +${diff} more` : diff < 0 ? `${Math.abs(diff)} extra capacity` : 'âœ“ Fully staffed'}
                                            </div>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        </div>
                    </div>
                `;
            } else if (staffingContainer) {
                staffingContainer.innerHTML = '';
            }
            
            // Render activity log
            if (logContainer) {
                const activities = [];
                batches.forEach(batch => {
                    if (batch.timeline && Array.isArray(batch.timeline)) {
                        batch.timeline.forEach(event => {
                            const eventDate = new Date(event.timestamp || event.date);
                            if (eventDate >= rangeStart) {
                                activities.push({
                                    ...event,
                                    batchId: batch.id,
                                    strain: batch.strain,
                                    date: eventDate,
                                    units: batch.units_packaged || 0
                                });
                            }
                        });
                    }
                });
                
                const filteredActivities = filter === 'all' 
                    ? activities 
                    : activities.filter(a => a.user === filter);
                
                const sortedActivities = filteredActivities.sort((a, b) => b.date - a.date);
                
                if (sortedActivities.length === 0) {
                    logContainer.innerHTML = '<p style="text-align: center; color: var(--text-secondary); padding: 40px;">No activities to display</p>';
                } else {
                    logContainer.innerHTML = `
                        <div style="overflow-x: auto;">
                            <table style="width: 100%; border-collapse: collapse;">
                                <thead>
                                    <tr style="background: var(--bg-tertiary); border-bottom: 2px solid var(--border);">
                                        <th style="padding: 15px; text-align: left; color: var(--text-secondary); font-size: 0.9rem; text-transform: uppercase;">Date</th>
                                        <th style="padding: 15px; text-align: left; color: var(--text-secondary); font-size: 0.9rem; text-transform: uppercase;">Employee</th>
                                        <th style="padding: 15px; text-align: left; color: var(--text-secondary); font-size: 0.9rem; text-transform: uppercase;">Action</th>
                                        <th style="padding: 15px; text-align: left; color: var(--text-secondary); font-size: 0.9rem; text-transform: uppercase;">Batch</th>
                                        <th style="padding: 15px; text-align: left; color: var(--text-secondary); font-size: 0.9rem; text-transform: uppercase;">Strain</th>
                                        <th style="padding: 15px; text-align: right; color: var(--text-secondary); font-size: 0.9rem; text-transform: uppercase;">Units</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${sortedActivities.slice(0, 100).map(activity => {
                                        const isCompletion = activity.action && (
                                            activity.action.toLowerCase().includes('completed') ||
                                            activity.action.toLowerCase().includes('labeled')
                                        );
                                        
                                        return `
                                            <tr style="border-bottom: 1px solid var(--border);">
                                                <td style="padding: 12px; color: var(--text-secondary); font-size: 0.95rem;">${activity.date.toLocaleDateString()} ${activity.date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</td>
                                                <td style="padding: 12px; font-weight: 600; font-size: 0.95rem;">${activity.user}</td>
                                                <td style="padding: 12px;">
                                                    <span style="background: rgba(147, 51, 234, 0.2); color: var(--accent-purple); padding: 6px 12px; border-radius: 12px; font-size: 0.85rem; text-transform: capitalize;">
                                                        ${activity.stage || 'unknown'}
                                                    </span>
                                                    ${isCompletion ? '<span style="margin-left: 8px; color: var(--accent-green);">âœ“</span>' : ''}
                                                </td>
                                                <td style="padding: 12px; font-family: 'Space Mono', monospace; font-size: 0.95rem;">${activity.batchId}</td>
                                                <td style="padding: 12px; color: var(--text-secondary); font-size: 0.95rem;">${activity.strain}</td>
                                                <td style="padding: 12px; text-align: right; font-weight: 700; font-family: 'Space Mono', monospace; font-size: 0.95rem;">${isCompletion && activity.units > 0 ? activity.units : '-'}</td>
                                            </tr>
                                        `;
                                    }).join('')}
                                </tbody>
                            </table>
                        </div>
                        ${sortedActivities.length > 100 ? '<p style="text-align: center; color: var(--text-secondary); margin-top: 20px;">Showing most recent 100 activities</p>' : ''}
                    `;
                }
            }
        }

        

        // Get employee role info from ROLES object
        function getEmployeeRole(employeeName) {
            const roleKey = Object.keys(ROLES).find(key => ROLES[key].name === employeeName);
            return roleKey ? ROLES[roleKey] : null;
        }

        // Render clickable employee cards
        function renderEmployeeCards(employeeData, timeRange) {
            const grid = document.getElementById('employeeCardsGrid');
            if (!grid) return;

            const targets = loadTargets();
            const now = new Date();
            const rangeStart = getPerformanceRangeStart(timeRange);

            // Update date range display
            const dateRangeEl = document.getElementById('performanceDateRange');
            if (dateRangeEl) {
                dateRangeEl.textContent = timeRange === 1 ? 'Today (' + getDenverDate().toLocaleDateString() + ')' : rangeStart.toLocaleDateString() + ' - ' + getDenverDate().toLocaleDateString();
            }

            // Get all employees from ROLES (excluding demo)
            const allEmployees = Object.values(ROLES)
                .filter(r => !r.isDemo && r.name !== 'Drew (Sales)')
                .map(r => {
                    const data = employeeData[r.name] || {
                        name: r.name,
                        packaging: { units: 0, batches: 0, byProduct: {}, dates: [], perDay: 0 },
                        labeling: { units: 0, batches: 0, dates: [], perDay: 0 },
                        extraction: { batches: 0, runs: 0, trimWeight: 0, dates: [], perDay: 0 },
                        daysActive: new Set(),
                        daysActiveCount: 0
                    };
                    return { ...data, role: r };
                });

            if (allEmployees.length === 0) {
                grid.innerHTML = '<p style="text-align: center; color: var(--text-secondary); padding: 40px;">No employees found</p>';
                return;
            }

            grid.innerHTML = allEmployees.map(emp => {
                const role = emp.role;
                const access = role.access || [];

                // Calculate overall performance %
                // Combined units target
                const unitsTarget = (targets.unitsPerDay || 800) * (emp.daysActiveCount || 1);
                const totalUnits = (emp.packaging?.units || 0) + (emp.labeling?.units || 0);
                const extractionTarget = (targets.extractionTrim || 11200) * (emp.daysActiveCount || 1);

                let scores = [];
                // Combined units score for packaging/labeling
                if ((access.includes('packaging') || access.includes('labeling')) && unitsTarget > 0) {
                    scores.push((totalUnits / unitsTarget) * 100);
                }
                // Extraction score
                if (access.includes('extraction') && extractionTarget > 0) {
                    scores.push((emp.extraction.trimWeight / extractionTarget) * 100);
                }

                const avgScore = scores.length > 0 ? scores.reduce((a, b) => a + b, 0) / scores.length : 0;
                const scoreColor = avgScore >= 90 ? 'var(--accent-green)' : avgScore >= 70 ? 'var(--accent-blue)' : avgScore >= 50 ? 'var(--accent-orange)' : 'var(--accent-red)';

                // Build skill badges based on access
                const skillBadges = [];
                if (access.includes('extraction')) skillBadges.push('<span style="background: rgba(245, 158, 11, 0.3); color: var(--accent-orange); padding: 3px 8px; border-radius: 10px; font-size: 0.75rem;">Extraction</span>');
                if (access.includes('finishing')) skillBadges.push('<span style="background: rgba(59, 130, 246, 0.3); color: var(--accent-blue); padding: 3px 8px; border-radius: 10px; font-size: 0.75rem;">Finishing</span>');
                if (access.includes('packaging')) skillBadges.push('<span style="background: rgba(147, 51, 234, 0.3); color: var(--accent-purple); padding: 3px 8px; border-radius: 10px; font-size: 0.75rem;">Packaging</span>');
                if (access.includes('labeling')) skillBadges.push('<span style="background: rgba(16, 185, 129, 0.3); color: var(--accent-green); padding: 3px 8px; border-radius: 10px; font-size: 0.75rem;">Labeling</span>');

                // Build quick stats based on access
                let quickStats = '';
                if (access.includes('packaging')) {
                    quickStats += '<div style="display: flex; justify-content: space-between; padding: 6px 0; border-bottom: 1px solid var(--border);"><span style="color: var(--text-secondary);">Packaged</span><span style="font-weight: 600; font-family: monospace;">' + emp.packaging.units.toLocaleString() + ' units</span></div>';
                }
                if (access.includes('labeling')) {
                    quickStats += '<div style="display: flex; justify-content: space-between; padding: 6px 0; border-bottom: 1px solid var(--border);"><span style="color: var(--text-secondary);">Labeled</span><span style="font-weight: 600; font-family: monospace;">' + emp.labeling.units.toLocaleString() + ' units</span></div>';
                }
                if (access.includes('extraction')) {
                    quickStats += '<div style="display: flex; justify-content: space-between; padding: 6px 0; border-bottom: 1px solid var(--border);"><span style="color: var(--text-secondary);">Extracted</span><span style="font-weight: 600; font-family: monospace;">' + emp.extraction.trimWeight.toFixed(0) + 'g trim</span></div>';
                }
                if (access.includes('finishing')) {
                    quickStats += '<div style="display: flex; justify-content: space-between; padding: 6px 0;"><span style="color: var(--text-secondary);">Batches Finished</span><span style="font-weight: 600; font-family: monospace;">' + emp.extraction.batches + '</span></div>';
                }

                if (!quickStats) {
                    quickStats = '<div style="color: var(--text-secondary); text-align: center; padding: 10px;">No tracked activities</div>';
                }

                // Determine current task status for this employee
                let currentTask = null;
                batches.forEach(batch => {
                    // Check packaging in progress - status stays as 'finishing' while packaging
                    if (batch.status === 'finishing') {
                        const hasStarted = batch.timeline && batch.timeline.some(t =>
                            t.action && t.action.toLowerCase().includes('packaging started') &&
                            t.user === emp.name);
                        const hasCompleted = batch.timeline && batch.timeline.some(t =>
                            t.stage === 'packaging' && t.action &&
                            (t.action.toLowerCase().includes('packaged') || t.action.includes('Packaging completed')));
                        if (hasStarted && !hasCompleted) {
                            currentTask = {
                                type: 'packaging',
                                batchId: batch.id,
                                strain: batch.strain || batch.strain_name || 'Unknown',
                                weight: batch.final_weight || batch.net_weight || batch.bulk_weight || 0,
                                paused: batch.packaging_paused || false
                            };
                        }
                    }
                    // Check labeling in progress - status is 'complete' while labeling
                    if (batch.status === 'complete') {
                        const hasStarted = batch.timeline && batch.timeline.some(t =>
                            t.action && t.action.toLowerCase().includes('labeling started') &&
                            t.user === emp.name);
                        const hasCompleted = batch.timeline && batch.timeline.some(t =>
                            t.stage === 'labeling' && t.action && t.action.toLowerCase().includes('labeled'));
                        if (hasStarted && !hasCompleted) {
                            currentTask = {
                                type: 'labeling',
                                batchId: batch.id,
                                strain: batch.strain || batch.strain_name || 'Unknown',
                                weight: batch.final_weight || batch.net_weight || batch.bulk_weight || 0,
                                paused: batch.labeling_paused || false
                            };
                        }
                    }
                });

                const currentTaskHtml = currentTask ? `
                    <div style="margin-top: 12px; display: flex; align-items: center; gap: 8px; padding: 8px 12px; border-radius: 20px; font-size: 0.85rem; font-weight: 600;
                        background: ${currentTask.paused ? 'rgba(255, 107, 0, 0.2)' : 'rgba(57, 255, 20, 0.2)'};
                        border: 1px solid ${currentTask.paused ? 'var(--accent-orange)' : 'var(--accent-green)'};
                        color: ${currentTask.paused ? 'var(--accent-orange)' : 'var(--accent-green)'};">
                        <span style="font-size: 1rem;">${currentTask.paused ? 'â¸ï¸' : currentTask.type === 'packaging' ? 'ðŸ“¦' : 'ðŸ·ï¸'}</span>
                        <span>${currentTask.paused ? 'PAUSED' : 'WORKING'}: ${currentTask.type === 'packaging' ? 'Packaging' : 'Labeling'} ${currentTask.strain}${currentTask.weight ? ' (' + currentTask.weight + 'g)' : ''}</span>
                    </div>
                ` : '';

                return `
                    <div onclick="showEmployeeDetailModal('${emp.name}')" style="background: var(--bg-tertiary); padding: 20px; border-radius: 15px; border: 2px solid var(--border); cursor: pointer; transition: all 0.2s ease; position: relative;" onmouseover="this.style.borderColor='var(--accent-purple)'; this.style.transform='translateY(-2px)';" onmouseout="this.style.borderColor='var(--border)'; this.style.transform='none';">
                        <!-- Performance Score Badge -->
                        <div style="position: absolute; top: 15px; right: 15px; background: ${scoreColor}; color: white; padding: 5px 10px; border-radius: 20px; font-weight: 700; font-size: 0.85rem;">
                            ${avgScore.toFixed(0)}%
                        </div>

                        <!-- Name and Days Active -->
                        <h3 style="font-size: 1.4rem; margin: 0 0 5px 0; color: var(--text-primary);">${emp.name.replace(' (Admin)', '')}</h3>
                        <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 12px;">${emp.daysActiveCount} days active</div>

                        <!-- Current Task Badge -->
                        ${currentTaskHtml}

                        <!-- Skill Badges -->
                        <div style="display: flex; gap: 5px; flex-wrap: wrap; margin-bottom: 15px; margin-top: 12px;">
                            ${skillBadges.join('')}
                        </div>

                        <!-- Quick Stats -->
                        <div style="font-size: 0.95rem;">
                            ${quickStats}
                        </div>
                    </div>
                `;
            }).join('');
        }

        // Show employee detail modal
        function showEmployeeDetailModal(employeeName) {
            const role = getEmployeeRole(employeeName);
            if (!role) return;

            const access = role.access || [];
            const timeRange = parseInt(document.getElementById('performanceTimeRange')?.value) || 30;
            const targets = loadTargets();

            // Recalculate employee data
            const now = new Date();
            const rangeStart = getPerformanceRangeStart(timeRange);

            let empData = {
                packaging: { units: 0, batches: 0, byProduct: {}, dates: [], timeMinutes: 0 },
                labeling: { units: 0, batches: 0, dates: [], timeMinutes: 0 },
                extraction: { batches: 0, runs: 0, trimWeight: 0, dates: [] },
                finishing: { batches: 0, dates: [] },
                daysActive: new Set()
            };

            // Add extraction runs from localStorage first
            const extractionRuns = JSON.parse(localStorage.getItem('wm_extraction_runs') || '[]');
            extractionRuns.forEach(run => {
                if (run.user !== employeeName) return;
                const runDate = new Date(run.timestamp);
                if (runDate < rangeStart) return;

                empData.extraction.runs += 1;
                empData.extraction.trimWeight += run.trimWeight || 0;
                empData.daysActive.add(runDate.toDateString());
            });

            // Calculate stats from batches
            batches.forEach(batch => {
                // Packaging - with time calculation
                if (batch.packaging_user === employeeName && batch.packaging_date && batch.units_packaged) {
                    const packagingDate = new Date(batch.packaging_date);
                    if (packagingDate >= rangeStart) {
                        empData.packaging.units += batch.units_packaged;
                        empData.packaging.batches += 1;
                        empData.daysActive.add(packagingDate.toDateString());
                        const productType = batch.packaged_product_type || 'Unknown';
                        empData.packaging.byProduct[productType] = (empData.packaging.byProduct[productType] || 0) + batch.units_packaged;

                        // Calculate packaging time from timeline
                        if (batch.timeline) {
                            const packagingStart = batch.timeline.find(t => t.action && t.action.toLowerCase().includes('packaging started'));
                            const packagingComplete = batch.timeline.find(t => t.stage === 'packaging' && t.action &&
                                (t.action.toLowerCase().includes('packaged') || t.action.includes('Packaging completed')));

                            if (packagingStart && packagingComplete) {
                                const startTime = new Date(packagingStart.date || packagingStart.timestamp);
                                const endTime = new Date(packagingComplete.date || packagingComplete.timestamp);
                                let batchTime = (endTime - startTime) / (1000 * 60); // minutes

                                // Subtract paused time
                                const pauses = batch.timeline.filter(t => t.action && t.action.toLowerCase().includes('packaging paused'));
                                const resumes = batch.timeline.filter(t => t.action && t.action.toLowerCase().includes('packaging resumed'));
                                for (let i = 0; i < Math.min(pauses.length, resumes.length); i++) {
                                    const pauseTime = new Date(pauses[i].date || pauses[i].timestamp);
                                    const resumeTime = new Date(resumes[i].date || resumes[i].timestamp);
                                    if (resumeTime > pauseTime) {
                                        batchTime -= (resumeTime - pauseTime) / (1000 * 60);
                                    }
                                }
                                empData.packaging.timeMinutes += Math.max(0, batchTime);
                            }
                        }
                    }
                }

                // Timeline events
                if (batch.timeline && batch.timeline.length > 0) {
                    batch.timeline.forEach(event => {
                        if (event.user !== employeeName) return;
                        const eventDate = new Date(event.timestamp || event.date);
                        if (eventDate < rangeStart) return;

                        // Labeling - with time calculation
                        if (event.stage === 'labeling' && event.action &&
                            (event.action.toLowerCase().includes('completed') || event.action.toLowerCase().includes('labeled'))) {
                            empData.labeling.units += batch.units_packaged || 0;
                            empData.labeling.batches += 1;
                            empData.daysActive.add(eventDate.toDateString());

                            // Calculate labeling time from timeline
                            const labelingStart = batch.timeline.find(t => t.action && t.action.toLowerCase().includes('labeling started'));
                            const labelingComplete = batch.timeline.find(t => t.stage === 'labeling' &&
                                (t.action && t.action.toLowerCase().includes('labeled') || t.timestamp));

                            if (labelingStart && labelingComplete) {
                                const startTime = new Date(labelingStart.date || labelingStart.timestamp);
                                const endTime = new Date(labelingComplete.date || labelingComplete.timestamp);
                                let batchTime = (endTime - startTime) / (1000 * 60); // minutes

                                // Subtract paused time
                                const pauses = batch.timeline.filter(t => t.action && t.action.toLowerCase().includes('labeling paused'));
                                const resumes = batch.timeline.filter(t => t.action && t.action.toLowerCase().includes('labeling resumed'));
                                for (let i = 0; i < Math.min(pauses.length, resumes.length); i++) {
                                    const pauseTime = new Date(pauses[i].date || pauses[i].timestamp);
                                    const resumeTime = new Date(resumes[i].date || resumes[i].timestamp);
                                    if (resumeTime > pauseTime) {
                                        batchTime -= (resumeTime - pauseTime) / (1000 * 60);
                                    }
                                }
                                empData.labeling.timeMinutes += Math.max(0, batchTime);
                            }
                        }

                        // Extraction - check multiple formats
                        const isExtractionComplete = (
                            (event.stage === 'extraction' && event.action && event.action.toLowerCase().includes('completed')) ||
                            (event.stage === 'ready_for_testing' && event.action && event.action.includes('Extraction Complete'))
                        );
                        if (isExtractionComplete) {
                            empData.extraction.batches += 1;
                            empData.extraction.runs += batch.extraction_runs ? parseInt(batch.extraction_runs) : 0;
                            empData.extraction.trimWeight += batch.trim_weight ? parseFloat(batch.trim_weight) : 0;
                            empData.daysActive.add(eventDate.toDateString());
                        }

                        // Finishing
                        if (event.stage === 'finishing' && event.action && event.action.toLowerCase().includes('completed')) {
                            empData.finishing.batches += 1;
                            empData.daysActive.add(eventDate.toDateString());
                        }
                    });
                }
            });

            const daysActive = empData.daysActive.size || 1;

            // Combined units calculation (available to both packaging and labeling sections)
            const unitsTarget = (targets.unitsPerDay || 800) * daysActive;
            const totalUnits = empData.packaging.units + empData.labeling.units;
            const unitsPct = unitsTarget > 0 ? ((totalUnits / unitsTarget) * 100).toFixed(0) : 0;
            const unitsColor = unitsPct >= 90 ? 'var(--accent-green)' : unitsPct >= 70 ? 'var(--accent-blue)' : unitsPct >= 50 ? 'var(--accent-orange)' : 'var(--accent-red)';

            // Build detail sections based on access
            let detailSections = '';

            if (access.includes('extraction')) {
                const extractionTarget = (targets.extractionTrim || 11200) * daysActive;
                const extractionPct = extractionTarget > 0 ? ((empData.extraction.trimWeight / extractionTarget) * 100).toFixed(0) : 0;
                const color = extractionPct >= 90 ? 'var(--accent-green)' : extractionPct >= 70 ? 'var(--accent-blue)' : extractionPct >= 50 ? 'var(--accent-orange)' : 'var(--accent-red)';

                detailSections += `
                    <div style="background: var(--bg-tertiary); padding: 20px; border-radius: 12px; margin-bottom: 15px; border-left: 4px solid var(--accent-orange);">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                            <h3 style="margin: 0; color: var(--accent-orange); font-size: 1.2rem;">Extraction</h3>
                            <span style="font-size: 1.5rem; font-weight: 700; color: ${color};">${extractionPct}%</span>
                        </div>
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; text-align: center;">
                            <div style="background: var(--bg-primary); padding: 15px; border-radius: 8px;">
                                <div style="font-size: 0.8rem; color: var(--text-secondary);">Trim Processed</div>
                                <div style="font-size: 1.8rem; font-weight: 700; color: var(--accent-orange);">${empData.extraction.trimWeight.toFixed(0)}g</div>
                            </div>
                            <div style="background: var(--bg-primary); padding: 15px; border-radius: 8px;">
                                <div style="font-size: 0.8rem; color: var(--text-secondary);">Batches</div>
                                <div style="font-size: 1.8rem; font-weight: 700; color: var(--accent-blue);">${empData.extraction.batches}</div>
                            </div>
                            <div style="background: var(--bg-primary); padding: 15px; border-radius: 8px;">
                                <div style="font-size: 0.8rem; color: var(--text-secondary);">Per Day Avg</div>
                                <div style="font-size: 1.8rem; font-weight: 700; color: var(--accent-green);">${(empData.extraction.trimWeight / daysActive).toFixed(0)}g</div>
                            </div>
                        </div>
                        <div style="margin-top: 15px; padding: 10px; background: var(--bg-primary); border-radius: 8px; font-size: 0.9rem; color: var(--text-secondary);">
                            Target: ${targets.extractionTrim || 11200}g/day x ${daysActive} days = ${extractionTarget.toLocaleString()}g
                        </div>
                    </div>
                `;
            }

            if (access.includes('packaging')) {
                const productBreakdown = Object.entries(empData.packaging.byProduct)
                    .sort((a, b) => b[1] - a[1])
                    .map(([product, units]) => `<div style="display: flex; justify-content: space-between; padding: 5px 0;"><span>${product}</span><span style="font-weight: 600;">${units}</span></div>`)
                    .join('');

                detailSections += `
                    <div style="background: var(--bg-tertiary); padding: 20px; border-radius: 12px; margin-bottom: 15px; border-left: 4px solid var(--accent-purple);">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                            <h3 style="margin: 0; color: var(--accent-purple); font-size: 1.2rem;">Packaging</h3>
                            <span style="font-size: 1.5rem; font-weight: 700; color: ${unitsColor};">${unitsPct}%</span>
                        </div>
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; text-align: center;">
                            <div style="background: var(--bg-primary); padding: 15px; border-radius: 8px;">
                                <div style="font-size: 0.8rem; color: var(--text-secondary);">Units Packaged</div>
                                <div style="font-size: 1.8rem; font-weight: 700; color: var(--accent-purple);">${empData.packaging.units.toLocaleString()}</div>
                            </div>
                            <div style="background: var(--bg-primary); padding: 15px; border-radius: 8px;">
                                <div style="font-size: 0.8rem; color: var(--text-secondary);">Batches</div>
                                <div style="font-size: 1.8rem; font-weight: 700; color: var(--accent-blue);">${empData.packaging.batches}</div>
                            </div>
                            <div style="background: var(--bg-primary); padding: 15px; border-radius: 8px;">
                                <div style="font-size: 0.8rem; color: var(--text-secondary);">Per Day Avg</div>
                                <div style="font-size: 1.8rem; font-weight: 700; color: var(--accent-green);">${(empData.packaging.units / daysActive).toFixed(0)}</div>
                            </div>
                        </div>
                        ${empData.packaging.timeMinutes > 0 ? `
                        <div style="margin-top: 15px; display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; text-align: center;">
                            <div style="background: linear-gradient(135deg, rgba(191, 0, 255, 0.2), rgba(191, 0, 255, 0.1)); padding: 15px; border-radius: 8px; border: 1px solid rgba(191, 0, 255, 0.3);">
                                <div style="font-size: 0.8rem; color: var(--text-secondary);">Time Worked</div>
                                <div style="font-size: 1.4rem; font-weight: 700; color: var(--accent-purple);">${Math.floor(empData.packaging.timeMinutes / 60)}h ${Math.round(empData.packaging.timeMinutes % 60)}m</div>
                            </div>
                            <div style="background: linear-gradient(135deg, rgba(57, 255, 20, 0.2), rgba(57, 255, 20, 0.1)); padding: 15px; border-radius: 8px; border: 1px solid rgba(57, 255, 20, 0.3);">
                                <div style="font-size: 0.8rem; color: var(--text-secondary);">Units/Hour</div>
                                <div style="font-size: 1.4rem; font-weight: 700; color: var(--accent-green);">${(empData.packaging.units / (empData.packaging.timeMinutes / 60)).toFixed(0)}</div>
                            </div>
                        </div>
                        ` : ''}
                        ${productBreakdown ? `<div style="margin-top: 15px; padding: 10px; background: var(--bg-primary); border-radius: 8px;"><div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 8px;">By Product Type:</div>${productBreakdown}</div>` : ''}
                        <div style="margin-top: 15px; padding: 10px; background: var(--bg-primary); border-radius: 8px; font-size: 0.9rem; color: var(--text-secondary);">
                            Target: ${targets.unitsPerDay || 800}/day x ${daysActive} days = ${unitsTarget.toLocaleString()} units
                        </div>
                    </div>
                `;
            }

            if (access.includes('labeling')) {
                // Uses combined units target from outer scope

                detailSections += `
                    <div style="background: var(--bg-tertiary); padding: 20px; border-radius: 12px; margin-bottom: 15px; border-left: 4px solid var(--accent-green);">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                            <h3 style="margin: 0; color: var(--accent-green); font-size: 1.2rem;">Labeling</h3>
                            <span style="font-size: 1.5rem; font-weight: 700; color: ${unitsColor};">${unitsPct}%</span>
                        </div>
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; text-align: center;">
                            <div style="background: var(--bg-primary); padding: 15px; border-radius: 8px;">
                                <div style="font-size: 0.8rem; color: var(--text-secondary);">Units Labeled</div>
                                <div style="font-size: 1.8rem; font-weight: 700; color: var(--accent-green);">${empData.labeling.units.toLocaleString()}</div>
                            </div>
                            <div style="background: var(--bg-primary); padding: 15px; border-radius: 8px;">
                                <div style="font-size: 0.8rem; color: var(--text-secondary);">Batches</div>
                                <div style="font-size: 1.8rem; font-weight: 700; color: var(--accent-blue);">${empData.labeling.batches}</div>
                            </div>
                            <div style="background: var(--bg-primary); padding: 15px; border-radius: 8px;">
                                <div style="font-size: 0.8rem; color: var(--text-secondary);">Per Day Avg</div>
                                <div style="font-size: 1.8rem; font-weight: 700; color: var(--accent-purple);">${(empData.labeling.units / daysActive).toFixed(0)}</div>
                            </div>
                        </div>
                        ${empData.labeling.timeMinutes > 0 ? `
                        <div style="margin-top: 15px; display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; text-align: center;">
                            <div style="background: linear-gradient(135deg, rgba(57, 255, 20, 0.2), rgba(57, 255, 20, 0.1)); padding: 15px; border-radius: 8px; border: 1px solid rgba(57, 255, 20, 0.3);">
                                <div style="font-size: 0.8rem; color: var(--text-secondary);">Time Worked</div>
                                <div style="font-size: 1.4rem; font-weight: 700; color: var(--accent-green);">${Math.floor(empData.labeling.timeMinutes / 60)}h ${Math.round(empData.labeling.timeMinutes % 60)}m</div>
                            </div>
                            <div style="background: linear-gradient(135deg, rgba(191, 0, 255, 0.2), rgba(191, 0, 255, 0.1)); padding: 15px; border-radius: 8px; border: 1px solid rgba(191, 0, 255, 0.3);">
                                <div style="font-size: 0.8rem; color: var(--text-secondary);">Units/Hour</div>
                                <div style="font-size: 1.4rem; font-weight: 700; color: var(--accent-purple);">${(empData.labeling.units / (empData.labeling.timeMinutes / 60)).toFixed(0)}</div>
                            </div>
                        </div>
                        ` : ''}
                        <div style="margin-top: 15px; padding: 10px; background: var(--bg-primary); border-radius: 8px; font-size: 0.9rem; color: var(--text-secondary);">
                            Target: ${targets.unitsPerDay || 800}/day x ${daysActive} days = ${unitsTarget.toLocaleString()} units
                        </div>
                    </div>
                `;
            }

            if (access.includes('finishing')) {
                detailSections += `
                    <div style="background: var(--bg-tertiary); padding: 20px; border-radius: 12px; margin-bottom: 15px; border-left: 4px solid var(--accent-blue);">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                            <h3 style="margin: 0; color: var(--accent-blue); font-size: 1.2rem;">Finishing</h3>
                        </div>
                        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; text-align: center;">
                            <div style="background: var(--bg-primary); padding: 15px; border-radius: 8px;">
                                <div style="font-size: 0.8rem; color: var(--text-secondary);">Batches Finished</div>
                                <div style="font-size: 1.8rem; font-weight: 700; color: var(--accent-blue);">${empData.finishing.batches}</div>
                            </div>
                            <div style="background: var(--bg-primary); padding: 15px; border-radius: 8px;">
                                <div style="font-size: 0.8rem; color: var(--text-secondary);">Days Active</div>
                                <div style="font-size: 1.8rem; font-weight: 700; color: var(--accent-green);">${daysActive}</div>
                            </div>
                        </div>
                    </div>
                `;
            }

            if (!detailSections) {
                detailSections = '<p style="text-align: center; color: var(--text-secondary); padding: 30px;">No tracked activities for this employee based on their access level.</p>';
            }

            // Create modal
            const modal = document.createElement('div');
            modal.id = 'employeeDetailModal';
            modal.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); z-index: 10001; display: flex; justify-content: center; align-items: flex-start; padding: 40px 20px; overflow-y: auto;';

            modal.innerHTML = `
                <div style="background: var(--bg-secondary); border-radius: 20px; max-width: 700px; width: 100%; max-height: 90vh; overflow-y: auto; position: relative;">
                    <div style="padding: 25px; border-bottom: 2px solid var(--border); display: flex; justify-content: space-between; align-items: center; position: sticky; top: 0; background: var(--bg-secondary); z-index: 10;">
                        <div>
                            <h2 style="margin: 0; font-size: 1.6rem;">${employeeName.replace(' (Admin)', '')}</h2>
                            <p style="margin: 5px 0 0 0; color: var(--text-secondary); font-size: 0.9rem;">Performance details for last ${timeRange} days</p>
                        </div>
                        <button onclick="document.getElementById('employeeDetailModal').remove()" style="background: rgba(255,255,255,0.2); border: none; color: white; font-size: 1.5rem; cursor: pointer; padding: 5px 12px; border-radius: 8px;">&times;</button>
                    </div>
                    <div style="padding: 25px;">
                        ${detailSections}
                    </div>
                </div>
            `;

            // Remove existing modal if any
            const existingModal = document.getElementById('employeeDetailModal');
            if (existingModal) existingModal.remove();

            document.body.appendChild(modal);

            // Close on backdrop click
            modal.addEventListener('click', function(e) {
                if (e.target === modal) {
                    modal.remove();
                }
            });
        }


                // Analytics filter buttons
        document.addEventListener('click', function(e) {
            if (e.target.classList.contains('filter-btn') && e.target.dataset.filterAnalytics) {
                document.querySelectorAll('[data-filter-analytics]').forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
                
                const filter = e.target.dataset.filterAnalytics;
                let filteredBatches = batches.filter(b => b.status === 'complete' && b.units_packaged);
                
                if (filter === 'thisMonth') {
                    const now = new Date();
                    const thisMonth = now.getMonth();
                    const thisYear = now.getFullYear();
                    filteredBatches = filteredBatches.filter(b => {
                        const date = new Date(b.completed_at);
                        return date.getMonth() === thisMonth && date.getFullYear() === thisYear;
                    });
                } else if (filter === 'lastMonth') {
                    const now = new Date();
                    const lastMonth = now.getMonth() === 0 ? 11 : now.getMonth() - 1;
                    const year = now.getMonth() === 0 ? now.getFullYear() - 1 : now.getFullYear();
                    filteredBatches = filteredBatches.filter(b => {
                        const date = new Date(b.completed_at);
                        return date.getMonth() === lastMonth && date.getFullYear() === year;
                    });
                }
                
                renderAnalyticsTable(filteredBatches);
            }
        });

        // Edit Batch Functions
        function openEditBatch(batchId) {
            const batch = batches.find(b => b.id === batchId);
            if (!batch) return;
            
            // Store original batch ID in hidden field
            document.getElementById('originalBatchId').value = batch.id;
            
            // Populate form
            document.getElementById('editBatchId').value = batch.id;
            document.getElementById('editBatchStatus').value = batch.status;
            document.getElementById('editStrainName').value = batch.strain;
            document.getElementById('editStrainType').value = batch.strain_type;
            document.getElementById('editTrimWeight').value = batch.trim_weight;
            document.getElementById('editSocksRemaining').value = batch.socks_remaining ?? batch.socks_total ?? '';
            document.getElementById('editBulkWeight').value = batch.final_weight || '';
            document.getElementById('editMaterialCost').value = batch.material_cost;
            document.getElementById('editCultivationLicense').value = batch.cultivation_license || '';
            document.getElementById('editGrowerName').value = batch.grower_name || '';
            document.getElementById('editMetrcTags').value = batch.metrc_tags || '';
            document.getElementById('editLabelsApplied').checked = batch.labels_applied || false;
            document.getElementById('editNotes').value = '';

            // Parse batch ID to extract info
            parseBatchIdForEdit(batch.id);
            
            // Show modal
            document.getElementById('editBatchModal').style.display = 'block';
        }

        // Parse batch ID to extract METRC last 4 and expiration date
        function parseBatchIdForEdit(batchId) {
            // Format: M.D.XXXX or MM.DD.XXXX
            const parts = batchId.split('.');
            
            if (parts.length === 3) {
                const month = parts[0];
                const day = parts[1];
                const last4 = parts[2];
                
                // Show parsed METRC last 4
                document.getElementById('parsedMetrcLast4').value = last4;
                
                // Calculate expiration date (use current/next year)
                const currentYear = new Date().getFullYear();
                const expMonth = parseInt(month, 10);
                const expDay = parseInt(day, 10);
                
                if (expMonth >= 1 && expMonth <= 12 && expDay >= 1 && expDay <= 31) {
                    // Create date - if it's in the past, use next year
                    let expDate = new Date(currentYear, expMonth - 1, expDay);
                    const today = new Date();
                    
                    if (expDate < today) {
                        expDate = new Date(currentYear + 1, expMonth - 1, expDay);
                    }
                    
                    document.getElementById('parsedExpirationDate').value = expDate.toISOString().split('T')[0];
                } else {
                    document.getElementById('parsedExpirationDate').value = '';
                }
            } else {
                // Invalid format
                document.getElementById('parsedMetrcLast4').value = '';
                document.getElementById('parsedExpirationDate').value = '';
            }
        }

        // Add event listener for batch ID changes
        document.getElementById('editBatchId').addEventListener('input', function() {
            parseBatchIdForEdit(this.value);
        });

        function closeEditBatch() {
            document.getElementById('editBatchModal').style.display = 'none';
        }

        async function saveEditedBatch() {
            const oldBatchId = document.getElementById('originalBatchId').value;
            const newBatchId = document.getElementById('editBatchId').value.trim();
            const batch = batches.find(b => b.id === oldBatchId);
            const editNotes = document.getElementById('editNotes').value;
            
            if (!batch) {
                alert('Error: Could not find batch to edit.');
                return;
            }
            
            if (!editNotes || editNotes.trim() === '') {
                alert('Please enter a note explaining why you\'re making this change.');
                return;
            }
            
            // Check if batch ID changed
            const batchIdChanged = oldBatchId !== newBatchId;
            
            if (batchIdChanged) {
                // Verify new batch ID doesn't already exist
                const existingBatch = batches.find(b => b.id === newBatchId);
                if (existingBatch && existingBatch.id !== oldBatchId) {
                    alert(`Error: Batch ID "${newBatchId}" already exists. Please choose a different ID.`);
                    return;
                }
                
                const confirmChange = confirm(
                    `âš ï¸ BATCH ID CHANGE\n\n` +
                    `Old ID: ${oldBatchId}\n` +
                    `New ID: ${newBatchId}\n\n` +
                    `This will update the batch ID and recalculate expiration date.\n\n` +
                    `Continue?`
                );
                
                if (!confirmChange) return;
            }
            
            // Collect updated values
            const bulkWeight = document.getElementById('editBulkWeight').value;
            const parsedBulkWeight = bulkWeight ? parseFloat(bulkWeight) : null;
            const socksRemainingVal = document.getElementById('editSocksRemaining').value;
            const updates = {
                status: document.getElementById('editBatchStatus').value,
                strain: document.getElementById('editStrainName').value,
                strain_type: document.getElementById('editStrainType').value,
                trim_weight: parseFloat(document.getElementById('editTrimWeight').value),
                socks_remaining: socksRemainingVal !== '' ? parseInt(socksRemainingVal) : null,
                final_weight: parsedBulkWeight,
                net_weight: parsedBulkWeight, // Keep net_weight in sync with final_weight
                material_cost: parseFloat(document.getElementById('editMaterialCost').value),
                cultivation_license: document.getElementById('editCultivationLicense').value,
                grower_name: document.getElementById('editGrowerName').value,
                metrc_tags: document.getElementById('editMetrcTags').value || null,
                labels_applied: document.getElementById('editLabelsApplied').checked
            };
            
            // If expiration date was parsed, update it
            const parsedExpDate = document.getElementById('parsedExpirationDate').value;
            if (parsedExpDate) {
                updates.test_expiration_date = parsedExpDate;
            }
            
            // Add edit to timeline
            const timeline = batch.timeline || [];
            const batchIdNote = batchIdChanged ? ` | Batch ID changed: ${oldBatchId} â†’ ${newBatchId}` : '';
            timeline.push({
                stage: 'edit',
                timestamp: new Date().toISOString(),
                user: currentRole.name,
                action: `Edited batch - ${editNotes}${batchIdNote}`
            });
            updates.timeline = timeline;
            
            // Handle batch ID change
            if (batchIdChanged) {
                // Create new batch with new ID
                const { error: insertError } = await supabaseClient
                    .from('wm_batches')
                    .insert({
                        ...batch,
                        ...updates,
                        id: newBatchId
                    });
                
                if (insertError) {
                    console.error('Error creating new batch:', insertError);
                    alert('Error updating batch ID. Please try again.');
                    return;
                }
                
                // Delete old batch
                const { error: deleteError } = await supabaseClient
                    .from('wm_batches')
                    .delete()
                    .eq('id', oldBatchId);
                
                if (deleteError) {
                    console.error('Error deleting old batch:', deleteError);
                    alert('Warning: New batch created but old batch could not be removed.');
                }
            } else {
                // Normal update
                const { error } = await supabaseClient
                    .from('wm_batches')
                    .update(updates)
                    .eq('id', oldBatchId);
                
                if (error) {
                    console.error('Error updating batch:', error);
                    alert('Error saving changes. Please try again.');
                    return;
                }
            }
            
            const finalBatchId = batchIdChanged ? newBatchId : oldBatchId;
            alert(`Batch ${finalBatchId} updated successfully!${batchIdChanged ? '\nâœ“ Batch ID changed and expiration date updated' : ''}`);
            closeEditBatch();
            await loadBatches();
            renderBatches();
        }

        // Close modal when clicking outside
        document.getElementById('editBatchModal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeEditBatch();
            }
        });

        // ==============================================
        // CREATE SUB-BATCH FUNCTIONS
        // ==============================================

        function openCreateSubBatch(batchId) {
            const batch = batches.find(b => b.id === batchId);

            if (!batch) {
                alert('Batch not found: ' + batchId);
                return;
            }
            
            // Store parent batch ID
            document.getElementById('subBatchParentId').value = batchId;
            
            // Generate next available sub-batch ID
            const existingSubBatches = batches.filter(b => b.parent_batch_id === batchId || b.id.startsWith(batchId + '-'));
            
            const subBatchLetters = existingSubBatches.map(b => {
                const match = b.id.match(/-([A-Z]|SIFT)$/);
                return match ? match[1] : null;
            }).filter(l => l && l !== 'SIFT');
            
            let nextLetter = 'A';
            if (subBatchLetters.length > 0) {
                const lastLetter = subBatchLetters.sort().pop();
                nextLetter = String.fromCharCode(lastLetter.charCodeAt(0) + 1);
            }
            
            const newSubBatchId = `${batchId}-${nextLetter}`;
            document.getElementById('newSubBatchId').value = newSubBatchId;
            
            // Show parent batch info
            const parentInfo = `
                <p><strong>Batch ID:</strong> ${batch.id}</p>
                <p><strong>Product:</strong> ${batch.strain} (${batch.strain_type})</p>
                <p><strong>Product Made:</strong> ${batch.product_made || 'N/A'}</p>
                <p><strong>Final Weight:</strong> ${batch.final_weight || batch.net_weight || 'N/A'}g</p>
                <p><strong>Status:</strong> ${batch.status}</p>
                ${existingSubBatches.length > 0 ? `<p style="color: var(--accent-orange);"><strong>Existing Sub-Batches:</strong> ${existingSubBatches.map(b => b.id).join(', ')}</p>` : ''}
            `;
            document.getElementById('subBatchParentDetails').innerHTML = parentInfo;
            
            // Clear form
            document.getElementById('subBatchProductType').value = '';
            document.getElementById('subBatchNotes').value = '';
            
            // Show modal
            const modal = document.getElementById('createSubBatchModal');
            if (modal) {
                // Force hide first to ensure clean state
                modal.style.display = 'none';
                // Force browser repaint
                modal.offsetHeight;
                // Now show it
                modal.style.display = 'block';
                modal.style.visibility = 'visible';
                modal.style.opacity = '1';

                // Scroll to top in case modal is below fold
                window.scrollTo(0, 0);
            } else {
                console.error('Modal element not found!');
                alert('Error: Modal not found in DOM');
            }
        }

        function closeCreateSubBatch() {
            document.getElementById('createSubBatchModal').style.display = 'none';
        }

        async function saveSubBatch() {
            if (!currentRole) {
                alert('Please login first!');
                return;
            }
            
            const parentBatchId = document.getElementById('subBatchParentId').value;
            const parentBatch = batches.find(b => b.id === parentBatchId);
            
            if (!parentBatch) {
                alert('Parent batch not found');
                return;
            }
            
            const newSubBatchId = document.getElementById('newSubBatchId').value;
            const productType = document.getElementById('subBatchProductType').value;
            const notes = document.getElementById('subBatchNotes').value;
            
            if (!productType) {
                alert('Please select a product type');
                return;
            }
            
            if (!notes.trim()) {
                alert('Please enter a reason for creating this retroactive sub-batch');
                return;
            }
            
            // Calculate proportional trim used from parent
            const parentTrimWeight = parseFloat(parentBatch.adjusted_trim_weight || parentBatch.trim_weight || 0);
            
            // Get all existing sub-batches BEFORE creating new one
            const existingSubBatches = batches.filter(b => 
                (b.parent_batch_id === parentBatchId || b.id.startsWith(parentBatchId + '-')) && 
                b.id !== parentBatchId
            );
            
            // For now, allocate equal trim across all sub-batches (will be recalculated when weights are entered)
            const numSubBatches = existingSubBatches.length + 1; // Including new one
            const trimUsed = parentTrimWeight / numSubBatches;
            
            // Set status to 'extraction' so it must go through post-processing (finishing)
            // This ensures the post-processor completes it properly
            const newStatus = 'extraction';
            
            // Create sub-batch
            const subBatch = {
                id: newSubBatchId,
                strain: parentBatch.strain,
                strain_type: parentBatch.strain_type,
                trim_weight: trimUsed,
                material_cost: 0,
                material_agreement: parentBatch.material_agreement,
                pre_sift: 'no',
                cultivation_license: parentBatch.cultivation_license,
                grower_name: parentBatch.grower_name,
                metrc_tags: parentBatch.metrc_tags,
                intake_date: parentBatch.intake_date,
                planned_products: [productType],
                intake_notes: `Retroactive sub-batch created from ${parentBatchId}. ${notes}`,
                status: newStatus,
                intake_user: parentBatch.intake_user,
                
                // Mark as sub-batch
                is_sub_batch: true,
                parent_batch_id: parentBatchId,
                
                // Set extraction data (completed by extractor)
                extraction_date: parentBatch.extraction_date || new Date().toISOString().split('T')[0],
                extraction_method: parentBatch.extraction_method,
                product_made: productType,
                extraction_notes: `Retroactive sub-batch of ${parentBatchId} - needs post-processing`,
                extraction_user: parentBatch.extraction_user || currentRole.name,
                
                // NO finishing data yet - post-processor must complete this
                finishing_date: null,
                final_weight: null,
                sample_weight: null,
                net_weight: null,
                finishing_notes: `Retroactive sub-batch - awaiting post-processing`,
                finishing_user: null,
                
                timeline: [
                    {
                        stage: 'intake',
                        timestamp: parentBatch.intake_date,
                        user: parentBatch.intake_user,
                        action: 'Batch created (parent)'
                    },
                    {
                        stage: 'extraction',
                        timestamp: parentBatch.extraction_date || new Date().toISOString(),
                        user: parentBatch.extraction_user || currentRole.name,
                        action: `Extracted as ${productType} - retroactive sub-batch created by ${currentRole.name}`
                    }
                ],
                created_at: new Date().toISOString()
            };

            // Insert sub-batch
            const { error: insertError } = await supabaseClient
                .from('wm_batches')
                .insert([subBatch]);
            
            if (insertError) {
                console.error('Error creating sub-batch:', insertError);
                alert(`Error creating sub-batch: ${insertError.message}`);
                return;
            }
            
            // Update parent batch timeline
            const parentTimeline = parentBatch.timeline || [];
            parentTimeline.push({
                stage: 'admin',
                timestamp: new Date().toISOString(),
                user: currentRole.name,
                action: `Retroactive sub-batch created: ${newSubBatchId} (${productType}) - needs post-processing`
            });
            
            await supabaseClient
                .from('wm_batches')
                .update({ timeline: parentTimeline })
                .eq('id', parentBatchId);
            
            alert(`âœ… Sub-batch ${newSubBatchId} created successfully!\n\nProduct: ${productType}\nStatus: extraction\n\nâš™ï¸ NEXT STEP:\nPost-processor must complete this batch on the "Post Extraction" page to:\nâ€¢ Enter final bulk weight\nâ€¢ Enter sample weight\nâ€¢ Complete finishing\n\nYields will be recalculated when weights are entered.`);
            
            closeCreateSubBatch();
            await loadBatches();
            renderBatches();
            
            // Refresh finishing select
            populateFinishingSelect();
        }

        // Close modal when clicking outside
        document.getElementById('createSubBatchModal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeCreateSubBatch();
            }
        });

        async function deleteSubBatch(subBatchId) {
            if (!currentRole || !currentRole.canEditBatches) {
                alert('You do not have permission to delete sub-batches');
                return;
            }
            
            const subBatch = batches.find(b => b.id === subBatchId);
            if (!subBatch) {
                alert('Sub-batch not found');
                return;
            }
            
            if (!subBatch.is_sub_batch) {
                alert('This is not a sub-batch. Only sub-batches can be deleted this way.');
                return;
            }
            
            const parentBatchId = subBatch.parent_batch_id;
            const parentBatch = batches.find(b => b.id === parentBatchId);
            
            const confirmation = confirm(
                `âš ï¸ DELETE SUB-BATCH?\n\n` +
                `Sub-Batch: ${subBatchId}\n` +
                `Product: ${subBatch.product_made || 'N/A'}\n` +
                `Weight: ${subBatch.final_weight || subBatch.net_weight || 'N/A'}g\n\n` +
                `This will:\n` +
                `â€¢ Delete this sub-batch permanently\n` +
                `â€¢ Recalculate yields for remaining sub-batches\n` +
                `â€¢ Update parent batch timeline\n\n` +
                `This action CANNOT be undone!\n\n` +
                `Type YES to confirm deletion.`
            );
            
            if (!confirmation) return;
            
            const userConfirmation = prompt('Type YES in capital letters to confirm deletion:');
            if (userConfirmation !== 'YES') {
                alert('Deletion cancelled.');
                return;
            }
            
            // Delete the sub-batch
            const { error: deleteError } = await supabaseClient
                .from('wm_batches')
                .delete()
                .eq('id', subBatchId);
            
            if (deleteError) {
                console.error('Error deleting sub-batch:', deleteError);
                alert(`Error deleting sub-batch: ${deleteError.message}`);
                return;
            }
            
            // Recalculate remaining sub-batches if parent exists and has other sub-batches
            if (parentBatch) {
                const remainingSubBatches = batches.filter(b => 
                    b.parent_batch_id === parentBatchId && 
                    b.id !== subBatchId &&
                    b.final_weight // Only completed sub-batches
                );
                
                if (remainingSubBatches.length > 0) {
                    const parentTrimWeight = parseFloat(parentBatch.adjusted_trim_weight || parentBatch.trim_weight || 0);
                    const totalRemainingWeight = remainingSubBatches.reduce((sum, b) => 
                        sum + parseFloat(b.final_weight || b.net_weight || 0), 0
                    );
                    
                    // Recalculate trim for each remaining sub-batch
                    for (const sub of remainingSubBatches) {
                        const subWeight = parseFloat(sub.final_weight || sub.net_weight || 0);
                        const recalculatedTrim = (subWeight / totalRemainingWeight) * parentTrimWeight;
                        
                        await supabaseClient
                            .from('wm_batches')
                            .update({ trim_weight: recalculatedTrim })
                            .eq('id', sub.id);
                    }
                }
                
                // Update parent timeline
                const parentTimeline = parentBatch.timeline || [];
                parentTimeline.push({
                    stage: 'admin',
                    timestamp: new Date().toISOString(),
                    user: currentRole.name,
                    action: `Sub-batch ${subBatchId} deleted. Yields recalculated for remaining sub-batches.`
                });
                
                await supabaseClient
                    .from('wm_batches')
                    .update({ timeline: parentTimeline })
                    .eq('id', parentBatchId);
                
                const resultMessage = remainingSubBatches.length > 0 
                    ? 'âœ“ Remaining sub-batch yields recalculated' 
                    : 'âœ“ This was the last sub-batch';
                alert(`âœ… Sub-batch ${subBatchId} deleted successfully!\n\n${resultMessage}`);
            } else {
                alert(`âœ… Sub-batch ${subBatchId} deleted successfully!`);
            }
            
            await loadBatches();
            renderBatches();
            
            // Refresh all selects
            
            populateFinishingSelect();
            populatePackagingSelect();
            populateTestingSelect();
        }

        // ==============================================
        // METRC INTEGRATION FUNCTIONS
        // ==============================================

        let metrcManifests = [];
        let selectedManifest = null;
        let selectedTags = [];

        // Load METRC config from localStorage
        function loadMetrcConfig() {
            const integratorKey = localStorage.getItem('metrcIntegratorKey');
            const userKey = localStorage.getItem('metrcUserKey');
            const licenseNumber = localStorage.getItem('metrcLicenseNumber') || '404R-00016';
            
            if (integratorKey) {
                document.getElementById('metrcIntegratorKey').value = integratorKey;
            }
            if (userKey) {
                document.getElementById('metrcUserKey').value = userKey;
            }
            document.getElementById('metrcLicenseNumber').value = licenseNumber;
            
            if (integratorKey && userKey) {
                updateMetrcConfigStatus(true);
            } else {
                updateMetrcConfigStatus(false);
            }
        }

        function updateMetrcConfigStatus(configured) {
            const statusEl = document.getElementById('metrcConfigStatus');
            if (configured) {
                statusEl.style.background = 'rgba(16, 185, 129, 0.2)';
                statusEl.style.color = 'var(--accent-green)';
                statusEl.style.border = '2px solid var(--accent-green)';
                statusEl.textContent = 'âœ“ Configured';
            } else {
                statusEl.style.background = 'rgba(239, 68, 68, 0.2)';
                statusEl.style.color = 'var(--accent-red)';
                statusEl.style.border = '2px solid var(--accent-red)';
                statusEl.textContent = 'âš  Not Configured';
            }
        }

        function saveMetrcConfig() {
            const integratorKey = document.getElementById('metrcIntegratorKey').value.trim();
            const userKey = document.getElementById('metrcUserKey').value.trim();
            const licenseNumber = document.getElementById('metrcLicenseNumber').value.trim();
            
            if (!integratorKey || !userKey || !licenseNumber) {
                alert('Please enter both Integrator Key and User API Key');
                return;
            }
            
            localStorage.setItem('metrcIntegratorKey', integratorKey);
            localStorage.setItem('metrcUserKey', userKey);
            localStorage.setItem('metrcLicenseNumber', licenseNumber);
            
            updateMetrcConfigStatus(true);
            alert('METRC credentials saved successfully!\n\nClick "Test Connection" to verify they work.');
        }

        async function testMetrcConnection() {
            const integratorKey = localStorage.getItem('metrcIntegratorKey');
            const userKey = localStorage.getItem('metrcUserKey');
            const licenseNumber = localStorage.getItem('metrcLicenseNumber');
            
            if (!integratorKey || !userKey || !licenseNumber) {
                showTestResult('error', 'Please save your credentials first.');
                return;
            }

            showTestResult('testing', 'Testing connection to METRC API...');

            try {
                // Try to get facilities as a simple test
                const url = `https://api-co.metrc.com/facilities/v1/`;
                
                // METRC requires: integratorKey:userKey
                const authString = `${integratorKey}:${userKey}`;
                
                const response = await fetch(url, {
                    method: 'GET',
                    headers: {
                        'Authorization': `Basic ${btoa(authString)}`,
                        'Content-Type': 'application/json'
                    },
                    mode: 'cors'
                });

                if (response.ok) {
                    const data = await response.json();
                    showTestResult('success', `âœ… Connection successful!\n\nFound ${data.length} facilities in your account.\n\nAuthentication format is correct.\nYou can try loading manifests (may still face CORS).`);
                } else {
                    let errorDetails = '';
                    try {
                        const errorData = await response.json();
                        errorDetails = errorData.Message || JSON.stringify(errorData);
                    } catch (e) {
                        errorDetails = await response.text();
                    }

                    showTestResult('error', `âŒ METRC returned ${response.status}\n\n${errorDetails}\n\nTroubleshooting:\nâ€¢ Verify Integrator Key is from METRC Connect\nâ€¢ Verify User API Key from Settings â†’ Integrations â†’ User API Keys\nâ€¢ Check if user has permissions for license 404R-00016\nâ€¢ Try Manual Entry instead`);
                }
            } catch (error) {
                if (error.message.includes('Failed to fetch') || error.name === 'TypeError') {
                    showTestResult('error', `ðŸš« Browser blocked the request (CORS)\n\nThis is expected - browsers block METRC API calls for security.\n\nSolutions:\n1. âœ… Use Manual Entry tab (recommended)\n2. Set up a server proxy for API calls\n3. Use METRC web interface and copy data`);
                } else {
                    showTestResult('error', `âŒ Connection failed:\n\n${error.message}`);
                }
            }
        }

        function showTestResult(type, message) {
            const resultEl = document.getElementById('metrcTestResult');
            resultEl.style.display = 'block';
            resultEl.style.padding = '15px';
            resultEl.style.borderRadius = '10px';
            resultEl.style.marginTop = '15px';
            resultEl.style.whiteSpace = 'pre-line';

            if (type === 'success') {
                resultEl.style.background = 'rgba(16, 185, 129, 0.2)';
                resultEl.style.border = '2px solid var(--accent-green)';
                resultEl.style.color = 'var(--accent-green)';
            } else if (type === 'error') {
                resultEl.style.background = 'rgba(239, 68, 68, 0.2)';
                resultEl.style.border = '2px solid var(--accent-red)';
                resultEl.style.color = 'var(--accent-red)';
            } else if (type === 'testing') {
                resultEl.style.background = 'rgba(245, 158, 11, 0.2)';
                resultEl.style.border = '2px solid var(--accent-orange)';
                resultEl.style.color = 'var(--accent-orange)';
            }

            resultEl.textContent = message;
        }

        function openMetrcImport() {
            document.getElementById('metrcImportModal').style.display = 'block';
            loadMetrcConfig();
            
            // Set default dates (last 7 days)
            const endDate = new Date();
            const startDate = new Date();
            startDate.setDate(startDate.getDate() - 7);
            
            document.getElementById('metrcStartDate').value = startDate.toISOString().split('T')[0];
            document.getElementById('metrcEndDate').value = endDate.toISOString().split('T')[0];
            
            // Default to manual entry tab (more reliable)
            switchMetrcTab('manual');
        }

        function closeMetrcImport() {
            document.getElementById('metrcImportModal').style.display = 'none';
            clearManifestSelection();
        }

        async function loadMetrcManifests() {
            const integratorKey = localStorage.getItem('metrcIntegratorKey');
            const userKey = localStorage.getItem('metrcUserKey');
            const licenseNumber = localStorage.getItem('metrcLicenseNumber');
            
            if (!integratorKey || !userKey || !licenseNumber) {
                showMetrcError('Please configure your METRC API credentials first (both Integrator and User keys required).');
                return;
            }
            
            const startDate = document.getElementById('metrcStartDate').value;
            const endDate = document.getElementById('metrcEndDate').value;
            
            if (!startDate || !endDate) {
                showMetrcError('Please select both start and end dates.');
                return;
            }
            
            // Show loading
            document.getElementById('metrcLoadingIndicator').style.display = 'block';
            document.getElementById('metrcManifestsList').style.display = 'none';
            document.getElementById('metrcError').style.display = 'none';
            
            try {
                // METRC API endpoint for incoming transfers
                const url = `https://api-co.metrc.com/transfers/v1/incoming?licenseNumber=${licenseNumber}&lastModifiedStart=${startDate}&lastModifiedEnd=${endDate}`;
                
                // METRC requires: integratorKey:userKey
                const authString = `${integratorKey}:${userKey}`;
                
                const response = await fetch(url, {
                    method: 'GET',
                    headers: {
                        'Authorization': `Basic ${btoa(authString)}`,
                        'Content-Type': 'application/json'
                    },
                    mode: 'cors'
                });
                
                if (!response.ok) {
                    let errorMsg = `METRC API returned ${response.status}`;
                    
                    if (response.status === 401) {
                        errorMsg = `Authentication failed (401).\n\nTroubleshooting:\nâ€¢ Verify your Integrator Key is from METRC Connect\nâ€¢ Verify your User API Key from Settings â†’ Integrations â†’ User API Keys\nâ€¢ Format must be integratorKey:userKey (done automatically)\nâ€¢ Check that user has permissions for license 404R-00016\nâ€¢ User must have access to view incoming transfers`;
                    } else if (response.status === 403) {
                        errorMsg = `Access forbidden (403).\n\nThe user may not have permission to access transfers for this license.`;
                    } else if (response.status === 404) {
                        errorMsg = `Endpoint not found (404).\n\nThe license number may be incorrect.`;
                    }
                    
                    // Try to get more details from response
                    try {
                        const errorData = await response.json();
                        if (errorData.Message) {
                            errorMsg += `\n\nMETRC says: ${errorData.Message}`;
                        }
                    } catch (e) {
                        // Response wasn't JSON
                    }
                    
                    throw new Error(errorMsg);
                }
                
                const data = await response.json();
                metrcManifests = data;
                
                if (metrcManifests.length === 0) {
                    showMetrcError('No incoming transfers found for the selected date range.');
                    return;
                }
                
                displayManifests();
                
            } catch (error) {
                console.error('METRC API Error:', error);
                
                // Check if it's a CORS error
                if (error.message.includes('CORS') || error.message.includes('Failed to fetch')) {
                    showMetrcError(`âš ï¸ Browser Security Block Detected\n\nDirect API calls from browsers are often blocked by CORS.\n\nOptions:\n1. Use METRC's web interface to export manifests\n2. Set up a server-side proxy (recommended for production)\n3. Use a browser extension to disable CORS (development only)\n\nOriginal error: ${error.message}`);
                } else {
                    showMetrcError(error.message);
                }
            } finally {
                document.getElementById('metrcLoadingIndicator').style.display = 'none';
            }
        }

        function showMetrcError(message) {
            const errorEl = document.getElementById('metrcError');
            errorEl.textContent = message;
            errorEl.style.display = 'block';
        }

        function displayManifests() {
            const container = document.getElementById('manifestsContainer');
            
            container.innerHTML = metrcManifests.map((manifest, index) => {
                const manifestDate = new Date(manifest.ReceivedDateTime || manifest.CreatedDate).toLocaleDateString();
                const packageCount = manifest.Deliveries ? manifest.Deliveries.reduce((sum, d) => sum + (d.Packages?.length || 0), 0) : 0;
                
                return `
                    <div onclick="selectManifest(${index})" style="background: var(--bg-tertiary); padding: 20px; border-radius: 12px; margin-bottom: 15px; cursor: pointer; border: 2px solid var(--border); transition: all 0.3s ease;">
                        <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 10px;">
                            <div>
                                <div style="font-size: 1.2rem; font-weight: 700; color: var(--accent-purple); font-family: 'Space Mono', monospace; margin-bottom: 5px;">
                                    Manifest #${manifest.ManifestNumber || manifest.Id}
                                </div>
                                <div style="color: var(--text-secondary); font-size: 0.9rem;">
                                    ${manifestDate} â€¢ ${packageCount} packages
                                </div>
                            </div>
                            <div style="background: rgba(147, 51, 234, 0.2); color: var(--accent-purple); padding: 6px 12px; border-radius: 15px; font-size: 0.85rem; font-weight: 600;">
                                Click to View
                            </div>
                        </div>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--border);">
                            <div>
                                <div style="color: var(--text-secondary); font-size: 0.8rem;">Shipper</div>
                                <div style="font-weight: 600; font-size: 0.95rem;">${manifest.ShipperFacilityName || 'N/A'}</div>
                            </div>
                            <div>
                                <div style="color: var(--text-secondary); font-size: 0.8rem;">Shipper License</div>
                                <div style="font-weight: 600; font-size: 0.95rem; font-family: 'Space Mono', monospace;">${manifest.ShipperFacilityLicenseNumber || 'N/A'}</div>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
            
            document.getElementById('metrcManifestsList').style.display = 'block';
            document.getElementById('metrcError').style.display = 'none';
        }

        function selectManifest(index) {
            selectedManifest = metrcManifests[index];
            selectedTags = [];
            
            // Display manifest details
            const manifestInfo = document.getElementById('manifestInfo');
            const manifestDate = new Date(selectedManifest.ReceivedDateTime || selectedManifest.CreatedDate);
            
            manifestInfo.innerHTML = `
                <div>
                    <div style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 5px;">Manifest Number</div>
                    <div style="font-family: 'Space Mono', monospace; font-size: 1.1rem; font-weight: 700;">${selectedManifest.ManifestNumber || selectedManifest.Id}</div>
                </div>
                <div>
                    <div style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 5px;">Received Date</div>
                    <div style="font-weight: 600;">${manifestDate.toLocaleDateString()} ${manifestDate.toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'})}</div>
                </div>
                <div>
                    <div style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 5px;">Shipper Name</div>
                    <div style="font-weight: 600;">${selectedManifest.ShipperFacilityName || 'N/A'}</div>
                </div>
                <div>
                    <div style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 5px;">Shipper License (403R)</div>
                    <div style="font-family: 'Space Mono', monospace; font-weight: 700; color: var(--accent-blue);">${selectedManifest.ShipperFacilityLicenseNumber || 'N/A'}</div>
                </div>
            `;
            
            // Display packages/tags
            displayManifestTags();
            
            // Show details section, hide manifests list
            document.getElementById('metrcManifestsList').style.display = 'none';
            document.getElementById('manifestDetailsSection').style.display = 'block';
        }

        function displayManifestTags() {
            const container = document.getElementById('tagsContainer');
            
            // Extract all packages from all deliveries
            let allPackages = [];
            if (selectedManifest.Deliveries) {
                selectedManifest.Deliveries.forEach(delivery => {
                    if (delivery.Packages) {
                        allPackages = allPackages.concat(delivery.Packages);
                    }
                });
            }
            
            // Filter for trim/shake packages only
            const trimPackages = allPackages.filter(pkg => {
                const productName = (pkg.ProductName || '').toLowerCase();
                const productCategory = (pkg.ProductCategoryName || '').toLowerCase();
                return productName.includes('trim') || productName.includes('shake') || 
                       productCategory.includes('trim') || productCategory.includes('shake');
            });
            
            if (trimPackages.length === 0) {
                container.innerHTML = '<div style="color: var(--text-secondary); font-style: italic; padding: 20px; text-align: center;">No trim or shake packages found in this manifest.</div>';
                return;
            }
            
            container.innerHTML = trimPackages.map((pkg, index) => {
                const tagNumber = pkg.PackageLabel || pkg.Label || 'N/A';
                const shortTag = tagNumber.length > 10 ? tagNumber.slice(-5) : tagNumber;
                const weight = parseFloat(pkg.Quantity || pkg.ShippedQuantity || 0);
                const unitWeight = pkg.UnitOfMeasureName || 'Grams';
                const strain = pkg.ProductName || 'Unknown Strain';
                
                return `
                    <label style="background: var(--bg-primary); padding: 20px; border-radius: 12px; border: 2px solid var(--border); cursor: pointer; transition: all 0.3s ease; display: flex; align-items: center; gap: 15px;" 
                           onmouseover="this.style.borderColor='var(--accent-purple)'" 
                           onmouseout="this.style.borderColor=document.getElementById('tagCheck${index}').checked ? 'var(--accent-purple)' : 'var(--border)'">
                        <input type="checkbox" id="tagCheck${index}" 
                               onchange="toggleTag(${index}, '${tagNumber}', ${weight}, '${strain}')"
                               style="width: 20px; height: 20px; cursor: pointer;">
                        <div style="flex: 1;">
                            <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 8px;">
                                <div>
                                    <div style="font-family: 'Space Mono', monospace; font-size: 1.1rem; font-weight: 700; color: var(--accent-purple);">
                                        Tag: ...${shortTag}
                                    </div>
                                    <div style="color: var(--text-secondary); font-size: 0.85rem; margin-top: 3px;">${tagNumber}</div>
                                </div>
                                <div style="text-align: right;">
                                    <div style="font-size: 1.5rem; font-weight: 700; color: var(--accent-green);">${weight.toFixed(1)}</div>
                                    <div style="color: var(--text-secondary); font-size: 0.85rem;">${unitWeight}</div>
                                </div>
                            </div>
                            <div style="color: var(--text-secondary); font-size: 0.9rem;">
                                <strong>Product:</strong> ${strain}
                            </div>
                        </div>
                    </label>
                `;
            }).join('');
            
            updateSelectedSummary();
        }

        function toggleTag(index, tagNumber, weight, strain) {
            const checkbox = document.getElementById(`tagCheck${index}`);
            
            if (checkbox.checked) {
                selectedTags.push({ tagNumber, weight, strain });
            } else {
                selectedTags = selectedTags.filter(t => t.tagNumber !== tagNumber);
            }
            
            updateSelectedSummary();
        }

        function updateSelectedSummary() {
            const summary = document.getElementById('selectedTagsSummary');
            
            if (selectedTags.length === 0) {
                summary.innerHTML = '<div style="color: var(--text-secondary); font-style: italic;">No tags selected. Select tags above to continue.</div>';
                return;
            }
            
            const totalWeight = selectedTags.reduce((sum, tag) => sum + tag.weight, 0);
            const uniqueStrains = [...new Set(selectedTags.map(t => t.strain))];
            
            summary.innerHTML = `
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-bottom: 20px;">
                    <div style="background: var(--bg-primary); padding: 15px; border-radius: 10px; text-align: center;">
                        <div style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 5px;">Tags Selected</div>
                        <div style="font-size: 2rem; font-weight: 700; color: var(--accent-purple);">${selectedTags.length}</div>
                    </div>
                    <div style="background: var(--bg-primary); padding: 15px; border-radius: 10px; text-align: center;">
                        <div style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 5px;">Total Weight</div>
                        <div style="font-size: 2rem; font-weight: 700; color: var(--accent-green);">${totalWeight.toFixed(1)}g</div>
                    </div>
                    <div style="background: var(--bg-primary); padding: 15px; border-radius: 10px; text-align: center;">
                        <div style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 5px;">Unique Strains</div>
                        <div style="font-size: 2rem; font-weight: 700; color: var(--accent-blue);">${uniqueStrains.length}</div>
                    </div>
                </div>
                <div style="background: var(--bg-primary); padding: 15px; border-radius: 10px;">
                    <div style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 10px;">Selected Tags:</div>
                    ${selectedTags.map(tag => `
                        <div style="display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid var(--border);">
                            <span style="font-family: 'Space Mono', monospace; font-size: 0.9rem;">...${tag.tagNumber.slice(-5)}</span>
                            <span style="font-weight: 600; color: var(--accent-green);">${tag.weight.toFixed(1)}g</span>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        function clearManifestSelection() {
            selectedManifest = null;
            selectedTags = [];
            document.getElementById('manifestDetailsSection').style.display = 'none';
            if (metrcManifests.length > 0) {
                document.getElementById('metrcManifestsList').style.display = 'block';
            }
        }

        function importManifestToBatch() {
            if (selectedTags.length === 0) {
                alert('Please select at least one tag to import.');
                return;
            }
            
            const totalWeight = selectedTags.reduce((sum, tag) => sum + tag.weight, 0);
            const uniqueStrains = [...new Set(selectedTags.map(t => t.strain))];
            const tagNumbers = selectedTags.map(t => t.tagNumber.slice(-5)).join(', ');
            
            // Determine strain name
            let strainName = uniqueStrains.length === 1 ? uniqueStrains[0] : 'Mixed Strains';
            
            // Pre-fill the intake form
            document.getElementById('trimWeight').value = totalWeight.toFixed(1);
            document.getElementById('cultivationLicense').value = selectedManifest.ShipperFacilityLicenseNumber || '';
            document.getElementById('growerName').value = selectedManifest.ShipperFacilityName || '';
            document.getElementById('metrcTags').value = tagNumbers;
            document.getElementById('strainName').value = strainName;
            document.getElementById('intakeDate').value = new Date(selectedManifest.ReceivedDateTime || selectedManifest.CreatedDate).toISOString().split('T')[0];
            
            // Close modal and switch to intake tab
            closeMetrcImport();
            
            // Switch to intake tab
            document.querySelectorAll('.station-tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.station-content').forEach(content => content.classList.remove('active'));
            document.querySelector('[data-station="intake"]').classList.add('active');
            document.getElementById('intake').classList.add('active');
            
            alert(`âœ… Imported ${selectedTags.length} tags (${totalWeight.toFixed(1)}g total)\n\nPlease review and complete the intake form.`);
        }

        // Close METRC modal when clicking outside
        document.getElementById('metrcImportModal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeMetrcImport();
            }
        });

        // Tab switching for METRC modal
        function switchMetrcTab(tab) {
            // Update tab buttons
            document.querySelectorAll('.metrc-tab-btn').forEach(btn => {
                if (btn.dataset.tab === tab) {
                    btn.style.borderBottom = '3px solid var(--accent-purple)';
                    btn.style.color = 'var(--accent-purple)';
                    btn.classList.add('active');
                } else {
                    btn.style.borderBottom = '3px solid transparent';
                    btn.style.color = 'var(--text-secondary)';
                    btn.classList.remove('active');
                }
            });

            // Show/hide sections
            if (tab === 'api') {
                document.getElementById('metrcLoadSection').style.display = 'block';
                document.getElementById('metrcManualSection').style.display = 'none';
            } else {
                document.getElementById('metrcLoadSection').style.display = 'none';
                document.getElementById('metrcManualSection').style.display = 'block';
                updateManualSummary();
            }
        }

        // Manual package entry
        function addManualPackageRow() {
            const container = document.getElementById('manualPackagesContainer');
            const newRow = document.createElement('div');
            newRow.className = 'manual-package-row';
            newRow.style.cssText = 'display: grid; grid-template-columns: 2fr 1fr 1fr auto; gap: 10px; margin-bottom: 10px; align-items: end;';
            newRow.innerHTML = `
                <div class="form-group" style="margin: 0;">
                    <input type="text" class="manual-tag-number" placeholder="1A4060300001234567890">
                </div>
                <div class="form-group" style="margin: 0;">
                    <input type="number" class="manual-tag-weight" step="0.1" placeholder="0">
                </div>
                <div class="form-group" style="margin: 0;">
                    <input type="text" class="manual-tag-strain" placeholder="Strain name">
                </div>
                <button onclick="this.parentElement.remove(); updateManualSummary();" 
                        style="padding: 10px 15px; background: var(--accent-red); border: none; border-radius: 8px; color: white; cursor: pointer; font-weight: 600;">
                    âœ•
                </button>
            `;
            container.appendChild(newRow);

            // Add event listeners for auto-summary update
            newRow.querySelectorAll('input').forEach(input => {
                input.addEventListener('input', updateManualSummary);
            });
        }

        function updateManualSummary() {
            const rows = document.querySelectorAll('.manual-package-row');
            const packages = [];
            
            rows.forEach(row => {
                const tag = row.querySelector('.manual-tag-number')?.value || '';
                const weight = parseFloat(row.querySelector('.manual-tag-weight')?.value) || 0;
                const strain = row.querySelector('.manual-tag-strain')?.value || '';
                
                if (tag && weight > 0) {
                    packages.push({ tag, weight, strain });
                }
            });

            const summaryEl = document.getElementById('manualSummary');
            
            if (packages.length === 0) {
                summaryEl.innerHTML = '<div style="color: var(--text-secondary); font-style: italic;">Enter package details above to see summary</div>';
                return;
            }

            const totalWeight = packages.reduce((sum, pkg) => sum + pkg.weight, 0);
            const uniqueStrains = [...new Set(packages.map(p => p.strain).filter(s => s))];

            summaryEl.innerHTML = `
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; margin-bottom: 15px;">
                    <div style="text-align: center;">
                        <div style="font-size: 2rem; font-weight: 700; color: var(--accent-purple);">${packages.length}</div>
                        <div style="color: var(--text-secondary); font-size: 0.85rem;">Packages</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="font-size: 2rem; font-weight: 700; color: var(--accent-green);">${totalWeight.toFixed(1)}g</div>
                        <div style="color: var(--text-secondary); font-size: 0.85rem;">Total Weight</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="font-size: 2rem; font-weight: 700; color: var(--accent-blue);">${uniqueStrains.length}</div>
                        <div style="color: var(--text-secondary); font-size: 0.85rem;">Unique Strains</div>
                    </div>
                </div>
                <div style="font-size: 0.9rem;">
                    ${packages.map(pkg => `
                        <div style="display: flex; justify-content: space-between; padding: 5px 0; border-bottom: 1px solid var(--border);">
                            <span style="font-family: 'Space Mono', monospace; font-size: 0.85rem;">...${pkg.tag.slice(-5)}</span>
                            <span style="color: var(--text-secondary);">${pkg.strain || 'Unknown'}</span>
                            <span style="font-weight: 600; color: var(--accent-green);">${pkg.weight.toFixed(1)}g</span>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        function importManualManifest() {
            const manifestNumber = document.getElementById('manualManifestNumber').value.trim();
            const receivedDate = document.getElementById('manualReceivedDate').value;
            const shipperName = document.getElementById('manualShipperName').value.trim();
            const shipperLicense = document.getElementById('manualShipperLicense').value.trim();

            if (!manifestNumber || !receivedDate) {
                alert('Please enter at least the manifest number and received date.');
                return;
            }

            const rows = document.querySelectorAll('.manual-package-row');
            const packages = [];
            
            rows.forEach(row => {
                const tag = row.querySelector('.manual-tag-number')?.value || '';
                const weight = parseFloat(row.querySelector('.manual-tag-weight')?.value) || 0;
                const strain = row.querySelector('.manual-tag-strain')?.value || '';
                
                if (tag && weight > 0) {
                    packages.push({ tag, weight, strain });
                }
            });

            if (packages.length === 0) {
                alert('Please add at least one package with tag and weight.');
                return;
            }

            const totalWeight = packages.reduce((sum, pkg) => sum + pkg.weight, 0);
            const uniqueStrains = [...new Set(packages.map(p => p.strain).filter(s => s))];
            const tagNumbers = packages.map(p => p.tag.slice(-5)).join(', ');
            const strainName = uniqueStrains.length === 1 ? uniqueStrains[0] : 'Mixed Strains';

            // Pre-fill the intake form
            document.getElementById('trimWeight').value = totalWeight.toFixed(1);
            document.getElementById('cultivationLicense').value = shipperLicense;
            document.getElementById('growerName').value = shipperName;
            document.getElementById('metrcTags').value = tagNumbers;
            document.getElementById('strainName').value = strainName;
            document.getElementById('intakeDate').value = receivedDate;
            
            // Add manifest number to notes
            const notesField = document.getElementById('intakeNotes');
            notesField.value = `METRC Manifest #${manifestNumber}${notesField.value ? '\n\n' + notesField.value : ''}`;

            // Close modal and switch to intake tab
            closeMetrcImport();
            
            document.querySelectorAll('.station-tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.station-content').forEach(content => content.classList.remove('active'));
            document.querySelector('[data-station="intake"]').classList.add('active');
            document.getElementById('intake').classList.add('active');
            
            alert(`âœ… Imported ${packages.length} packages (${totalWeight.toFixed(1)}g total)\n\nPlease review and complete the intake form.`);
        }

        // Add event listener to first manual package row
        document.addEventListener('DOMContentLoaded', function() {
            const firstRow = document.querySelector('.manual-package-row');
            if (firstRow) {
                firstRow.querySelectorAll('input').forEach(input => {
                    input.addEventListener('input', updateManualSummary);
                });
            }

            // Load production targets
            loadTargets();
        });

        // ==================== FRONT OF HOUSE ====================

        // Partner database for auto-tagging
        const fohPartners = {
            'in the flow': { name: 'In The Flow', instagram: '@intheflow_farms', website: 'https://intheflowfarms.com', type: 'farm', hashtags: ['#InTheFlowFarms', '#ColoradoGrown'] },
            'veritas': { name: 'Veritas Fine Cannabis', instagram: '@veritasfinecannabis', website: 'https://veritasfinecannabis.com', type: 'farm', hashtags: ['#VeritasCannabis'] },
            'locol love': { name: 'Locol Love', instagram: '@locollove', website: 'https://locol-love.com', type: 'farm', hashtags: ['#LocolLove', '#DenverGrown'] },
            'snaxland': { name: 'Snaxland', instagram: '@snaxland', website: null, type: 'farm', hashtags: ['#Snaxland'] },
            'cherry': { name: 'Cherry', instagram: '@cherry.co', website: 'https://cherry.co', type: 'farm', hashtags: ['#CherryCannabis'] },
            'native roots': { name: 'Native Roots', instagram: '@nativerootsdispensary', website: 'https://nativerootsdispensary.com', type: 'dispensary', hashtags: ['#NativeRoots'] },
            'the green solution': { name: 'The Green Solution', instagram: '@thegreensolution', website: 'https://tgscolorado.com', type: 'dispensary', hashtags: ['#TGS'] },
            'lightshade': { name: 'Lightshade', instagram: '@lightshadeco', website: 'https://lightshade.com', type: 'dispensary', hashtags: ['#Lightshade'] }
        };

        const fohTemplates = {
            equipment: [
                { title: "ðŸ”§ Gear Upgrade Alert", intro: "The lab just got a serious upgrade, fam!", body: "We're always pushing our extraction game to the next level.", cta: "Stay tuned for even better concentrates! ðŸš€" },
                { title: "âš¡ New Tech in the Lab", intro: "When you're obsessed with quality, you never stop upgrading.", body: "Just added some new firepower to our arsenal.", cta: "Better equipment = better terps. ðŸ’¯" }
            ],
            newStrain: [
                { title: "ðŸ”¥ Fresh Heat Incoming", intro: "The terp hunters have spoken!", body: "Just got our hands on some absolutely incredible material. The nose on this one is INSANE.", cta: "Keep your eyes peeled at your local dispensary! ðŸ‘€" },
                { title: "ðŸŒŸ Strain Alert", intro: "Sometimes a strain walks in and you just KNOW it's gonna be special.", body: "The terpene profile on this one is chef's kiss.", cta: "Coming soon to a dispo near you! ðŸƒâ€â™‚ï¸" }
            ],
            batch: [
                { title: "ðŸ§ª Fresh Batch Alert", intro: "The extractors have been BUSY!", body: "Just wrapped up a beautiful run and the results speak for themselves.", cta: "Ask your budtender about White Mousse! ðŸ”¥" },
                { title: "ðŸ’Ž Quality Check: PASSED", intro: "Another batch, another banger.", body: "When you prioritize terps and quality, the results are always fire.", cta: "Keep an eye out at your local spot! ðŸ‘€" }
            ],
            general: [
                { title: "ðŸ“£ What's Good, Fam", intro: "Just had to hop on and share what's happening at the lab!", body: "You know we're always cooking up something special.", cta: "More updates coming soon. Stay lifted! âœŒï¸" },
                { title: "ðŸŽ¯ Lab Update", intro: "Another day, another chance to serve the terps!", body: "Things are moving fast over here.", cta: "Thanks for rocking with White Mousse! ðŸ’š" }
            ]
        };

        const fohExcitingWords = ['absolutely fire', 'incredible', 'next level', 'game-changing', 'beautiful', 'insane', 'chef\'s kiss', 'dialed in', 'premium', 'top shelf'];
        const fohEmojis = ['ðŸ”¥', 'ðŸ’Ž', 'âœ¨', 'ðŸš€', 'ðŸ’¯', 'âš¡', 'ðŸŒŸ', 'ðŸŽ¯', 'ðŸ’š', 'ðŸ§ª'];

        let fohGeneratedPost = null;

        function detectFOHPartners(input) {
            const lowerInput = input.toLowerCase();
            // Use demo partners in demo mode
            const partnersDb = isDemoMode() ? demoFOHPartners : fohPartners;
            return Object.entries(partnersDb)
                .filter(([key]) => lowerInput.includes(key))
                .map(([, partner]) => partner);
        }

        function formatPartnerShoutout(partner) {
            const webLink = partner.website ? `[${partner.name}](${partner.website})` : partner.name;
            const igLink = partner.instagram || '';
            const phrases = {
                farm: [`Huge shoutout to ${webLink} for this incredible material! ${igLink}`, `This fire came straight from ${webLink}! ${igLink}`],
                dispensary: [`Available at ${webLink}! ${igLink}`, `Find this at ${webLink} - tell them WM sent you! ${igLink}`],
                equipment: [`Thanks to ${webLink} for keeping our lab running smooth! ${igLink}`]
            };
            const typePhrs = phrases[partner.type] || [`${webLink} ${igLink}`];
            return typePhrs[Math.floor(Math.random() * typePhrs.length)];
        }

        function generateFOHHashtags(partners) {
            const base = ['#WhiteMousse', '#ColoradoConcentrates', '#LiveResin', '#Terps', '#CannabisCommunity'];
            const partnerTags = partners.flatMap(p => p.hashtags || []);
            return [...new Set([...base, ...partnerTags])].slice(0, 10).join(' ');
        }

        function addQuickTag(tag) {
            const input = document.getElementById('fohQuickInput');
            input.value = input.value ? `${input.value} ${tag}` : tag;
            input.focus();
        }

        function generateBlogPost() {
            const input = document.getElementById('fohQuickInput').value.trim();
            if (!input) { alert('Type something first!'); return; }

            const lowerInput = input.toLowerCase();
            const partners = detectFOHPartners(input);

            let templateType = 'general';
            if (lowerInput.match(/hardware|equipment|machine|tech/)) templateType = 'equipment';
            else if (lowerInput.match(/strain|flower|material|trim|grabbed|picked up|gmo|cookies|og/)) templateType = 'newStrain';
            else if (lowerInput.match(/batch|run|extract/)) templateType = 'batch';

            const templates = fohTemplates[templateType];
            const template = templates[Math.floor(Math.random() * templates.length)];
            const word = fohExcitingWords[Math.floor(Math.random() * fohExcitingWords.length)];
            const emoji = fohEmojis[Math.floor(Math.random() * fohEmojis.length)];

            const expansions = [
                `So here's the deal: ${input}. And let me tell you, it's ${word}!`,
                `Big news from the lab: ${input}. We're honestly so hyped about this one.`,
                `Had to share this with y'all: ${input}. The quality is ${word}.`
            ];
            const expanded = expansions[Math.floor(Math.random() * expansions.length)];

            let partnerSection = '';
            if (partners.length > 0) {
                partnerSection = `\n\n---\n\n**ðŸ¤ Shoutouts**\n\n${partners.map(p => formatPartnerShoutout(p)).join('\n\n')}`;
            }

            const hashtags = generateFOHHashtags(partners);
            const title = template.title + ': ' + input.split(' ').slice(0, 4).join(' ') + '...';
            const content = `${template.intro}\n\n${expanded}\n\n${template.body}${partnerSection}\n\n${template.cta}\n\n---\n${hashtags}`;

            fohGeneratedPost = {
                title,
                content,
                excerpt: `${template.intro} ${expanded.slice(0, 100)}...`,
                category: templateType === 'equipment' ? 'update' : templateType === 'newStrain' ? 'strains' : 'update',
                emoji
            };

            const partnerInfo = partners.length > 0
                ? `<div style="background: rgba(57,255,20,0.1); border: 1px solid var(--accent-green); padding: 10px; border-radius: 8px; margin-bottom: 15px;">
                     <strong>ðŸ”— Auto-detected:</strong> ${partners.map(p => `${p.name} ${p.instagram || ''}`).join(', ')}
                   </div>` : '';

            document.getElementById('fohPartnerInfo').innerHTML = partnerInfo;
            document.getElementById('fohPreviewTitle').textContent = title;
            document.getElementById('fohPreviewContent').innerHTML = content.replace(/\n/g, '<br>');
            document.getElementById('fohGeneratedPreview').style.display = 'block';
        }

        function regenerateBlogPost() {
            generateBlogPost();
        }

        function editBlogPost() {
            if (!fohGeneratedPost) return;
            const newTitle = prompt('Edit title:', fohGeneratedPost.title);
            if (newTitle) fohGeneratedPost.title = newTitle;
            const newContent = prompt('Edit content (basic):', fohGeneratedPost.content.slice(0, 200));
            if (newContent) fohGeneratedPost.content = newContent;
            document.getElementById('fohPreviewTitle').textContent = fohGeneratedPost.title;
            document.getElementById('fohPreviewContent').innerHTML = fohGeneratedPost.content.replace(/\n/g, '<br>');
        }

        async function publishBlogPost() {
            if (!fohGeneratedPost) {
                alert('No post generated');
                return;
            }

            // Demo mode - simulate publishing
            if (isDemoMode()) {
                alert('ðŸŽ­ DEMO MODE: Publishing is disabled in demo mode.\n\nIn production, this post would be published to your blog and social media channels.');
                document.getElementById('fohQuickInput').value = '';
                document.getElementById('fohGeneratedPreview').style.display = 'none';
                fohGeneratedPost = null;
                return;
            }

            // Production mode - actual publishing
            if (!supabaseClient) {
                alert('Not connected to database');
                return;
            }

            try {
                const { error } = await supabaseClient.from('wm_blog_posts').insert([{
                    title: fohGeneratedPost.title,
                    content: fohGeneratedPost.content,
                    excerpt: fohGeneratedPost.excerpt,
                    category: fohGeneratedPost.category,
                    emoji: fohGeneratedPost.emoji,
                    status: 'published',
                    created_at: new Date().toISOString()
                }]);

                if (error) throw error;

                alert('Post published! ðŸš€');
                document.getElementById('fohQuickInput').value = '';
                document.getElementById('fohGeneratedPreview').style.display = 'none';
                fohGeneratedPost = null;
                loadFOHPosts();
                loadSalesDashboard();
            } catch (error) {
                console.error('Publish error:', error);
                alert('Error publishing: ' + error.message);
            }
        }

        async function loadFOHRecentBatches() {
            const container = document.getElementById('fohRecentBatches');
            if (!container) return;

            const completedBatches = batches.filter(b => b.status === 'complete').slice(0, 5);

            if (completedBatches.length === 0) {
                container.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-secondary);">No completed batches yet</div>';
                return;
            }

            container.innerHTML = completedBatches.map(batch => `
                <div class="foh-batch-card" onclick="createPostFromBatch('${batch.id}')">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <div style="font-weight: 700; font-size: 1.1rem; color: var(--accent-green);">${batch.id}</div>
                            <div style="color: var(--text-secondary);">${batch.strain || 'Unknown Strain'} â€¢ ${batch.material_type || 'Trim'}</div>
                        </div>
                        <div style="text-align: right;">
                            <div style="font-size: 0.85rem; color: var(--text-secondary);">Final: ${batch.final_weight || batch.bulk_weight || '?'}g</div>
                            <button class="btn" style="background: var(--accent-purple); padding: 6px 12px; font-size: 0.85rem; margin-top: 5px;">ðŸ“ Create Post</button>
                        </div>
                    </div>
                </div>
            `).join('');
        }

        function toggleBlogGenerator() {
            const section = document.getElementById("blogGeneratorSection");
            section.style.display = section.style.display === "none" ? "block" : "none";
        }

        function createPostFromBatch(batchId) {
            const batch = batches.find(b => b.id === batchId);
            if (!batch) return;

            const input = `Fresh batch of ${batch.strain || 'premium material'} just finished! ${batch.final_weight || batch.bulk_weight || ''}g of pure fire.`;
            document.getElementById('fohQuickInput').value = input;
            generateBlogPost();
        }

        async function loadFOHPosts() {
            const container = document.getElementById('fohPostsList');
            if (!container) return;

            // Use demo data in demo mode
            if (isDemoMode()) {
                const data = generateDemoBlogPosts();

                // Helper to escape HTML
                const escapeHtml = (str) => {
                    if (!str) return '';
                    return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;').replace(/`/g, '&#96;');
                };

                container.innerHTML = data.map(post => {
                    const safeTitle = escapeHtml(post.title);
                    const safeEmoji = escapeHtml(post.emoji) || 'ðŸ“';
                    const safeExcerpt = post.excerpt ? escapeHtml(post.excerpt.slice(0, 100)) + '...' : '';
                    const safeStatus = escapeHtml(post.status);
                    const dateStr = new Date(post.created_at).toLocaleDateString();

                    return `<div class="foh-post-card" onclick="viewBlogPost('${post.id}')" style="cursor: pointer;">
                        <div style="flex: 1;">
                            <div style="font-weight: 600;">${safeEmoji} ${safeTitle}</div>
                            <div style="font-size: 0.85rem; color: var(--text-secondary); margin-top: 5px;">${safeExcerpt}</div>
                            <div style="font-size: 0.8rem; color: var(--text-secondary); margin-top: 8px;">${dateStr}</div>
                        </div>
                        <div style="display: flex; flex-direction: column; align-items: flex-end; gap: 8px;">
                            <span class="foh-post-status ${safeStatus}">${safeStatus}</span>
                            <span style="font-size: 0.8rem; color: var(--accent-blue);">Click to view â†’</span>
                        </div>
                    </div>`;
                }).join('');

                // Store posts for viewing
                window.fohBlogPosts = data;
                return;
            }

            // Production mode - use Supabase
            if (!supabaseClient) return;

            try {
                const { data, error } = await supabaseClient
                    .from('wm_blog_posts')
                    .select('*')
                    .order('created_at', { ascending: false })
                    .limit(10);

                if (error) throw error;

                if (!data || data.length === 0) {
                    container.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-secondary);">No posts yet. Create your first one above!</div>';
                    return;
                }

                // Helper to escape HTML
                const escapeHtml = (str) => {
                    if (!str) return '';
                    return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;').replace(/`/g, '&#96;');
                };

                container.innerHTML = data.map(post => {
                    const safeTitle = escapeHtml(post.title);
                    const safeEmoji = escapeHtml(post.emoji) || 'ðŸ“';
                    const safeExcerpt = post.excerpt ? escapeHtml(post.excerpt.slice(0, 100)) + '...' : '';
                    const safeStatus = escapeHtml(post.status);
                    const dateStr = new Date(post.created_at).toLocaleDateString();

                    return `<div class="foh-post-card" onclick="viewBlogPost('${post.id}')" style="cursor: pointer;">
                        <div style="flex: 1;">
                            <div style="font-weight: 600;">${safeEmoji} ${safeTitle}</div>
                            <div style="font-size: 0.85rem; color: var(--text-secondary); margin-top: 5px;">${safeExcerpt}</div>
                            <div style="font-size: 0.8rem; color: var(--text-secondary); margin-top: 8px;">${dateStr}</div>
                        </div>
                        <div style="display: flex; flex-direction: column; align-items: flex-end; gap: 8px;">
                            <span class="foh-post-status ${safeStatus}">${safeStatus}</span>
                            <span style="font-size: 0.8rem; color: var(--accent-blue);">Click to view â†’</span>
                        </div>
                    </div>`;
                }).join('');

                // Store posts for viewing
                window.fohBlogPosts = data;
            } catch (error) {
                console.error('Error loading posts:', error);
                container.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-secondary);">Error loading posts</div>';
            }
        }

        // View a blog post in modal
        function viewBlogPost(postId) {
            const posts = window.fohBlogPosts || [];
            const post = posts.find(p => p.id === postId);

            if (!post) {
                console.error('Post not found:', postId);
                return;
            }

            // Set modal content
            document.getElementById('blogPostViewTitle').textContent = (post.emoji || '') + ' ' + post.title;
            document.getElementById('blogPostViewMeta').textContent = `Posted ${new Date(post.created_at).toLocaleDateString()} | Status: ${post.status}`;
            document.getElementById('blogPostViewContent').textContent = post.content || post.excerpt || 'No content available.';

            // Show modal
            document.getElementById('blogPostViewModal').style.display = 'block';
            document.body.style.overflow = 'hidden';
        }

        function closeBlogPostView() {
            document.getElementById('blogPostViewModal').style.display = 'none';
            document.body.style.overflow = 'auto';
        }

        // ==================== LEAFLINK DROP CALENDAR ====================

        // Use hosted Railway proxy to avoid CORS issues
        const LEAFLINK_PROXY_URL = 'https://leaflink-proxy-production.up.railway.app/api';

        let dropCalendarData = [];
        let currentCalendarView = 'calendar';
        let calendarDisplayMonth = new Date().getMonth();
        let calendarDisplayYear = new Date().getFullYear();

        function openDropCalendarModal() {
            document.getElementById('dropCalendarModal').style.display = 'block';
            document.body.style.overflow = 'hidden';
            // Reset to current month when opening
            calendarDisplayMonth = new Date().getMonth();
            calendarDisplayYear = new Date().getFullYear();
            // Auto-refresh if no data
            if (dropCalendarData.length === 0) {
                loadDropCalendar();
            } else {
                renderCalendarView();
            }
        }

        function closeDropCalendarModal() {
            document.getElementById('dropCalendarModal').style.display = 'none';
            document.body.style.overflow = 'auto';
        }

        function navigateCalendarMonth(direction) {
            calendarDisplayMonth += direction;
            if (calendarDisplayMonth > 11) {
                calendarDisplayMonth = 0;
                calendarDisplayYear++;
            } else if (calendarDisplayMonth < 0) {
                calendarDisplayMonth = 11;
                calendarDisplayYear--;
            }
            renderCalendarView();
        }

        async function loadDropCalendar() {
            const content = document.getElementById('dropCalendarContent');
            content.innerHTML = '<div style="text-align: center; padding: 60px; color: var(--text-secondary);"><div style="font-size: 2rem; margin-bottom: 10px;">â³</div>Loading drop data from LeafLink...</div>';

            try {
                // Calculate date 2 months ago
                const twoMonthsAgo = new Date();
                twoMonthsAgo.setMonth(twoMonthsAgo.getMonth() - 2);
                const dateFilter = twoMonthsAgo.toISOString().split('T')[0];

                // Fetch shipped and complete orders via proxy
                let allOrders = [];
                let nextUrl = `${LEAFLINK_PROXY_URL}/orders-received/?status=Accepted&status=Shipped&status=Complete&created_on__gte=${dateFilter}&page_size=100`;

                while (nextUrl) {
                    const response = await fetch(nextUrl);

                    if (!response.ok) throw new Error('API request failed - is the proxy server running?');

                    const data = await response.json();
                    allOrders = allOrders.concat(data.results);
                    nextUrl = data.next;

                    // Safety limit
                    if (allOrders.length > 500) break;
                }

                // Process orders into drop calendar data
                dropCalendarData = processDropData(allOrders);
                updateDropStats();
                renderCalendarView();

            } catch (error) {
                console.error('Error loading drop calendar:', error);
                content.innerHTML = `<div style="text-align: center; padding: 60px; color: var(--accent-red);">
                    <div style="font-size: 2rem; margin-bottom: 10px;">âŒ</div>
                    Error loading data: ${error.message}<br>
                    <small style="color: var(--text-secondary);">Make sure the proxy server is running:<br><code>cd proxy && npm install && npm start</code></small>
                </div>`;
            }
        }

        function processDropData(orders) {
            const customerDrops = {};

            orders.forEach(order => {
                if (!order.customer || !order.ship_date) return;

                const customerId = order.customer.id;
                const customerName = order.customer.display_name;
                const shipDate = order.ship_date.split('T')[0];

                // Extract products from line_items
                const products = (order.line_items || []).map(item => ({
                    name: item.frozen_data?.product?.name || 'Unknown Product',
                    quantity: Math.round(parseFloat(item.quantity) || 1),
                    sku: item.frozen_data?.product?.sku || ''
                }));

                // Aggregate products by name for cleaner display
                const productSummary = {};
                products.forEach(p => {
                    if (productSummary[p.name]) {
                        productSummary[p.name] += p.quantity;
                    } else {
                        productSummary[p.name] = p.quantity;
                    }
                });

                if (!customerDrops[customerId]) {
                    customerDrops[customerId] = {
                        id: customerId,
                        name: customerName,
                        deliveryPrefs: order.delivery_preferences || '',
                        drops: [],
                        totalOrders: 0,
                        totalProducts: 0
                    };
                }

                const totalProductCount = products.reduce((sum, p) => sum + p.quantity, 0);

                customerDrops[customerId].drops.push({
                    date: shipDate,
                    orderId: order.short_id,
                    products: productSummary,
                    productCount: totalProductCount,
                    status: order.status,
                    notes: order.notes || ''
                });
                customerDrops[customerId].totalOrders++;
                customerDrops[customerId].totalProducts += totalProductCount;
            });

            // Sort drops by date for each customer
            Object.values(customerDrops).forEach(customer => {
                customer.drops.sort((a, b) => new Date(b.date) - new Date(a.date));
                customer.lastDrop = customer.drops[0]?.date;
                customer.avgDaysBetween = calculateAvgDaysBetween(customer.drops);
            });

            return Object.values(customerDrops).sort((a, b) =>
                new Date(b.lastDrop) - new Date(a.lastDrop)
            );
        }

        function calculateAvgDaysBetween(drops) {
            if (drops.length < 2) return null;
            let totalDays = 0;
            for (let i = 1; i < drops.length; i++) {
                const diff = new Date(drops[i-1].date) - new Date(drops[i].date);
                totalDays += diff / (1000 * 60 * 60 * 24);
            }
            return Math.round(totalDays / (drops.length - 1));
        }

        function updateDropStats() {
            const totalDrops = dropCalendarData.reduce((sum, c) => sum + c.totalOrders, 0);
            const uniqueCustomers = dropCalendarData.length;
            const totalProducts = dropCalendarData.reduce((sum, c) => sum + c.totalProducts, 0);

            // This week
            const now = new Date();
            const weekStart = new Date(now);
            weekStart.setDate(now.getDate() - now.getDay());
            const thisWeek = dropCalendarData.reduce((sum, c) => {
                return sum + c.drops.filter(d => new Date(d.date) >= weekStart).length;
            }, 0);

            // Avg per week (over 2 months = ~8 weeks)
            const avgPerWeek = Math.round(totalDrops / 8);

            document.getElementById('statTotalDrops').textContent = totalDrops;
            document.getElementById('statUniqueCustomers').textContent = uniqueCustomers;
            document.getElementById('statThisWeek').textContent = thisWeek;
            document.getElementById('statTotalProducts').textContent = totalProducts;
        }

        function setCalendarView(view) {
            currentCalendarView = view;

            // Update button styles
            document.getElementById('viewCalendarBtn').style.background = view === 'calendar' ? 'var(--accent-blue)' : 'var(--bg-tertiary)';
            document.getElementById('viewListBtn').style.background = view === 'list' ? 'var(--accent-blue)' : 'var(--bg-tertiary)';
            document.getElementById('viewFreqBtn').style.background = view === 'frequency' ? 'var(--accent-blue)' : 'var(--bg-tertiary)';

            renderCalendarView();
        }

        function renderCalendarView() {
            const content = document.getElementById('dropCalendarContent');

            if (dropCalendarData.length === 0) {
                content.innerHTML = '<div style="text-align: center; padding: 60px; color: var(--text-secondary);">No drop data loaded yet</div>';
                return;
            }

            switch (currentCalendarView) {
                case 'calendar':
                    renderMonthCalendar(content);
                    break;
                case 'list':
                    renderCustomerList(content);
                    break;
                case 'frequency':
                    renderFrequencyView(content);
                    break;
            }
        }

        function renderMonthCalendar(container) {
            const now = new Date();
            const year = calendarDisplayYear;
            const month = calendarDisplayMonth;

            // Build calendar grid
            const firstDay = new Date(year, month, 1);
            const lastDay = new Date(year, month + 1, 0);
            const startPad = firstDay.getDay();

            // Get all drops for this month
            const monthDrops = {};
            dropCalendarData.forEach(customer => {
                customer.drops.forEach(drop => {
                    const dropDate = new Date(drop.date);
                    if (dropDate.getMonth() === month && dropDate.getFullYear() === year) {
                        const day = dropDate.getDate();
                        if (!monthDrops[day]) monthDrops[day] = [];
                        monthDrops[day].push({ customer: customer.name, ...drop });
                    }
                });
            });

            const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                               'July', 'August', 'September', 'October', 'November', 'December'];

            // Check if this is the current month
            const isCurrentMonth = month === now.getMonth() && year === now.getFullYear();

            let html = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <button onclick="navigateCalendarMonth(-1)" style="background: var(--accent-blue); border: none; color: white; padding: 10px 18px; border-radius: 8px; cursor: pointer; font-size: 1.1rem; font-weight: 700; transition: all 0.2s ease;" onmouseover="this.style.background='var(--accent-purple)'" onmouseout="this.style.background='var(--accent-blue)'">&larr; Prev</button>
                    <h3 style="margin: 0; font-size: 1.3rem;">${monthNames[month]} ${year}</h3>
                    <button onclick="navigateCalendarMonth(1)" style="background: var(--accent-blue); border: none; color: white; padding: 10px 18px; border-radius: 8px; cursor: pointer; font-size: 1.1rem; font-weight: 700; transition: all 0.2s ease;" onmouseover="this.style.background='var(--accent-purple)'" onmouseout="this.style.background='var(--accent-blue)'">Next &rarr;</button>
                </div>
                <div style="display: grid; grid-template-columns: repeat(7, 1fr); gap: 5px;">
                    <div style="text-align: center; font-weight: 700; color: var(--text-secondary); padding: 10px;">Sun</div>
                    <div style="text-align: center; font-weight: 700; color: var(--text-secondary); padding: 10px;">Mon</div>
                    <div style="text-align: center; font-weight: 700; color: var(--text-secondary); padding: 10px;">Tue</div>
                    <div style="text-align: center; font-weight: 700; color: var(--text-secondary); padding: 10px;">Wed</div>
                    <div style="text-align: center; font-weight: 700; color: var(--text-secondary); padding: 10px;">Thu</div>
                    <div style="text-align: center; font-weight: 700; color: var(--text-secondary); padding: 10px;">Fri</div>
                    <div style="text-align: center; font-weight: 700; color: var(--text-secondary); padding: 10px;">Sat</div>
            `;

            // Empty cells for start padding
            for (let i = 0; i < startPad; i++) {
                html += '<div></div>';
            }

            // Calendar days
            for (let day = 1; day <= lastDay.getDate(); day++) {
                const drops = monthDrops[day] || [];
                const isToday = isCurrentMonth && day === now.getDate();
                const hasDrops = drops.length > 0;

                html += `
                    <div style="background: ${hasDrops ? 'var(--accent-green)' : 'var(--bg-secondary)'};
                                ${isToday ? 'border: 2px solid var(--accent-blue);' : ''}
                                border-radius: 8px; padding: 8px; min-height: 60px; cursor: ${hasDrops ? 'pointer' : 'default'};"
                         ${hasDrops ? `onclick="showDayDrops(${day}, ${month}, ${year})"` : ''}>
                        <div style="font-weight: 700; ${hasDrops ? 'color: white;' : ''}">${day}</div>
                        ${hasDrops ? `<div style="font-size: 0.75rem; color: rgba(255,255,255,0.9); margin-top: 3px;">${drops.length} drop${drops.length > 1 ? 's' : ''}</div>` : ''}
                    </div>
                `;
            }

            html += '</div>';
            container.innerHTML = html;
        }

        function showDayDrops(day, month, year) {
            const drops = [];
            dropCalendarData.forEach(customer => {
                customer.drops.forEach(drop => {
                    const dropDate = new Date(drop.date);
                    if (dropDate.getDate() === day && dropDate.getMonth() === month && dropDate.getFullYear() === year) {
                        drops.push({ customer: customer.name, ...drop });
                    }
                });
            });

            // Build a nice modal instead of alert
            const dateStr = new Date(year, month, day).toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric' });

            let modalHtml = `
                <div id="dropDayModal" style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.8); z-index: 10000; display: flex; align-items: center; justify-content: center; padding: 20px;" onclick="if(event.target.id==='dropDayModal')this.remove()">
                    <div style="background: var(--bg-secondary); border-radius: 16px; padding: 25px; max-width: 600px; width: 100%; max-height: 80vh; overflow-y: auto;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                            <h3 style="margin: 0; color: var(--accent-green);">ðŸ“… ${dateStr}</h3>
                            <button onclick="this.closest('#dropDayModal').remove()" style="background: none; border: none; color: var(--text-primary); font-size: 1.5rem; cursor: pointer;">&times;</button>
                        </div>
                        <div style="display: grid; gap: 15px;">
                            ${drops.map(d => `
                                <div style="background: var(--bg-primary); border-radius: 12px; padding: 15px; border-left: 4px solid var(--accent-green);">
                                    <div style="font-weight: 700; font-size: 1.1rem; margin-bottom: 10px;">${d.customer}</div>
                                    <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                                        ${Object.entries(d.products || {}).map(([name, qty]) => `
                                            <div style="background: var(--bg-tertiary); padding: 6px 12px; border-radius: 20px; font-size: 0.85rem;">
                                                <span style="color: var(--accent-blue); font-weight: 700;">${qty}x</span> ${name.length > 40 ? name.substring(0, 40) + '...' : name}
                                            </div>
                                        `).join('')}
                                    </div>
                                    <div style="margin-top: 10px; font-size: 0.85rem; color: var(--text-secondary);">
                                        ${d.productCount} items total
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                </div>
            `;
            document.body.insertAdjacentHTML('beforeend', modalHtml);
        }

        function renderCustomerList(container) {
            let html = `
                <div style="display: grid; gap: 10px;">
                    ${dropCalendarData.map(customer => `
                        <div style="background: var(--bg-secondary); padding: 15px; border-radius: 10px;">
                            <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 10px;">
                                <div>
                                    <div style="font-weight: 700; font-size: 1.1rem;">${customer.name}</div>
                                    <div style="color: var(--text-secondary); font-size: 0.85rem;">
                                        Last drop: ${customer.lastDrop || 'N/A'} â€¢ ${customer.totalOrders} orders â€¢ ${customer.totalProducts} products
                                    </div>
                                </div>
                                <div style="text-align: right;">
                                    ${customer.avgDaysBetween ? `<div style="background: var(--accent-purple); color: white; padding: 5px 10px; border-radius: 20px; font-size: 0.85rem;">Every ~${customer.avgDaysBetween} days</div>` : ''}
                                </div>
                            </div>
                            ${customer.drops.length > 0 && customer.drops[0].products ? `
                                <div style="display: flex; flex-wrap: wrap; gap: 6px; margin-top: 8px;">
                                    ${Object.entries(customer.drops[0].products).slice(0, 5).map(([name, qty]) => `
                                        <div style="background: var(--bg-tertiary); padding: 4px 10px; border-radius: 15px; font-size: 0.8rem;">
                                            <span style="color: var(--accent-green); font-weight: 600;">${qty}x</span> ${name.length > 30 ? name.substring(0, 30) + '...' : name}
                                        </div>
                                    `).join('')}
                                    ${Object.keys(customer.drops[0].products).length > 5 ? `<div style="color: var(--text-secondary); font-size: 0.8rem; padding: 4px;">+${Object.keys(customer.drops[0].products).length - 5} more</div>` : ''}
                                </div>
                            ` : ''}
                        </div>
                    `).join('')}
                </div>
            `;
            container.innerHTML = html;
        }

        function renderFrequencyView(container) {
            // Group by frequency
            const weekly = dropCalendarData.filter(c => c.avgDaysBetween && c.avgDaysBetween <= 10);
            const biweekly = dropCalendarData.filter(c => c.avgDaysBetween && c.avgDaysBetween > 10 && c.avgDaysBetween <= 20);
            const monthly = dropCalendarData.filter(c => c.avgDaysBetween && c.avgDaysBetween > 20);
            const oneTime = dropCalendarData.filter(c => !c.avgDaysBetween);

            const renderGroup = (title, customers, color) => `
                <div style="margin-bottom: 20px;">
                    <h4 style="color: ${color}; margin: 0 0 10px 0; display: flex; align-items: center; gap: 10px;">
                        ${title} <span style="background: ${color}; color: white; padding: 2px 8px; border-radius: 10px; font-size: 0.8rem;">${customers.length}</span>
                    </h4>
                    <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                        ${customers.map(c => `
                            <div style="background: var(--bg-secondary); padding: 8px 12px; border-radius: 20px; font-size: 0.9rem; border-left: 3px solid ${color};">
                                ${c.name}
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;

            container.innerHTML = `
                ${renderGroup('ðŸ”¥ Weekly (1-10 days)', weekly, 'var(--accent-green)')}
                ${renderGroup('ðŸ“… Bi-Weekly (11-20 days)', biweekly, 'var(--accent-blue)')}
                ${renderGroup('ðŸ“† Monthly (21+ days)', monthly, 'var(--accent-purple)')}
                ${renderGroup('ðŸ†• One-Time / New', oneTime, 'var(--accent-orange)')}
            `;
        }

        // ==================== SHARED LEAFLINK DATA ====================

        let allLeafLinkOrders = [];
        let customerFirstOrderDates = {};
        let leafLinkDataLoaded = false;
        const LEAFLINK_CACHE_KEY = 'leaflink_orders_cache';
        const LEAFLINK_CACHE_DURATION = 15 * 60 * 1000; // 15 minutes

        // Load cached data from localStorage
        function loadCachedLeafLinkData() {
            try {
                const cached = localStorage.getItem(LEAFLINK_CACHE_KEY);
                if (!cached) return null;

                const { orders, timestamp, customerDates } = JSON.parse(cached);
                const age = Date.now() - timestamp;

                // Return cached data if less than 15 minutes old
                if (age < LEAFLINK_CACHE_DURATION) {
                    console.log(`Using cached LeafLink data (${Math.round(age/1000)}s old, ${orders.length} orders)`);
                    return { orders, customerDates, isFresh: false };
                }

                // Return stale data but flag for refresh
                console.log(`Cached data is stale (${Math.round(age/60000)}min old), will refresh`);
                return { orders, customerDates, isFresh: false, needsRefresh: true };
            } catch (e) {
                console.error('Error loading cache:', e);
                return null;
            }
        }

        // Save data to localStorage cache
        function saveLeafLinkCache(orders, customerDates) {
            try {
                const cacheData = {
                    orders,
                    customerDates,
                    timestamp: Date.now()
                };
                localStorage.setItem(LEAFLINK_CACHE_KEY, JSON.stringify(cacheData));
                console.log(`Cached ${orders.length} LeafLink orders`);
            } catch (e) {
                console.error('Error saving cache:', e);
            }
        }

        // Build customer first order dates from orders
        function buildCustomerFirstOrderDates(orders) {
            const dates = {};
            orders.forEach(order => {
                if (!order.customer) return;
                const customerId = order.customer.id;
                const orderDate = new Date(order.created_on);
                if (!dates[customerId] || orderDate < dates[customerId].date) {
                    dates[customerId] = {
                        date: orderDate,
                        name: order.customer.display_name
                    };
                }
            });
            return dates;
        }

        // Shared function to load LeafLink data with caching
        
        // Force refresh sales data from LeafLink (bypasses all caches)
        async function forceRefreshSales() {
            try {
                // Clear all caches
                localStorage.removeItem('leaflink_orders_cache');
                allLeafLinkOrders = [];
                leafLinkDataLoaded = false;
                
                // Fetch fresh from LeafLink
                const orders = await fetchLeafLinkOrders();
                if (orders && orders.length > 0) {
                    allLeafLinkOrders = orders;
                    customerFirstOrderDates = buildCustomerFirstOrderDates(orders);
                    leafLinkDataLoaded = true;
                    saveLeafLinkCache(orders, customerFirstOrderDates);
                    
                    // Update Supabase cache
                    saveSalesDataToSupabase(orders);
                }
                
                // Refresh display
                updateSalesDashboard();
                renderSalesBarChart();
                console.log('Force refreshed ' + orders.length + ' orders from LeafLink');
            } catch (error) {
                console.error('Error force refreshing sales:', error);
                alert('Error refreshing data: ' + error.message);
            }
        }

        async function ensureLeafLinkData(forceRefresh = false) {
            // Return fake data in demo mode
            if (isDemoMode()) {
                if (allLeafLinkOrders.length === 0) {
                    allLeafLinkOrders = generateDemoLeafLinkOrders();
                    customerFirstOrderDates = buildCustomerFirstOrderDates(allLeafLinkOrders);
                    leafLinkDataLoaded = true;
                }
                return allLeafLinkOrders;
            }

            // Check if already loaded in memory
            if (!forceRefresh && leafLinkDataLoaded && allLeafLinkOrders.length > 0) {
                return allLeafLinkOrders;
            }

            // Try to load from cache first
            if (!forceRefresh) {
                const cached = loadCachedLeafLinkData();
                if (cached && !cached.needsRefresh) {
                    allLeafLinkOrders = cached.orders;
                    customerFirstOrderDates = cached.customerDates || buildCustomerFirstOrderDates(cached.orders);
                    leafLinkDataLoaded = true;
                    return allLeafLinkOrders;
                }

                // Use stale cache immediately, refresh in background
                if (cached && cached.needsRefresh) {
                    allLeafLinkOrders = cached.orders;
                    customerFirstOrderDates = cached.customerDates || buildCustomerFirstOrderDates(cached.orders);
                    leafLinkDataLoaded = true;
                    // Refresh in background
                    fetchLeafLinkOrders().then(orders => {
                        if (orders.length > 0) {
                            allLeafLinkOrders = orders;
                            customerFirstOrderDates = buildCustomerFirstOrderDates(orders);
                            saveLeafLinkCache(orders, customerFirstOrderDates);
                        }
                    });
                    return allLeafLinkOrders;
                }
            }

            // No cache or force refresh - fetch fresh data
            const orders = await fetchLeafLinkOrders();
            if (orders.length > 0) {
                allLeafLinkOrders = orders;
                customerFirstOrderDates = buildCustomerFirstOrderDates(orders);
                leafLinkDataLoaded = true;
                saveLeafLinkCache(orders, customerFirstOrderDates);
            }
            return allLeafLinkOrders;
        }

        // Fetch orders from LeafLink API
        async function fetchLeafLinkOrders() {
            // Return fake data in demo mode
            if (isDemoMode()) {
                return generateDemoLeafLinkOrders();
            }

            try {
                const twoMonthsAgo = new Date();
                twoMonthsAgo.setMonth(twoMonthsAgo.getMonth() - 2);
                const dateFilter = twoMonthsAgo.toISOString().split('T')[0];

                let allOrders = [];
                let nextUrl = `${LEAFLINK_PROXY_URL}/orders-received/?status=Accepted&status=Shipped&status=Complete&created_on__gte=${dateFilter}&page_size=100`;

                while (nextUrl && allOrders.length < 300) {
                    const response = await fetch(nextUrl);
                    if (!response.ok) throw new Error('API request failed');
                    const data = await response.json();
                    allOrders = allOrders.concat(data.results);
                    nextUrl = data.next;
                }

                console.log(`Fetched ${allOrders.length} orders from LeafLink`);
                return allOrders;
            } catch (error) {
                console.error('Error fetching LeafLink data:', error);
                return [];
            }
        }

        // Calculate payment stats from orders
        function calculatePaymentStats(orders) {
            const paid = orders.filter(o => o.paid === true);
            const unpaid = orders.filter(o => o.paid === false);
            const paidTotal = paid.reduce((sum, o) => sum + (o.total?.amount || 0), 0);
            const unpaidTotal = unpaid.reduce((sum, o) => sum + (o.total?.amount || 0), 0);

            // Find overdue payments (unpaid and past due date)
            const now = new Date();
            const overdue = unpaid.filter(o => {
                if (!o.payment_due_date) return false;
                return new Date(o.payment_due_date) < now;
            });
            const overdueTotal = overdue.reduce((sum, o) => sum + (o.total?.amount || 0), 0);

            // Calculate days overdue for each order
            const overdueOrders = overdue.map(o => {
                const dueDate = new Date(o.payment_due_date);
                const daysOverdue = Math.floor((now - dueDate) / (1000 * 60 * 60 * 24));
                return {
                    orderNumber: o.number || o.id,
                    customer: o.customer?.display_name || 'Unknown',
                    amount: o.total?.amount || 0,
                    dueDate: o.payment_due_date,
                    daysOverdue: daysOverdue
                };
            });

            return {
                paidCount: paid.length,
                unpaidCount: unpaid.length,
                paidTotal,
                unpaidTotal,
                overdueCount: overdue.length,
                overdueTotal,
                overdueOrders: overdueOrders
            };
        }

        // Global variable to track current sort for overdue payments
        let overduePaymentSort = 'daysOverdue';
        let overduePaymentData = [];

        function sortOverduePayments(sortBy) {
            overduePaymentSort = sortBy;
            const sorted = [...overduePaymentData];

            switch(sortBy) {
                case 'amount':
                    sorted.sort((a, b) => b.amount - a.amount);
                    break;
                case 'daysOverdue':
                    sorted.sort((a, b) => b.daysOverdue - a.daysOverdue);
                    break;
                case 'customer':
                    sorted.sort((a, b) => a.customer.localeCompare(b.customer));
                    break;
                case 'dueDate':
                    sorted.sort((a, b) => new Date(a.dueDate) - new Date(b.dueDate));
                    break;
            }

            renderOverduePayments(sorted);

            // Update active sort button
            document.querySelectorAll('.overdue-sort-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.sort === sortBy) btn.classList.add('active');
            });
        }

        function renderOverduePayments(orders) {
            const container = document.getElementById('overduePaymentsList');
            if (!container) return;

            container.innerHTML = orders.map(order => {
                const severityColor = order.daysOverdue > 60 ? '#ff0000' :
                                      order.daysOverdue > 30 ? '#ff6b00' :
                                      'var(--accent-red)';
                const severityLabel = order.daysOverdue > 60 ? 'ðŸ”´ CRITICAL' :
                                      order.daysOverdue > 30 ? 'ðŸŸ  SEVERE' : '';
                return `
                    <div style="background: linear-gradient(135deg, rgba(239, 68, 68, 0.1), rgba(239, 68, 68, 0.05)); border: 1px solid rgba(239, 68, 68, 0.3); padding: 15px; border-radius: 10px; display: flex; justify-content: space-between; align-items: center;">
                        <div style="flex: 1;">
                            <div style="font-weight: 600; color: var(--text-primary);">${order.customer}</div>
                            <div style="font-size: 0.85rem; color: var(--text-secondary);">Order #${order.orderNumber}</div>
                        </div>
                        <div style="text-align: center; min-width: 80px;">
                            <div style="font-weight: 700; color: ${severityColor}; font-size: 1.1rem;">${order.daysOverdue} days</div>
                            ${severityLabel ? `<div style="font-size: 0.75rem; color: ${severityColor};">${severityLabel}</div>` : ''}
                        </div>
                        <div style="text-align: right; min-width: 100px;">
                            <div style="font-weight: 700; color: var(--accent-red);">${order.amount.toLocaleString('en-US', {minimumFractionDigits: 0, maximumFractionDigits: 0})}</div>
                            <div style="font-size: 0.8rem; color: var(--accent-red);">Due: ${new Date(order.dueDate).toLocaleDateString()}</div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function toggleOverduePayments() {
            const content = document.getElementById('overduePaymentsContent');
            const arrow = document.getElementById('overdueArrow');
            if (content.style.display === 'none') {
                content.style.display = 'block';
                arrow.textContent = 'â–¼';
            } else {
                content.style.display = 'none';
                arrow.textContent = 'â–¶';
            }
        }

        // Calculate sales stats from loaded data
        function calculateSalesStats(period = 'month') {
            const now = new Date();
            let startDate, prevStartDate, prevEndDate;

            switch (period) {
                case 'week':
                    startDate = new Date(now);
                    startDate.setDate(now.getDate() - now.getDay());
                    startDate.setHours(0, 0, 0, 0);
                    prevStartDate = new Date(startDate);
                    prevStartDate.setDate(prevStartDate.getDate() - 7);
                    prevEndDate = new Date(startDate);
                    break;
                case 'month':
                    startDate = new Date(now.getFullYear(), now.getMonth(), 1);
                    prevStartDate = new Date(now.getFullYear(), now.getMonth() - 1, 1);
                    prevEndDate = new Date(now.getFullYear(), now.getMonth(), 0);
                    break;
                case 'quarter':
                    const quarter = Math.floor(now.getMonth() / 3);
                    startDate = new Date(now.getFullYear(), quarter * 3, 1);
                    prevStartDate = new Date(now.getFullYear(), (quarter - 1) * 3, 1);
                    prevEndDate = new Date(now.getFullYear(), quarter * 3, 0);
                    break;
                case 'all':
                    startDate = new Date(0);
                    prevStartDate = new Date(0);
                    prevEndDate = new Date(0);
                    break;
            }

            const currentOrders = allLeafLinkOrders.filter(o => {
                const orderDate = new Date(o.created_on);
                return orderDate >= startDate && orderDate <= now;
            });

            const prevOrders = allLeafLinkOrders.filter(o => {
                const orderDate = new Date(o.created_on);
                return orderDate >= prevStartDate && orderDate < prevEndDate;
            });

            const totalOrders = currentOrders.length;
            const totalDollars = currentOrders.reduce((sum, o) => sum + (o.total?.amount || 0), 0);
            const prevTotalOrders = prevOrders.length;
            const prevTotalDollars = prevOrders.reduce((sum, o) => sum + (o.total?.amount || 0), 0);

            // Find new shops
            const newShops = [];
            const seenCustomers = new Set();
            currentOrders.forEach(order => {
                if (!order.customer) return;
                const customerId = order.customer.id;
                if (seenCustomers.has(customerId)) return;
                seenCustomers.add(customerId);

                const firstOrderInfo = customerFirstOrderDates[customerId];
                if (firstOrderInfo && firstOrderInfo.date >= startDate) {
                    newShops.push({
                        id: customerId,
                        name: order.customer.display_name,
                        firstOrderDate: firstOrderInfo.date
                    });
                }
            });

            const ordersChange = prevTotalOrders > 0 ? Math.round(((totalOrders - prevTotalOrders) / prevTotalOrders) * 100) : 0;
            const dollarsChange = prevTotalDollars > 0 ? Math.round(((totalDollars - prevTotalDollars) / prevTotalDollars) * 100) : 0;

            return {
                totalOrders,
                totalDollars,
                newShops,
                ordersChange,
                dollarsChange,
                uniqueCustomers: seenCustomers.size
            };
        }

        // Load FOH data when switching to that tab
        const origShowStation = typeof showStation === 'function' ? showStation : null;
        function showStationWithFOH(stationId) {
            if (origShowStation) origShowStation(stationId);
            if (stationId === 'frontofhouse') {
                loadFOHRecentBatches();
                loadDropCalendar();
                loadFOHPosts();
                loadSalesDashboard();
            }
        }


        // ==================== SALES DASHBOARD ====================

        const COMMISSION_RATE = 0.08; // 8% commission

        // Extract unique sales reps from orders
        function extractSalesReps(orders) {
            const repsMap = new Map();
            orders.forEach(order => {
                if (order.sales_reps && Array.isArray(order.sales_reps)) {
                    order.sales_reps.forEach(rep => {
                        if (rep.user) {
                            // Handle both string and object user formats
                            const userName = typeof rep.user === 'string' ? rep.user : (rep.user.name || rep.user.first_name || `Rep ${rep.id}`);
                            if (!repsMap.has(rep.id)) {
                                repsMap.set(rep.id, { id: rep.id, name: userName });
                            }
                        }
                    });
                }
            });
            return Array.from(repsMap.values()).sort((a, b) => a.name.localeCompare(b.name));
        }

        // Filter orders by sales rep
        function filterOrdersBySalesRep(orders, repIdOrName) {
            if (repIdOrName === 'all') return orders;
            return orders.filter(order => {
                if (!order.sales_reps || !Array.isArray(order.sales_reps)) return false;
                return order.sales_reps.some(rep => {
                    if (rep.id == repIdOrName) return true;
                    const userName = typeof rep.user === 'string' ? rep.user : (rep.user?.name || rep.user?.first_name || '');
                    return userName.toLowerCase().includes(repIdOrName.toLowerCase());
                });
            });
        }

        // Calculate commission for a set of orders
        function calculateCommission(orders, salesRepFilter = 'all') {
            const filteredOrders = filterOrdersBySalesRep(orders, salesRepFilter);
            const paidOrders = filteredOrders.filter(o => o.paid === true);
            const paidTotal = paidOrders.reduce((sum, o) => sum + (o.total?.amount || 0), 0);
            return paidTotal * COMMISSION_RATE;
        }

        // Get orders for a specific month
        function getOrdersForMonth(orders, year, month) {
            return orders.filter(order => {
                // Use paid_date for commission calculations (when invoice was paid)
                const dateField = order.paid ? (order.paid_date || order.created_on) : order.created_on;
                if (!dateField) return false;
                const orderDate = new Date(dateField);
                return orderDate.getFullYear() === year && orderDate.getMonth() === month;
            });
        }

        // Get paid orders for a specific month (for commission)
        function getPaidOrdersForMonth(orders, year, month) {
            return orders.filter(order => {
                if (order.paid !== true) return false;
                // Use paid_date if available, otherwise created_on
                const dateField = order.paid_date || order.created_on;
                if (!dateField) return false;
                const paidDate = new Date(dateField);
                return paidDate.getFullYear() === year && paidDate.getMonth() === month;
            });
        }

        // Determine next payday and what commission period it covers
        // Commission is paid on the FIRST pay period of each month
        // Commission covers all payments received SINCE the last commission payout
        function getNextPaydayInfo() {
            const now = new Date();
            // Starting reference: January 9, 2025 (Friday) - first payday of the year
            const referencePayday = new Date(2025, 0, 9); // Jan 9, 2025

            // Build list of all paydays from reference
            const allPaydays = [];
            let payday = new Date(referencePayday);
            // Go back to find earlier paydays (for historical commission dates)
            while (payday.getFullYear() >= 2024) {
                payday.setDate(payday.getDate() - 14);
            }
            payday.setDate(payday.getDate() + 14); // Move forward to first valid payday

            // Build list of paydays through 2026
            while (payday.getFullYear() <= 2026) {
                allPaydays.push(new Date(payday));
                payday.setDate(payday.getDate() + 14);
            }

            // Find which paydays are "first pay periods" (on or before 14th of month)
            // These are the commission paydays
            const commissionPaydays = allPaydays.filter(pd => pd.getDate() <= 14);

            // Find next payday (any payday, not just commission)
            let nextPayday = allPaydays.find(pd => pd > now);
            if (!nextPayday) {
                nextPayday = allPaydays[allPaydays.length - 1];
            }

            // Determine if next payday is a commission payday (first pay period)
            const payMonth = nextPayday.getMonth();
            const payYear = nextPayday.getFullYear();
            const dayOfMonth = nextPayday.getDate();
            const isFirstPayPeriod = dayOfMonth <= 14;

            // Find last commission payout date (most recent commission payday before now)
            let lastCommissionPayday = null;
            for (let i = commissionPaydays.length - 1; i >= 0; i--) {
                if (commissionPaydays[i] <= now) {
                    lastCommissionPayday = commissionPaydays[i];
                    break;
                }
            }
            // Fallback: Dec 6, 2024 was a known commission payday
            if (!lastCommissionPayday) {
                lastCommissionPayday = new Date(2024, 11, 6); // Dec 6, 2024
            }

            // Find next commission payday (for calculating commission period end)
            let nextCommissionPayday = null;
            for (let i = 0; i < commissionPaydays.length; i++) {
                if (commissionPaydays[i] > now) {
                    nextCommissionPayday = commissionPaydays[i];
                    break;
                }
            }

            return {
                nextPayday,
                isFirstPayPeriod,
                payMonth,
                payYear,
                lastCommissionPayday,
                nextCommissionPayday,
                // Legacy fields for backward compatibility
                commissionMonth: isFirstPayPeriod ? (payMonth === 0 ? 11 : payMonth - 1) : null,
                commissionYear: isFirstPayPeriod ? (payMonth === 0 ? payYear - 1 : payYear) : null
            };
        }

        // Get paid orders between two dates (for commission calculation)
        // Uses paid_date field to determine when payment was received
        function getPaidOrdersBetweenDates(orders, startDate, endDate) {
            return orders.filter(order => {
                if (order.paid !== true) return false;
                if (!order.paid_date) return false;
                const paidDate = new Date(order.paid_date);
                // Include orders with paid_date > startDate and <= endDate
                return paidDate > startDate && paidDate <= endDate;
            });
        }

        // Format month name
        function getMonthName(month) {
            const months = ['January', 'February', 'March', 'April', 'May', 'June',
                           'July', 'August', 'September', 'October', 'November', 'December'];
            return months[month];
        }

        // Load and display sales dashboard
        async function loadSalesDashboard() {
            try {
                await ensureLeafLinkData();
                // Load Pipeline, Inventory, Needs data for inline display
                loadSalesPipeline();
                await loadLeafLinkInventory();
                await loadNeedsData();

                // Populate sales rep dropdown
                const salesReps = extractSalesReps(allLeafLinkOrders);
                const dropdown = document.getElementById('salesRepFilter');
                if (dropdown) {
                    dropdown.innerHTML = '<option value="all">All Sales Reps</option>';
                    salesReps.forEach(rep => {
                        const option = document.createElement('option');
                        option.value = rep.id;
                        option.textContent = rep.name;
                        dropdown.appendChild(option);
                    });
                }

                updateSalesDashboard();
            } catch (error) {
                console.error('Error loading sales dashboard:', error);
            }
        }

        // Update dashboard with current filter
        function updateSalesDashboard() {
            const salesRepFilter = document.getElementById('salesRepFilter')?.value || 'all';
            const filteredOrders = filterOrdersBySalesRep(allLeafLinkOrders, salesRepFilter);

            // Calculate stats
            const now = new Date();
            const currentMonth = now.getMonth();
            const currentYear = now.getFullYear();
            const prevMonth = currentMonth === 0 ? 11 : currentMonth - 1;
            const prevYear = currentMonth === 0 ? currentYear - 1 : currentYear;

            // Current month orders (by created_on)
            const currentMonthOrders = filteredOrders.filter(o => {
                const d = new Date(o.created_on);
                return d.getMonth() === currentMonth && d.getFullYear() === currentYear;
            });

            // All-time stats
            const totalOrders = filteredOrders.length;
            // Last 30 days revenue
            const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
            const last30DaysOrders = filteredOrders.filter(o => new Date(o.created_on) >= thirtyDaysAgo);
            const totalRevenue = last30DaysOrders.reduce((sum, o) => sum + (o.total?.amount || 0), 0);
            const paidOrders = filteredOrders.filter(o => o.paid === true);
            const unpaidOrders = filteredOrders.filter(o => o.paid === false);

            // Count unique new customers this month
            const currentMonthCustomers = new Set();
            currentMonthOrders.forEach(o => {
                if (o.customer?.id) currentMonthCustomers.add(o.customer.id);
            });

            // Check which are truly new (first order ever)
            let newCustomersCount = 0;
            currentMonthCustomers.forEach(customerId => {
                const firstOrderInfo = customerFirstOrderDates[customerId];
                if (firstOrderInfo) {
                    const firstOrderDate = new Date(firstOrderInfo.date);
                    if (firstOrderDate.getMonth() === currentMonth && firstOrderDate.getFullYear() === currentYear) {
                        newCustomersCount++;
                    }
                }
            });

            // Update stats display
            document.getElementById('salesStatTotalOrders').textContent = totalOrders.toLocaleString();
            document.getElementById('salesStatTotalRevenue').textContent = '$' + totalRevenue.toLocaleString(undefined, {minimumFractionDigits: 0, maximumFractionDigits: 0});
            document.getElementById('salesStatPaidOrders').textContent = paidOrders.length.toLocaleString();
            document.getElementById('salesStatUnpaidOrders').textContent = unpaidOrders.length.toLocaleString();
            document.getElementById('salesStatNewCustomers').textContent = newCustomersCount.toLocaleString();

            // Commission calculations - based on PAYMENT DATE, not order date
            // Get payday info including last commission payout date
            const paydayInfo = getNextPaydayInfo();

            // Get payments since last commission payout (for next paycheck)
            const paymentsSinceLastPayout = getPaidOrdersBetweenDates(filteredOrders, paydayInfo.lastCommissionPayday, now);
            const paymentsSinceLastPayoutTotal = paymentsSinceLastPayout.reduce((sum, o) => sum + (o.total?.amount || 0), 0);
            const pendingCommission = paymentsSinceLastPayoutTotal * COMMISSION_RATE;

            // For display purposes, also show current and previous month payments
            const currentMonthPaid = getPaidOrdersForMonth(filteredOrders, currentYear, currentMonth);
            const prevMonthPaid = getPaidOrdersForMonth(filteredOrders, prevYear, prevMonth);
            const currentMonthCommission = currentMonthPaid.reduce((sum, o) => sum + (o.total?.amount || 0), 0) * COMMISSION_RATE;
            const prevMonthCommission = prevMonthPaid.reduce((sum, o) => sum + (o.total?.amount || 0), 0) * COMMISSION_RATE;

            // Next paycheck calculation
            let nextPaycheckCommission = 0;
            let paycheckNote = '';

            if (paydayInfo.isFirstPayPeriod) {
                // First pay period - pays out commission for payments since last commission payout
                nextPaycheckCommission = pendingCommission;
                const lastPayoutFormatted = paydayInfo.lastCommissionPayday.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
                paycheckNote = `Payments since ${lastPayoutFormatted} (${paymentsSinceLastPayout.length} orders, $${paymentsSinceLastPayoutTotal.toLocaleString(undefined, {minimumFractionDigits: 0, maximumFractionDigits: 0})} total)`;
            } else {
                // Second pay period - show what will be paid on next commission payday
                const nextCommissionFormatted = paydayInfo.nextCommissionPayday ?
                    paydayInfo.nextCommissionPayday.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }) : 'next month';
                nextPaycheckCommission = 0; // No commission this pay period
                paycheckNote = `No commission this pay period. Next commission on ${nextCommissionFormatted}.`;
            }

            // Update commission display
            document.getElementById('commissionCurrentMonth').textContent = '$' + currentMonthCommission.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2});
            document.getElementById('commissionCurrentMonthLabel').textContent = `${getMonthName(currentMonth)} ${currentYear} (by paid_date)`;

            document.getElementById('commissionPrevMonth').textContent = '$' + prevMonthCommission.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2});
            document.getElementById('commissionPrevMonthLabel').textContent = `${getMonthName(prevMonth)} ${prevYear} (by paid_date)`;

            document.getElementById('commissionNextPaycheck').textContent = '$' + nextPaycheckCommission.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2});
            document.getElementById('commissionPaydayDate').textContent = paydayInfo.nextPayday.toLocaleDateString('en-US', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });
            document.getElementById('commissionPayScheduleNote').textContent = paycheckNote;

            // Build monthly breakdown
            renderMonthlyBreakdown(filteredOrders);
        }

        // Store for commission details modal data
        let currentCommissionOrders = [];

        // Show commission details modal
        function showCommissionDetails(period) {
            const salesRepFilter = document.getElementById('salesRepFilter')?.value || 'all';
            const filteredOrders = filterOrdersBySalesRep(allLeafLinkOrders, salesRepFilter);

            const now = new Date();
            const currentMonth = now.getMonth();
            const currentYear = now.getFullYear();
            const prevMonth = currentMonth === 0 ? 11 : currentMonth - 1;
            const prevYear = currentMonth === 0 ? currentYear - 1 : currentYear;

            let orders = [];
            let title = '';
            let subtitle = '';
            let startDate, endDate;

            if (period === 'currentMonth') {
                orders = getPaidOrdersForMonth(filteredOrders, currentYear, currentMonth);
                title = `Commission Details - ${getMonthName(currentMonth)} ${currentYear}`;
                startDate = new Date(currentYear, currentMonth, 1);
                endDate = new Date(currentYear, currentMonth + 1, 0);
                subtitle = `Payments from ${formatDateShort(startDate)} to ${formatDateShort(endDate)}`;
            } else if (period === 'prevMonth') {
                orders = getPaidOrdersForMonth(filteredOrders, prevYear, prevMonth);
                title = `Commission Details - ${getMonthName(prevMonth)} ${prevYear}`;
                startDate = new Date(prevYear, prevMonth, 1);
                endDate = new Date(prevYear, prevMonth + 1, 0);
                subtitle = `Payments from ${formatDateShort(startDate)} to ${formatDateShort(endDate)}`;
            } else if (period === 'nextPaycheck') {
                const paydayInfo = getNextPaydayInfo();
                orders = getPaidOrdersBetweenDates(filteredOrders, paydayInfo.lastCommissionPayday, now);
                const paydayFormatted = paydayInfo.nextPayday.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
                title = `Commission Details - Next Paycheck (${paydayFormatted})`;
                subtitle = `Payments from ${formatDateShort(paydayInfo.lastCommissionPayday)} to ${formatDateShort(now)}`;
            }

            // Store for clipboard copy
            currentCommissionOrders = orders;

            // Update modal content
            document.getElementById('commissionModalTitle').textContent = title;
            document.getElementById('commissionModalSubtitle').textContent = subtitle;

            // Build table rows
            const tbody = document.getElementById('commissionDetailsBody');
            let totalAmount = 0;
            let totalCommission = 0;

            if (orders.length === 0) {
                tbody.innerHTML = `<tr><td colspan="6" style="padding: 30px; text-align: center; color: var(--text-secondary);">No paid orders found for this period</td></tr>`;
            } else {
                // Sort orders by paid_date
                const sortedOrders = [...orders].sort((a, b) => {
                    const dateA = new Date(a.paid_date || a.created_on);
                    const dateB = new Date(b.paid_date || b.created_on);
                    return dateA - dateB;
                });

                tbody.innerHTML = sortedOrders.map((order, index) => {
                    const invoiceNumber = order.short_id || order.number || 'N/A';
                    const store = order.customer?.display_name || order.customer?.name || 'Unknown';
                    const amount = order.total?.amount || 0;
                    const payAmount = amount * COMMISSION_RATE;
                    const paidDate = order.paid_date ? formatDateShort(new Date(order.paid_date)) : 'N/A';

                    totalAmount += amount;
                    totalCommission += payAmount;

                    const rowBg = index % 2 === 0 ? 'transparent' : 'rgba(255,255,255,0.02)';

                    return `<tr style="background: ${rowBg}; border-bottom: 1px solid var(--border);">
                        <td style="padding: 12px; color: var(--accent-blue); font-family: 'Space Mono', monospace;">${invoiceNumber}</td>
                        <td style="padding: 12px; color: var(--text-primary);">${escapeHtml(store)}</td>
                        <td style="padding: 12px; text-align: right; color: var(--text-primary);">$${amount.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})}</td>
                        <td style="padding: 12px; text-align: right; color: var(--accent-green); font-weight: 600;">$${payAmount.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})}</td>
                        <td style="padding: 12px; color: var(--text-secondary);">${paidDate}</td>
                    </tr>`;
                }).join('');
            }

            // Update totals
            document.getElementById('commissionTotalOrders').textContent = orders.length.toLocaleString();
            document.getElementById('commissionTotalAmount').textContent = '$' + totalAmount.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2});
            document.getElementById('commissionTotalPay').textContent = '$' + totalCommission.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2});

            // Show modal
            document.getElementById('commissionDetailsModal').style.display = 'block';
            document.body.style.overflow = 'hidden';
        }

        // Close commission details modal
        function closeCommissionDetailsModal() {
            document.getElementById('commissionDetailsModal').style.display = 'none';
            document.body.style.overflow = '';
        }

        // Format date in short format (e.g., "Dec 15, 2024")
        function formatDateShort(date) {
            return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
        }

        // Escape HTML to prevent XSS
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Copy commission details to clipboard
        function copyCommissionToClipboard() {
            if (currentCommissionOrders.length === 0) {
                alert('No orders to copy');
                return;
            }

            // Sort orders by paid_date
            const sortedOrders = [...currentCommissionOrders].sort((a, b) => {
                const dateA = new Date(a.paid_date || a.created_on);
                const dateB = new Date(b.paid_date || b.created_on);
                return dateA - dateB;
            });

            // Build tab-separated data (for pasting into spreadsheet)
            let clipboardData = 'Invoice Number\tStore\tAmount\tPay Amount\tPaid Date\n';
            let totalAmount = 0;
            let totalCommission = 0;

            sortedOrders.forEach(order => {
                const invoiceNumber = order.short_id || order.number || 'N/A';
                const store = order.customer?.display_name || order.customer?.name || 'Unknown';
                const amount = order.total?.amount || 0;
                const payAmount = amount * COMMISSION_RATE;
                const paidDate = order.paid_date ? formatDateShort(new Date(order.paid_date)) : 'N/A';

                totalAmount += amount;
                totalCommission += payAmount;

                clipboardData += `${invoiceNumber}\t${store}\t$${amount.toFixed(2)}\t$${payAmount.toFixed(2)}\t${paidDate}\n`;
            });

            // Add totals row
            clipboardData += `\nTOTAL\t${sortedOrders.length} orders\t$${totalAmount.toFixed(2)}\t$${totalCommission.toFixed(2)}\t\n`;

            navigator.clipboard.writeText(clipboardData).then(() => {
                const statusEl = document.getElementById('commissionCopyStatus');
                statusEl.style.display = 'inline';
                setTimeout(() => {
                    statusEl.style.display = 'none';
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy:', err);
                alert('Failed to copy to clipboard');
            });
        }

        // Close modal on backdrop click
        document.addEventListener('click', function(e) {
            const modal = document.getElementById('commissionDetailsModal');
            if (e.target === modal) {
                closeCommissionDetailsModal();
            }
        });

        // Close modal on Escape key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                const modal = document.getElementById('commissionDetailsModal');
                if (modal && modal.style.display === 'block') {
                    closeCommissionDetailsModal();
                }
            }
        });

        // Render monthly sales breakdown
        function renderMonthlyBreakdown(orders) {
            const container = document.getElementById('salesMonthlyBreakdown');
            if (!container) return;

            // Group orders by month
            const monthlyData = {};
            orders.forEach(order => {
                const date = new Date(order.created_on);
                const key = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                if (!monthlyData[key]) {
                    monthlyData[key] = {
                        year: date.getFullYear(),
                        month: date.getMonth(),
                        orders: [],
                        paidOrders: [],
                        revenue: 0,
                        paidRevenue: 0
                    };
                }
                monthlyData[key].orders.push(order);
                monthlyData[key].revenue += order.total?.amount || 0;
                if (order.paid === true) {
                    monthlyData[key].paidOrders.push(order);
                    monthlyData[key].paidRevenue += order.total?.amount || 0;
                }
            });

            // Sort by date descending
            const sortedMonths = Object.keys(monthlyData).sort().reverse();

            if (sortedMonths.length === 0) {
                container.innerHTML = '<div style="text-align: center; padding: 30px; color: var(--text-secondary);">No sales data available</div>';
                return;
            }

            let html = '<table style="width: 100%; border-collapse: collapse;">';
            html += '<thead><tr style="border-bottom: 2px solid var(--border-color);">';
            html += '<th style="text-align: left; padding: 10px; color: var(--text-secondary);">Month</th>';
            html += '<th style="text-align: right; padding: 10px; color: var(--text-secondary);">Orders</th>';
            html += '<th style="text-align: right; padding: 10px; color: var(--text-secondary);">Revenue</th>';
            html += '<th style="text-align: right; padding: 10px; color: var(--text-secondary);">Paid</th>';
            html += '<th style="text-align: right; padding: 10px; color: var(--text-secondary);">Commission</th>';
            html += '</tr></thead><tbody>';

            sortedMonths.forEach(key => {
                const data = monthlyData[key];
                const commission = data.paidRevenue * COMMISSION_RATE;
                const monthName = getMonthName(data.month);

                html += `<tr style="border-bottom: 1px solid var(--border-color);">`;
                html += `<td style="padding: 12px 10px; font-weight: 600;">${monthName} ${data.year}</td>`;
                html += `<td style="padding: 12px 10px; text-align: right; color: var(--accent-blue);">${data.orders.length}</td>`;
                html += `<td style="padding: 12px 10px; text-align: right; color: #FFD700;">$${data.revenue.toLocaleString(undefined, {minimumFractionDigits: 0, maximumFractionDigits: 0})}</td>`;
                html += `<td style="padding: 12px 10px; text-align: right; color: var(--accent-green);">$${data.paidRevenue.toLocaleString(undefined, {minimumFractionDigits: 0, maximumFractionDigits: 0})}</td>`;
                html += `<td style="padding: 12px 10px; text-align: right; color: var(--accent-purple); font-weight: 600;">$${commission.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})}</td>`;
                html += '</tr>';
            });

            html += '</tbody></table>';
            container.innerHTML = html;
        }


        // ============================================
        // SUPABASE DATA CACHING FOR FOH
        // ============================================

        /*
         * SUPABASE TABLE SCHEMAS - Run these in Supabase SQL Editor:
         *
         * -- Drop Calendar Cache Table
         * CREATE TABLE IF NOT EXISTS drop_calendar_cache (
         *     id SERIAL PRIMARY KEY,
         *     customer_id TEXT NOT NULL,
         *     customer_name TEXT NOT NULL,
         *     delivery_prefs TEXT,
         *     last_drop_date DATE,
         *     total_orders INTEGER DEFAULT 0,
         *     total_products INTEGER DEFAULT 0,
         *     avg_days_between INTEGER,
         *     drops_json JSONB,
         *     synced_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
         *     UNIQUE(customer_id)
         * );
         *
         * -- Sales Data Cache Table
         * CREATE TABLE IF NOT EXISTS sales_data_cache (
         *     id SERIAL PRIMARY KEY,
         *     order_id TEXT NOT NULL,
         *     short_id TEXT,
         *     customer_id TEXT,
         *     customer_name TEXT,
         *     sales_rep_id TEXT,
         *     sales_rep_name TEXT,
         *     total_amount DECIMAL(10,2),
         *     paid BOOLEAN DEFAULT FALSE,
         *     paid_date TIMESTAMP WITH TIME ZONE,
         *     created_on TIMESTAMP WITH TIME ZONE,
         *     status TEXT,
         *     order_json JSONB,
         *     synced_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
         *     UNIQUE(order_id)
         * );
         *
         * -- Monthly Sales Summary Table (for quick chart data)
         * CREATE TABLE IF NOT EXISTS sales_monthly_summary (
         *     id SERIAL PRIMARY KEY,
         *     year INTEGER NOT NULL,
         *     month INTEGER NOT NULL,
         *     sales_rep_id TEXT DEFAULT 'all',
         *     total_orders INTEGER DEFAULT 0,
         *     total_revenue DECIMAL(12,2) DEFAULT 0,
         *     paid_revenue DECIMAL(12,2) DEFAULT 0,
         *     commission DECIMAL(10,2) DEFAULT 0,
         *     new_customers INTEGER DEFAULT 0,
         *     synced_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
         *     UNIQUE(year, month, sales_rep_id)
         * );
         *
         * -- Cache metadata table
         * CREATE TABLE IF NOT EXISTS cache_metadata (
         *     id SERIAL PRIMARY KEY,
         *     cache_key TEXT NOT NULL UNIQUE,
         *     last_sync TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
         *     record_count INTEGER DEFAULT 0
         * );
         */

        const SUPABASE_CACHE_DURATION = 30 * 60 * 1000; // 30 minutes for Supabase cache
        let salesChartType = 'revenue';
        let cachedMonthlyData = null;
        let lastSupabaseSync = null;

        // ==================== DROP CALENDAR SUPABASE CACHING ====================

        // Save drop calendar data to Supabase
        async function saveDropCalendarToSupabase(data) {
            if (!supabaseClient || !data || data.length === 0) return false;

            try {
                // Prepare records for upsert
                const records = data.map(customer => ({
                    customer_id: String(customer.id),
                    customer_name: customer.name,
                    delivery_prefs: customer.deliveryPrefs || '',
                    last_drop_date: customer.lastDrop || null,
                    total_orders: customer.totalOrders || 0,
                    total_products: customer.totalProducts || 0,
                    avg_days_between: customer.avgDaysBetween || null,
                    drops_json: JSON.stringify(customer.drops || []),
                    synced_at: new Date().toISOString()
                }));

                // Upsert in batches
                const batchSize = 50;
                for (let i = 0; i < records.length; i += batchSize) {
                    const batch = records.slice(i, i + batchSize);
                    const { error } = await supabaseClient
                        .from('drop_calendar_cache')
                        .upsert(batch, { onConflict: 'customer_id' });

                    if (error) {
                        console.error('Error saving drop calendar batch:', error);
                    }
                }

                // Update cache metadata
                await supabaseClient
                    .from('cache_metadata')
                    .upsert({
                        cache_key: 'drop_calendar',
                        last_sync: new Date().toISOString(),
                        record_count: records.length
                    }, { onConflict: 'cache_key' });

                console.log(`Saved ${records.length} drop calendar records to Supabase`);
                return true;
            } catch (error) {
                console.error('Error saving drop calendar to Supabase:', error);
                return false;
            }
        }

        // Load drop calendar data from Supabase
        async function loadDropCalendarFromSupabase() {
            if (!supabaseClient) return null;

            try {
                // Check cache freshness
                const { data: metadata } = await supabaseClient
                    .from('cache_metadata')
                    .select('last_sync, record_count')
                    .eq('cache_key', 'drop_calendar')
                    .single();

                if (!metadata || !metadata.last_sync) return null;

                const cacheAge = Date.now() - new Date(metadata.last_sync).getTime();
                if (cacheAge > SUPABASE_CACHE_DURATION) {
                    console.log('Supabase drop calendar cache is stale');
                    return { stale: true };
                }

                // Load cached data
                const { data, error } = await supabaseClient
                    .from('drop_calendar_cache')
                    .select('*')
                    .order('last_drop_date', { ascending: false });

                if (error || !data) return null;

                // Transform back to original format
                const calendarData = data.map(record => ({
                    id: record.customer_id,
                    name: record.customer_name,
                    deliveryPrefs: record.delivery_prefs,
                    lastDrop: record.last_drop_date,
                    totalOrders: record.total_orders,
                    totalProducts: record.total_products,
                    avgDaysBetween: record.avg_days_between,
                    drops: JSON.parse(record.drops_json || '[]')
                }));

                console.log(`Loaded ${calendarData.length} drop calendar records from Supabase`);
                return { data: calendarData, lastSync: metadata.last_sync };
            } catch (error) {
                console.error('Error loading drop calendar from Supabase:', error);
                return null;
            }
        }

        // ==================== SALES DATA SUPABASE CACHING ====================

        // Save sales data to Supabase
        async function saveSalesDataToSupabase(orders) {
            if (!supabaseClient || !orders || orders.length === 0) return false;

            try {
                // Deduplicate orders by ID
                const uniqueOrders = [...new Map(orders.map(o => [String(o.id), o])).values()];

                // Prepare order records
                const orderRecords = uniqueOrders.map(order => ({
                    order_id: String(order.id),
                    short_id: order.short_id || order.number || '',
                    customer_id: order.customer?.id ? String(order.customer.id) : '',
                    customer_name: order.customer?.display_name || order.customer?.name || '',
                    sales_rep_id: order.sales_reps?.[0]?.id ? String(order.sales_reps[0].id) : '',
                    sales_rep_name: getSalesRepName(order),
                    total_amount: order.total?.amount || 0,
                    paid: order.paid === true,
                    paid_date: order.paid_date || null,
                    created_on: order.created_on,
                    status: order.status || '',
                    order_json: JSON.stringify(order),
                    synced_at: new Date().toISOString()
                }));

                // Upsert orders in batches
                const batchSize = 50;
                for (let i = 0; i < orderRecords.length; i += batchSize) {
                    const batchRaw = orderRecords.slice(i, i + batchSize);
                    // Extra dedup safety within each batch
                    const batch = [...new Map(batchRaw.map(r => [r.order_id, r])).values()];
                    const { error } = await supabaseClient
                        .from('sales_data_cache')
                        .upsert(batch, { onConflict: 'order_id' });

                    if (error) {
                        console.error('Error saving sales data batch:', error);
                    }
                }

                // Calculate and save monthly summaries
                await saveMonthlySummariesToSupabase(orders);

                // Update cache metadata
                await supabaseClient
                    .from('cache_metadata')
                    .upsert({
                        cache_key: 'sales_data',
                        last_sync: new Date().toISOString(),
                        record_count: orderRecords.length
                    }, { onConflict: 'cache_key' });

                lastSupabaseSync = new Date();
                updateCacheStatusDisplay();
                console.log(`Saved ${orderRecords.length} sales records to Supabase`);
                return true;
            } catch (error) {
                console.error('Error saving sales data to Supabase:', error);
                return false;
            }
        }

        // Get sales rep name from order
        function getSalesRepName(order) {
            if (!order.sales_reps || !Array.isArray(order.sales_reps) || order.sales_reps.length === 0) {
                return '';
            }
            const rep = order.sales_reps[0];
            if (rep.user) {
                return typeof rep.user === 'string' ? rep.user : (rep.user.name || rep.user.first_name || '');
            }
            return '';
        }

        // Save monthly summaries to Supabase
        async function saveMonthlySummariesToSupabase(orders) {
            if (!supabaseClient) return;

            try {
                // Group by month
                const monthlyData = {};
                orders.forEach(order => {
                    const date = new Date(order.created_on);
                    const year = date.getFullYear();
                    const month = date.getMonth();
                    const key = `${year}-${month}`;

                    if (!monthlyData[key]) {
                        monthlyData[key] = {
                            year,
                            month,
                            sales_rep_id: 'all',
                            total_orders: 0,
                            total_revenue: 0,
                            paid_revenue: 0,
                            new_customers: 0
                        };
                    }

                    monthlyData[key].total_orders++;
                    monthlyData[key].total_revenue += order.total?.amount || 0;
                    if (order.paid === true) {
                        monthlyData[key].paid_revenue += order.total?.amount || 0;
                    }
                });

                // Calculate commission
                const summaries = Object.values(monthlyData).map(data => ({
                    ...data,
                    commission: data.paid_revenue * COMMISSION_RATE,
                    synced_at: new Date().toISOString()
                }));

                // Upsert summaries
                if (summaries.length > 0) {
                    const { error } = await supabaseClient
                        .from('sales_monthly_summary')
                        .upsert(summaries, { onConflict: 'year,month,sales_rep_id' });

                    if (error) {
                        console.error('Error saving monthly summaries:', error);
                    }
                }

                cachedMonthlyData = summaries;
            } catch (error) {
                console.error('Error saving monthly summaries:', error);
            }
        }

        // Load sales data from Supabase
        async function loadSalesDataFromSupabase() {
            if (!supabaseClient) return null;

            try {
                // Check cache freshness
                const { data: metadata } = await supabaseClient
                    .from('cache_metadata')
                    .select('last_sync, record_count')
                    .eq('cache_key', 'sales_data')
                    .single();

                if (!metadata || !metadata.last_sync) return null;

                const cacheAge = Date.now() - new Date(metadata.last_sync).getTime();
                if (cacheAge > SUPABASE_CACHE_DURATION) {
                    console.log('Supabase sales cache is stale');
                    return { stale: true };
                }

                // Load cached orders
                const { data, error } = await supabaseClient
                    .from('sales_data_cache')
                    .select('order_json')
                    .order('created_on', { ascending: false });

                if (error || !data) return null;

                // Parse order JSON
                const orders = data.map(record => JSON.parse(record.order_json));

                lastSupabaseSync = new Date(metadata.last_sync);
                console.log(`Loaded ${orders.length} sales records from Supabase`);
                return { data: orders, lastSync: metadata.last_sync };
            } catch (error) {
                console.error('Error loading sales data from Supabase:', error);
                return null;
            }
        }

        // Load monthly summaries from Supabase (faster for charts)
        async function loadMonthlySummariesFromSupabase() {
            if (!supabaseClient) return null;

            try {
                const { data, error } = await supabaseClient
                    .from('sales_monthly_summary')
                    .select('*')
                    .eq('sales_rep_id', 'all')
                    .order('year', { ascending: false })
                    .order('month', { ascending: false })
                    .limit(12);

                if (error || !data) return null;

                return data;
            } catch (error) {
                console.error('Error loading monthly summaries:', error);
                return null;
            }
        }

        // Force sync to Supabase
        async function forceSyncSalesData() {
            const statusEl = document.getElementById('cacheStatusText');
            if (statusEl) statusEl.textContent = 'Syncing...';

            try {
                // Sync drop calendar
                if (dropCalendarData && dropCalendarData.length > 0) {
                    await saveDropCalendarToSupabase(dropCalendarData);
                }

                // Sync sales data
                if (allLeafLinkOrders && allLeafLinkOrders.length > 0) {
                    await saveSalesDataToSupabase(allLeafLinkOrders);
                }

                updateCacheStatusDisplay();
            } catch (error) {
                console.error('Error during force sync:', error);
                if (statusEl) statusEl.textContent = 'Sync failed';
            }
        }

        // Update cache status display
        function updateCacheStatusDisplay() {
            const statusEl = document.getElementById('cacheStatusText');
            if (!statusEl) return;

            if (lastSupabaseSync) {
                const age = Math.round((Date.now() - lastSupabaseSync.getTime()) / 60000);
                statusEl.textContent = `Last synced: ${age} min ago (${allLeafLinkOrders?.length || 0} orders)`;
                statusEl.style.color = age < 30 ? 'var(--accent-green)' : 'var(--accent-orange)';
            } else {
                statusEl.textContent = 'Not synced to cloud yet';
                statusEl.style.color = 'var(--text-secondary)';
            }
        }

        // ==================== BAR CHART RENDERING ====================

        // Set chart type
        function setSalesChartType(type) {
            salesChartType = type;

            // Update button styles
            document.getElementById('chartTypeRevenue').style.background = type === 'revenue' ? 'var(--accent-orange)' : 'var(--bg-tertiary)';
            document.getElementById('chartTypeOrders').style.background = type === 'orders' ? 'var(--accent-green)' : 'var(--bg-tertiary)';

            renderSalesBarChart();
        }

        // Render sales bar chart (CSS-based, no external dependencies)
        function renderSalesBarChart() {
            const container = document.getElementById('salesBarChart');
            if (!container) return;

            // Group orders by month (last 6 months)
            const monthlyData = {};
            const now = new Date();

            // Initialize last 6 months
            for (let i = 5; i >= 0; i--) {
                const date = new Date(now.getFullYear(), now.getMonth() - i, 1);
                const key = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                monthlyData[key] = {
                    year: date.getFullYear(),
                    month: date.getMonth(),
                    orders: 0,
                    revenue: 0,
                    paidRevenue: 0,
                    commission: 0
                };
            }

            // Populate with actual data
            if (allLeafLinkOrders && allLeafLinkOrders.length > 0) {
                allLeafLinkOrders.forEach(order => {
                    const date = new Date(order.created_on);
                    const key = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;

                    if (monthlyData[key]) {
                        monthlyData[key].orders++;
                        monthlyData[key].revenue += order.total?.amount || 0;
                        if (order.paid === true) {
                            monthlyData[key].paidRevenue += order.total?.amount || 0;
                        }
                    }
                });
            }

            // Calculate commission
            Object.values(monthlyData).forEach(data => {
                data.commission = data.paidRevenue * COMMISSION_RATE;
            });

            // Get sorted months
            const sortedMonths = Object.keys(monthlyData).sort();

            // Determine max value based on chart type
            let maxValue = 0;
            let valueKey = 'revenue';
            let valueLabel = 'Revenue';
            let valueColor = '#FFD700';
            let valuePrefix = '$';

            switch (salesChartType) {
                case 'orders':
                    valueKey = 'orders';
                    valueLabel = 'Orders';
                    valueColor = '#39ff14';
                    valuePrefix = '';
                    break;
                default:
                    valueKey = 'revenue';
                    valueLabel = 'Revenue';
                    valueColor = '#ff6b00';
                    valuePrefix = '$';
            }

            sortedMonths.forEach(key => {
                const value = monthlyData[key][valueKey];
                if (value > maxValue) maxValue = value;
            });

            if (maxValue === 0) maxValue = 1; // Prevent division by zero

            // Build chart HTML
            const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

            // Detect mobile viewport for responsive styling
            const isMobile = window.innerWidth <= 768;
            const isSmallMobile = window.innerWidth <= 480;
            const chartHeight = isSmallMobile ? 140 : (isMobile ? 160 : 180);
            const chartGap = isSmallMobile ? 2 : (isMobile ? 4 : 8);
            const labelFontSize = isSmallMobile ? '0.6rem' : (isMobile ? '0.65rem' : '0.7rem');
            const monthFontSize = isSmallMobile ? '0.65rem' : '0.75rem';

            // Helper function to abbreviate numbers on mobile
            function formatValueForDisplay(val, prefix, isOrders) {
                if (isOrders) {
                    return prefix + val;
                }
                if (isMobile && val >= 1000) {
                    const k = val / 1000;
                    return prefix + k.toFixed(k >= 10 ? 0 : 1) + 'K';
                }
                return prefix + val.toLocaleString(undefined, {minimumFractionDigits: 0, maximumFractionDigits: 0});
            }

            let html = `
                <div style="display: flex; align-items: flex-end; justify-content: space-between; height: ${chartHeight}px; padding: 10px 0; gap: ${chartGap}px;">
            `;

            sortedMonths.forEach(key => {
                const data = monthlyData[key];
                const value = data[valueKey];
                const heightPercent = Math.max((value / maxValue) * 100, 2);
                const monthLabel = monthNames[data.month];

                // Full display value for tooltip
                const fullDisplayValue = valuePrefix + (valueKey === 'orders'
                    ? value
                    : value.toLocaleString(undefined, {minimumFractionDigits: 0, maximumFractionDigits: 0}));

                // Abbreviated display value for bar label
                const displayValue = formatValueForDisplay(value, valuePrefix, valueKey === 'orders');

                // On very small screens, hide value labels (users can tap to see tooltip)
                const showValueLabel = !isSmallMobile || value > 0;
                const valueLabelOpacity = isSmallMobile ? '0.85' : '1';

                html += `
                    <div style="flex: 1; display: flex; flex-direction: column; align-items: center; height: 100%; min-width: 0;">
                        <div style="flex: 1; display: flex; align-items: flex-end; width: 100%;">
                            <div style="
                                width: 100%;
                                height: ${heightPercent}%;
                                background: linear-gradient(to top, ${valueColor}, ${valueColor}aa);
                                border-radius: ${isMobile ? '4px 4px 0 0' : '6px 6px 0 0'};
                                position: relative;
                                min-height: 4px;
                                transition: all 0.3s ease;
                                cursor: pointer;
                            "
                            onmouseover="this.style.transform='scaleY(1.02)'; this.style.boxShadow='0 -4px 12px ${valueColor}40';"
                            onmouseout="this.style.transform='scaleY(1)'; this.style.boxShadow='none';"
                            title="${monthLabel} ${data.year}: ${fullDisplayValue}">
                                ${showValueLabel ? `<div style="
                                    position: absolute;
                                    top: -22px;
                                    left: 50%;
                                    transform: translateX(-50%);
                                    font-size: ${labelFontSize};
                                    font-weight: 600;
                                    color: ${valueColor};
                                    white-space: nowrap;
                                    opacity: ${valueLabelOpacity};
                                    text-shadow: 0 1px 2px rgba(0,0,0,0.5);
                                ">${displayValue}</div>` : ''}
                            </div>
                        </div>
                        <div style="margin-top: ${isMobile ? '6px' : '8px'}; font-size: ${monthFontSize}; color: var(--text-secondary); font-weight: 500;">
                            ${monthLabel}
                        </div>
                    </div>
                `;
            });

            html += `</div>`;

            // Add total summary
            const totalValue = sortedMonths.reduce((sum, key) => sum + monthlyData[key][valueKey], 0);
            const avgValue = totalValue / sortedMonths.length;

            // Format summary values (abbreviated on mobile)
            const formattedTotal = formatValueForDisplay(totalValue, valuePrefix, valueKey === 'orders');
            const formattedAvg = formatValueForDisplay(Math.round(avgValue), valuePrefix, valueKey === 'orders');
            const summaryFontSize = isSmallMobile ? '0.95rem' : '1.1rem';
            const summaryLabelSize = isSmallMobile ? '0.7rem' : '0.75rem';

            html += `
                <div style="display: flex; justify-content: space-around; padding: ${isSmallMobile ? '10px' : '15px'} 0; border-top: 1px solid var(--border-color); margin-top: 10px;">
                    <div style="text-align: center;">
                        <div style="font-size: ${summaryLabelSize}; color: var(--text-secondary);">6-Month Total</div>
                        <div style="font-size: ${summaryFontSize}; font-weight: 700; color: ${valueColor};">
                            ${formattedTotal}
                        </div>
                    </div>
                    <div style="text-align: center;">
                        <div style="font-size: ${summaryLabelSize}; color: var(--text-secondary);">Monthly Avg</div>
                        <div style="font-size: ${summaryFontSize}; font-weight: 700; color: ${valueColor};">
                            ${formattedAvg}
                        </div>
                    </div>
                </div>
            `;

            container.innerHTML = html;
        }

        // Re-render chart on window resize for responsive behavior
        let salesChartResizeTimeout;
        window.addEventListener('resize', function() {
            clearTimeout(salesChartResizeTimeout);
            salesChartResizeTimeout = setTimeout(function() {
                if (document.getElementById('salesBarChart')) {
                    renderSalesBarChart();
                }
            }, 250);
        });

        // ==================== ENHANCED DATA LOADING WITH SUPABASE ====================

        // Enhanced loadDropCalendar with Supabase caching
        const originalLoadDropCalendar = loadDropCalendar;
        loadDropCalendar = async function() {
            const content = document.getElementById('dropCalendarContent');

            // Try to load from Supabase first
            const cached = await loadDropCalendarFromSupabase();
            if (cached && cached.data && !cached.stale) {
                dropCalendarData = cached.data;
                updateDropStats();
                renderCalendarView();
                console.log('Using Supabase cached drop calendar data');
                return;
            }

            // Show loading state
            content.innerHTML = '<div style="text-align: center; padding: 60px; color: var(--text-secondary);"><div style="font-size: 2rem; margin-bottom: 10px;">...</div>Loading drop data from LeafLink...</div>';

            try {
                const twoMonthsAgo = new Date();
                twoMonthsAgo.setMonth(twoMonthsAgo.getMonth() - 2);
                const dateFilter = twoMonthsAgo.toISOString().split('T')[0];

                let allOrders = [];
                let nextUrl = `${LEAFLINK_PROXY_URL}/orders-received/?status=Accepted&status=Shipped&status=Complete&created_on__gte=${dateFilter}&page_size=100`;

                while (nextUrl) {
                    const response = await fetch(nextUrl);
                    if (!response.ok) throw new Error('API request failed');
                    const data = await response.json();
                    allOrders = allOrders.concat(data.results);
                    nextUrl = data.next;
                    if (allOrders.length > 500) break;
                }

                dropCalendarData = processDropData(allOrders);
                updateDropStats();
                renderCalendarView();

                // Save to Supabase in background
                saveDropCalendarToSupabase(dropCalendarData);

            } catch (error) {
                console.error('Error loading drop calendar:', error);

                // Try to use stale Supabase data as fallback
                if (cached && cached.stale) {
                    const staleData = await loadDropCalendarFromSupabase();
                    if (staleData && staleData.data) {
                        dropCalendarData = staleData.data;
                        updateDropStats();
                        renderCalendarView();
                        content.insertAdjacentHTML('afterbegin',
                            '<div style="background: var(--accent-orange); color: #000; padding: 10px; border-radius: 8px; margin-bottom: 15px; text-align: center;">Using cached data (API unavailable)</div>');
                        return;
                    }
                }

                content.innerHTML = `<div style="text-align: center; padding: 60px; color: var(--accent-red);">
                    <div style="font-size: 2rem; margin-bottom: 10px;">X</div>
                    Error loading data: ${error.message}
                </div>`;
            }
        };

        // Enhanced loadSalesDashboard with Supabase caching
        const originalLoadSalesDashboard = loadSalesDashboard;
        loadSalesDashboard = async function() {
            try {
                // If we already have good data in memory, just update display
                if (allLeafLinkOrders && allLeafLinkOrders.length > 10) {
                    console.log("Using existing in-memory data:", allLeafLinkOrders.length, "orders");
                } else {
                    // Skip Supabase cache - use localStorage/API instead
                    const cached = null; // await loadSalesDataFromSupabase();
                    if (false && cached && cached.data && !cached.stale && cached.data.length > 0) {
                    allLeafLinkOrders = cached.data;
                    customerFirstOrderDates = buildCustomerFirstOrderDates(cached.data);
                    leafLinkDataLoaded = true;
                    console.log('Using Supabase cached sales data');
                } else {
                    // Fetch fresh data
                    await ensureLeafLinkData();

                    // Save to Supabase in background
                    if (allLeafLinkOrders && allLeafLinkOrders.length > 0) {
                        saveSalesDataToSupabase(allLeafLinkOrders);
                    }
                }
                }

                // Populate sales rep dropdown
                const salesReps = extractSalesReps(allLeafLinkOrders);
                const dropdown = document.getElementById('salesRepFilter');
                if (dropdown) {
                    dropdown.innerHTML = '<option value="all">All Sales Reps</option>';
                    salesReps.forEach(rep => {
                        const option = document.createElement('option');
                        option.value = rep.id;
                        option.textContent = rep.name;
                        dropdown.appendChild(option);
                    });
                }

                updateSalesDashboard();
                renderSalesBarChart();
                updateCacheStatusDisplay();

            } catch (error) {
                console.error('Error loading sales dashboard:', error);
            }
        };

        // Periodic sync (every 30 minutes)
        setInterval(async () => {
            if (supabaseClient && allLeafLinkOrders && allLeafLinkOrders.length > 0) {
                console.log('Running periodic Supabase sync...');
                await saveSalesDataToSupabase(allLeafLinkOrders);
                if (dropCalendarData && dropCalendarData.length > 0) {
                    await saveDropCalendarToSupabase(dropCalendarData);
                }
            }
        }, 30 * 60 * 1000);


        // ============================================
        // TIME CLOCK SYSTEM
        // ============================================

        // Authorized work IPs - add your work IP addresses here
        // For testing, Ryan (admin) can bypass IP check
        const AUTHORIZED_IPS = [
            '75.70.251.65'  // Work location IP
        ];

        // Pay period configuration - paydays are every 2 weeks on Friday
        // Pay periods run Saturday to Friday
        const PAY_PERIOD_CONFIG = {
            basePayday: new Date('2025-01-11'), // Saturday after a payday (aligns Sat-Fri periods)
            periodDays: 14 // Bi-weekly
        };

        let currentUserIP = null;
        let ipVerified = false;
        let clockUpdateInterval = null;

        // Setup timeclock table in Supabase
        async function setupTimeclockTable() {
            if (!supabaseClient) return;

            // Check if table exists by trying to query it
            const { data, error } = await supabaseClient
                .from('timeclock')
                .select('id')
                .limit(1);

            if (error && error.code === '42P01') {
                // Table does not exist - show instructions
                console.log('Timeclock table needs to be created. SQL:');
                console.log(`
CREATE TABLE timeclock (
    id SERIAL PRIMARY KEY,
    user_name TEXT NOT NULL,
    user_role TEXT NOT NULL,
    punch_type TEXT NOT NULL CHECK (punch_type IN ('in', 'out')),
    punch_time TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    ip_address TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_timeclock_user ON timeclock(user_name, punch_time);
CREATE INDEX idx_timeclock_date ON timeclock(punch_time);
                `);
            }
        }

        // Get current pay period dates
        // Note: Pay period ends 1 WEEK before payday (not the day before)
        // Staff are paid for "two weeks prior and one week prior, but not week of"
        function getPayPeriodDates(periodType = 'current') {
            const today = new Date();
            const basePayday = new Date(PAY_PERIOD_CONFIG.basePayday);
            const periodDays = PAY_PERIOD_CONFIG.periodDays;

            // Calculate days since base payday
            const daysSinceBase = Math.floor((today - basePayday) / (1000 * 60 * 60 * 24));

            // Find current period number
            let periodNumber = Math.floor(daysSinceBase / periodDays) + 1;
            if (daysSinceBase < 0) {
                periodNumber = Math.ceil(daysSinceBase / periodDays);
            }

            if (periodType === 'previous') {
                periodNumber -= 1;
            }

            // Calculate payday for this period
            const payday = new Date(basePayday);
            payday.setDate(basePayday.getDate() + (periodNumber * periodDays));

            // Period ends 1 week (7 days) before payday
            // Period is 14 days, so it starts 21 days before payday
            const periodEnd = new Date(payday);
            periodEnd.setDate(payday.getDate() - 7); // End 1 week before payday
            periodEnd.setHours(23, 59, 59, 999);

            const periodStart = new Date(periodEnd);
            periodStart.setDate(periodEnd.getDate() - periodDays + 1); // Go back 13 days for 14-day period
            periodStart.setHours(0, 0, 0, 0);

            return {
                start: periodStart,
                end: periodEnd,
                payday: payday
            };
        }

        // Verify user IP address
        async function verifyIP() {
            try {
                const response = await fetch('https://api.ipify.org?format=json');
                const data = await response.json();
                currentUserIP = data.ip;

                // Check if IP is authorized
                const isAuthorized = AUTHORIZED_IPS.includes(currentUserIP);

                // Admin (Ryan) bypass for testing
                const isAdmin = currentRole && currentRole.name.includes('Ryan');

                ipVerified = isAuthorized || isAdmin || AUTHORIZED_IPS.length === 0;

                // Update IP status display
                const ipStatusEl = document.getElementById('ipStatusText');
                if (ipStatusEl) {
                    if (AUTHORIZED_IPS.length === 0) {
                        ipStatusEl.textContent = 'No IP restrictions set (testing mode)';
                        ipStatusEl.style.color = 'var(--accent-blue)';
                    } else if (ipVerified) {
                        ipStatusEl.textContent = 'Verified - Work Location';
                        ipStatusEl.style.color = 'var(--accent-green)';
                    } else {
                        ipStatusEl.textContent = 'Not at work location (' + currentUserIP + ')';
                        ipStatusEl.style.color = 'var(--accent-red)';
                    }
                }

                return ipVerified;
            } catch (error) {
                console.error('IP verification error:', error);
                const ipStatusEl = document.getElementById('ipStatusText');
                if (ipStatusEl) {
                    ipStatusEl.textContent = 'Could not verify IP';
                    ipStatusEl.style.color = 'var(--accent-orange)';
                }
                // Allow clock in if IP check fails (for reliability)
                ipVerified = true;
                return true;
            }
        }

        // Get user clock status
        async function getUserClockStatus() {
            if (!supabaseClient || !currentRole) return null;

            try {
                const { data, error } = await supabaseClient
                    .from('timeclock')
                    .select('*')
                    .eq('user_name', currentRole.name)
                    .order('punch_time', { ascending: false })
                    .limit(1);

                if (error) throw error;

                if (data && data.length > 0) {
                    return data[0];
                }
                return null;
            } catch (error) {
                console.error('Error getting clock status:', error);
                return null;
            }
        }

        // Calculate hours between two timestamps
        function calculateHours(startTime, endTime) {
            const start = new Date(startTime);
            const end = new Date(endTime);
            const diffMs = end - start;
            return diffMs / (1000 * 60 * 60); // Convert to hours
        }

        // Get today's punches for a user
        async function getTodayPunches(userName) {
            if (!supabaseClient) return [];

            const today = new Date();
            today.setHours(0, 0, 0, 0);
            const tomorrow = new Date(today);
            tomorrow.setDate(tomorrow.getDate() + 1);

            try {
                const { data, error } = await supabaseClient
                    .from('timeclock')
                    .select('*')
                    .eq('user_name', userName)
                    .gte('punch_time', today.toISOString())
                    .lt('punch_time', tomorrow.toISOString())
                    .order('punch_time', { ascending: true });

                if (error) throw error;
                return data || [];
            } catch (error) {
                console.error('Error getting today punches:', error);
                return [];
            }
        }

        // Get pay period punches for a user
        async function getPayPeriodPunches(userName, periodType = 'current') {
            if (!supabaseClient) return [];

            const period = getPayPeriodDates(periodType);

            try {
                const { data, error } = await supabaseClient
                    .from('timeclock')
                    .select('*')
                    .eq('user_name', userName)
                    .gte('punch_time', period.start.toISOString())
                    .lte('punch_time', period.end.toISOString())
                    .order('punch_time', { ascending: true });

                if (error) throw error;
                return data || [];
            } catch (error) {
                console.error('Error getting pay period punches:', error);
                return [];
            }
        }

        // Calculate total hours from punch pairs
        function calculateTotalHours(punches) {
            let totalHours = 0;

            for (let i = 0; i < punches.length; i++) {
                if (punches[i].punch_type === 'in') {
                    // Find matching out punch
                    const nextPunch = punches[i + 1];
                    if (nextPunch && nextPunch.punch_type === 'out') {
                        totalHours += calculateHours(punches[i].punch_time, nextPunch.punch_time);
                        i++; // Skip the out punch
                    } else {
                        // Still clocked in - calculate to now
                        totalHours += calculateHours(punches[i].punch_time, new Date());
                    }
                }
            }

            return totalHours;
        }

        // Calculate weekly hours for overtime checking
        async function getWeeklyHours(userName) {
            if (!supabaseClient) return 0;

            // Get start of current week (Sunday)
            const now = new Date();
            const startOfWeek = new Date(now);
            startOfWeek.setDate(now.getDate() - now.getDay());
            startOfWeek.setHours(0, 0, 0, 0);

            try {
                const { data, error } = await supabaseClient
                    .from('timeclock')
                    .select('*')
                    .eq('user_name', userName)
                    .gte('punch_time', startOfWeek.toISOString())
                    .order('punch_time', { ascending: true });

                if (error) throw error;
                return calculateTotalHours(data || []);
            } catch (error) {
                console.error('Error getting weekly hours:', error);
                return 0;
            }
        }

        // ============================================
        // CURRENTLY CLOCKED IN TRACKING
        // ============================================

        let clockedInRefreshInterval = null;

        // Get all employees currently clocked in
        async function getCurrentlyClockedIn() {
            if (!supabaseClient) return [];

            try {
                // Get all unique users with their most recent punch
                const { data: allPunches, error } = await supabaseClient
                    .from('timeclock')
                    .select('*')
                    .order('punch_time', { ascending: false });

                if (error) throw error;

                // Group by user and get their latest punch
                const userLatestPunch = {};
                (allPunches || []).forEach(punch => {
                    if (!userLatestPunch[punch.user_name]) {
                        userLatestPunch[punch.user_name] = punch;
                    }
                });

                // Filter to only those clocked in
                const clockedIn = [];
                for (const [userName, punch] of Object.entries(userLatestPunch)) {
                    if (punch.punch_type === 'in') {
                        // Get today's punches to calculate hours worked today
                        const todayPunches = await getTodayPunches(userName);
                        const todayHours = calculateTotalHours(todayPunches);

                        clockedIn.push({
                            userName: userName,
                            clockInTime: punch.punch_time,
                            todayHours: todayHours
                        });
                    }
                }

                return clockedIn;
            } catch (error) {
                console.error('Error getting currently clocked in:', error);
                return [];
            }
        }

        // Render currently clocked in section
        async function renderCurrentlyClockedIn() {
            const container = document.getElementById('currentlyClockedInContainer');
            if (!container) return;

            const clockedIn = await getCurrentlyClockedIn();

            if (clockedIn.length === 0) {
                container.innerHTML = `
                    <div style="text-align: center; padding: 30px; color: var(--text-secondary);">
                        <div style="font-size: 2rem; margin-bottom: 10px;">No one currently clocked in</div>
                    </div>
                `;
                return;
            }

            let html = '<div style="display: grid; gap: 15px;">';

            clockedIn.forEach(employee => {
                const clockInTime = new Date(employee.clockInTime);
                const now = new Date();
                const hoursWorking = calculateHours(employee.clockInTime, now);

                const clockInStr = clockInTime.toLocaleTimeString('en-US', {
                    hour: '2-digit',
                    minute: '2-digit',
                    hour12: true
                });

                // Format hours and minutes working
                const hours = Math.floor(hoursWorking);
                const minutes = Math.floor((hoursWorking - hours) * 60);
                const workingStr = hours > 0 ? `${hours}h ${minutes}m` : `${minutes}m`;

                html += `
                    <div style="display: flex; justify-content: space-between; align-items: center; background: var(--bg-tertiary); padding: 15px 20px; border-radius: 10px; border-left: 4px solid var(--accent-green);">
                        <div>
                            <div style="font-weight: 600; color: var(--text-primary); font-size: 1.1rem;">${employee.userName}</div>
                            <div style="color: var(--text-secondary); font-size: 0.85rem;">Clocked in at ${clockInStr}</div>
                        </div>
                        <div style="text-align: right;">
                            <div style="font-size: 1.3rem; font-weight: 700; color: var(--accent-green);">${workingStr}</div>
                            <div style="color: var(--text-secondary); font-size: 0.8rem;">Today: ${employee.todayHours.toFixed(2)} hrs</div>
                        </div>
                    </div>
                `;
            });

            html += '</div>';

            // Add last updated timestamp
            const updateTime = new Date().toLocaleTimeString('en-US', {
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: true
            });
            html += `<div style="text-align: center; margin-top: 15px; color: var(--text-secondary); font-size: 0.8rem;">Last updated: ${updateTime}</div>`;

            container.innerHTML = html;
        }

        // Start auto-refresh for clocked in data
        function startClockedInRefresh() {
            // Initial load
            renderCurrentlyClockedIn();

            // Refresh every 45 seconds
            clockedInRefreshInterval = setInterval(() => {
                renderCurrentlyClockedIn();
            }, 45000);
        }

        // Stop auto-refresh
        function stopClockedInRefresh() {
            if (clockedInRefreshInterval) {
                clearInterval(clockedInRefreshInterval);
                clockedInRefreshInterval = null;
            }
        }

        // Open Time Clock Modal
        async function openTimeClockModal() {
            if (!currentRole) {
                alert('Please login first to use the time clock!');
                return;
            }

            document.getElementById('timeClockModal').style.display = 'block';
            document.getElementById('timeClockUserName').textContent = currentRole.name;

            // Start clock update
            updateCurrentTime();
            clockUpdateInterval = setInterval(updateCurrentTime, 1000);

            // Verify IP
            await verifyIP();

            // Update status
            await updateClockStatus();
        }

        // Close Time Clock Modal
        function closeTimeClockModal() {
            document.getElementById('timeClockModal').style.display = 'none';
            if (clockUpdateInterval) {
                clearInterval(clockUpdateInterval);
                clockUpdateInterval = null;
            }
        }

        // Update current time display
        function updateCurrentTime() {
            const now = new Date();
            const timeStr = now.toLocaleTimeString('en-US', {
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: true
            });
            const dateStr = now.toLocaleDateString('en-US', {
                weekday: 'long',
                year: 'numeric',
                month: 'long',
                day: 'numeric'
            });

            const timeEl = document.getElementById('currentTimeDisplay');
            const dateEl = document.getElementById('currentDateDisplay');
            if (timeEl) timeEl.textContent = timeStr;
            if (dateEl) dateEl.textContent = dateStr;
        }

        // Update clock status display
        async function updateClockStatus() {
            if (!currentRole) return;

            const lastPunch = await getUserClockStatus();
            const statusTextEl = document.getElementById('clockStatusText');
            const lastPunchEl = document.getElementById('clockLastPunch');
            const actionBtn = document.getElementById('clockActionBtn');
            const statusDisplay = document.getElementById('clockStatusDisplay');

            const isClockedIn = lastPunch && lastPunch.punch_type === 'in';

            if (isClockedIn) {
                statusTextEl.textContent = 'Clocked In';
                statusTextEl.style.color = 'var(--accent-green)';
                statusDisplay.style.borderLeft = '4px solid var(--accent-green)';

                actionBtn.textContent = 'CLOCK OUT';
                actionBtn.style.background = 'linear-gradient(135deg, var(--accent-orange), var(--accent-red))';
                actionBtn.style.borderColor = 'var(--accent-orange)';
                actionBtn.style.boxShadow = '0 10px 40px rgba(255, 107, 0, 0.4)';
            } else {
                statusTextEl.textContent = 'Clocked Out';
                statusTextEl.style.color = 'var(--accent-red)';
                statusDisplay.style.borderLeft = '4px solid var(--accent-red)';

                actionBtn.textContent = 'CLOCK IN';
                actionBtn.style.background = 'linear-gradient(135deg, var(--accent-green), #00aa00)';
                actionBtn.style.borderColor = 'var(--accent-green)';
                actionBtn.style.boxShadow = '0 10px 40px rgba(57, 255, 20, 0.4)';
            }

            // Update last punch time
            if (lastPunch) {
                const punchTime = new Date(lastPunch.punch_time);
                lastPunchEl.textContent = 'Last punch: ' + lastPunch.punch_type.toUpperCase() + ' at ' +
                    punchTime.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: true }) +
                    ' on ' + punchTime.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
            } else {
                lastPunchEl.textContent = 'No previous punches';
            }

            // Update hours
            await updateHoursDisplay();
        }

        // Update hours display
        async function updateHoursDisplay() {
            if (!currentRole) return;

            // Today's hours
            const todayPunches = await getTodayPunches(currentRole.name);
            const todayHours = calculateTotalHours(todayPunches);
            document.getElementById('todayHours').textContent = todayHours.toFixed(2);

            // Pay period hours
            const periodPunches = await getPayPeriodPunches(currentRole.name);
            const periodHours = calculateTotalHours(periodPunches);
            document.getElementById('payPeriodHours').textContent = periodHours.toFixed(2);
        }

        // Perform clock action (in or out)
        async function performClockAction() {
            if (!currentRole || !supabaseClient) {
                alert('Please login first!');
                return;
            }

            // Check IP verification
            if (!ipVerified && AUTHORIZED_IPS.length > 0) {
                const isAdmin = currentRole.name.includes('Ryan');
                if (!isAdmin) {
                    alert('You must be at the work location to clock in/out.\n\nYour IP: ' + currentUserIP);
                    return;
                }
            }

            const lastPunch = await getUserClockStatus();
            const isClockedIn = lastPunch && lastPunch.punch_type === 'in';
            const newPunchType = isClockedIn ? 'out' : 'in';

            // Get role key from currentRole
            let roleKey = 'unknown';
            for (const [key, role] of Object.entries(ROLES)) {
                if (role.name === currentRole.name) {
                    roleKey = key;
                    break;
                }
            }

            try {
                const { data, error } = await supabaseClient
                    .from('timeclock')
                    .insert([{
                        user_name: currentRole.name,
                        user_role: roleKey,
                        punch_type: newPunchType,
                        punch_time: new Date().toISOString(),
                        ip_address: currentUserIP || 'unknown'
                    }]);

                if (error) throw error;

                // Update display
                await updateClockStatus();

                // Check for overtime on clock out
                if (newPunchType === 'out') {
                    await checkOvertime();
                }

                // Show success feedback
                const actionBtn = document.getElementById('clockActionBtn');
                const originalText = actionBtn.textContent;
                actionBtn.textContent = 'SUCCESS!';
                setTimeout(() => {
                    updateClockStatus();
                }, 1000);

            } catch (error) {
                console.error('Clock action error:', error);
                alert('Error recording punch. Please try again.\n\n' + error.message);
            }
        }

        // Check for overtime and show alert
        async function checkOvertime() {
            if (!currentRole) return;

            const todayPunches = await getTodayPunches(currentRole.name);
            const todayHours = calculateTotalHours(todayPunches);
            const weeklyHours = await getWeeklyHours(currentRole.name);

            let alertMessage = null;

            if (todayHours > 8) {
                alertMessage = 'Daily overtime alert!\n\nYou have worked ' + todayHours.toFixed(2) + ' hours today (over 8 hours).';
            }

            if (weeklyHours > 40) {
                const overtimeWeekly = weeklyHours - 40;
                if (alertMessage) {
                    alertMessage += '\n\n';
                } else {
                    alertMessage = '';
                }
                alertMessage += 'Weekly overtime alert!\n\nYou have worked ' + weeklyHours.toFixed(2) + ' hours this week (' + overtimeWeekly.toFixed(2) + ' overtime hours).';
            }

            if (alertMessage) {
                showOvertimeAlert(alertMessage);
            }
        }

        // Show overtime alert modal
        function showOvertimeAlert(message) {
            document.getElementById('overtimeAlertMessage').textContent = message;
            document.getElementById('overtimeAlertModal').style.display = 'block';
        }

        // Close overtime alert
        function closeOvertimeAlert() {
            document.getElementById('overtimeAlertModal').style.display = 'none';
        }

        // ============================================
        // ADMIN TIMECARD FUNCTIONS
        // ============================================

        // Open Timecards Modal (Admin only)
        async function openTimecardsModal() {
            // Check if user is admin (Ryan)
            if (!currentRole || !currentRole.name.includes('Ryan')) {
                alert('Only administrators can view timecards.');
                return;
            }

            document.getElementById('timecardsModal').style.display = 'block';

            // Populate employee dropdown
            const select = document.getElementById('timecardEmployeeSelect');
            select.innerHTML = '<option value="">Select Employee...</option>';

            // Only show hourly employees (not salaried)
            for (const [key, role] of Object.entries(ROLES)) {
                if (role.salary) continue; // Skip salaried employees
                const option = document.createElement('option');
                option.value = role.name;
                option.textContent = role.name;
                select.appendChild(option);
            }

            // Update pay period display
            updatePayPeriodDisplay();

            // Start auto-refresh for currently clocked in section
            startClockedInRefresh();
        }

        // Close Timecards Modal
        function closeTimecardsModal() {
            document.getElementById('timecardsModal').style.display = 'none';
            // Stop auto-refresh when modal closes
            stopClockedInRefresh();
        }

        // ==================== DELETED BATCHES (TRASH) ====================

        let batchToDelete = null;

        // Open Trash Modal
        async function openTrashModal() {
            if (!currentRole || !currentRole.canEditBatches) {
                alert('You do not have permission to view deleted batches.');
                return;
            }

            document.getElementById('trashModal').style.display = 'block';
            await renderTrashBatches();
        }

        // Close Trash Modal
        function closeTrashModal() {
            document.getElementById('trashModal').style.display = 'none';
        }

        // Render deleted batches
        async function renderTrashBatches() {
            const container = document.getElementById('trashBatchesList');

            try {
                const { data: deletedBatches, error } = await supabaseClient
                    .from('wm_batches')
                    .select('*')
                    .eq('status', 'deleted')
                    .order('deleted_at', { ascending: false });

                if (error) throw error;

                if (!deletedBatches || deletedBatches.length === 0) {
                    container.innerHTML = `
                        <div style="text-align: center; padding: 60px; color: var(--text-secondary);">
                            <div style="font-size: 3rem; margin-bottom: 15px;">ðŸ—‘ï¸</div>
                            <div style="font-size: 1.1rem;">No deleted batches</div>
                            <div style="font-size: 0.9rem; margin-top: 5px;">Batches you delete will appear here</div>
                        </div>
                    `;
                    return;
                }

                container.innerHTML = deletedBatches.map(batch => `
                    <div style="background: var(--bg-tertiary); border-radius: 12px; padding: 20px; margin-bottom: 15px; border-left: 4px solid #ef4444;">
                        <div style="display: flex; justify-content: space-between; align-items: flex-start; gap: 15px;">
                            <div style="flex: 1;">
                                <div style="font-weight: 700; font-size: 1.2rem; color: #ef4444; margin-bottom: 8px;">
                                    ${batch.id}
                                </div>
                                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px; font-size: 0.9rem;">
                                    <div><span style="color: var(--text-secondary);">Strain:</span> ${batch.strain || 'N/A'}</div>
                                    <div><span style="color: var(--text-secondary);">License:</span> ${batch.cultivation_license || 'N/A'}</div>
                                    <div><span style="color: var(--text-secondary);">Intake:</span> ${batch.intake_date || 'N/A'}</div>
                                    <div><span style="color: var(--text-secondary);">Deleted:</span> ${batch.deleted_at ? new Date(batch.deleted_at).toLocaleDateString() : 'N/A'}</div>
                                </div>
                                ${batch.delete_note ? `
                                    <div style="margin-top: 12px; padding: 10px; background: rgba(239, 68, 68, 0.1); border-radius: 8px;">
                                        <div style="font-size: 0.8rem; color: var(--text-secondary); margin-bottom: 4px;">Reason for deletion:</div>
                                        <div style="color: var(--text-primary);">${batch.delete_note}</div>
                                    </div>
                                ` : ''}
                                <div style="margin-top: 8px; font-size: 0.85rem; color: var(--text-secondary);">
                                    Deleted by: ${batch.deleted_by || 'Unknown'}
                                </div>
                            </div>
                        </div>
                    </div>
                `).join('');

            } catch (error) {
                console.error('Error loading deleted batches:', error);
                container.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: #ef4444;">
                        Error loading deleted batches: ${error.message}
                    </div>
                `;
            }
        }

        // Open delete batch confirmation modal
        function openDeleteBatchModal(batchId) {
            if (!currentRole || !currentRole.canEditBatches) {
                alert('You do not have permission to delete batches.');
                return;
            }

            const batch = batches.find(b => b.id === batchId);
            if (!batch) {
                alert('Batch not found.');
                return;
            }

            batchToDelete = batch;
            document.getElementById('deleteBatchId').textContent = batch.id;
            document.getElementById('deleteBatchInfo').textContent = `${batch.strain || 'Unknown strain'} â€¢ ${batch.cultivation_license || 'No license'} â€¢ Status: ${batch.status}`;
            document.getElementById('deleteNoteInput').value = '';
            document.getElementById('deleteBatchModal').style.display = 'block';
        }

        // Close delete batch modal
        function closeDeleteBatchModal() {
            document.getElementById('deleteBatchModal').style.display = 'none';
            batchToDelete = null;
        }

        // Confirm and execute batch deletion
        async function confirmDeleteBatch() {
            if (!batchToDelete) return;

            const deleteNote = document.getElementById('deleteNoteInput').value.trim();
            if (!deleteNote) {
                alert('Please enter a reason for deleting this batch.');
                return;
            }

            try {
                const { error } = await supabaseClient
                    .from('wm_batches')
                    .update({
                        status: 'deleted',
                        deleted_at: new Date().toISOString(),
                        deleted_by: currentRole.name,
                        delete_note: deleteNote
                    })
                    .eq('id', batchToDelete.id);

                if (error) throw error;

                alert(`âœ… Batch ${batchToDelete.id} has been deleted.`);
                closeDeleteBatchModal();
                await loadBatches();

            } catch (error) {
                console.error('Error deleting batch:', error);
                alert('Error deleting batch: ' + error.message);
            }
        }

        // ==================== END DELETED BATCHES ====================

        // Update pay period display
        function updatePayPeriodDisplay() {
            const periodType = document.getElementById('timecardPayPeriodSelect').value;
            const period = getPayPeriodDates(periodType);

            const dateStr = period.start.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' }) +
                ' - ' + period.end.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });

            document.getElementById('timecardPeriodDates').textContent = dateStr;
        }

        // Load employee timecard
        async function loadEmployeeTimecard() {
            const employeeName = document.getElementById('timecardEmployeeSelect').value;
            const periodType = document.getElementById('timecardPayPeriodSelect').value;

            updatePayPeriodDisplay();

            if (!employeeName) {
                document.getElementById('timecardTableBody').innerHTML =
                    '<tr><td colspan="7" style="padding: 40px; text-align: center; color: var(--text-secondary);">Select an employee to view their timecard</td></tr>';
                document.getElementById('timecardSummary').style.display = 'none';
                return;
            }

            const punches = await getPayPeriodPunches(employeeName, periodType);
            renderTimecard(punches);
        }

        // Render timecard table
        function renderTimecard(punches) {
            const tbody = document.getElementById('timecardTableBody');
            const summary = document.getElementById('timecardSummary');

            if (!punches || punches.length === 0) {
                tbody.innerHTML = '<tr><td colspan="7" style="padding: 40px; text-align: center; color: var(--text-secondary);">No time records found for this period</td></tr>';
                summary.style.display = 'none';
                return;
            }

            // Group punches by date
            const punchsByDate = {};
            punches.forEach(punch => {
                const date = new Date(punch.punch_time).toLocaleDateString('en-US');
                if (!punchsByDate[date]) {
                    punchsByDate[date] = [];
                }
                punchsByDate[date].push(punch);
            });

            let html = '';
            let totalHours = 0;
            let totalDays = 0;

            // Sort dates
            const sortedDates = Object.keys(punchsByDate).sort((a, b) => new Date(a) - new Date(b));

            sortedDates.forEach(date => {
                const dayPunches = punchsByDate[date];
                const dayHours = calculateTotalHours(dayPunches);
                totalHours += dayHours;
                totalDays++;

                // Pair up in/out punches
                for (let i = 0; i < dayPunches.length; i++) {
                    const punch = dayPunches[i];
                    const punchTime = new Date(punch.punch_time);
                    const timeStr = punchTime.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: true });

                    if (punch.punch_type === 'in') {
                        const nextPunch = dayPunches[i + 1];
                        let outTime = '--';
                        let pairHours = 0;

                        if (nextPunch && nextPunch.punch_type === 'out') {
                            const outPunchTime = new Date(nextPunch.punch_time);
                            outTime = outPunchTime.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: true });
                            pairHours = calculateHours(punch.punch_time, nextPunch.punch_time);
                            i++; // Skip the out punch
                        } else {
                            // Still clocked in
                            outTime = '<span style="color: var(--accent-orange);">Still In</span>';
                            pairHours = calculateHours(punch.punch_time, new Date());
                        }

                        const isFirst = i === 0 || (i === 1 && dayPunches[0].punch_type === 'in');
                        html += '<tr style="border-bottom: 1px solid var(--border);">';
                        html += '<td style="padding: 12px; color: var(--text-primary);">' + (isFirst ? new Date(date).toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' }) : '') + '</td>';
                        html += '<td style="padding: 12px; text-align: center; color: var(--accent-green);">' + timeStr + '</td>';
                        html += '<td style="padding: 12px; text-align: center; color: var(--accent-orange);">' + outTime + '</td>';
                        html += '<td style="padding: 12px; text-align: right; color: var(--accent-blue);">' + pairHours.toFixed(2) + '</td>';
                        html += '<td style="padding: 12px; text-align: right; font-weight: 600; color: ' + (dayHours > 8 ? 'var(--accent-orange)' : 'var(--accent-green)') + ';">' + (isFirst ? dayHours.toFixed(2) : '') + '</td>';
                        // Check if this is a sick day
                        const isSickDay = punch.ip_address && punch.ip_address.includes('sick-day');
                        const sickDayNote = isSickDay ? '<span style="color: var(--accent-blue); font-weight: 600;">ðŸ¤’ Sick Day</span>' : '';
                        html += '<td style="padding: 12px; text-align: center;">' + sickDayNote + '</td>';

                        const outPunchId = (nextPunch && nextPunch.punch_type === 'out') ? nextPunch.id : 'null';
                        html += '<td style="padding: 12px; text-align: center;"><button onclick="openEditShiftModal(' + punch.id + ', ' + outPunchId + ')" style="padding: 6px 12px; background: var(--accent-blue); border: none; border-radius: 4px; color: white; cursor: pointer; font-size: 0.75rem;" title="Edit Shift">Edit</button></td>';
                        html += '</tr>';
                    }
                }
            });

            tbody.innerHTML = html;

            // Update summary
            const regularHours = Math.min(totalHours, 80); // Assuming 80 hours per pay period is regular
            const overtimeHours = Math.max(0, totalHours - 80);

            document.getElementById('summaryRegularHours').textContent = regularHours.toFixed(2);
            document.getElementById('summaryOvertimeHours').textContent = overtimeHours.toFixed(2);
            document.getElementById('summaryTotalHours').textContent = totalHours.toFixed(2);
            document.getElementById('summaryDaysWorked').textContent = totalDays;

            summary.style.display = 'block';
        }

        // Print/Export timecard
        // Edit punch time functions
        let currentEditPunch = null;
        
        async function openEditPunchModal(punchId) {
            // Fetch the punch record
            const { data: punch, error } = await supabaseClient
                .from('timeclock')
                .select('*')
                .eq('id', punchId)
                .single();
            
            if (error || !punch) {
                alert('Error loading punch record');
                return;
            }
            
            currentEditPunch = punch;
            
            // Populate modal
            document.getElementById('editPunchEmployee').textContent = punch.user_name;
            document.getElementById('editPunchType').innerHTML = punch.punch_type === 'in' 
                ? '<span style="color: var(--accent-green);">Clock In</span>' 
                : '<span style="color: var(--accent-orange);">Clock Out</span>';
            
            const punchTime = new Date(punch.punch_time);
            document.getElementById('editPunchOriginal').textContent = punchTime.toLocaleString();
            
            // Set datetime-local input value
            const localDateTime = new Date(punchTime.getTime() - punchTime.getTimezoneOffset() * 60000)
                .toISOString().slice(0, 16);
            document.getElementById('editPunchNewTime').value = localDateTime;
            document.getElementById('editPunchReason').value = '';
            document.getElementById('editPunchId').value = punchId;
            
            document.getElementById('editPunchModal').style.display = 'block';
        }
        
        function closeEditPunchModal() {
            document.getElementById('editPunchModal').style.display = 'none';
            currentEditPunch = null;
        }
        
        async function saveEditedPunch() {
            const punchId = document.getElementById('editPunchId').value;
            const newTimeInput = document.getElementById('editPunchNewTime').value;
            const reason = document.getElementById('editPunchReason').value.trim();
            
            if (!newTimeInput) {
                alert('Please select a new date and time');
                return;
            }
            
            if (!reason) {
                alert('Please provide a reason for this adjustment');
                return;
            }
            
            const newTime = new Date(newTimeInput).toISOString();
            const originalTime = currentEditPunch.punch_time;
            
            // Update the punch record
            const { error } = await supabaseClient
                .from('timeclock')
                .update({ punch_time: newTime })
                .eq('id', punchId);
            
            if (error) {
                console.error('Error updating punch:', error);
                alert('Error saving changes. The database may need additional columns. Please check console.');
                return;
            }
            
            alert('Punch time updated successfully!\n\nOriginal: ' + new Date(originalTime).toLocaleString() + '\nNew: ' + new Date(newTime).toLocaleString() + '\nReason: ' + reason);
            
            closeEditPunchModal();
            
            // Refresh the timecard
            const selectedEmployee = document.getElementById('timecardEmployeeSelect').value;
            if (selectedEmployee) {
                loadEmployeeTimecard(selectedEmployee);
            }
        }

        async function openAddClockOutModal(punchId) {
            const { data: punch, error } = await supabaseClient
                .from('timeclock')
                .select('*')
                .eq('id', punchId)
                .single();
            if (error || !punch) { alert('Error loading punch record'); return; }
            document.getElementById('addClockOutEmployee').textContent = punch.user_name;
            document.getElementById('addClockOutClockInTime').textContent = new Date(punch.punch_time).toLocaleString();
            const now = new Date();
            const localDateTime = new Date(now.getTime() - now.getTimezoneOffset() * 60000).toISOString().slice(0, 16);
            document.getElementById('addClockOutTime').value = localDateTime;
            document.getElementById('addClockOutClockInId').value = punchId;
            document.getElementById('addClockOutReason').value = '';
            document.getElementById('addClockOutModal').style.display = 'block';
        }

        function closeAddClockOutModal() {
            document.getElementById('addClockOutModal').style.display = 'none';
        }

        async function saveAddClockOut() {
            const clockInPunchId = document.getElementById('addClockOutClockInId').value;
            const clockOutTime = document.getElementById('addClockOutTime').value;
            const reason = document.getElementById('addClockOutReason').value.trim();
            if (!clockOutTime) { alert('Please select a clock out time'); return; }
            if (!reason) { alert('Please provide a reason'); return; }
            const { data: clockInPunch, error: fetchError } = await supabaseClient
                .from('timeclock')
                .select('*')
                .eq('id', clockInPunchId)
                .single();
            if (fetchError || !clockInPunch) { alert('Error loading clock-in record'); return; }
            const { error } = await supabaseClient
                .from('timeclock')
                .insert([{
                    user_name: clockInPunch.user_name,
                    user_role: clockInPunch.user_role,
                    punch_type: 'out',
                    punch_time: new Date(clockOutTime).toISOString(),
                    ip_address: 'admin-manual'
                }]);
            if (error) { alert('Error adding clock out: ' + error.message); return; }
            alert('Clock out added for ' + clockInPunch.user_name + '!\n\nTime: ' + new Date(clockOutTime).toLocaleString() + '\nReason: ' + reason);
            closeAddClockOutModal();
            const selectedEmployee = document.getElementById('timecardEmployeeSelect').value;
            if (selectedEmployee) { loadEmployeeTimecard(selectedEmployee); }
        }

        // Edit Shift functions
        async function openEditShiftModal(inPunchId, outPunchId) {
            const { data: inPunch, error: inError } = await supabaseClient
                .from('timeclock')
                .select('*')
                .eq('id', inPunchId)
                .single();
            if (inError || !inPunch) { alert('Error loading clock-in record'); return; }

            document.getElementById('editShiftEmployee').textContent = inPunch.user_name;
            document.getElementById('editShiftDate').textContent = new Date(inPunch.punch_time).toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric', year: 'numeric' });
            document.getElementById('editShiftInPunchId').value = inPunchId;
            document.getElementById('editShiftOutPunchId').value = outPunchId || '';

            const inTime = new Date(inPunch.punch_time);
            const inTimeLocal = new Date(inTime.getTime() - inTime.getTimezoneOffset() * 60000).toISOString().slice(0, 16);
            document.getElementById('editShiftInTime').value = inTimeLocal;

            if (outPunchId && outPunchId !== 'null') {
                const { data: outPunch, error: outError } = await supabaseClient
                    .from('timeclock')
                    .select('*')
                    .eq('id', outPunchId)
                    .single();
                if (outPunch) {
                    const outTime = new Date(outPunch.punch_time);
                    const outTimeLocal = new Date(outTime.getTime() - outTime.getTimezoneOffset() * 60000).toISOString().slice(0, 16);
                    document.getElementById('editShiftOutTime').value = outTimeLocal;
                }
            } else {
                document.getElementById('editShiftOutTime').value = '';
            }

            document.getElementById('editShiftReason').value = '';
            document.getElementById('editShiftModal').style.display = 'block';
        }

        function closeEditShiftModal() {
            document.getElementById('editShiftModal').style.display = 'none';
        }

        // Sick Day functions
        function openAddSickDayModal() {
            // Populate employee dropdown
            const select = document.getElementById('sickDayEmployee');
            select.innerHTML = '';
            Object.entries(ROLES).forEach(([key, role]) => {
                if (!role.isDemo && !role.salary) {
                    const option = document.createElement('option');
                    option.value = role.name;
                    option.textContent = role.displayName || role.name;
                    select.appendChild(option);
                }
            });

            // Set default date to today
            const today = new Date();
            const dateStr = today.toISOString().split('T')[0];
            document.getElementById('sickDayDate').value = dateStr;
            document.getElementById('sickDayHours').value = '8';
            document.getElementById('sickDayNotes').value = '';

            document.getElementById('addSickDayModal').style.display = 'block';
        }

        function closeAddSickDayModal() {
            document.getElementById('addSickDayModal').style.display = 'none';
        }

        async function saveSickDay() {
            const employeeName = document.getElementById('sickDayEmployee').value;
            const dateStr = document.getElementById('sickDayDate').value;
            const hours = parseFloat(document.getElementById('sickDayHours').value) || 8;
            const notes = document.getElementById('sickDayNotes').value.trim();

            if (!employeeName) { alert('Please select an employee'); return; }
            if (!dateStr) { alert('Please select a date'); return; }

            // Create clock in at 8am and clock out after X hours
            const clockInTime = new Date(dateStr + 'T08:00:00');
            const clockOutTime = new Date(clockInTime.getTime() + (hours * 60 * 60 * 1000));

            // Find the role to get user_role
            const roleEntry = Object.entries(ROLES).find(([key, role]) => role.name === employeeName);
            const userRole = roleEntry ? roleEntry[0] : 'unknown';

            // Insert clock in punch
            const { error: inError } = await supabaseClient
                .from('timeclock')
                .insert([{
                    user_name: employeeName,
                    user_role: userRole,
                    punch_type: 'in',
                    punch_time: clockInTime.toISOString(),
                    ip_address: 'sick-day' + (notes ? ': ' + notes : '')
                }]);

            if (inError) { alert('Error adding sick day clock in: ' + inError.message); return; }

            // Insert clock out punch
            const { error: outError } = await supabaseClient
                .from('timeclock')
                .insert([{
                    user_name: employeeName,
                    user_role: userRole,
                    punch_type: 'out',
                    punch_time: clockOutTime.toISOString(),
                    ip_address: 'sick-day' + (notes ? ': ' + notes : '')
                }]);

            if (outError) { alert('Error adding sick day clock out: ' + outError.message); return; }

            alert('âœ… Sick day added for ' + employeeName + '!\n\nDate: ' + new Date(dateStr).toLocaleDateString() + '\nHours: ' + hours);
            closeAddSickDayModal();

            // Refresh timecard if viewing
            const selectedEmployee = document.getElementById('timecardEmployeeSelect').value;
            if (selectedEmployee) { loadEmployeeTimecard(selectedEmployee); }
        }

        async function saveEditedShift() {
            const inPunchId = document.getElementById('editShiftInPunchId').value;
            const outPunchId = document.getElementById('editShiftOutPunchId').value;
            const newInTime = document.getElementById('editShiftInTime').value;
            const newOutTime = document.getElementById('editShiftOutTime').value;
            const reason = document.getElementById('editShiftReason').value.trim();

            if (!newInTime) { alert('Please enter a clock in time'); return; }
            if (!reason) { alert('Please provide a reason for the adjustment'); return; }

            // Update the clock in punch
            const { error: inError } = await supabaseClient
                .from('timeclock')
                .update({ punch_time: new Date(newInTime).toISOString() })
                .eq('id', inPunchId);
            if (inError) { alert('Error updating clock in: ' + inError.message); return; }

            // Handle clock out
            if (newOutTime) {
                if (outPunchId && outPunchId !== 'null' && outPunchId !== '') {
                    // Update existing out punch
                    const { error: outError } = await supabaseClient
                        .from('timeclock')
                        .update({ punch_time: new Date(newOutTime).toISOString() })
                        .eq('id', outPunchId);
                    if (outError) { alert('Error updating clock out: ' + outError.message); return; }
                } else {
                    // Create new out punch
                    const { data: inPunch } = await supabaseClient
                        .from('timeclock')
                        .select('*')
                        .eq('id', inPunchId)
                        .single();
                    if (inPunch) {
                        const { error: insertError } = await supabaseClient
                            .from('timeclock')
                            .insert([{
                                user_name: inPunch.user_name,
                                user_role: inPunch.user_role,
                                punch_type: 'out',
                                punch_time: new Date(newOutTime).toISOString(),
                                ip_address: 'admin-adjusted'
                            }]);
                        if (insertError) { alert('Error adding clock out: ' + insertError.message); return; }
                    }
                }
            }

            alert('Shift updated successfully!\n\nReason: ' + reason);
            closeEditShiftModal();
            const selectedEmployee = document.getElementById('timecardEmployeeSelect').value;
            if (selectedEmployee) { loadEmployeeTimecard(selectedEmployee); }
        }

        function printTimecard() {
            const employeeName = document.getElementById('timecardEmployeeSelect').value;
            if (!employeeName) {
                alert('Please select an employee first.');
                return;
            }

            const periodDates = document.getElementById('timecardPeriodDates').textContent;
            const table = document.getElementById('timecardTable').outerHTML;
            const summary = document.getElementById('timecardSummary').innerHTML;

            const printWindow = window.open('', '_blank');
            printWindow.document.write(`
                <!DOCTYPE html>
                <html>
                <head>
                    <title>Timecard - ${employeeName}</title>
                    <style>
                        body { font-family: Arial, sans-serif; padding: 20px; }
                        h1 { color: #333; }
                        h2 { color: #666; font-size: 1.2rem; }
                        table { width: 100%; border-collapse: collapse; margin: 20px 0; }
                        th, td { border: 1px solid #ddd; padding: 10px; text-align: left; }
                        th { background: #f5f5f5; }
                        .summary { margin-top: 30px; padding: 20px; background: #f9f9f9; border-radius: 8px; }
                        .summary h3 { margin-top: 0; }
                        @media print {
                            body { padding: 0; }
                            button { display: none; }
                        }
                    </style>
                </head>
                <body>
                    <h1>Employee Timecard</h1>
                    <h2>${employeeName}</h2>
                    <p>Pay Period: ${periodDates}</p>
                    ${table}
                    <div class="summary">
                        ${summary}
                    </div>
                    <button onclick="window.print()" style="margin-top: 20px; padding: 10px 20px; cursor: pointer;">Print</button>
                </body>
                </html>
            `);
            printWindow.document.close();
        }

        // Export all employee timecards as a single CSV file for payroll
        async function exportAllTimecards() {
            if (!supabaseClient) {
                alert('Database not connected');
                return;
            }

            const periodType = document.getElementById('timecardPayPeriodSelect').value;
            const period = getPayPeriodDates(periodType);

            const periodLabel = period.start.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }) +
                ' - ' + period.end.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });

            try {
                // Get all punches for the pay period
                const { data: allPunches, error } = await supabaseClient
                    .from('timeclock')
                    .select('*')
                    .gte('punch_time', period.start.toISOString())
                    .lte('punch_time', period.end.toISOString())
                    .order('user_name', { ascending: true })
                    .order('punch_time', { ascending: true });

                if (error) throw error;

                if (!allPunches || allPunches.length === 0) {
                    alert('No timecard data found for this pay period.');
                    return;
                }

                // Group by employee
                const employeeData = {};
                allPunches.forEach(punch => {
                    if (!employeeData[punch.user_name]) {
                        employeeData[punch.user_name] = [];
                    }
                    employeeData[punch.user_name].push(punch);
                });

                // Build CSV content
                let csv = 'PAYROLL EXPORT - ' + periodLabel + '\n';
                csv += 'Generated: ' + new Date().toLocaleString() + '\n\n';

                let grandTotalRegular = 0;
                let grandTotalOvertime = 0;

                for (const [employeeName, punches] of Object.entries(employeeData)) {
                    csv += '\n';
                    csv += '"EMPLOYEE: ' + employeeName + '"\n';
                    csv += 'Date,Clock In,Clock Out,Hours,Notes\n';

                    // Group by date
                    const punchesByDate = {};
                    punches.forEach(punch => {
                        const date = new Date(punch.punch_time).toLocaleDateString('en-US');
                        if (!punchesByDate[date]) punchesByDate[date] = [];
                        punchesByDate[date].push(punch);
                    });

                    let employeeTotalHours = 0;

                    for (const [date, dayPunches] of Object.entries(punchesByDate)) {
                        let dayHours = 0;

                        for (let i = 0; i < dayPunches.length; i++) {
                            const punch = dayPunches[i];
                            if (punch.punch_type === 'in') {
                                const inTime = new Date(punch.punch_time);
                                const inTimeStr = inTime.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });

                                let outTimeStr = 'Still In';
                                let pairHours = 0;

                                const nextPunch = dayPunches[i + 1];
                                if (nextPunch && nextPunch.punch_type === 'out') {
                                    const outTime = new Date(nextPunch.punch_time);
                                    outTimeStr = outTime.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
                                    pairHours = (outTime - inTime) / (1000 * 60 * 60);
                                    i++; // Skip out punch
                                }

                                dayHours += pairHours;
                                const sickNote = (punch.ip_address && punch.ip_address.includes('sick-day')) ? 'Sick Day' : '';
                                csv += '"' + date + '",' + inTimeStr + ',' + outTimeStr + ',' + pairHours.toFixed(2) + ',"' + sickNote + '"\n';
                            }
                        }

                        employeeTotalHours += dayHours;
                    }

                    const regularHours = Math.min(employeeTotalHours, 40);
                    const overtimeHours = Math.max(employeeTotalHours - 40, 0);

                    csv += '\n';
                    csv += 'TOTAL HOURS,' + employeeTotalHours.toFixed(2) + '\n';
                    csv += 'Regular (up to 40),' + regularHours.toFixed(2) + '\n';
                    csv += 'Overtime (over 40),' + overtimeHours.toFixed(2) + '\n';

                    grandTotalRegular += regularHours;
                    grandTotalOvertime += overtimeHours;
                }

                // Grand totals
                csv += '\n';
                csv += '"GRAND TOTALS"\n';
                csv += 'Total Regular Hours,' + grandTotalRegular.toFixed(2) + '\n';
                csv += 'Total Overtime Hours,' + grandTotalOvertime.toFixed(2) + '\n';
                csv += 'Total All Hours,' + (grandTotalRegular + grandTotalOvertime).toFixed(2) + '\n';

                // Download the file
                const blob = new Blob([csv], { type: 'text/csv' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'Payroll_' + period.start.toISOString().split('T')[0] + '_to_' + period.end.toISOString().split('T')[0] + '.csv';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                alert('Payroll export downloaded!\n\nFile includes all ' + Object.keys(employeeData).length + ' employees for ' + periodLabel);

            } catch (error) {
                console.error('Export error:', error);
                alert('Error exporting timecards: ' + error.message);
            }
        }

        // Export timecards in QuickBooks-compatible CSV format
        async function exportForQuickBooks() {
            if (!supabaseClient) {
                alert('Database not connected');
                return;
            }

            const periodType = document.getElementById('timecardPayPeriodSelect').value;
            const period = getPayPeriodDates(periodType);

            try {
                // Get all punches for the pay period
                const { data: allPunches, error } = await supabaseClient
                    .from('timeclock')
                    .select('*')
                    .gte('punch_time', period.start.toISOString())
                    .lte('punch_time', period.end.toISOString())
                    .order('user_name', { ascending: true })
                    .order('punch_time', { ascending: true });

                if (error) throw error;

                if (!allPunches || allPunches.length === 0) {
                    alert('No timecard data found for this pay period.');
                    return;
                }

                // QuickBooks Time Import CSV Header
                // Format: Employee, Date, Hours, Payroll Item, Customer:Job, Notes
                let csv = 'Employee,Date,Hours,Payroll Item,Service Item,Notes\n';

                // Group by employee
                const employeeData = {};
                allPunches.forEach(punch => {
                    if (!employeeData[punch.user_name]) {
                        employeeData[punch.user_name] = [];
                    }
                    employeeData[punch.user_name].push(punch);
                });

                let totalRows = 0;

                for (const [employeeName, punches] of Object.entries(employeeData)) {
                    // Remove role suffix for cleaner QB import (e.g., "Ryan (Admin)" -> "Ryan")
                    const cleanName = employeeName.replace(/\s*\([^)]*\)\s*/g, '').trim();

                    // Group by date
                    const punchesByDate = {};
                    punches.forEach(punch => {
                        const date = new Date(punch.punch_time).toLocaleDateString('en-US');
                        if (!punchesByDate[date]) punchesByDate[date] = [];
                        punchesByDate[date].push(punch);
                    });

                    for (const [date, dayPunches] of Object.entries(punchesByDate)) {
                        let dayHours = 0;

                        // Calculate total hours for the day
                        for (let i = 0; i < dayPunches.length; i++) {
                            const punch = dayPunches[i];
                            if (punch.punch_type === 'in') {
                                const inTime = new Date(punch.punch_time);
                                const nextPunch = dayPunches[i + 1];

                                if (nextPunch && nextPunch.punch_type === 'out') {
                                    const outTime = new Date(nextPunch.punch_time);
                                    dayHours += (outTime - inTime) / (1000 * 60 * 60);
                                    i++; // Skip out punch
                                }
                            }
                        }

                        if (dayHours > 0) {
                            // Determine if regular or overtime
                            // QuickBooks uses Payroll Items to distinguish
                            const regularHours = Math.min(dayHours, 8);
                            const overtimeHours = Math.max(dayHours - 8, 0);

                            // Add regular hours row
                            if (regularHours > 0) {
                                csv += `"${cleanName}",${date},${regularHours.toFixed(2)},Regular Pay,,Auto-imported from WM Tracker\n`;
                                totalRows++;
                            }

                            // Add overtime hours row (if any)
                            if (overtimeHours > 0) {
                                csv += `"${cleanName}",${date},${overtimeHours.toFixed(2)},Overtime,,Auto-imported from WM Tracker\n`;
                                totalRows++;
                            }
                        }
                    }
                }

                // Download the file
                const blob = new Blob([csv], { type: 'text/csv' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'QuickBooks_TimeImport_' + period.start.toISOString().split('T')[0] + '.csv';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                alert('QuickBooks import file downloaded!\n\n' + totalRows + ' time entries ready to import.\n\nTo import in QuickBooks:\n1. Go to Employees â†’ Enter Time â†’ Use Weekly Timesheet\n2. Or use File â†’ Utilities â†’ Import â†’ Timer Activities');

            } catch (error) {
                console.error('QB Export error:', error);
                alert('Error exporting for QuickBooks: ' + error.message);
            }
        }

        function toggleActionsMenu() {
            const dropdown = document.querySelector('.actions-dropdown');
            if (dropdown.style.display === 'block') {
                dropdown.style.display = 'none';
            } else {
                dropdown.style.display = 'block';
            }
        }

        // Initialize timeclock on page load
        async function initializeTimeclock() {
            if (supabaseClient) {
                await setupTimeclockTable();
            }
        }

        // ============================================
        // SALES PIPELINE FUNCTIONS
        // ============================================

        let pipelineData = [];
        let pipelineCategoryData = {};

        function openSalesPipelineModal() {
            document.getElementById('salesPipelineModal').style.display = 'block';
            document.body.style.overflow = 'hidden';
            loadSalesPipeline();
        }

        function closeSalesPipelineModal() {
            document.getElementById('salesPipelineModal').style.display = 'none';
            document.body.style.overflow = '';
        }

        function closePipelineStrainsPopup() {
            document.getElementById('pipelineStrainsPopup').style.display = 'none';
        }

        // Get sales percentage based on material agreement
        function getSalesPercentage(materialAgreement) {
            if (!materialAgreement) return 100;
            const agreement = materialAgreement.toLowerCase();
            if (agreement.includes('house') || agreement.includes('wholesale') || agreement === 'wholesale') return 100;
            if (agreement.includes('50') || agreement.includes('split') || agreement.includes('percentage')) return 50;
            if (agreement.includes('gram') || agreement.includes('buyback') || agreement.includes('buy back') || agreement.includes('buy-back')) return 0;
            return 100;
        }

        // Map product names to categories
        function getProductCategory(productMade) {
            if (!productMade) return null;
            const product = productMade.toLowerCase();

            if (product.includes('wax') && !product.includes('sugar')) return 'Wax';
            if (product.includes('sugar')) return 'Sugar Wax';
            if (product.includes('shatter')) return 'Shatter';
            if (product.includes('cart') || product === 'live resin oil') return 'Live Resin Carts';
            if (product.includes('aio') || product.includes('all-in-one') || product.includes('all in one')) return 'Live Resin AIOs';
            if (product.includes('brick') || product.includes('hash')) return 'Brick Hash';

            return null;
        }

        function loadSalesPipeline() {
            // If batches not loaded yet, retry after delay
            if (!batches || batches.length === 0) {
                console.log('Pipeline: batches not loaded yet, retrying in 2s...');
                setTimeout(loadSalesPipeline, 2000);
                return;
            }

            // Define the 6 product categories
            const categories = [
                { key: 'Wax', label: 'Wax', color: '#F59E0B' },
                { key: 'Shatter', label: 'Shatter', color: '#3B82F6' },
                { key: 'Sugar Wax', label: 'Sugar Wax', color: '#F97316' },
                { key: 'Live Resin Carts', label: 'Live Resin Carts', color: '#10B981' },
                { key: 'Live Resin AIOs', label: 'Live Resin AIOs', color: '#8B5CF6' },
                { key: 'Brick Hash', label: 'Brick Hash', color: '#6B7280' }
            ];

            // Initialize category data
            pipelineCategoryData = {};
            categories.forEach(cat => {
                pipelineCategoryData[cat.key] = { count: 0, strains: [], color: cat.color, label: cat.label };
            });

            // Filter batches in pipeline (extraction, finishing, packaging stages)
            pipelineData = batches.filter(batch => {
                const hasWeight = batch.final_weight || batch.net_weight || batch.grams_labeled;
                if (!hasWeight) return false;
                const salesPercent = getSalesPercentage(batch.material_agreement);
                if (salesPercent === 0) return false;
                const validStatuses = ['extraction', 'finishing', 'packaging'];
                return validStatuses.includes(batch.status);
            });

            // Group batches by category
            pipelineData.forEach(batch => {
                const category = getProductCategory(batch.product_made);
                if (category && pipelineCategoryData[category]) {
                    pipelineCategoryData[category].count++;
                    const weight = batch.final_weight || batch.net_weight || batch.grams_labeled || 0;
                    const salesPercent = getSalesPercentage(batch.material_agreement);
                    const availableGrams = (weight * salesPercent / 100).toFixed(1);
                    pipelineCategoryData[category].strains.push({
                        strain: batch.strain || 'Unknown',
                        strainType: batch.strain_type || 'Hybrid',
                        batchId: batch.id,
                        status: batch.status,
                        weight: weight,
                        availableGrams: availableGrams
                    });
                }
            });

            renderPipelineCategories();
        }

        function renderPipelineCategories() {
            const categoryOrder = ['Wax', 'Shatter', 'Sugar Wax', 'Live Resin Carts', 'Live Resin AIOs', 'Brick Hash'];

            const html = categoryOrder.map(key => {
                const data = pipelineCategoryData[key];
                const hasItems = data.count > 0;

                // Count by strain type
                const strainCounts = { Sativa: 0, Hybrid: 0, Indica: 0 };
                (data.strains || []).forEach(item => {
                    if (item.strainType) strainCounts[item.strainType]++;
                });

                // Calculate total grams
                const totalGrams = (data.strains || []).reduce((sum, s) => sum + (parseFloat(s.availableGrams) || 0), 0);

                return `
                    <button onclick="showPipelineStrains('${key}')" class="foh-btn" style="opacity: ${hasItems ? '1' : '0.5'};">
                        <div class="foh-btn-name">${data.label}</div>
                        <div class="foh-btn-num">${data.count}</div>
                        <div class="foh-btn-sub">${totalGrams.toFixed(0)}g</div>
                    </button>
                `;
            }).join('');

            // Render to both modal and inline
            const modalContainer = document.getElementById('pipelineCategoryGrid');
            const inlineContainer = document.getElementById('inlinePipelineGrid');
            if (modalContainer) modalContainer.innerHTML = html;
            if (inlineContainer) inlineContainer.innerHTML = html;
        }

        function showPipelineStrains(category) {
            const data = pipelineCategoryData[category];
            if (!data || data.count === 0) {
                return;
            }

            document.getElementById('pipelinePopupTitle').textContent = data.label + ' (' + data.count + ')';
            document.getElementById('pipelinePopupTitle').style.color = data.color;

            const contentEl = document.getElementById('pipelinePopupContent');

            // Group strains and count occurrences
            const strainCounts = {};
            let totalGrams = 0;
            data.strains.forEach(item => {
                const key = item.strain;
                if (!strainCounts[key]) {
                    strainCounts[key] = { count: 0, batches: [], grams: 0, strainType: item.strainType };
                }
                strainCounts[key].count++;
                strainCounts[key].batches.push({ id: item.batchId, grams: item.availableGrams });
                strainCounts[key].grams += parseFloat(item.availableGrams) || 0;
                totalGrams += parseFloat(item.availableGrams) || 0;
            });

            // Update title with total grams
            document.getElementById('pipelinePopupTitle').textContent = data.label + ' - ' + totalGrams.toFixed(1) + 'g';

            // Sort by strain type (Sativa, Hybrid, Indica), then by grams descending
            const strainOrder = { 'Sativa': 0, 'Hybrid': 1, 'Indica': 2 };
            const sortedStrains = Object.entries(strainCounts)
                .sort((a, b) => {
                    const typeA = strainOrder[a[1].strainType] ?? 1;
                    const typeB = strainOrder[b[1].strainType] ?? 1;
                    if (typeA !== typeB) return typeA - typeB;
                    return b[1].grams - a[1].grams;
                });

            // Get strain color based on type (Sativa=Red, Indica=Blue, Hybrid=Green)
            const getStrainColor = (type) => {
                if (type === 'Sativa') return '#ff0055';
                if (type === 'Indica') return '#0055ff';
                return '#39ff14'; // Hybrid default
            };

            contentEl.innerHTML = sortedStrains.map(([strain, info]) => {
                const strainColor = getStrainColor(info.strainType);
                return `
                <div style="padding: 12px 15px; background: var(--bg-primary); border-radius: 8px; margin-bottom: 10px; border-left: 3px solid ${strainColor}; box-shadow: 0 0 10px ${strainColor}33;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <span style="font-weight: 600; color: var(--text-primary);">${strain}</span>
                        <span style="background: ${strainColor}22; color: ${strainColor}; padding: 6px 12px; border-radius: 12px; font-size: 1.1rem; font-weight: 700;">${info.grams.toFixed(1)}g</span>
                    </div>
                </div>
            `;
            }).join('');

            document.getElementById('pipelineStrainsPopup').style.display = 'block';
        }

    </script>

    <!-- RTA Manager Modal -->
    <div id="rtaManagerModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); z-index: 10005; overflow-y: auto;">
        <div style="max-width: 800px; margin: 30px auto; background: var(--bg-secondary); border-radius: 20px; overflow: hidden;">
            <div style="background: linear-gradient(135deg, var(--accent-purple), var(--accent-blue)); padding: 25px; display: flex; justify-content: space-between; align-items: center;">
                <h2 style="margin: 0; color: white;">ðŸ“‹ RTA Qualification Manager</h2>
                <button onclick="closeRTAManager()" style="background: rgba(255,255,255,0.2); border: none; color: white; font-size: 1.5rem; cursor: pointer; padding: 5px 15px; border-radius: 8px;">&times;</button>
            </div>
            <div style="padding: 25px;">
                <!-- Status Overview Cards -->
                <div id="rtaStatusCards" style="margin-bottom: 25px;">
                    <!-- Populated by JS -->
                </div>

                <!-- 30-Day Compliance Reminders -->
                <div id="rtaReminder" style="margin-bottom: 25px;">
                    <!-- Populated by JS -->
                </div>

                <div style="background: var(--bg-tertiary); padding: 15px; border-radius: 10px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 10px; color: var(--accent-orange);">âš ï¸ Colorado MED RTA Requirements</h4>
                    <ul style="margin: 0; padding-left: 20px; color: var(--text-secondary); font-size: 0.9rem;">
                        <li><strong>Initial Qualification:</strong> 4 consecutive passing full panel batches within 4 weeks</li>
                        <li><strong>RTA Duration:</strong> Valid for 1 year from first passing batch</li>
                        <li><strong>Reauthorization (after fail):</strong> 5 consecutive passing batches required</li>
                        <li><strong>Ongoing:</strong> 1 full panel test every 30 days to maintain</li>
                    </ul>
                </div>
                <div id="rtaManagerContent">
                    <!-- Product type RTA cards populated by JS -->
                </div>
                <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid var(--bg-tertiary);">
                    <button class="btn" style="background: var(--accent-red);" onclick="resetAllRTA()">Reset All RTA Status</button>
                </div>
            </div>
        </div>
    </div>

    <!-- LeafLink Inventory Modal -->
    <!-- LeafLink Inventory Modal -->
    <div id="leafLinkInventoryModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); z-index: 10001; overflow-y: auto;">
        <div style="max-width: 800px; margin: 50px auto; background: var(--bg-secondary); border-radius: 20px; padding: 0; box-shadow: 0 20px 60px rgba(139, 92, 246, 0.4);">
            <!-- Header -->
            <div style="background: linear-gradient(135deg, #8B5CF6, #EC4899); padding: 25px 30px; border-radius: 20px 20px 0 0;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <h2 style="color: white; margin: 0; font-size: 1.5rem;">Inventory</h2>
                    <button onclick="closeLeafLinkInventoryModal()" style="background: rgba(255,255,255,0.2); border: none; color: white; font-size: 1.5rem; cursor: pointer; padding: 5px 12px; border-radius: 8px;">&times;</button>
                </div>
            </div>

            <!-- Content -->
            <div style="padding: 30px;">
                <!-- Product Category Grid -->
                <div id="inventoryCategoryGrid" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px;">
                    <!-- Populated dynamically -->
                </div>
            </div>
        </div>
    </div>

    <!-- Inventory Items Popup (matches Pipeline strains popup) -->
    <div id="inventoryItemsPopup" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); z-index: 10002; overflow-y: auto;">
        <div style="max-width: 500px; margin: 80px auto; background: var(--bg-secondary); border-radius: 16px; padding: 0; box-shadow: 0 20px 60px rgba(0,0,0,0.5);">
            <div style="background: var(--bg-tertiary); padding: 20px 25px; border-radius: 16px 16px 0 0; display: flex; justify-content: space-between; align-items: center;">
                <h3 id="inventoryPopupTitle" style="margin: 0; color: var(--text-primary); font-size: 1.2rem;">Items</h3>
                <button onclick="closeInventoryItemsPopup()" style="background: none; border: none; color: var(--text-secondary); font-size: 1.5rem; cursor: pointer;">&times;</button>
            </div>
            <div id="inventoryPopupContent" style="padding: 20px 25px; max-height: 400px; overflow-y: auto;">
            </div>
        </div>
    </div>

    <!-- Needs Modal -->
    <div id="needsModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); z-index: 10001; overflow-y: auto;">
        <div style="max-width: 800px; margin: 50px auto; background: var(--bg-secondary); border-radius: 20px; padding: 0; box-shadow: 0 20px 60px rgba(245, 158, 11, 0.4);">
            <div style="background: linear-gradient(135deg, #F59E0B, #EF4444); padding: 25px 30px; border-radius: 20px 20px 0 0;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <h2 style="color: white; margin: 0; font-size: 1.5rem;">Needs</h2>
                    <button onclick="closeNeedsModal()" style="background: rgba(255,255,255,0.2); border: none; color: white; font-size: 1.5rem; cursor: pointer; padding: 5px 12px; border-radius: 8px;">&times;</button>
                </div>
            </div>
            <div style="padding: 30px;">
                <div id="needsCategoryGrid" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px;"></div>
            </div>
        </div>
    </div>

    <!-- Needs Items Popup -->
    <div id="needsItemsPopup" style="display: none; position: fixed; bottom: 0; left: 0; right: 0; background: var(--bg-secondary); border-radius: 20px 20px 0 0; z-index: 10002; box-shadow: 0 -10px 40px rgba(0,0,0,0.5); max-height: 70vh;">
        <div style="background: var(--bg-tertiary); padding: 20px 25px; border-radius: 16px 16px 0 0; display: flex; justify-content: space-between; align-items: center;">
            <h3 id="needsPopupTitle" style="margin: 0; color: var(--text-primary); font-size: 1.2rem;">Needs</h3>
            <button onclick="closeNeedsItemsPopup()" style="background: none; border: none; color: var(--text-secondary); font-size: 1.5rem; cursor: pointer;">&times;</button>
        </div>
        <div id="needsPopupContent" style="padding: 20px 25px; max-height: 400px; overflow-y: auto;"></div>
    </div>

    <script>
    // ==================== LEAFLINK INVENTORY MANAGEMENT ====================

    let inventoryCategoryData = {};

    const inventoryCategories = [
        { key: 'Wax', label: 'Wax', color: '#FFD700', keywords: ['wax'] },
        { key: 'Shatter', label: 'Shatter', color: '#00CED1', keywords: ['shatter'] },
        { key: 'Sugar Wax', label: 'Sugar Wax', color: '#FF69B4', keywords: ['sugar'] },
        { key: 'Live Resin Carts', label: 'Carts', color: '#10B981', keywords: ['cart'] },
        { key: 'Live Resin AIOs', label: 'AIOs', color: '#8B5CF6', keywords: ['aio', 'disposable'] },
        { key: 'Brick Hash', label: 'Brick Hash', color: '#6B7280', keywords: ['hash', 'brick'] },
        { key: '4g Wax', label: '4g Wax', color: '#F97316', keywords: ['4 gram', 'bucket'] },
        { key: '4g Sugar', label: '4g Sugar', color: '#EC4899', keywords: ['4 gram sugar', 'bucket sugar'] }
    ];

    function openLeafLinkInventoryModal() {
        document.getElementById('leafLinkInventoryModal').style.display = 'block';
        loadLeafLinkInventory();
    }

    function closeLeafLinkInventoryModal() {
        document.getElementById('leafLinkInventoryModal').style.display = 'none';
    }

    function closeInventoryItemsPopup() {
        document.getElementById('inventoryItemsPopup').style.display = 'none';
    }

    async function refreshLeafLinkInventory() {
        await loadLeafLinkInventory();
    }

    async function loadLeafLinkInventory() {
        const container = document.getElementById('inventoryCategoryGrid');
        if (container) {
            container.innerHTML = '<div style="grid-column: span 3; text-align: center; padding: 40px; color: var(--text-secondary);">Loading...</div>';
        }

        // Initialize category data
        inventoryCategoryData = {};
        inventoryCategories.forEach(cat => {
            inventoryCategoryData[cat.key] = { count: 0, items: [], color: cat.color, label: cat.label, totalQty: 0 };
        });

        // Fetch products from LeafLink
        const products = await fetchLeafLinkInventory();

        // Categorize products
        products.forEach(product => {
            const name = (product.name || '').toLowerCase();
            const displayName = product.display_name || product.name || '';
            // Handle parent as object or string
            let parentName = '';
            if (product.parent && typeof product.parent === 'object') {
                parentName = (product.parent.name || '').toLowerCase();
            } else if (typeof product.parent === 'string') {
                parentName = product.parent.toLowerCase();
            }
            const productLine = (typeof product.product_line === 'string' ? product.product_line : (product.product_line?.name || '')).toLowerCase();
            const category_field = (typeof product.category === 'string' ? product.category : (product.category?.name || '')).toLowerCase();
            const qty = parseFloat(product.available_inventory != null ? product.available_inventory : (product.quantity || 0)) || 0;

            // Combine all fields for matching - include display name too
            const matchText = (parentName + ' ' + productLine + ' ' + category_field + ' ' + displayName).toLowerCase();

            // Check if this is a 4g bucket product (allow Internal for these)
            const is4gBucket = matchText.includes('4 gram') || matchText.includes('4gram') || matchText.includes('bucket');

            // Skip archived products always, skip internal unless it's a 4g bucket
            if (product.listing_state === 'Archived') return;
            if (product.listing_state === 'Internal' && !is4gBucket) return;

            // Skip products with 0 quantity
            if (qty <= 0) return;

            // Determine strain type from name
            let strainType = 'Hybrid';
            if (name.includes('sativa') || name.includes('(sativa)')) strainType = 'Sativa';
            else if (name.includes('indica') || name.includes('(indica)')) strainType = 'Indica';

            // Map to our categories - check specific product types
            let category = null;

            // Skip non-concentrate products
            if (matchText.includes('syrup') || matchText.includes('jousse') ||
                matchText.includes('rso') || matchText.includes('battery') ||
                matchText.includes('510 thread')) {
                return; // Skip syrups, RSO, batteries
            }

            // Check for 4g buckets first (before other wax/sugar matching)
            const is4g = matchText.includes('4 gram') || matchText.includes('4gram') || matchText.includes('4g ') || matchText.includes('bucket');
            const isHash = matchText.includes('brick') || matchText.includes('hash');

            if (is4g && matchText.includes('sugar')) {
                category = '4g Sugar';
            } else if (is4g && !isHash) {
                category = '4g Wax';
            } else if (matchText.includes('shatter')) {
                category = 'Shatter';
            } else if (matchText.includes('sugar')) {
                category = 'Sugar Wax';
            } else if (matchText.includes('disposable') || matchText.includes('all in one') || matchText.includes('all-in-one') || matchText.includes('aio')) {
                category = 'Live Resin AIOs';
            } else if (matchText.includes('cartridge') || matchText.includes('100% live resin')) {
                category = 'Live Resin Carts';
            } else if (isHash) {
                category = 'Brick Hash';
            } else if ((matchText.includes('wax') || matchText.includes('badder') || matchText.includes('budder')) && !isHash) {
                category = 'Wax';
            }

            if (category && inventoryCategoryData[category]) {
                inventoryCategoryData[category].count++;
                inventoryCategoryData[category].totalQty += qty;
                inventoryCategoryData[category].items.push({
                    name: displayName || product.name,
                    quantity: qty,
                    strainType: strainType,
                    sku: product.sku
                });
            }
        });

        renderInventoryCategories();
    }

    async function fetchLeafLinkInventory() {
        if (typeof isDemoMode === 'function' && isDemoMode()) {
            return generateDemoInventory();
        }

        let allProducts = [];
        let nextUrl = LEAFLINK_PROXY_URL + '/products/?page_size=100';

        while (nextUrl) {
            try {
                const response = await fetch(nextUrl);
                if (!response.ok) break;
                const data = await response.json();
                allProducts = allProducts.concat(data.results || []);
                nextUrl = data.next;
            } catch (error) {
                break;
            }
        }
        return allProducts;
    }

    function generateDemoInventory() {
        const strains = ['Blue Dream Sativa', 'GMO Indica', 'Gelato Hybrid', 'Wedding Cake Indica', 'Runtz Hybrid', 'Purple Punch Indica', 'OG Kush Hybrid', 'Sour Diesel Sativa'];
        const products = [];

        inventoryCategories.forEach(cat => {
            const numProducts = Math.floor(Math.random() * 4) + 2;
            for (let i = 0; i < numProducts; i++) {
                const strain = strains[Math.floor(Math.random() * strains.length)];
                const qty = Math.floor(Math.random() * 100) + 5;
                products.push({
                    name: strain + ' ' + cat.label,
                    quantity: qty,
                    available_inventory: qty,
                    sku: 'WM-' + Math.floor(Math.random() * 10000)
                });
            }
        });
        return products;
    }

    // ============================================
    // LEAFLINK PRODUCT PUSH INTEGRATION
    // ============================================

    // LeafLink configuration - will be populated from existing products
    let leafLinkConfig = null;

    // Pending LeafLink approvals (stored on batch records in Supabase)

    async function queueForLeafLinkApproval(batch) {
        // Calculate quantity based on material agreement
        const multiplier = batch.material_agreement === '50-50 Split' ? 0.5 : 1.0;
        const quantity = Math.floor((batch.grams_labeled || batch.final_weight || 0) * multiplier);

        // Update batch with pending LeafLink flag
        const { error } = await supabaseClient
            .from('wm_batches')
            .update({
                leaflink_pending: true,
                leaflink_quantity: quantity,
                leaflink_queued_at: new Date().toISOString(),
                leaflink_queued_by: currentRole?.name || 'Unknown'
            })
            .eq('id', batch.id);

        if (error) {
            console.error('Error queueing batch for LeafLink:', error);
        } else {
            console.log('Batch queued for LeafLink approval:', batch.id);
        }
    }

    async function renderLeafLinkApprovalQueue() {
        const container = document.getElementById('leaflinkApprovalQueue');
        if (!container) return;

        container.innerHTML = '<p style="color: var(--text-secondary); text-align: center;">Loading...</p>';

        // Fetch batches pending LeafLink approval from Supabase
        const { data: pendingBatches, error } = await supabaseClient
            .from('wm_batches')
            .select('*')
            .eq('leaflink_pending', true)
            .order('leaflink_queued_at', { ascending: false });

        if (error) {
            console.error('Error loading LeafLink queue:', error);
            container.innerHTML = '<p style="color: var(--accent-red);">Error loading queue</p>';
            return;
        }

        if (!pendingBatches || pendingBatches.length === 0) {
            container.innerHTML = '<p style="color: var(--text-secondary); text-align: center;">No pending approvals</p>';
            return;
        }

        const html = pendingBatches.map(batch => {
            const productType = batch.packaged_product_type || batch.product_made || 'Unknown';
            const quantity = batch.leaflink_quantity || batch.grams_labeled || 0;
            return `
            <div style="background: var(--card-bg); border: 1px solid var(--border-color); border-radius: 8px; padding: 15px; margin-bottom: 10px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <strong style="color: var(--accent-green);">${batch.strain}</strong>
                    <span style="font-size: 0.85em; color: var(--text-secondary);">${batch.id}</span>
                </div>
                <div style="font-size: 0.9em; color: var(--text-secondary); margin-bottom: 10px;">
                    <div>${productType} â€¢ ${batch.strain_type || 'Hybrid'}</div>
                    <div>${quantity}g to LeafLink (${batch.material_agreement})</div>
                    <div>THC: ${batch.test_thc_percent || 'N/A'}% â€¢ Price: $${batch.wholesale_price || 0}</div>
                    <div style="font-size: 0.8em; margin-top: 5px;">Queued: ${batch.leaflink_queued_at ? new Date(batch.leaflink_queued_at).toLocaleString() : 'N/A'} by ${batch.leaflink_queued_by || 'Unknown'}</div>
                </div>
                <div style="display: flex; gap: 10px;">
                    <button onclick="approveLeafLinkPush('${batch.id}')" style="flex: 1; padding: 8px; background: var(--accent-green); color: white; border: none; border-radius: 5px; cursor: pointer;">
                        âœ“ Approve & Push
                    </button>
                    <button onclick="rejectLeafLinkPush('${batch.id}')" style="flex: 1; padding: 8px; background: var(--accent-red, #ef4444); color: white; border: none; border-radius: 5px; cursor: pointer;">
                        âœ— Reject
                    </button>
                </div>
            </div>
        `}).join('');

        container.innerHTML = html;
    }

    async function approveLeafLinkPush(batchId) {
        // Get the full batch data from Supabase
        const { data: batch, error } = await supabaseClient
            .from('wm_batches')
            .select('*')
            .eq('id', batchId)
            .single();

        if (error || !batch) {
            alert('Error loading batch data: ' + (error?.message || 'Not found'));
            return;
        }

        const productType = batch.packaged_product_type || batch.product_made || 'Unknown';
        const quantity = batch.leaflink_quantity || batch.grams_labeled || 0;

        if (!confirm(`Push ${batch.strain} (${productType}) to LeafLink?\n\nQuantity: ${quantity}g\nTHC: ${batch.test_thc_percent}%`)) {
            return;
        }

        // Push to LeafLink
        const result = await pushBatchToLeafLink(batch);

        if (result.success) {
            // Clear pending flag
            await supabaseClient
                .from('wm_batches')
                .update({
                    leaflink_pending: false,
                    leaflink_product_id: result.product_id,
                    leaflink_pushed_at: new Date().toISOString(),
                    leaflink_pushed_by: currentRole?.name || 'Unknown'
                })
                .eq('id', batchId);

            alert(`âœ… Successfully pushed to LeafLink!\n\nProduct ID: ${result.product_id}`);
            renderLeafLinkApprovalQueue();
        } else {
            alert(`âŒ LeafLink push failed:\n\n${result.error}\n\n${JSON.stringify(result.details, null, 2)}`);
        }
    }

    async function rejectLeafLinkPush(batchId) {
        if (!confirm('Remove this batch from the LeafLink queue?\n\nThis will NOT delete the batch, just remove it from the approval queue.')) {
            return;
        }

        // Clear pending flag
        await supabaseClient
            .from('wm_batches')
            .update({ leaflink_pending: false })
            .eq('id', batchId);

        renderLeafLinkApprovalQueue();
    }

    async function initLeafLinkConfig() {
        // Check cache first
        const cached = localStorage.getItem('leaflink_config');
        if (cached) {
            try {
                const parsed = JSON.parse(cached);
                // Use cache if less than 24 hours old
                if (parsed.timestamp && Date.now() - parsed.timestamp < 24 * 60 * 60 * 1000) {
                    leafLinkConfig = parsed;
                    console.log('Using cached LeafLink config:', leafLinkConfig);
                    return leafLinkConfig;
                }
            } catch (e) {
                console.log('LeafLink config cache parse error');
            }
        }

        console.log('Fetching LeafLink config from products...');

        try {
            // Fetch products to extract IDs
            const response = await fetch(LEAFLINK_PROXY_URL + '/products/?page_size=100&has_children=true');
            if (!response.ok) {
                console.error('Failed to fetch LeafLink products for config');
                return null;
            }

            const data = await response.json();
            const products = data.results || [];

            if (products.length === 0) {
                console.error('No LeafLink products found');
                return null;
            }

            // Extract common IDs from first product
            // Note: Some fields are nested objects {id: x}, others are direct IDs or strings
            const firstProduct = products[0];
            console.log('First product raw data:', JSON.stringify(firstProduct, null, 2));

            // UOM string to ID mapping (LeafLink returns strings but requires IDs for POST)
            // These IDs may need adjustment based on your LeafLink account
            const UOM_STRING_TO_ID = {
                'Gram': 2,
                'gram': 2,
                'g': 2,
                'Unit': 1,
                'Each': 1,
                'Milligram': 3,
                'mg': 3,
                'Ounce': 4,
                'oz': 4
            };

            // Get UOM ID - handle string, object with id, or direct ID
            let uomId = null;
            const uom = firstProduct.unit_of_measure;
            if (typeof uom === 'string') {
                uomId = UOM_STRING_TO_ID[uom] || 2; // Default to Gram (2) if unknown
                console.log(`UOM string "${uom}" mapped to ID: ${uomId}`);
            } else if (uom?.id) {
                uomId = uom.id;
            } else if (typeof uom === 'number') {
                uomId = uom;
            } else {
                uomId = 2; // Default to Gram
                console.log('Could not determine UOM ID, defaulting to 2 (Gram)');
            }

            leafLinkConfig = {
                seller_id: firstProduct.seller?.id || firstProduct.seller,
                brand_id: firstProduct.brand?.id || firstProduct.brand,
                license_id: firstProduct.license?.id || firstProduct.license,
                unit_of_measure_id: uomId,
                unit_denomination_id: firstProduct.unit_denomination?.id || firstProduct.unit_denomination,
                category_id: firstProduct.category?.id || firstProduct.category,
                product_lines: {},
                timestamp: Date.now()
            };

            // Fetch actual product lines from /product-lines endpoint
            try {
                const plResponse = await fetch(LEAFLINK_PROXY_URL + '/product-lines/?page_size=50');
                if (plResponse.ok) {
                    const plData = await plResponse.json();
                    const productLines = plData.results || [];

                    productLines.forEach(pl => {
                        const name = (pl.name || '').toLowerCase();
                        const plData = {
                            product_line_id: pl.id,
                            category_id: pl.category?.id || pl.category,
                            name: pl.name
                        };

                        // Map to our internal categories
                        if (name.includes('sugar wax') && name.includes('1 gram')) {
                            leafLinkConfig.product_lines['Sugar Wax'] = plData;
                        } else if (name.includes('sugar wax') && name.includes('4 gram')) {
                            leafLinkConfig.product_lines['Sugar Wax 4g'] = plData;
                        } else if (name === 'shatter') {
                            leafLinkConfig.product_lines['Shatter'] = plData;
                        } else if (name.includes('wax') && name.includes('1 gram') && !name.includes('sugar')) {
                            leafLinkConfig.product_lines['Wax'] = plData;
                        } else if (name.includes('wax') && name.includes('4 gram') && !name.includes('sugar')) {
                            leafLinkConfig.product_lines['Wax 4g'] = plData;
                        } else if (name.includes('disposable') || name.includes('all in one')) {
                            leafLinkConfig.product_lines['Live Resin AIOs'] = plData;
                        } else if (name.includes('cartridge')) {
                            leafLinkConfig.product_lines['Live Resin Carts'] = plData;
                        } else if (name.includes('brick hash')) {
                            leafLinkConfig.product_lines['Brick Hash'] = plData;
                        }
                    });
                }
            } catch (plError) {
                console.error('Error fetching product lines:', plError);
            }

            console.log('Mapped product lines:', leafLinkConfig.product_lines);

            // Cache the config
            localStorage.setItem('leaflink_config', JSON.stringify(leafLinkConfig));
            console.log('LeafLink config initialized:', leafLinkConfig);

            return leafLinkConfig;
        } catch (error) {
            console.error('Error initializing LeafLink config:', error);
            return null;
        }
    }

    async function pushBatchToLeafLink(batch) {
        // Skip if no batch or buyback agreement
        if (!batch) return { success: false, error: 'No batch provided' };
        if (batch.material_agreement === 'Custom Buyback') {
            console.log('Skipping LeafLink push for buyback batch:', batch.id);
            return { success: false, error: 'Buyback - not pushed to LeafLink' };
        }

        // Ensure config is loaded
        if (!leafLinkConfig) {
            await initLeafLinkConfig();
        }

        if (!leafLinkConfig) {
            console.error('Could not initialize LeafLink config');
            return { success: false, error: 'LeafLink config not available' };
        }

        // Get product type mapping - normalize compound types
        let productType = batch.packaged_product_type || batch.product_made || '';

        // Normalize product types that don't match LeafLink categories exactly
        const productTypeNormalization = {
            'Sugar': 'Sugar Wax',
            'Live Resin': 'Wax',
            'Badder': 'Wax',
            'Diamonds': 'Wax',
            'Sauce': 'Wax'
        };

        if (productTypeNormalization[productType]) {
            console.log(`Normalizing product type: ${productType} -> ${productTypeNormalization[productType]}`);
            productType = productTypeNormalization[productType];
        }

        const productLineConfig = leafLinkConfig.product_lines[productType];

        if (!productLineConfig) {
            console.error('Unknown product type for LeafLink:', productType);
            console.log('Available product lines:', Object.keys(leafLinkConfig.product_lines));
            return { success: false, error: `Unknown product type: ${productType}` };
        }

        // Calculate quantity based on material agreement
        // Wholesale = 100%, 50-50 Split = 50%
        const multiplier = batch.material_agreement === '50-50 Split' ? 0.5 : 1.0;
        const quantity = Math.floor((batch.grams_labeled || batch.final_weight || 0) * multiplier);

        if (quantity <= 0) {
            console.error('No sellable quantity for batch:', batch.id);
            return { success: false, error: 'No sellable quantity' };
        }

        // Build LeafLink product payload
        // Pricing per unit by product type
        const PRODUCT_PRICING = {
            'Sugar Wax': 6,
            'Wax': 6,
            'Shatter': 6,
            'Live Resin Carts': 15,
            'Live Resin AIOs': 22,
            'Brick Hash': 8
        };
        const pricePerUnit = PRODUCT_PRICING[productType] || 6;

        // Sub-category IDs by product type (from LeafLink)
        const SUB_CATEGORY_IDS = {
            'Sugar Wax': 55,
            'Wax': 49,
            'Shatter': 49,  // Same as wax
            'Live Resin Carts': 14,
            'Live Resin AIOs': 14,
            'Brick Hash': 49
        };
        const subCategoryId = SUB_CATEGORY_IDS[productType];

        // Clean strain name - remove WM prefix, product type suffixes, and size
        let strainName = (batch.strain || 'Unknown Strain')
            .replace(/^WM\s+/i, '')           // Remove "WM " prefix
            .replace(/\s+(SW|SH|WX|LRC|AIO|BH)\b/gi, '')  // Remove product type codes
            .replace(/\s*\(\d+g?\)/gi, '')    // Remove size like "(1g)" or "(4g)"
            .trim();

        const payload = {
            sku: batch.id, // Use batch ID as SKU (e.g., "9.23.5447")
            name: strainName,
            description: `${strainName} - ${productType}`,
            // API wants field names without _id suffix
            seller: leafLinkConfig.seller_id,
            brand: leafLinkConfig.brand_id,
            license: leafLinkConfig.license_id,
            category: productLineConfig.category_id || leafLinkConfig.category_id,
            sub_category: subCategoryId,
            manufacturer: leafLinkConfig.seller_id, // Same as seller
            unit_of_measure: 'Gram',
            sell_in_unit_of_measure: 'Case',
            unit_multiplier: 10, // 10 units per case
            unit_denomination: leafLinkConfig.unit_denomination_id,
            listing_state: 'Internal', // TODO: Change to 'Available' after testing
            strain_classification: (batch.strain_type || 'hybrid').toLowerCase(),
            inventory_management: 1, // 1 = track inventory
            quantity: quantity.toFixed(4), // Initial inventory quantity
            minimum_order: '1.0000', // 1 case minimum
            maximum_order: null,
            wholesale_price: {
                amount: pricePerUnit,
                currency: 'USD'
            },
            retail_price: {
                amount: 0,
                currency: 'USD'
            },
            sale_price: {
                amount: 0,
                currency: 'USD'
            }
        };

        // Only add product_line_id if we have a valid ID (not all categories have one)
        if (productLineConfig.product_line_id) {
            payload.product_line_id = productLineConfig.product_line_id;
        }

        // Add test results if available
        if (batch.test_thc_percent) {
            payload.product_specification_items = [
                {
                    product_specification_id: 1, // THC
                    decimal_value: batch.test_thc_percent.toString()
                }
            ];
            if (batch.test_cbd_percent) {
                payload.product_specification_items.push({
                    product_specification_id: 2, // CBD
                    decimal_value: batch.test_cbd_percent.toString()
                });
            }
        }

        console.log('Pushing batch to LeafLink:', batch.id, payload);

        try {
            const response = await fetch(LEAFLINK_PROXY_URL + '/products', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            const result = await response.json();

            if (!response.ok) {
                console.error('LeafLink API error:', result);
                return { success: false, error: result.detail || 'API error', details: result };
            }

            console.log('LeafLink product created:', result.id);

            // Store LeafLink product ID on batch
            try {
                await supabaseClient.from('wm_batches')
                    .update({ leaflink_product_id: result.id })
                    .eq('id', batch.id);
            } catch (dbError) {
                console.error('Error saving LeafLink ID to batch:', dbError);
            }

            return { success: true, product_id: result.id, data: result };
        } catch (error) {
            console.error('Error pushing to LeafLink:', error);
            return { success: false, error: error.message };
        }
    }

    function renderInventoryCategories() {
        const categoryOrder = ['Wax', 'Shatter', 'Sugar Wax', 'Live Resin Carts', 'Live Resin AIOs', 'Brick Hash', '4g Wax', '4g Sugar'];

        const html = categoryOrder.map(key => {
            const data = inventoryCategoryData[key];
            const hasItems = data.count > 0;

            // Count by strain type
            const strainCounts = { Sativa: 0, Hybrid: 0, Indica: 0 };
            (data.items || []).forEach(item => {
                if (item.strainType) strainCounts[item.strainType]++;
            });

            const unit = (key.includes('Cart') || key.includes('AIO') || key.includes('4g')) ? '' : 'g';
            return `
                <button onclick="showInventoryItems('${key}')" class="foh-btn" style="opacity: ${hasItems ? '1' : '0.5'};">
                    <div class="foh-btn-name">${data.label}</div>
                    <div class="foh-btn-num">${data.count}</div>
                    <div class="foh-btn-sub">${Math.round(data.totalQty)}${unit}</div>
                </button>
            `;
        }).join('');

        // Render to both modal and inline
        const modalContainer = document.getElementById('inventoryCategoryGrid');
        const inlineContainer = document.getElementById('inlineInventoryGrid');
        if (modalContainer) modalContainer.innerHTML = html;
        if (inlineContainer) inlineContainer.innerHTML = html;
    }

        function showInventoryItems(category) {
        const data = inventoryCategoryData[category];
        if (!data || data.count === 0) return;

        const unit = (category.includes('Cart') || category.includes('AIO') || category.includes('4g')) ? '' : 'g';
        document.getElementById('inventoryPopupTitle').textContent = data.label + ' - ' + Math.round(data.totalQty) + unit;
        document.getElementById('inventoryPopupTitle').style.color = data.color;

        const contentEl = document.getElementById('inventoryPopupContent');

        // Sort by strain type (Sativa, Hybrid, Indica), then by quantity descending
        const strainOrder = { 'Sativa': 0, 'Hybrid': 1, 'Indica': 2 };
        const sortedItems = [...data.items].sort((a, b) => {
            const typeA = strainOrder[a.strainType] ?? 1;
            const typeB = strainOrder[b.strainType] ?? 1;
            if (typeA !== typeB) return typeA - typeB;
            return b.quantity - a.quantity;
        });

        // Get strain color
        const getStrainColor = (type) => {
            if (type === 'Sativa') return '#ff0055';
            if (type === 'Indica') return '#0055ff';
            return '#39ff14';
        };

        contentEl.innerHTML = sortedItems.map(item => {
            const strainColor = getStrainColor(item.strainType);
            return `
                <div style="padding: 12px 15px; background: var(--bg-primary); border-radius: 8px; margin-bottom: 10px; border-left: 3px solid ${strainColor}; box-shadow: 0 0 10px ${strainColor}33;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <span style="font-weight: 600; color: var(--text-primary);">${item.name}</span>
                        <span style="background: ${strainColor}22; color: ${strainColor}; padding: 6px 12px; border-radius: 12px; font-size: 1.1rem; font-weight: 700;">${item.quantity}${unit}</span>
                    </div>
                </div>
            `;
        }).join('');

        document.getElementById('inventoryItemsPopup').style.display = 'block';
    }

    // ============ NEEDS MODAL ============
    let needsData = {};
    let salesByCategory = {};
    let needsDataLoading = null; // Track loading promise to prevent concurrent loads

    function openNeedsModal() {
        document.getElementById('needsModal').style.display = 'block';
        loadNeedsData();
    }

    function closeNeedsModal() {
        document.getElementById('needsModal').style.display = 'none';
    }

    function closeNeedsItemsPopup() {
        document.getElementById('needsItemsPopup').style.display = 'none';
    }

    async function loadNeedsData(forceReload = false) {
        // If already loading, return the existing promise
        if (needsDataLoading && !forceReload) {
            return needsDataLoading;
        }

        // Load cached data immediately for instant display
        const cachedData = localStorage.getItem('foh_needs_cache');
        if (cachedData && Object.keys(needsData).length === 0) {
            try {
                const parsed = JSON.parse(cachedData);
                // Validate cache structure - must have Wax with needs array
                // Also check that cache has actual data (not all zeros)
                const hasRealData = parsed && parsed['Wax'] && Array.isArray(parsed['Wax'].needs) &&
                    Object.values(parsed).some(cat => cat.totalInventory > 0 || cat.totalPipeline > 0 || (cat.needs && cat.needs.length > 0));
                if (hasRealData) {
                    needsData = parsed;
                    renderNeedsCategories();
                } else {
                    // Invalid or empty cache, clear it
                    console.log('Needs cache invalid or empty, clearing...');
                    localStorage.removeItem('foh_needs_cache');
                }
            } catch (e) {
                console.log('Cache parse error:', e);
                localStorage.removeItem('foh_needs_cache');
            }
        }

        // If data already exists and not forcing reload, just re-render
        if (!forceReload && Object.keys(needsData).length > 0 && needsData['Wax']?.needs?.length > 0) {
            renderNeedsCategories();
            // Still refresh in background but don't wait
            setTimeout(() => loadNeedsData(true), 100);
            return Promise.resolve();
        }

        needsDataLoading = (async () => {
            // Ensure pipeline data is loaded first (it populates pipelineCategoryData)
            loadSalesPipeline();

        // Initialize needs data structure
        const categories = ['Wax', 'Shatter', 'Sugar Wax', 'Live Resin Carts', 'Live Resin AIOs', 'Brick Hash', '4g Wax', '4g Sugar'];
        const strainTypes = ['Indica', 'Sativa', 'Hybrid'];

        const newNeedsData = {};
        salesByCategory = {};

        categories.forEach(cat => {
            newNeedsData[cat] = { label: cat, color: getCategoryColor(cat), needs: [] };
            salesByCategory[cat] = { Indica: 0, Sativa: 0, Hybrid: 0 };
        });

        // Get 60-day sales data
        const orders = await fetchLeafLinkOrders();
        const salesPeriodStart = new Date();
        salesPeriodStart.setDate(salesPeriodStart.getDate() - 60);

        // Calculate sales by category and strain type
        orders.forEach(order => {
            const orderDate = new Date(order.ordered_at || order.created_on);
            if (orderDate < salesPeriodStart) return;

            (order.line_items || []).forEach(item => {
                const productName = (item.frozen_data?.product?.name || item.product?.name || '').toLowerCase();
                const qty = parseFloat(item.quantity) || 0;

                // Determine category
                let category = null;
                const is4g = productName.includes('4 gram') || productName.includes('4gram') || productName.includes('4g ') || productName.includes('bucket');
                const isHash = productName.includes('brick') || productName.includes('hash');

                if (is4g && productName.includes('sugar')) category = '4g Sugar';
                else if (is4g && !isHash) category = '4g Wax';
                else if (productName.includes('shatter')) category = 'Shatter';
                else if (productName.includes('sugar')) category = 'Sugar Wax';
                else if (productName.includes('cartridge') || productName.includes('cart')) category = 'Live Resin Carts';
                else if (productName.includes('disposable') || productName.includes('all in one') || productName.includes('aio')) category = 'Live Resin AIOs';
                else if (isHash) category = 'Brick Hash';
                else if ((productName.includes('wax') || productName.includes('badder') || productName.includes('budder')) && !isHash) category = 'Wax';

                if (!category) return;

                // Determine strain type
                let strainType = 'Hybrid';
                if (productName.includes('sativa') || productName.includes('(s)')) strainType = 'Sativa';
                else if (productName.includes('indica') || productName.includes('(i)')) strainType = 'Indica';

                salesByCategory[category][strainType] += qty;
            });
        });

        // Get current inventory
        const products = await fetchLeafLinkInventory();
        const inventoryByCategory = {};
        categories.forEach(cat => {
            inventoryByCategory[cat] = { Indica: [], Sativa: [], Hybrid: [] };
        });

        products.forEach(product => {
            const name = (product.name || '').toLowerCase();
            const displayName = product.display_name || product.name || '';
            let parentName = '';
            if (product.parent && typeof product.parent === 'object') {
                parentName = (product.parent.name || '').toLowerCase();
            }
            const matchText = (parentName + ' ' + displayName).toLowerCase();
            const qty = parseFloat(product.available_inventory != null ? product.available_inventory : (product.quantity || 0)) || 0;

            // Check if this is a 4g bucket product (allow Internal for these)
            const is4g = matchText.includes('4 gram') || matchText.includes('4gram') || matchText.includes('4g ') || matchText.includes('bucket');
            const isHash = matchText.includes('brick') || matchText.includes('hash');

            // Skip archived, skip internal unless 4g bucket
            if (product.listing_state === 'Archived') return;
            if (product.listing_state === 'Internal' && !is4g) return;
            if (qty <= 0) return;

            // Skip non-concentrates
            if (matchText.includes('syrup') || matchText.includes('jousse') || matchText.includes('rso') || matchText.includes('battery')) return;

            // Determine category
            let category = null;
            if (is4g && matchText.includes('sugar')) category = '4g Sugar';
            else if (is4g && !isHash) category = '4g Wax';
            else if (matchText.includes('shatter')) category = 'Shatter';
            else if (matchText.includes('sugar')) category = 'Sugar Wax';
            else if (matchText.includes('cartridge') || (matchText.includes('cart') && matchText.includes('live resin')) || matchText.includes('100% live resin')) category = 'Live Resin Carts';
            else if (matchText.includes('disposable') || matchText.includes('all in one') || matchText.includes('aio')) category = 'Live Resin AIOs';
            else if (isHash) category = 'Brick Hash';
            else if ((matchText.includes('wax') || matchText.includes('badder') || matchText.includes('budder')) && !isHash) category = 'Wax';

            if (!category) return;

            // Determine strain type
            let strainType = 'Hybrid';
            if (name.includes('sativa') || name.includes('(sativa)')) strainType = 'Sativa';
            else if (name.includes('indica') || name.includes('(indica)')) strainType = 'Indica';

            inventoryByCategory[category][strainType].push({ name: displayName, qty: qty });
        });

        // Add pipeline inventory to the calculation (product being made counts as upcoming inventory)
        try {
            if (typeof pipelineCategoryData === 'object' && pipelineCategoryData !== null) {
                categories.forEach(cat => {
                    if (!pipelineCategoryData[cat]) return;
                    const strains = pipelineCategoryData[cat].strains;
                    if (!Array.isArray(strains)) return;

                    strains.forEach(item => {
                        // Normalize strain type to match inventory keys
                        let strainType = (item.strainType || 'Hybrid').trim();
                        if (!['Indica', 'Sativa', 'Hybrid'].includes(strainType)) {
                            strainType = 'Hybrid';
                        }

                        const weight = parseFloat(item.availableGrams) || parseFloat(item.weight) || 0;
                        if (weight > 0) {
                            // Double check the array exists before pushing
                            if (inventoryByCategory[cat] && Array.isArray(inventoryByCategory[cat][strainType])) {
                                inventoryByCategory[cat][strainType].push({
                                    name: (item.strain || 'Unknown') + ' (Pipeline)',
                                    qty: weight,
                                    isPipeline: true
                                });
                            }
                        }
                    });
                });
            }
        } catch(e) {
            console.log('Pipeline data error in needs calc:', e.message);
        }

        // Calculate needs: 1-week supply based on 60-day sales average (7 days for urgent visibility)
        categories.forEach(cat => {
            strainTypes.forEach(strain => {
                const totalSold = salesByCategory[cat][strain];
                const parLevel = Math.ceil((totalSold / 60) * 7); // 1-week supply based on 60-day daily average
                const currentItems = inventoryByCategory[cat][strain];

                // Separate pipeline and inventory quantities
                const pipelineQty = currentItems.filter(i => i.isPipeline).reduce((sum, i) => sum + i.qty, 0);
                const inventoryQty = currentItems.filter(i => !i.isPipeline).reduce((sum, i) => sum + i.qty, 0);
                const totalQty = pipelineQty + inventoryQty;
                // Only count varieties with 60g or more as "stocked"
                const varietyCount = currentItems.filter(i => i.qty >= 60).length;

                // Need more if total quantity is below par level
                const qtyNeeded = Math.max(0, parLevel - totalQty);
                // Need varieties if we have less than 3 varieties with adequate stock (60g+)
                const varietiesNeeded = Math.max(0, 3 - varietyCount);

                // Always add all strain types so they show in popup
                const existingIndex = newNeedsData[cat].needs.findIndex(n => n.strainType === strain);
                const needEntry = {
                    strainType: strain,
                    varietiesNeeded: varietiesNeeded,
                    qtyNeeded: Math.round(qtyNeeded),
                    parLevel: parLevel,
                    pipelineQty: Math.round(pipelineQty),
                    inventoryQty: Math.round(inventoryQty),
                    currentVarieties: varietyCount,
                    currentQty: Math.round(totalQty),
                    isStocked: qtyNeeded === 0 && varietiesNeeded === 0
                };
                if (existingIndex >= 0) {
                    newNeedsData[cat].needs[existingIndex] = needEntry;
                } else {
                    newNeedsData[cat].needs.push(needEntry);
                }
            });
        });

        // Update global data and cache
        needsData = newNeedsData;
        localStorage.setItem('foh_needs_cache', JSON.stringify(needsData));
        renderNeedsCategories();
        })();

        // Wait for the loading to complete, then clear the flag
        try {
            await needsDataLoading;
        } finally {
            needsDataLoading = null;
        }
    }

    function getCategoryColor(cat) {
        const colors = {
            'Wax': '#8B5CF6',
            'Shatter': '#EC4899',
            'Sugar Wax': '#F59E0B',
            'Live Resin Carts': '#10B981',
            'Live Resin AIOs': '#3B82F6',
            'Brick Hash': '#6366F1',
            '4g Wax': '#F97316',
            '4g Sugar': '#EC4899'
        };
        return colors[cat] || '#8B5CF6';
    }

    function renderNeedsCategories() {
        const categoryOrder = ['Wax', 'Shatter', 'Sugar Wax', 'Live Resin Carts', 'Live Resin AIOs', 'Brick Hash', '4g Wax', '4g Sugar'];

        const html = categoryOrder.map(key => {
            const data = needsData[key] || { label: key, needs: [] };

            // Get needs by strain type
            const needsByStrain = { Sativa: 0, Hybrid: 0, Indica: 0 };
            (data.needs || []).forEach(need => {
                needsByStrain[need.strainType] = need.varietiesNeeded;
            });

            const totalNeeded = needsByStrain.Sativa + needsByStrain.Hybrid + needsByStrain.Indica;
            const isOk = totalNeeded === 0;
            // Color based on urgency: green=stocked, yellow=1-2 needed, red=3+ needed
            const glowColor = isOk ? '#10B981' : (totalNeeded <= 2 ? '#F59E0B' : '#EF4444');
            return `
                <button onclick="showNeedsItems('${key}')" class="foh-btn">
                    <div class="foh-btn-name">${data.label}</div>
                    <div class="foh-btn-num foh-needs-num" style="text-shadow: 0 0 8px ${glowColor}, 0 0 15px ${glowColor}, 0 0 25px ${glowColor}, 0 0 40px ${glowColor};">${isOk ? 'âœ“' : totalNeeded}</div>
                    <div class="foh-btn-sub">${isOk ? 'Stocked' : 'varieties needed'}</div>
                </button>
            `;
        }).join('');

        // Render to modal, inline FOH, and dashboard
        const modalContainer = document.getElementById('needsCategoryGrid');
        const inlineContainer = document.getElementById('inlineNeedsGrid');
        const dashboardContainer = document.getElementById('dashboardNeedsGrid');
        if (modalContainer) modalContainer.innerHTML = html;
        if (inlineContainer) inlineContainer.innerHTML = html;
        if (dashboardContainer) dashboardContainer.innerHTML = html;
    }

    function showNeedsItems(category) {
        const data = needsData[category];
        const contentEl = document.getElementById('needsPopupContent');

        // Check if data is ready
        if (!data || !data.needs || data.needs.length === 0) {
            document.getElementById('needsPopupTitle').textContent = (data?.label || category) + ' Needs';
            document.getElementById('needsPopupTitle').style.color = data?.color || '#F59E0B';
            contentEl.innerHTML = '<div style="padding: 20px; text-align: center; color: var(--text-secondary);">Loading data...</div>';
            document.getElementById('needsItemsPopup').style.display = 'block';
            // Try to reload data
            loadNeedsData().then(() => {
                if (needsData[category]?.needs?.length > 0) {
                    showNeedsItems(category);
                }
            });
            return;
        }

        document.getElementById('needsPopupTitle').textContent = data.label + ' Needs';
        document.getElementById('needsPopupTitle').style.color = data.color;

        const getStrainColor = (type) => {
            if (type === 'Sativa') return '#ff0055';
            if (type === 'Indica') return '#0055ff';
            return '#39ff14';
        };

        {
            // Sort by strain type (Sativa, Hybrid, Indica)
            const strainOrder = { 'Sativa': 0, 'Hybrid': 1, 'Indica': 2 };
            const sortedNeeds = [...data.needs].sort((a, b) => {
                const typeA = strainOrder[a.strainType] ?? 1;
                const typeB = strainOrder[b.strainType] ?? 1;
                return typeA - typeB;
            });
            contentEl.innerHTML = sortedNeeds.map(need => {
                const strainColor = getStrainColor(need.strainType);
                const isStocked = need.isStocked || (need.qtyNeeded === 0 && need.varietiesNeeded === 0);
                const statusBadge = isStocked
                    ? '<span style="background: #10B98122; color: #10B981; padding: 4px 10px; border-radius: 8px; font-size: 0.9rem; font-weight: 600;">âœ“ Stocked</span>'
                    : `<span style="background: #EF444422; color: #EF4444; padding: 4px 10px; border-radius: 8px; font-size: 0.9rem; font-weight: 600;">Need ${need.varietiesNeeded > 0 ? need.varietiesNeeded + ' varieties' : need.qtyNeeded + 'g'}</span>`;
                return `
                    <div style="padding: 15px; background: var(--bg-primary); border-radius: 8px; margin-bottom: 10px; border-left: 3px solid ${strainColor}; box-shadow: 0 0 10px ${strainColor}33; opacity: ${isStocked ? '0.7' : '1'};">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <span style="font-weight: 700; color: ${strainColor}; font-size: 1.1rem;">${need.strainType}</span>
                            ${statusBadge}
                        </div>
                        <div style="display: flex; gap: 20px; color: var(--text-secondary); font-size: 0.9rem;">
                            <span><strong>Par:</strong> ${need.parLevel}g</span>
                            <span><strong>Pipeline:</strong> ${need.pipelineQty || 0}g</span>
                            <span><strong>Inventory:</strong> ${need.inventoryQty || 0}g</span>
                        </div>
                    </div>
                `;
            }).join('');
        }

        document.getElementById('needsItemsPopup').style.display = 'block';
    }

    // Initialize FOH grids on page load
    window.addEventListener('load', function() {
        setTimeout(function() {
            if (document.getElementById('inlinePipelineGrid')) {
                loadSalesPipeline();
                loadLeafLinkInventory();
                loadNeedsData();
            }
        }, 1000);
    });

    </script>

</body>
</html>
