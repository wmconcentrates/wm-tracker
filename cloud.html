<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>White Mousse Production Tracker - Cloud Sync</title>

    <!-- PWA Meta Tags -->
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#0a0a0f">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="WM Tracker">
    <link rel="apple-touch-icon" href="https://images.squarespace-cdn.com/content/v1/5501f606e4b0b9ba3b7be5ec/1537298893777-QBVYYWKI0KBKGYJGQJB5/WM.png?format=180w">
    <link rel="icon" type="image/png" href="https://images.squarespace-cdn.com/content/v1/5501f606e4b0b9ba3b7be5ec/1537298893777-QBVYYWKI0KBKGYJGQJB5/WM.png?format=32w">
    <link rel="icon" type="image/png" sizes="192x192" href="https://images.squarespace-cdn.com/content/v1/5501f606e4b0b9ba3b7be5ec/1537298893777-QBVYYWKI0KBKGYJGQJB5/WM.png?format=192w">

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Space+Mono:wght@400;700&family=Work+Sans:wght@300;400;600;700&display=swap');

        :root {
            /* Electric Forest - Laser show vibes */
            --bg-primary: #000000;
            --bg-secondary: #0a0a0a;
            --bg-tertiary: #141414;
            --accent-purple: #bf00ff;
            --accent-green: #39ff14;
            --accent-blue: #0055ff;
            --accent-orange: #ff6b00;
            --accent-red: #ff0055;
            --accent-pink: #ff10f0;
            --text-primary: #ffffff;
            --text-secondary: #888888;
            --border: #222222;
            --glow-green: 0 0 20px rgba(57, 255, 20, 0.5);
            --glow-pink: 0 0 20px rgba(255, 16, 240, 0.5);
            --glow-blue: 0 0 20px rgba(0, 240, 255, 0.5);
            --glow-purple: 0 0 20px rgba(191, 0, 255, 0.5);
            font-size: 18px;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Work Sans', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            padding: 20px;
            font-size: 1.1rem; /* Increased base font size */
        }
        
        .connection-status {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 10px 20px;
            border-radius: 20px;
            font-weight: 600;
            font-size: 1rem;
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .connection-status.connected {
            background: rgba(16, 185, 129, 0.2);
            border: 2px solid var(--accent-green);
            color: var(--accent-green);
        }
        
        .connection-status.disconnected {
            background: rgba(239, 68, 68, 0.2);
            border: 2px solid var(--accent-red);
            color: var(--accent-red);
        }
        
        .connection-status.connecting {
            background: rgba(245, 158, 11, 0.2);
            border: 2px solid var(--accent-orange);
            color: var(--accent-orange);
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Celebration animations */
        @keyframes confetti-fall {
            0% { transform: translateY(-100vh) rotate(0deg); opacity: 1; }
            100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
        }

        @keyframes celebration-pop {
            0% { transform: scale(0) rotate(-10deg); opacity: 0; }
            50% { transform: scale(1.1) rotate(5deg); }
            100% { transform: scale(1) rotate(0deg); opacity: 1; }
        }

        @keyframes bounce-in {
            0% { transform: scale(0); }
            50% { transform: scale(1.2); }
            70% { transform: scale(0.9); }
            100% { transform: scale(1); }
        }

        @keyframes shimmer {
            0% { background-position: -200% center; }
            100% { background-position: 200% center; }
        }

        /* Laser show animations */
        @keyframes laser-sweep {
            0% { transform: rotate(-45deg) translateX(-100vw); opacity: 0; }
            10% { opacity: 1; }
            90% { opacity: 1; }
            100% { transform: rotate(45deg) translateX(100vw); opacity: 0; }
        }

        @keyframes laser-pulse {
            0%, 100% { opacity: 0.3; box-shadow: 0 0 20px currentColor, 0 0 40px currentColor; }
            50% { opacity: 1; box-shadow: 0 0 40px currentColor, 0 0 80px currentColor, 0 0 120px currentColor; }
        }

        @keyframes laser-rotate {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .laser-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000000;
            overflow: hidden;
        }

        .laser-beam {
            position: absolute;
            width: 3px;
            height: 200vh;
            transform-origin: center center;
            animation: laser-pulse 0.3s ease-in-out infinite;
        }

        /* Fire cannon animations */
        @keyframes fire-shoot {
            0% {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
            50% {
                opacity: 1;
            }
            100% {
                transform: translateY(100vh) scale(0.3);
                opacity: 0;
            }
        }

        @keyframes fire-flicker {
            0%, 100% { transform: scaleX(1); }
            50% { transform: scaleX(1.2); }
        }

        .fire-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 99998;
            overflow: hidden;
        }

        .fire-particle {
            position: absolute;
            top: -20px;
            border-radius: 50%;
            animation: fire-shoot ease-out forwards;
        }

        .fire-cannon {
            position: absolute;
            top: 0;
            width: 60px;
            height: 80px;
            background: linear-gradient(to bottom, #ff6b00, #ff0055, #ff10f0);
            filter: blur(20px);
            animation: fire-flicker 0.1s ease-in-out infinite;
        }

        .celebration-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            z-index: 99999;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(5px);
        }

        .celebration-content {
            text-align: center;
            animation: celebration-pop 0.5s ease-out;
            max-width: 500px;
            padding: 40px;
        }

        .celebration-emoji {
            font-size: 5rem;
            animation: bounce-in 0.6s ease-out;
            margin-bottom: 20px;
        }

        .celebration-title {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 15px;
            background: linear-gradient(90deg, var(--accent-green), var(--accent-blue), var(--accent-pink), var(--accent-green));
            background-size: 200% auto;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: shimmer 2s linear infinite;
            text-shadow: 0 0 30px rgba(57, 255, 20, 0.3);
        }

        .celebration-message {
            font-size: 1.2rem;
            color: var(--text-secondary);
            margin-bottom: 30px;
            line-height: 1.6;
        }

        .celebration-stats {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-bottom: 30px;
        }

        .celebration-stat {
            background: var(--bg-secondary);
            padding: 20px 30px;
            border-radius: 15px;
            border: 2px solid var(--accent-green);
            box-shadow: 0 0 20px rgba(57, 255, 20, 0.3), inset 0 0 20px rgba(57, 255, 20, 0.05);
        }

        .celebration-stat-value {
            font-size: 2rem;
            font-weight: 700;
            color: var(--accent-green);
            text-shadow: 0 0 10px rgba(57, 255, 20, 0.5);
        }

        .celebration-stat-label {
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .celebration-btn {
            background: transparent;
            border: 2px solid var(--accent-pink);
            padding: 15px 40px;
            border-radius: 12px;
            color: var(--accent-pink);
            font-size: 1.1rem;
            font-weight: 700;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            box-shadow: 0 0 20px rgba(255, 16, 240, 0.4), 0 0 40px rgba(191, 0, 255, 0.2), inset 0 0 15px rgba(255, 16, 240, 0.05);
            text-shadow: 0 0 10px rgba(255, 16, 240, 0.5);
        }

        .celebration-btn:hover {
            transform: scale(1.05);
            background: rgba(255, 16, 240, 0.15);
            box-shadow: 0 0 30px rgba(255, 16, 240, 0.6), 0 0 60px rgba(191, 0, 255, 0.4), inset 0 0 20px rgba(255, 16, 240, 0.1);
        }

        .confetti-piece {
            position: fixed;
            width: 10px;
            height: 10px;
            top: -20px;
            animation: confetti-fall linear forwards;
            z-index: 999999;
        }

        .header {
            background: transparent;
            padding: 20px;
            margin-bottom: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .header-content {
            display: flex;
            justify-content: center;
        }

        .header-logo {
            width: 250px;
            height: auto;
        }

        .header-logo img {
            max-width: 100%;
            height: auto;
            display: block;
            object-fit: contain;
            filter: drop-shadow(0 0 8px rgba(191, 0, 255, 0.8))
                    drop-shadow(0 0 15px rgba(191, 0, 255, 0.6))
                    drop-shadow(0 0 30px rgba(191, 0, 255, 0.4))
                    drop-shadow(0 0 50px rgba(0, 240, 255, 0.3));
            animation: neon-flicker 3s ease-in-out infinite;
        }

        @keyframes neon-flicker {
            0%, 100% {
                filter: drop-shadow(0 0 8px rgba(191, 0, 255, 0.8))
                        drop-shadow(0 0 15px rgba(191, 0, 255, 0.6))
                        drop-shadow(0 0 30px rgba(191, 0, 255, 0.4))
                        drop-shadow(0 0 50px rgba(0, 240, 255, 0.3));
            }
            50% {
                filter: drop-shadow(0 0 12px rgba(191, 0, 255, 1))
                        drop-shadow(0 0 25px rgba(191, 0, 255, 0.8))
                        drop-shadow(0 0 45px rgba(191, 0, 255, 0.5))
                        drop-shadow(0 0 70px rgba(0, 240, 255, 0.4));
            }
        }

        .header-logo svg {
            width: 100%;
            height: 100%;
        }

        .header h1 {
            font-family: 'Space Mono', monospace;
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .header p {
            font-size: 1rem;
            opacity: 0.9;
        }
        
        .setup-section {
            background: var(--bg-secondary);
            padding: 30px;
            border-radius: 15px;
            margin-bottom: 30px;
            border: 2px solid var(--border);
        }
        
        .setup-section h2 {
            color: var(--accent-orange);
            margin-bottom: 20px;
            font-size: 1.5rem;
        }
        
        .setup-section.hidden {
            display: none;
        }
        
        .credentials-form {
            display: grid;
            gap: 20px;
        }
        
        .form-group {
            display: flex;
            flex-direction: column;
        }
        
        .form-group label {
            font-weight: 600;
            margin-bottom: 8px;
            color: var(--text-secondary);
            font-size: 1.05rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .form-group input,
        .form-group select,
        .form-group textarea {
            padding: 14px;
            background: var(--bg-tertiary);
            border: 2px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 1.1rem;
            font-family: 'Work Sans', sans-serif;
            transition: all 0.3s ease;
        }
        
        .form-group select option {
            background: var(--bg-tertiary);
            color: var(--text-primary);
        }
        
        .form-group input:focus,
        .form-group select:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: var(--accent-purple);
            background: rgba(147, 51, 234, 0.05);
        }
        
        .form-group textarea {
            min-height: 100px;
            resize: vertical;
        }
        
        .help-text {
            font-size: 1rem;
            color: var(--text-secondary);
            margin-top: 5px;
            font-style: italic;
        }
        
        .user-login {
            padding: 25px;
            padding-top: 60px;
            margin-bottom: 30px;
        }
        
        .user-login h2 {
            font-size: 1.3rem;
            margin-bottom: 15px;
            color: var(--accent-green);
        }
        
        .user-select {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .user-btn {
            padding: 15px;
            background: transparent;
            border: 2px solid var(--border);
            color: var(--text-primary);
            border-radius: 10px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: all 0.3s ease;
        }

        .user-btn:hover {
            border-color: var(--accent-purple);
            color: var(--accent-purple);
            background: transparent;
            box-shadow: 0 0 15px rgba(191, 0, 255, 0.3), inset 0 0 10px rgba(191, 0, 255, 0.05);
        }

        .user-btn.active {
            background: transparent;
            border-color: var(--accent-purple);
            color: var(--accent-purple);
            box-shadow: 0 0 20px rgba(191, 0, 255, 0.5), 0 0 40px rgba(191, 0, 255, 0.3), inset 0 0 15px rgba(191, 0, 255, 0.1);
        }
        
        .current-user {
            background: var(--bg-tertiary);
            padding: 15px;
            border-radius: 10px;
            border-left: 4px solid var(--accent-green);
            font-weight: 600;
        }
        
        .station-tabs {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }
        
        .station-tab {
            padding: 20px;
            background: transparent;
            border: 2px solid var(--border);
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            text-align: center;
        }

        .station-tab:hover {
            transform: translateY(-2px);
            border-color: var(--accent-purple);
            color: var(--accent-purple);
            box-shadow: 0 0 20px rgba(191, 0, 255, 0.3), 0 5px 20px rgba(0,0,0,0.3), inset 0 0 10px rgba(191, 0, 255, 0.05);
        }

        .station-tab.active {
            border-color: var(--accent-purple);
            background: transparent;
            color: var(--accent-purple);
            box-shadow: 0 0 20px rgba(191, 0, 255, 0.5), 0 0 40px rgba(191, 0, 255, 0.3), inset 0 0 15px rgba(191, 0, 255, 0.1);
        }
        
        .station-tab h3 {
            font-size: 1.2rem;
            margin-bottom: 5px;
        }
        
        .station-tab .icon {
            font-size: 2rem;
            margin-bottom: 10px;
            position: relative;
            display: inline-block;
        }
        
        .badge {
            position: absolute;
            top: -8px;
            right: -12px;
            background: linear-gradient(135deg, var(--accent-purple), var(--accent-blue));
            color: white;
            font-size: 0.75rem;
            font-weight: 700;
            padding: 3px 8px;
            border-radius: 12px;
            min-width: 20px;
            text-align: center;
            box-shadow: 0 2px 8px rgba(147, 51, 234, 0.3);
            display: none;
        }
        
        .badge.has-count {
            display: inline-block;
        }
        
        .station-content {
            display: none;
            animation: fadeIn 0.3s ease;
        }
        
        .station-content.active {
            display: block;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .form-section {
            background: var(--bg-secondary);
            padding: 30px;
            border-radius: 15px;
            margin-bottom: 20px;
            border: 2px solid var(--border);
        }
        
        .form-section h2 {
            font-size: 1.5rem;
            margin-bottom: 20px;
            color: var(--accent-purple);
            font-family: 'Space Mono', monospace;
        }
        
        .form-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .checkbox-group {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 10px;
        }
        
        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 12px;
            background: var(--bg-tertiary);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .checkbox-item:hover {
            background: rgba(147, 51, 234, 0.1);
        }
        
        .checkbox-item input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }
        
        .btn {
            padding: 15px 30px;
            background: transparent;
            color: var(--accent-purple);
            border: 2px solid var(--accent-purple);
            border-radius: 10px;
            font-size: 1rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 0 10px rgba(191, 0, 255, 0.3), inset 0 0 10px rgba(191, 0, 255, 0.05);
        }

        .btn:hover {
            background: rgba(191, 0, 255, 0.15);
            transform: translateY(-2px);
            box-shadow: 0 0 20px rgba(191, 0, 255, 0.5), 0 0 40px rgba(191, 0, 255, 0.3), inset 0 0 15px rgba(191, 0, 255, 0.1);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            box-shadow: none;
        }

        /* Neon button color variants */
        .btn[style*="--accent-green"], .btn[style*="accent-green"] {
            color: var(--accent-green);
            border-color: var(--accent-green);
            box-shadow: 0 0 10px rgba(57, 255, 20, 0.3), inset 0 0 10px rgba(57, 255, 20, 0.05);
        }
        .btn[style*="--accent-green"]:hover, .btn[style*="accent-green"]:hover {
            background: rgba(57, 255, 20, 0.15);
            box-shadow: 0 0 20px rgba(57, 255, 20, 0.5), 0 0 40px rgba(57, 255, 20, 0.3), inset 0 0 15px rgba(57, 255, 20, 0.1);
        }

        .btn[style*="--accent-blue"], .btn[style*="accent-blue"] {
            color: var(--accent-blue);
            border-color: var(--accent-blue);
            box-shadow: 0 0 10px rgba(0, 240, 255, 0.3), inset 0 0 10px rgba(0, 240, 255, 0.05);
        }
        .btn[style*="--accent-blue"]:hover, .btn[style*="accent-blue"]:hover {
            background: rgba(0, 240, 255, 0.15);
            box-shadow: 0 0 20px rgba(0, 240, 255, 0.5), 0 0 40px rgba(0, 240, 255, 0.3), inset 0 0 15px rgba(0, 240, 255, 0.1);
        }

        .btn[style*="--accent-orange"], .btn[style*="accent-orange"] {
            color: var(--accent-orange);
            border-color: var(--accent-orange);
            box-shadow: 0 0 10px rgba(255, 107, 0, 0.3), inset 0 0 10px rgba(255, 107, 0, 0.05);
        }
        .btn[style*="--accent-orange"]:hover, .btn[style*="accent-orange"]:hover {
            background: rgba(255, 107, 0, 0.15);
            box-shadow: 0 0 20px rgba(255, 107, 0, 0.5), 0 0 40px rgba(255, 107, 0, 0.3), inset 0 0 15px rgba(255, 107, 0, 0.1);
        }

        .btn[style*="--accent-red"], .btn[style*="accent-red"] {
            color: var(--accent-red);
            border-color: var(--accent-red);
            box-shadow: 0 0 10px rgba(255, 0, 85, 0.3), inset 0 0 10px rgba(255, 0, 85, 0.05);
        }
        .btn[style*="--accent-red"]:hover, .btn[style*="accent-red"]:hover {
            background: rgba(255, 0, 85, 0.15);
            box-shadow: 0 0 20px rgba(255, 0, 85, 0.5), 0 0 40px rgba(255, 0, 85, 0.3), inset 0 0 15px rgba(255, 0, 85, 0.1);
        }

        .btn[style*="--accent-pink"], .btn[style*="accent-pink"] {
            color: var(--accent-pink);
            border-color: var(--accent-pink);
            box-shadow: 0 0 10px rgba(255, 16, 240, 0.3), inset 0 0 10px rgba(255, 16, 240, 0.05);
        }
        .btn[style*="--accent-pink"]:hover, .btn[style*="accent-pink"]:hover {
            background: rgba(255, 16, 240, 0.15);
            box-shadow: 0 0 20px rgba(255, 16, 240, 0.5), 0 0 40px rgba(255, 16, 240, 0.3), inset 0 0 15px rgba(255, 16, 240, 0.1);
        }

        /* Neon outline overrides for buttons with inline background styles */
        .btn[style*="background"] {
            background: transparent !important;
            border: 2px solid var(--accent-purple) !important;
            color: var(--accent-purple) !important;
            box-shadow: 0 0 10px rgba(191, 0, 255, 0.3), inset 0 0 10px rgba(191, 0, 255, 0.05);
        }
        .btn[style*="background"]:hover {
            background: rgba(191, 0, 255, 0.15) !important;
            box-shadow: 0 0 20px rgba(191, 0, 255, 0.5), 0 0 40px rgba(191, 0, 255, 0.3), inset 0 0 15px rgba(191, 0, 255, 0.1);
        }

        /* Green neon buttons */
        .btn[style*="accent-green"], .btn[style*="#39ff14"], .btn[style*="#10B981"], .btn[style*="10B981"] {
            border-color: var(--accent-green) !important;
            color: var(--accent-green) !important;
            box-shadow: 0 0 10px rgba(57, 255, 20, 0.3), inset 0 0 10px rgba(57, 255, 20, 0.05);
        }
        .btn[style*="accent-green"]:hover, .btn[style*="#39ff14"]:hover, .btn[style*="#10B981"]:hover, .btn[style*="10B981"]:hover {
            background: rgba(57, 255, 20, 0.15) !important;
            box-shadow: 0 0 20px rgba(57, 255, 20, 0.5), 0 0 40px rgba(57, 255, 20, 0.3), inset 0 0 15px rgba(57, 255, 20, 0.1);
        }

        /* Blue neon buttons */
        .btn[style*="accent-blue"], .btn[style*="#0055ff"], .btn[style*="#3B82F6"], .btn[style*="3B82F6"] {
            border-color: var(--accent-blue) !important;
            color: var(--accent-blue) !important;
            box-shadow: 0 0 10px rgba(0, 240, 255, 0.3), inset 0 0 10px rgba(0, 240, 255, 0.05);
        }
        .btn[style*="accent-blue"]:hover, .btn[style*="#0055ff"]:hover, .btn[style*="#3B82F6"]:hover, .btn[style*="3B82F6"]:hover {
            background: rgba(0, 240, 255, 0.15) !important;
            box-shadow: 0 0 20px rgba(0, 240, 255, 0.5), 0 0 40px rgba(0, 240, 255, 0.3), inset 0 0 15px rgba(0, 240, 255, 0.1);
        }

        /* Orange neon buttons */
        .btn[style*="accent-orange"], .btn[style*="#ff6b00"] {
            border-color: var(--accent-orange) !important;
            color: var(--accent-orange) !important;
            box-shadow: 0 0 10px rgba(255, 107, 0, 0.3), inset 0 0 10px rgba(255, 107, 0, 0.05);
        }
        .btn[style*="accent-orange"]:hover, .btn[style*="#ff6b00"]:hover {
            background: rgba(255, 107, 0, 0.15) !important;
            box-shadow: 0 0 20px rgba(255, 107, 0, 0.5), 0 0 40px rgba(255, 107, 0, 0.3), inset 0 0 15px rgba(255, 107, 0, 0.1);
        }

        /* Red neon buttons */
        .btn[style*="accent-red"], .btn[style*="#ff0055"] {
            border-color: var(--accent-red) !important;
            color: var(--accent-red) !important;
            box-shadow: 0 0 10px rgba(255, 0, 85, 0.3), inset 0 0 10px rgba(255, 0, 85, 0.05);
        }
        .btn[style*="accent-red"]:hover, .btn[style*="#ff0055"]:hover {
            background: rgba(255, 0, 85, 0.15) !important;
            box-shadow: 0 0 20px rgba(255, 0, 85, 0.5), 0 0 40px rgba(255, 0, 85, 0.3), inset 0 0 15px rgba(255, 0, 85, 0.1);
        }

        /* Gradient neon buttons - use purple as primary with multi-color glow */
        .btn[style*="linear-gradient"] {
            border-color: var(--accent-purple) !important;
            color: var(--accent-purple) !important;
            box-shadow: 0 0 10px rgba(191, 0, 255, 0.3), 0 0 20px rgba(0, 240, 255, 0.2), inset 0 0 10px rgba(191, 0, 255, 0.05);
        }
        .btn[style*="linear-gradient"]:hover {
            background: rgba(191, 0, 255, 0.15) !important;
            box-shadow: 0 0 25px rgba(191, 0, 255, 0.5), 0 0 40px rgba(0, 240, 255, 0.4), 0 0 60px rgba(255, 16, 240, 0.3), inset 0 0 15px rgba(191, 0, 255, 0.1);
        }

        /* Silver neon buttons (machine status) */
        .btn[style*="#C0C0C0"], .btn[style*="C0C0C0"] {
            background: transparent !important;
            border-color: #C0C0C0 !important;
            color: #E8E8E8 !important;
            box-shadow: 0 0 15px rgba(192, 192, 192, 0.4), 0 0 30px rgba(192, 192, 192, 0.2), inset 0 0 15px rgba(192, 192, 192, 0.05) !important;
        }
        .btn[style*="#C0C0C0"]:hover, .btn[style*="C0C0C0"]:hover {
            background: rgba(192, 192, 192, 0.15) !important;
            box-shadow: 0 0 25px rgba(192, 192, 192, 0.6), 0 0 50px rgba(192, 192, 192, 0.3), inset 0 0 20px rgba(192, 192, 192, 0.1) !important;
        }

        /* Gold neon buttons (pull batch) */
        .btn[style*="#FFD700"], .btn[style*="FFD700"] {
            background: transparent !important;
            border-color: #FFD700 !important;
            color: #FFD700 !important;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.4), 0 0 30px rgba(255, 215, 0, 0.2), inset 0 0 15px rgba(255, 215, 0, 0.05) !important;
        }
        .btn[style*="#FFD700"]:hover, .btn[style*="FFD700"]:hover {
            background: rgba(255, 215, 0, 0.15) !important;
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.6), 0 0 50px rgba(255, 215, 0, 0.3), inset 0 0 20px rgba(255, 215, 0, 0.1) !important;
        }

        /* Tertiary/muted neon buttons */
        .btn[style*="bg-tertiary"] {
            border-color: var(--text-secondary) !important;
            color: var(--text-primary) !important;
            box-shadow: 0 0 8px rgba(136, 136, 136, 0.2), inset 0 0 8px rgba(136, 136, 136, 0.03);
        }
        .btn[style*="bg-tertiary"]:hover {
            border-color: var(--accent-purple) !important;
            color: var(--accent-purple) !important;
            background: rgba(191, 0, 255, 0.1) !important;
            box-shadow: 0 0 15px rgba(191, 0, 255, 0.4), inset 0 0 10px rgba(191, 0, 255, 0.05);
        }

        .batch-list {
            background: var(--bg-secondary);
            padding: 30px;
            border-radius: 15px;
            border: 2px solid var(--border);
        }
        
        .batch-list h2 {
            font-size: 1.5rem;
            margin-bottom: 20px;
            color: var(--accent-green);
            font-family: 'Space Mono', monospace;
        }
        
        .batch-item {
            background: var(--bg-tertiary);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 15px;
            border-left: 4px solid var(--accent-purple);
            position: relative;
            transition: all 0.3s ease;
        }
        
        .batch-item:hover {
            transform: translateX(5px);
            box-shadow: 0 5px 20px rgba(0,0,0,0.3);
        }
        
        .batch-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .batch-id {
            font-family: 'Space Mono', monospace;
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--accent-purple);
        }
        
        .batch-status {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 1rem;
            font-weight: 600;
            text-transform: uppercase;
        }
        
        .status-intake { background: var(--accent-blue); }
        .status-extraction { background: var(--accent-orange); }
        .status-finishing { background: var(--accent-green); }
        .status-packaging { background: var(--accent-red); }
        .status-complete { background: #6b7280; }
        .status-consumed { background: #9333ea; }
        
        .batch-details {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        
        .batch-detail {
            display: flex;
            flex-direction: column;
        }
        
        .batch-detail-label {
            font-size: 0.95rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 5px;
        }
        
        .batch-detail-value {
            font-size: 1.15rem;
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .batch-actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        
        .btn-small {
            padding: 8px 16px;
            font-size: 1rem;
            background: transparent;
            color: var(--accent-purple);
            border: 2px solid var(--accent-purple);
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 0 8px rgba(191, 0, 255, 0.3), inset 0 0 8px rgba(191, 0, 255, 0.05);
        }

        .btn-small:hover {
            background: rgba(191, 0, 255, 0.15);
            box-shadow: 0 0 15px rgba(191, 0, 255, 0.5), 0 0 30px rgba(191, 0, 255, 0.3), inset 0 0 10px rgba(191, 0, 255, 0.1);
        }
        
        .filter-bar {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        
        .filter-btn {
            padding: 10px 20px;
            background: transparent;
            border: 2px solid var(--border);
            color: var(--text-primary);
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.3s ease;
        }

        .filter-btn:hover {
            border-color: var(--accent-purple);
            color: var(--accent-purple);
            box-shadow: 0 0 15px rgba(191, 0, 255, 0.3), inset 0 0 10px rgba(191, 0, 255, 0.05);
        }

        .filter-btn.active {
            background: transparent;
            border-color: var(--accent-purple);
            color: var(--accent-purple);
            box-shadow: 0 0 15px rgba(191, 0, 255, 0.4), 0 0 30px rgba(191, 0, 255, 0.2), inset 0 0 10px rgba(191, 0, 255, 0.1);
        }
        
        .search-box {
            flex: 1;
            min-width: 250px;
        }
        
        .search-box input {
            width: 100%;
            padding: 12px;
            background: var(--bg-tertiary);
            border: 2px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            font-size: 1rem;
        }
        
        .timeline {
            position: relative;
            padding-left: 30px;
            margin-top: 15px;
        }
        
        .timeline::before {
            content: '';
            position: absolute;
            left: 8px;
            top: 0;
            bottom: 0;
            width: 2px;
            background: var(--border);
        }
        
        .timeline-item {
            position: relative;
            padding-bottom: 20px;
        }
        
        .timeline-item::before {
            content: '';
            position: absolute;
            left: -26px;
            top: 5px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--accent-purple);
            border: 2px solid var(--bg-primary);
        }
        
        .timeline-content {
            background: rgba(147, 51, 234, 0.1);
            padding: 10px 15px;
            border-radius: 8px;
            border-left: 3px solid var(--accent-purple);
        }
        
        .timeline-user {
            font-weight: 600;
            color: var(--accent-purple);
        }
        
        .timeline-date {
            font-size: 1rem;
            color: var(--text-secondary);
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .stat-card {
            background: var(--bg-secondary);
            padding: 20px;
            border-radius: 15px;
            border: 2px solid var(--border);
            text-align: center;
        }
        
        .stat-value {
            font-size: 2rem;
            font-weight: 700;
            color: var(--accent-purple);
            font-family: 'Space Mono', monospace;
        }
        
        .stat-label {
            font-size: 1.05rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-top: 5px;
        }
        
        .success-message {
            background: rgba(16, 185, 129, 0.2);
            border: 2px solid var(--accent-green);
            color: var(--accent-green);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            font-weight: 600;
            text-align: center;
        }
        
        .error-message {
            background: rgba(239, 68, 68, 0.2);
            border: 2px solid var(--accent-red);
            color: var(--accent-red);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            font-weight: 600;
            text-align: center;
        }
        
        .leaflink-section {
            background: rgba(59, 130, 246, 0.1);
            border: 2px solid var(--accent-blue);
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
        }
        
        .leaflink-section h3 {
            color: var(--accent-blue);
            margin-bottom: 15px;
        }

        .app-container {
            display: none;
        }

        .app-container.active {
            display: block;
        }

        .analytics-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        .analytics-table th {
            background: var(--bg-tertiary);
            padding: 15px;
            text-align: left;
            font-weight: 700;
            text-transform: uppercase;
            font-size: 1rem;
            letter-spacing: 0.5px;
            color: var(--text-secondary);
            border-bottom: 2px solid var(--border);
        }

        .analytics-table td {
            padding: 15px;
            border-bottom: 1px solid var(--border);
            font-size: 1.05rem;
        }

        .analytics-table tr:hover {
            background: rgba(147, 51, 234, 0.05);
        }

        .profit-positive {
            color: var(--accent-green);
            font-weight: 600;
        }

        .profit-negative {
            color: var(--accent-red);
            font-weight: 600;
        }

                /* METRC Manifest hover effects */
                #manifestsContainer > div:hover {
                    background: rgba(147, 51, 234, 0.1) !important;
                    border-color: var(--accent-purple) !important;
                    transform: translateY(-2px);
                    box-shadow: 0 8px 25px rgba(147, 51, 234, 0.3);
                }
        
                .actions-menu {
                    position: fixed;
                    top: 20px;
                    left: 20px;
                    z-index: 1000;
                }
        
                .actions-toggle-btn {
                    background: transparent;
                    color: var(--accent-purple);
                    border: 2px solid var(--accent-purple);
                    padding: 12px 24px;
                    border-radius: 12px;
                    font-weight: 700;
                    cursor: pointer;
                    font-size: 1rem;
                    box-shadow: 0 0 15px rgba(191, 0, 255, 0.4), 0 0 30px rgba(0, 240, 255, 0.2), inset 0 0 10px rgba(191, 0, 255, 0.05);
                    transition: all 0.3s ease;
                }

                .actions-toggle-btn:hover {
                    background: rgba(191, 0, 255, 0.15);
                    box-shadow: 0 0 25px rgba(191, 0, 255, 0.6), 0 0 50px rgba(0, 240, 255, 0.4), inset 0 0 15px rgba(191, 0, 255, 0.1);
                }

                .actions-dropdown {
                    display: none;
                    position: absolute;
                    top: 100%;
                    left: 0;
                    background: var(--bg-secondary);
                    border-radius: 12px;
                    padding: 10px;
                    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.5), 0 0 20px rgba(191, 0, 255, 0.2);
                    margin-top: 10px;
                    width: 200px;
                    border: 2px solid var(--accent-purple);
                    z-index: 10000;
                }

                .actions-dropdown button {
                    display: block;
                    width: 100%;
                    padding: 10px;
                    margin-bottom: 5px;
                    text-align: left;
                    background: transparent;
                    color: var(--text-primary);
                    border: 1px solid var(--border);
                    border-radius: 8px;
                    font-size: 0.9rem;
                    transition: all 0.2s ease;
                }

                .actions-dropdown button:hover {
                    background: transparent;
                    border-color: var(--accent-purple);
                    color: var(--accent-purple);
                    box-shadow: 0 0 10px rgba(191, 0, 255, 0.3), inset 0 0 8px rgba(191, 0, 255, 0.05);
                }
                
                        #connectionStatus {
                            display: none !important;
                        }
                                
                @media (max-width: 768px) {            body {
                padding: 10px;
                font-size: 1rem;
            }

            .header {
                padding: 20px;
                margin-bottom: 20px;
            }

            .header h1 {
                font-size: 1.8rem;
            }

            .form-section, .setup-section, .user-login, .batch-list {
                padding: 20px;
            }

            .form-section h2, .batch-list h2, .setup-section h2, .user-login h2 {
                font-size: 1.3rem;
            }

            /* App Icon Style Navigation */
            .station-tabs {
                display: grid;
                grid-template-columns: repeat(3, 1fr);
                gap: 15px;
                padding: 10px;
            }

            .station-tab {
                padding: 12px 8px;
                aspect-ratio: 1;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                border-radius: 20px;
                background: linear-gradient(145deg, rgba(40, 40, 60, 0.9), rgba(25, 25, 40, 0.95));
                border: 1px solid rgba(255, 255, 255, 0.1);
                box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.1);
            }

            .station-tab:hover, .station-tab.active {
                transform: scale(1.05);
                box-shadow: 0 0 20px rgba(191, 0, 255, 0.4), 0 4px 15px rgba(0, 0, 0, 0.3);
            }

            .station-tab .icon {
                font-size: 2rem;
                margin-bottom: 5px;
            }

            .station-tab h3 {
                font-size: 0.7rem;
                text-align: center;
                margin: 0;
                line-height: 1.2;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
                max-width: 100%;
            }

            .station-tab p {
                display: none;
            }

            .station-tab .badge {
                position: absolute;
                top: -5px;
                right: -5px;
                font-size: 0.65rem;
                min-width: 16px;
                height: 16px;
                padding: 0 4px;
            }

            /* Mobile Popup Page Styles */
            .station-content {
                display: none;
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: var(--bg-primary);
                z-index: 1000;
                overflow-y: auto;
                padding: 60px 15px 20px 15px;
                animation: slideUp 0.25s ease-out;
            }

            .station-content.active {
                display: block;
            }

            @keyframes slideUp {
                from { transform: translateY(100%); opacity: 0; }
                to { transform: translateY(0); opacity: 1; }
            }

            /* Back button for mobile popups */
            .mobile-back-btn {
                position: fixed;
                top: 15px;
                left: 15px;
                z-index: 1002;
                background: rgba(30, 30, 45, 0.95);
                border: 2px solid var(--accent-purple);
                color: var(--text-primary);
                padding: 10px 18px;
                border-radius: 25px;
                font-size: 1rem;
                font-weight: 600;
                cursor: pointer;
                box-shadow: 0 0 15px rgba(191, 0, 255, 0.3);
                display: block;
            }

            /* Keep station tabs visible as home screen */
            .station-tabs {
                position: relative;
                z-index: 1;
            }

            .btn {
                padding: 12px 20px;
                font-size: 0.9rem;
            }

            #batchDetailsModal > div, #editBatchModal > div {
                width: 95%;
                margin: 20px auto;
                padding: 20px;
            }

            #myStatsBtn, #timeClockBtn, #viewTimecardsBtn {
                position: relative;
                top: auto;
                left: auto;
                width: 100%;
                margin-bottom: 10px;
                display: block !important;
            }
            
            .header-content {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .filter-bar {
                flex-direction: column;
            }
            
            .search-box {
                min-width: unset;
                width: 100%;
            }

            /* Front of House Mobile Fixes */

            /* Force Generate Post to stack vertically */
            .foh-generate-container {
                flex-direction: column !important;
            }

            #fohQuickInput {
                width: 100% !important;
                flex: none !important;
                min-width: 100% !important;
                box-sizing: border-box !important;
            }

            .foh-generate-btn {
                width: 100% !important;
                flex: none !important;
            }

            #frontofhouse div[style*="display: flex"] {
                flex-wrap: wrap !important;
            }

            #frontofhouse div[style*="display: flex"][style*="justify-content: space-between"],
            #frontofhouse div[style*="display: flex"][style*="gap: 15px"] {
                flex-direction: column !important;
                align-items: stretch !important;
                gap: 10px !important;
            }

            #frontofhouse .btn,
            #frontofhouse button.btn,
            #frontofhouse a.btn {
                width: 100% !important;
                text-align: center !important;
                padding: 12px 20px !important;
                margin: 0 !important;
            }

            #frontofhouse input[type="text"] {
                width: 100% !important;
                max-width: 100% !important;
                flex: none !important;
                margin: 0 !important;
                box-sizing: border-box !important;
            }

            /* Sales Dashboard Mobile Fixes */
            #frontofhouse select {
                width: 100% !important;
                min-width: unset !important;
            }

            /* Generated Preview buttons */
            #fohGeneratedPreview div[style*="display: flex"] {
                flex-direction: column !important;
                gap: 10px !important;
            }

            /* Reduce padding on containers */
            #frontofhouse > div > div[style*="padding: 25px"] {
                padding: 15px !important;
            }
        }

        /* Extra aggressive fix for smaller phones */
        @media (max-width: 600px) {
            body {
                font-size: 0.9rem;
            }

            .foh-generate-container {
                display: block !important;
            }

            #fohQuickInput {
                display: block !important;
                width: 100% !important;
                margin-bottom: 10px !important;
                font-size: 1rem !important;
            }

            .foh-generate-btn {
                display: block !important;
                width: 100% !important;
                font-size: 1rem !important;
                padding: 12px !important;
            }

            #frontofhouse button,
            #frontofhouse .btn {
                font-size: 0.95rem !important;
                padding: 10px 15px !important;
            }

            #frontofhouse .form-section {
                padding: 15px !important;
            }

            /* Fix Sales Dashboard grid minimum width */
            #salesDashboardStats {
                grid-template-columns: 1fr !important;
            }

            /* Sales Bar Chart mobile fixes */
            #salesBarChart {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }

            /* Fix Commission Calculator grid overflow on mobile */
            #commissionCalculatorGridSales {
                grid-template-columns: 1fr !important;
            }

            /* Reduce padding on commission cards for mobile */
            #commissionCalculatorGridSales > div {
                padding: 15px !important;
            }

            /* Fix Monthly Sales Breakdown table overflow */
            #salesMonthlyBreakdown {
                overflow-x: auto !important;
                -webkit-overflow-scrolling: touch;
            }

            /* Improve table readability on mobile */
            #salesMonthlyBreakdown table {
                min-width: 500px;
            }
        }
    </style>
</head>
<body>
    <div class="connection-status connecting" id="connectionStatus">
        <div class="status-dot"></div>
        <span id="statusText">Connecting...</span>
    </div>
    
    <div class="actions-menu" id="actionsMenu" style="display: none;">
        <button class="actions-toggle-btn" onclick="toggleActionsMenu()">Actions</button>
        <div class="actions-dropdown">
            <!-- Business Selector -->
            <div id="businessSelector" style="display: none; padding: 10px; border-bottom: 1px solid var(--border); margin-bottom: 8px;">
                <label style="display: block; font-size: 0.8rem; color: var(--text-secondary); margin-bottom: 5px;">Switch Business</label>
                <select id="businessFilter" onchange="switchBusiness(this.value)" style="width: 100%; background: var(--bg-tertiary); color: var(--text-primary); border: 2px solid var(--border); border-radius: 8px; padding: 8px 12px; font-size: 0.9rem; cursor: pointer;">
                    <option value="all">All Businesses</option>
                </select>
            </div>
            <button id="logoutBtn" onclick="logout()" style="display: none; background: transparent; border: 2px solid var(--accent-red); color: var(--accent-red); box-shadow: 0 0 15px rgba(255, 0, 85, 0.4), 0 0 30px rgba(255, 0, 85, 0.2);"> Log Out</button>
            <button id="myStatsBtn" onclick="openPersonalStatsModal()" style="display: none;"> My Workload</button>
            <button id="timeClockBtn" onclick="openTimeClockModal()" style="display: none;">Time Clock</button>
            <button id="viewTimecardsBtn" onclick="openTimecardsModal()" style="display: none;">Timecards</button>
            <button id="viewTrashBtn" onclick="openTrashModal()" style="display: none;"> Deleted Batches</button>
            <button id="complianceBtn" onclick="openComplianceModal()" style="display: none;"> Compliance</button>
            <button id="loginHistoryBtn" onclick="openLoginHistoryModal()" style="display: none;"> Login History</button>
            <button id="leaflinkApprovalsBtn" onclick="openLeafLinkApprovalsModal()" style="display: none;"> LeafLink Queue</button>
            <button id="printLabelsBtn" onclick="openPrintLabelsModal()"> Print Labels</button>
            <button id="manageEmployeesBtn" onclick="openEmployeeManagement()" style="display: none;"> Manage Employees</button>
            <button id="adminConfigBtn" onclick="window.open('admin-config.html', '_blank')" style="display: none;"> Admin Config</button>
        </div>
    </div>

    <!-- Login History Modal -->
    <div id="loginHistoryModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); z-index: 10005; overflow-y: auto;">
        <div style="max-width: 800px; margin: 30px auto; background: var(--bg-secondary); border-radius: 20px; overflow: hidden;">
            <div style="background: linear-gradient(135deg, var(--accent-purple), var(--accent-blue)); padding: 25px; display: flex; justify-content: space-between; align-items: center;">
                <h2 style="margin: 0; color: white;"> Login History</h2>
                <button onclick="closeLoginHistoryModal()" style="background: rgba(255,255,255,0.2); border: none; color: white; font-size: 1.5rem; cursor: pointer; padding: 5px 15px; border-radius: 8px;">&times;</button>
            </div>
            <div style="padding: 25px;">
                <div id="loginHistoryContent" style="max-height: 500px; overflow-y: auto;">
                    Loading...
                </div>
            </div>
        </div>
    </div>

    <!-- LeafLink Approvals Modal -->
    <div id="leaflinkApprovalsModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); z-index: 10005; overflow-y: auto;">
        <div style="max-width: 600px; margin: 30px auto; background: var(--bg-secondary); border-radius: 20px; overflow: hidden;">
            <div style="background: linear-gradient(135deg, #10B981, #059669); padding: 25px; display: flex; justify-content: space-between; align-items: center;">
                <h2 style="margin: 0; color: white;"> LeafLink Approval Queue</h2>
                <button onclick="closeLeafLinkApprovalsModal()" style="background: rgba(255,255,255,0.2); border: none; color: white; font-size: 1.5rem; cursor: pointer; padding: 5px 15px; border-radius: 8px;">&times;</button>
            </div>
            <div style="padding: 25px;">
                <p style="color: var(--text-secondary); margin-bottom: 15px; font-size: 0.9em;">
                    Batches awaiting approval before being pushed to LeafLink inventory.
                </p>
                <div id="leaflinkApprovalQueue" style="max-height: 500px; overflow-y: auto;">
                    Loading...
                </div>
            </div>
        </div>
    </div>

    <!-- Print Labels Modal -->
    <div id="printLabelsModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); z-index: 10005; overflow-y: auto;">
        <div style="max-width: 500px; margin: 30px auto; background: var(--bg-secondary); border-radius: 20px; overflow: hidden;">
            <div style="background: linear-gradient(135deg, #8B5CF6, #6366F1); padding: 25px; display: flex; justify-content: space-between; align-items: center;">
                <h2 style="margin: 0; color: white;"> Print Labels</h2>
                <button onclick="closePrintLabelsModal()" style="background: rgba(255,255,255,0.2); border: none; color: white; font-size: 1.5rem; cursor: pointer; padding: 5px 15px; border-radius: 8px;">&times;</button>
            </div>
            <div style="padding: 25px;">
                <div class="form-group" style="margin-bottom: 20px;">
                    <label style="color: var(--text-secondary); margin-bottom: 8px; display: block;">Select Batch</label>
                    <select id="printLabelsBatchSelect" style="width: 100%; padding: 12px; border-radius: 8px; border: 2px solid var(--border); background: var(--bg-tertiary); color: var(--text-primary); font-size: 1rem;">
                        <option value="">Select a batch...</option>
                    </select>
                </div>
                <div id="printLabelsBatchInfo" style="display: none; background: var(--bg-tertiary); padding: 15px; border-radius: 10px; margin-bottom: 20px;">
                </div>
                <div class="form-group" style="margin-bottom: 20px;">
                    <label style="color: var(--text-secondary); margin-bottom: 8px; display: block;">Label Type</label>
                    <select id="printLabelsLabelType" style="width: 100%; padding: 12px; border-radius: 8px; border: 2px solid var(--border); background: var(--bg-tertiary); color: var(--text-primary); font-size: 1rem;">
                        <option value="intake"> Intake Label</option>
                        <option value="postprod"> Post-Production Label</option>
                        <option value="labeling"> Labeling Complete Label</option>
                    </select>
                </div>
                <button onclick="printFromActionsModal()" style="width: 100%; background: linear-gradient(135deg, #8B5CF6, #6366F1); color: white; border: none; padding: 15px; border-radius: 10px; font-size: 1.1rem; cursor: pointer; font-weight: 600;">
                     Print Label
                </button>
            </div>
        </div>
    </div>

    <!-- Employee Management Modal -->
    <div id="employeeManagementModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); z-index: 10005; overflow-y: auto;">
        <div style="max-width: 700px; margin: 30px auto; background: var(--bg-secondary); border-radius: 20px; overflow: hidden;">
            <div style="background: linear-gradient(135deg, var(--accent-purple), var(--accent-blue)); padding: 25px; display: flex; justify-content: space-between; align-items: center;">
                <h2 style="margin: 0; color: white;"> Manage Employees</h2>
                <button onclick="closeEmployeeManagement()" style="background: rgba(255,255,255,0.2); border: none; color: white; font-size: 1.5rem; cursor: pointer; padding: 5px 15px; border-radius: 8px;">&times;</button>
            </div>
            <div style="padding: 25px;">
                <button onclick="openAddEmployee()" style="background: var(--accent-green); color: white; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer; font-size: 1rem; margin-bottom: 20px;">+ Add Employee</button>
                <div id="employeeListContent" style="max-height: 500px; overflow-y: auto;">
                    Loading...
                </div>
            </div>
        </div>
    </div>

    <!-- Add/Edit Employee Modal -->
    <div id="employeeFormModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); z-index: 10006; overflow-y: auto;">
        <div style="max-width: 500px; margin: 30px auto; background: var(--bg-secondary); border-radius: 20px; overflow: hidden;">
            <div style="background: linear-gradient(135deg, var(--accent-green), var(--accent-blue)); padding: 25px; display: flex; justify-content: space-between; align-items: center;">
                <h2 id="employeeFormTitle" style="margin: 0; color: white;">Add Employee</h2>
                <button onclick="closeEmployeeForm()" style="background: rgba(255,255,255,0.2); border: none; color: white; font-size: 1.5rem; cursor: pointer; padding: 5px 15px; border-radius: 8px;">&times;</button>
            </div>
            <div style="padding: 25px;">
                <input type="hidden" id="employeeEditId">
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; color: var(--text-secondary);">Name</label>
                    <input type="text" id="employeeName" style="width: 100%; padding: 12px; border-radius: 8px; border: 1px solid var(--border-color); background: var(--bg-tertiary); color: var(--text-primary); font-size: 1rem;" placeholder="Employee name">
                </div>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 5px; color: var(--text-secondary);">PIN (4 digits)</label>
                    <input type="text" id="employeePIN" maxlength="4" style="width: 100%; padding: 12px; border-radius: 8px; border: 1px solid var(--border-color); background: var(--bg-tertiary); color: var(--text-primary); font-size: 1rem;" placeholder="1234">
                </div>
                <div style="margin-bottom: 20px; display: flex; gap: 20px; flex-wrap: wrap;">
                    <label style="display: flex; align-items: center; gap: 8px; color: var(--text-primary); cursor: pointer;">
                        <input type="checkbox" id="employeeIsAdmin" style="width: 18px; height: 18px;"> Admin
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; color: var(--text-primary); cursor: pointer;">
                        <input type="checkbox" id="employeeIsSalary" style="width: 18px; height: 18px;"> Salary
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; color: var(--text-primary); cursor: pointer;">
                        <input type="checkbox" id="employeeReadOnly" style="width: 18px; height: 18px;"> Read Only
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; color: var(--text-primary); cursor: pointer;">
                        <input type="checkbox" id="employeeCanEditBatches" style="width: 18px; height: 18px;"> Can Edit Batches
                    </label>
                </div>
                <div style="margin-bottom: 20px;">
                    <label style="display: block; margin-bottom: 10px; color: var(--text-secondary);">Station Access</label>
                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">
                        <label style="display: flex; align-items: center; gap: 8px; color: var(--text-primary); cursor: pointer;">
                            <input type="checkbox" class="station-checkbox" value="dashboard" style="width: 16px; height: 16px;"> Dashboard
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; color: var(--text-primary); cursor: pointer;">
                            <input type="checkbox" class="station-checkbox" value="intake" style="width: 16px; height: 16px;"> Intake
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; color: var(--text-primary); cursor: pointer;">
                            <input type="checkbox" class="station-checkbox" value="extraction" style="width: 16px; height: 16px;"> Extraction
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; color: var(--text-primary); cursor: pointer;">
                            <input type="checkbox" class="station-checkbox" value="finishing" style="width: 16px; height: 16px;"> Post-Extract
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; color: var(--text-primary); cursor: pointer;">
                            <input type="checkbox" class="station-checkbox" value="packaging" style="width: 16px; height: 16px;"> Packaging
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; color: var(--text-primary); cursor: pointer;">
                            <input type="checkbox" class="station-checkbox" value="testing" style="width: 16px; height: 16px;"> Testing
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; color: var(--text-primary); cursor: pointer;">
                            <input type="checkbox" class="station-checkbox" value="labeling" style="width: 16px; height: 16px;"> Labeling
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; color: var(--text-primary); cursor: pointer;">
                            <input type="checkbox" class="station-checkbox" value="analytics" style="width: 16px; height: 16px;"> Analytics
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; color: var(--text-primary); cursor: pointer;">
                            <input type="checkbox" class="station-checkbox" value="performance" style="width: 16px; height: 16px;"> Performance
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; color: var(--text-primary); cursor: pointer;">
                            <input type="checkbox" class="station-checkbox" value="frontofhouse" style="width: 16px; height: 16px;"> Front of House
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; color: var(--text-primary); cursor: pointer;">
                            <input type="checkbox" class="station-checkbox" value="sales" style="width: 16px; height: 16px;"> Sales
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; color: var(--text-primary); cursor: pointer;">
                            <input type="checkbox" class="station-checkbox" value="costing" style="width: 16px; height: 16px;"> Costing
                        </label>
                    </div>
                </div>
                <div style="display: flex; gap: 10px; justify-content: space-between;">
                    <button id="deactivateEmployeeBtn" onclick="deactivateEmployee()" style="display: none; background: var(--accent-red); color: white; border: none; padding: 12px 20px; border-radius: 8px; cursor: pointer;">Deactivate</button>
                    <div style="display: flex; gap: 10px; margin-left: auto;">
                        <button onclick="closeEmployeeForm()" style="background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border-color); padding: 12px 24px; border-radius: 8px; cursor: pointer;">Cancel</button>
                        <button onclick="saveEmployee()" style="background: var(--accent-green); color: white; border: none; padding: 12px 24px; border-radius: 8px; cursor: pointer;">Save</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Setup Section -->
    <div class="setup-section hidden" id="setupSection">
        <h2> Supabase Configuration</h2>
        <p style="margin-bottom: 20px; color: var(--text-secondary);">
            Enter your Supabase credentials once. They'll be saved securely in your browser.
        </p>
        <form class="credentials-form" id="credentialsForm">
            <div class="form-group">
                <label>Supabase Project URL</label>
                <input type="text" id="supabaseUrl" placeholder="https://xxxxx.supabase.co" required>
                <div class="help-text">Found in Project Settings  API  Project URL</div>
            </div>
            <div class="form-group">
                <label>Supabase Anon/Public Key</label>
                <input type="text" id="supabaseKey" placeholder="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..." required>
                <div class="help-text">Found in Project Settings  API  Project API keys  anon public</div>
            </div>
            <button type="submit" class="btn">Connect to Supabase</button>
        </form>
        <div style="margin-top: 20px; padding: 15px; background: rgba(245, 158, 11, 0.1); border-radius: 8px; border-left: 4px solid var(--accent-orange);">
            <strong>First Time Setup:</strong> After connecting, I'll automatically create the required database table for you.
        </div>
    </div>

    <!-- Main App -->
    <div class="app-container" id="appContainer">
        <div class="header">
            <div class="header-content">
                <div class="header-logo">
                    <img src="https://images.squarespace-cdn.com/content/v1/5501f606e4b0b9ba3b7be5ec/1537298893777-QBVYYWKI0KBKGYJGQJB5/WM.png?format=1500w" alt="White Mousse" id="headerLogo">
                </div>
                <div id="versionTag" style="position: absolute; top: 5px; right: 10px; font-size: 0.7rem; color: var(--text-muted); opacity: 0.6;">loading...</div>
                            </div>
        </div>
        <!-- Demo Mode Indicator -->
        <div id="demoIndicator" style="display: none; background: linear-gradient(90deg, var(--accent-purple), var(--accent-blue)); color: white; text-align: center; padding: 8px; font-weight: 700; font-size: 0.9rem;">
             DEMO MODE - No database changes will be saved
        </div>

        <div class="user-login" id="userLogin">
            
            <form id="pinForm" style="max-width: 300px; margin: 0 auto;" onsubmit="event.preventDefault(); login();">
                <input type="password" 
                       id="pinInput" 
                       maxlength="4" 
                       pattern="[0-9]{4}" 
                       placeholder=""
                       inputmode="numeric"
                       autocomplete="off"
                       style="width: 100%; padding: 15px; font-size: 1.5rem; text-align: center; letter-spacing: 10px; background: var(--bg-tertiary); border: 2px solid var(--border); border-radius: 10px; color: var(--text-primary); font-family: 'Space Mono', monospace; margin-bottom: 15px;">
                <button type="submit" id="loginBtn" style="width: 100%; padding: 15px; background: transparent; border: 2px solid var(--accent-purple); border-radius: 10px; color: var(--accent-purple); font-size: 1.1rem; font-weight: 700; cursor: pointer; box-shadow: 0 0 15px rgba(191, 0, 255, 0.4), 0 0 30px rgba(191, 0, 255, 0.2), inset 0 0 15px rgba(191, 0, 255, 0.05);">Login</button>
                <div id="loginError" style="color: var(--accent-red); text-align: center; margin-top: 10px; display: none;">Invalid PIN</div>
            </form>
            
        </div>

        <div id="appContent" style="display: none;">
        <div class="station-tabs">
            <div class="station-tab active" data-station="intake">
                <div class="icon"></div>
                <h3>Intake</h3>
                <p>Log trim batches</p>
            </div>
            <div class="station-tab" data-station="extraction">
                <div class="icon"><span class="badge" id="badge-extraction">0</span></div>
                <h3>Extraction</h3>
                <p>Process batches</p>
            </div>
            <div class="station-tab" data-station="finishing">
                <div class="icon"><span class="badge" id="badge-finishing">0</span></div>
                <h3>Post Extraction</h3>
                <p>Bulk weight & splitting</p>
            </div>
            <div class="station-tab" data-station="packaging">
                <div class="icon"><svg viewBox="0 0 24 24" width="28" height="28" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="vertical-align: middle;"><ellipse cx="6" cy="6" rx="4" ry="2"/><path d="M6 8c-2.2 0-4-.9-4-2v0M10 6c0 1.1-1.8 2-4 2"/><line x1="8" y1="7" x2="16" y2="15"/><path d="M14 17c0-1.5 1.5-3 4-3s4 1.5 4 3v2c0 1.1-1.8 2-4 2s-4-.9-4-2v-2z"/><path d="M12 13l-1 2"/><path d="M13 14l-1 2"/></svg><span class="badge" id="badge-packaging">0</span></div>
                <h3>Packaging</h3>
                <p>Final count & listing</p>
            </div>
            <div class="station-tab" data-station="testing">
                <div class="icon"><span class="badge" id="badge-testing">0</span></div>
                <h3>Testing</h3>
                <p>Test results entry</p>
            </div>
            <div class="station-tab" data-station="labeling">
                <div class="icon"><span class="badge" id="badge-labeling">0</span></div>
                <h3>Labeling</h3>
                <p>Print & apply labels</p>
            </div>
            <div class="station-tab" data-station="analytics">
                <div class="icon"></div>
                <h3>Analytics</h3>
                <p>Yield & Cost</p>
            </div>
            <div class="station-tab" data-station="performance">
                <div class="icon"></div>
                <h3>Performance</h3>
                <p>Employee Stats</p>
            </div>
            <div class="station-tab" data-station="dashboard">
                <div class="icon"></div>
                <h3>Dashboard</h3>
                <p>View all batches</p>
            </div>
            <div class="station-tab" data-station="frontofhouse">
                <div class="icon"></div>
                <h3>Front of House</h3>
                <p>Pipeline & Blog</p>
            </div>
            <div class="station-tab" data-station="sales">
                <div class="icon"></div>
                <h3>Sales</h3>
                <p>Orders & Commission</p>
            </div>
            <div class="station-tab" data-station="costing">
                <div class="icon"></div>
                <h3>Costing</h3>
                <p>COGS & Margins</p>
            </div>
        </div>

        <!-- Intake Station -->
        <div class="station-content" id="intake">
            <div class="form-section">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h2 style="margin: 0;"> New Trim Intake</h2>
                    <button type="button" class="btn" style="background: var(--accent-blue); display: none;" onclick="openMetrcImport()">
                         Import from METRC Manifest
                    </button>
                </div>
                <form id="intakeForm">
                    <div class="form-grid">
                        <div class="form-group">
                            <label>Batch ID (Auto-Generated)</label>
                            <input type="text" id="batchId" readonly>
                        </div>
                        <div class="form-group">
                            <label>Strain Name</label>
                            <input type="text" id="strainName" required>
                        </div>

                        <div class="form-group">
                            <label id="weightLabel">Trim Weight (grams)</label>
                            <input type="number" id="trimWeight" step="0.1" required>
                        </div>
                        <div class="form-group">
                            <label id="socksLabel">Number of Socks</label>
                            <input type="number" id="socksTotal" min="1" value="1" required>
                            <div class="help-text" id="socksHelp">How many socks is this trim packed into?</div>
                        </div>
                        <div class="form-group">
                            <label>Cost of Material ($)</label>
                            <input type="number" id="materialCost" step="0.01" required>
                        </div>
                        <div class="form-group">
                            <label>Material Agreement Type</label>
                            <select id="materialAgreement" required>
                                <option value="">Select Type</option>
                                <option value="Wholesale">Wholesale Purchase (100% owned)</option>
                                <option value="50-50 Split">50/50 Split (customer gets 50% yield)</option>
                                <option value="Custom Buyback">Custom Buyback</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Pre-Sift Before BHO?</label>
                            <select id="preSift" required>
                                <option value="no">No - Direct to BHO</option>
                                <option value="yes">Yes - Sift first</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Cultivation License # (Grower)</label>
                            <input type="text" id="cultivationLicense" placeholder="403R-01007 or 404R-00000" required>
                            <div class="help-text">Grower's license number (cultivation or manufacturing)</div>
                        </div>
                        <div class="form-group">
                            <label>Grower Name (Optional)</label>
                            <input type="text" id="growerName" placeholder="Farm/supplier name">
                        </div>
                        <div class="form-group">
                            <label>METRC Tag Numbers (last 4-5 digits) <span style="color: var(--accent-red);">*</span></label>
                            <input type="text" id="metrcTags" placeholder="e.g., 12345, 67890, 11223" required>
                            <div class="help-text">Required. Multiple tags separated by commas. Use last 4-5 digits only.</div>
                        </div>
                        <div class="form-group">
                            <label>Intake Date</label>
                            <input type="date" id="intakeDate" required>
                        </div>
                        <div class="form-group">
                            <label>Strain Type</label>
                            <select id="strainType" required>
                                <option value="">Select Type</option>
                                <option value="Indica">Indica (Blue Lid)</option>
                                <option value="Sativa">Sativa (Red Lid)</option>
                                <option value="Hybrid">Hybrid (Green Lid)</option>
                                <option value="Dealer's Choice">Dealer's Choice (Decide at Testing)</option>
                            </select>
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label>Planned Products</label>
                        <div class="checkbox-group">
                            <label class="checkbox-item">
                                <input type="checkbox" name="products" value="Live Resin Carts" onchange="updateMaterialTypeUI()">
                                <span>Live Resin Carts</span>
                            </label>
                            <label class="checkbox-item">
                                <input type="checkbox" name="products" value="Live Resin AIOs" onchange="updateMaterialTypeUI()">
                                <span>Live Resin AIOs</span>
                            </label>
                            <label class="checkbox-item">
                                <input type="checkbox" name="products" value="Wax">
                                <span>Wax</span>
                            </label>
                            <label class="checkbox-item">
                                <input type="checkbox" name="products" value="Sugar Wax">
                                <span>Sugar Wax</span>
                            </label>
                            <label class="checkbox-item">
                                <input type="checkbox" name="products" value="Shatter">
                                <span>Shatter</span>
                            </label>
                            <label class="checkbox-item">
                                <input type="checkbox" name="products" value="Extractor's Choice">
                                <span>Extractor's Choice</span>
                            </label>
                            <label class="checkbox-item">
                                <input type="checkbox" name="products" value="Brick Hash" id="brickHash">
                                <span>Brick Hash</span>
                            </label>
                            <label class="checkbox-item">
                                <input type="checkbox" name="products" value="Hash Hits" id="hashHits">
                                <span>Hash Hits</span>
                            </label>
                            <label class="checkbox-item">
                                <input type="checkbox" name="products" value="RSO Syringes">
                                <span>RSO Syringes</span>
                            </label>
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label>Notes</label>
                        <textarea id="intakeNotes" placeholder="Any special notes about this batch..."></textarea>
                    </div>
                    
                    <div style="display: flex; gap: 10px;">
                        <!-- Print button removed - auto-prints on submit -->
                        <button type="submit" class="btn" style="flex: 2;">Submit Intake</button>
                    </div>
                </form>
            </div>
        </div>

        <!-- Extraction Station -->
        <div class="station-content" id="extraction">
            <button class="mobile-back-btn" onclick="closeMobileStation()"> Back</button>
            <div class="form-section">
                <h2> Extraction Processing</h2>
                
                <!-- Gas Tracking Button -->
                <div style="margin-bottom: 25px;">
                    <button class="btn" style="background: linear-gradient(135deg, var(--accent-orange), var(--accent-red)); padding: 20px; width: 100%; font-size: 1.1rem;" onclick="openSuppliesModal()">
                        <div style="font-weight: 700; margin-bottom: 10px;"> Extraction Supplies</div>
                        <div style="display: flex; justify-content: center; gap: 30px; font-size: 0.95rem;">
                            <span>Butane: <strong id="btnButaneDisplay">0 lbs</strong></span>
                            <span>Nitrogen: <strong id="btnNitrogenDisplay">0 tanks</strong></span>
                        </div>
                    </button>
                </div>

                <!-- Machine Run Log Button -->
                <div style="margin-bottom: 25px;">
                    <button class="btn" style="background: linear-gradient(135deg, var(--accent-blue), var(--accent-purple)); padding: 15px 20px; width: 100%; font-size: 1rem;" onclick="openMachineLogModal()">
                        <span style="font-weight: 700;"> Machine Run Log</span>
                        <span style="font-size: 0.85rem; opacity: 0.9; margin-left: 10px;">Cross-Contamination Tracking</span>
                    </button>
                </div>
                
                <!-- Machine Status Buttons (Dynamic from CONFIG) -->
                <div id="machineButtonsContainer" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 15px;">
                    <!-- Populated by renderMachineButtons() -->
                </div>

                <!-- Extraction Queue with Sock Counts -->
                <div style="background: var(--bg-tertiary); padding: 20px; border-radius: 12px; margin-bottom: 25px;">
                    <h3 style="color: var(--accent-blue); margin-bottom: 15px;"> Extraction Queue</h3>
                    <div id="extractionQueueList" style="max-height: 300px; overflow-y: auto;">
                        <!-- Populated by JS -->
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Finishing Station -->
        <!-- Post Extraction Station -->
        <div class="station-content" id="finishing">
            <button class="mobile-back-btn" onclick="closeMobileStation()"> Back</button>
            <div class="form-section">
                <h2> Post Extraction & Batch Splitting</h2>


                <div class="form-group">
                    <label>Select Batch to Finish</label>
                    <select id="finishingBatchSelect" required>
                        <option value="">Select a batch...</option>
                    </select>
                </div>
                
                <div id="finishingForm" style="display: none;">
                    <div id="batchInfo" style="background: var(--bg-tertiary); padding: 15px; border-radius: 10px; margin-bottom: 20px;">
                        <h3 style="color: var(--accent-purple); margin-bottom: 10px;">Batch Details</h3>
                        <div id="batchInfoContent"></div>
                    </div>

                    <div class="form-group">
                        <label>Split this batch into multiple products?</label>
                        <select id="splitBatch" required>
                            <option value="no">No - Single product batch</option>
                            <option value="yes">Yes - Split into sub-batches</option>
                        </select>
                    </div>

                    <!-- Single Product Finishing -->
                    <div id="singleFinishing">
                        <div class="form-grid">
                            <div class="form-group">
                                <label>Finishing Date</label>
                                <input type="date" id="finishingDate" required>
                            </div>
                            <div class="form-group">
                                <label>Final Bulk Weight (grams)</label>
                                <input type="number" id="finalWeight" step="0.1" required>
                            </div>
                            <div class="form-group">
                                <label>Sample Weight Pulled (grams)</label>
                                <input type="number" id="sampleWeight" step="0.1" required>                            </div>
                            <div class="form-group">
                                <label>Final Product Type</label>
                                <select id="finishingProductType">
                                    <option value="">Keep original (from pull batch)</option>
                                    <option value="Wax">Wax</option>
                                    <option value="Sugar Wax">Sugar Wax</option>
                                    <option value="Shatter">Shatter</option>
                                    <option value="Live Resin Carts">Live Resin Carts</option>
                                    <option value="Live Resin AIOs">Live Resin AIOs</option>
                                    <option value="Brick Hash">Brick Hash</option>
                                </select>
                                <div class="help-text">Change if product type changed during post-extraction</div>
                            </div>
                        </div>

                        <!-- Output Containers Section -->
                        <div id="outputContainersSection" style="display: none; background: var(--bg-tertiary); padding: 15px; border-radius: 10px; margin-bottom: 20px;">
                            <div id="bulkJarsOutput" style="display: none;">
                                <div class="form-group">
                                    <label style="color: var(--accent-purple);"> Number of Bowls (for labels)</label>
                                    <input type="number" id="outputBowlsCount" min="1" value="1" style="max-width: 150px;">
                                    <div class="help-text">How many bowls after combining? Used for label numbering.</div>
                                </div>
                            </div>
                            <div id="shatterSlabsOutput" style="display: none;">
                                <div class="form-group">
                                    <label style="color: var(--accent-orange);"> Number of Output Slabs</label>
                                    <input type="number" id="outputSlabsCount" min="1" value="1" style="max-width: 150px;">
                                    <div class="help-text">How many slabs after post-extraction?</div>
                                </div>
                            </div>
                        </div>

                        <div class="form-group">
                            <label>QC Notes</label>
                            <textarea id="finishingNotes" placeholder="Quality observations, color, consistency, issues..."></textarea>
                        </div>
                        
                        <button type="button" class="btn" onclick="submitFinishing()">Complete Finishing</button>
                    </div>

                    <!-- Split Batch Finishing -->
                    <div id="splitFinishing" style="display: none;">
                        <h3 style="color: var(--accent-green); margin: 20px 0 15px 0; font-size: 1.2rem;">Divide Batch Into Products</h3>
                        <p style="color: var(--text-secondary); margin-bottom: 20px;">Specify how much material goes to each product. System will create sub-batches.</p>
                        
                        <div id="splitProducts">
                            <div class="split-product-item" style="background: var(--bg-tertiary); padding: 20px; border-radius: 10px; margin-bottom: 15px;">
                                <h4 style="color: var(--accent-purple); margin-bottom: 15px;">Product 1</h4>
                                <div class="form-grid">
                                    <div class="form-group">
                                        <label>Product Type</label>
                                        <select class="splitProductType" required>
                                            <option value="">Select Product</option>
                                            <option value="Wax">Wax</option>
                                            <option value="Sugar Wax">Sugar Wax</option>
                                            <option value="Shatter">Shatter</option>
                                            <option value="Live Resin Carts">Live Resin Carts</option>
                                    <option value="Live Resin AIOs">Live Resin AIOs</option>
                                            <option value="Brick Hash">Brick Hash</option>
                                            <option value="Hash Hits">Hash Hits</option>
                                        </select>
                                    </div>
                                    <div class="form-group">
                                        <label>Weight Allocated (grams)</label>
                                        <input type="number" class="splitWeight" step="0.1" required>
                                    </div>
                                </div>
                            </div>

                            <div class="split-product-item" style="background: var(--bg-tertiary); padding: 20px; border-radius: 10px; margin-bottom: 15px;">
                                <h4 style="color: var(--accent-purple); margin-bottom: 15px;">Product 2</h4>
                                <div class="form-grid">
                                    <div class="form-group">
                                        <label>Product Type</label>
                                        <select class="splitProductType" required>
                                            <option value="">Select Product</option>
                                            <option value="Wax">Wax</option>
                                            <option value="Sugar Wax">Sugar Wax</option>
                                            <option value="Shatter">Shatter</option>
                                            <option value="Live Resin Carts">Live Resin Carts</option>
                                            <option value="Live Resin AIOs">Live Resin AIOs</option>
                                            <option value="Brick Hash">Brick Hash</option>
                                            <option value="Hash Hits">Hash Hits</option>
                                        </select>
                                    </div>
                                    <div class="form-group">
                                        <label>Weight Allocated (grams)</label>
                                        <input type="number" class="splitWeight" step="0.1" required>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <button type="button" class="btn" style="background: var(--accent-blue); margin-right: 10px;" onclick="addSplitProduct()">+ Add Another Product</button>
                        <button type="button" class="btn" onclick="submitSplitBatch()">Create Sub-Batches</button>
                        
                        <div id="splitValidation" style="margin-top: 15px; padding: 15px; border-radius: 10px;"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Packaging Station -->
        <div class="station-content" id="packaging">
            <button class="mobile-back-btn" onclick="closeMobileStation()"> Back</button>
            <div class="form-section">
                <h2> Packaging & Listing</h2>
                <div class="form-group">
                    <label>Select Batch to Package</label>
                    <select id="packagingBatchSelect" required>
                        <option value="">Select a batch...</option>
                    </select>
                </div>
                
                <div id="packagingForm" style="display: none;">
                    <!-- Strain Type Indicator for Lid Color -->
                    <div id="strainTypeAlert" style="display: none; padding: 20px; border-radius: 12px; margin-bottom: 25px; text-align: center; border: 4px solid;">
                        <div style="font-size: 0.9rem; font-weight: 600; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px;">LID COLOR</div>
                        <div id="strainTypeName" style="font-size: 2.5rem; font-weight: 900; text-transform: uppercase; letter-spacing: 2px;"></div>
                    </div>

                    <div class="form-grid">
                        <div class="form-group">
                            <label>Packaging Date</label>
                            <input type="date" id="packagingDate" required>
                        </div>
                        <div class="form-group">
                            <label>Primary Product Type</label>
                            <select id="packagedProductType" required>
                                <option value="">Select Type</option>
                                <option value="Live Resin Carts">Live Resin Carts (1g)</option>
                                <option value="Live Resin AIOs">Live All-In-One (1g)</option>
                                <option value="Wax">Wax (1g & 4g)</option>
                                <option value="Sugar Wax">Sugar Wax (1g & 4g)</option>
                                <option value="Shatter">Shatter (1g)</option>
                                <option value="Brick Hash">Brick Hash (1g & 4g)</option>
                                <option value="Hash Hits">Hash Hits (2-pack & 5-pack)</option>
                                <option value="RSO Syringe">RSO Syringes</option>
                                <option value="Bulk Sale"> Bulk Sale (Skip Labeling)</option>
                            </select>
                        </div>
                    </div>

                    <!-- Multi-size packaging section -->
                    <div id="multiSizeSection" style="display: none;">
                        <h3 style="color: var(--accent-green); margin: 20px 0 15px 0; font-size: 1.2rem;">Package Sizes</h3>
                        <div class="form-grid">
                            <div class="form-group">
                                <label>1g Units</label>
                                <input type="number" id="units1g" value="0" min="0">
                            </div>
                            <div class="form-group">
                                <label>4g Units</label>
                                <input type="number" id="units4g" value="0" min="0">
                            </div>
                            <div class="form-group">
                                <label>Total Grams Calculated</label>
                                <input type="number" id="totalGramsCalc" readonly style="background: var(--bg-primary); color: var(--accent-green); font-weight: 700;">
                            </div>
                            <div class="form-group">
                                <label>Total Units (Combined)</label>
                                <input type="number" id="totalUnitsCalc" readonly style="background: var(--bg-primary); color: var(--accent-green); font-weight: 700;">
                            </div>
                        </div>
                    </div>

                    <!-- Single size packaging section -->
                    <div id="singleSizeSection">
                        <div class="form-grid">
                            <div class="form-group">
                                <label>Total Units/Eaches</label>
                                <input type="number" id="unitsPackaged" min="0">
                            </div>
                        </div>
                    </div>
                    
                    <div class="form-group" style="display: none;">
                        <input type="number" id="wholesalePrice" step="0.01" min="0" value="0" style="display: none;">
                    </div>
                    
                    <div class="form-group">
                        <label>Packaging Notes</label>
                        <textarea id="packagingNotes" placeholder="Any issues, special packaging notes..."></textarea>
                    </div>
                    
                    <!-- Bulk Sale Alert -->
                    <div id="bulkSaleAlert" style="display: none; background: rgba(16, 185, 129, 0.15); border-left: 4px solid var(--accent-green); padding: 15px; border-radius: 8px; margin: 20px 0;">
                        <strong> Bulk Sale Selected</strong>
                        <p style="margin: 8px 0 0 0; color: var(--text-secondary);">
                            This batch will go through testing but will skip the labeling process after test results are entered.
                        </p>
                    </div>
                    
                    <div style="background: rgba(59, 130, 246, 0.15); border-left: 4px solid var(--accent-blue); padding: 15px; border-radius: 8px; margin: 20px 0;">
                        <strong> Workflow Options:</strong>
                        <ul style="margin: 8px 0 0 20px; line-height: 1.8;">
                            <li><strong>Start Packaging:</strong> Mark batch as in-progress (tracking only, can finish later)</li>
                            <li><strong>Pause/Resume:</strong> Temporarily pause work (breaks, end of shift, equipment issues)</li>
                            <li><strong>Complete Packaging:</strong> Finish packaging (skips "start" if single session)</li>
                        </ul>
                    </div>
                    
                    <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                        <button type="button" class="btn" style="background: var(--accent-blue); flex: 1; min-width: 200px;" onclick="startPackaging()"> Start Packaging</button>
                        <button type="button" class="btn" id="pausePackagingBtn" style="background: var(--accent-orange); flex: 1; min-width: 200px; display: none;" onclick="togglePausePackaging()"> Pause</button>
                        <button type="button" class="btn" style="background: var(--accent-green); flex: 1; min-width: 200px;" onclick="submitPackaging()"> Complete Packaging</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Testing Station -->
        <div class="station-content" id="testing">
            <button class="mobile-back-btn" onclick="closeMobileStation()"> Back</button>
            <div class="form-section">
                <h2> Test Results Entry</h2>

                <!-- COA Auto-Sync Panel -->
                <div id="coaSyncPanel" style="background: linear-gradient(135deg, rgba(16, 185, 129, 0.15), rgba(59, 130, 246, 0.15)); padding: 20px; border-radius: 12px; margin-bottom: 25px; border: 2px solid var(--accent-green);">
                    <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 15px;">
                        <div>
                            <h3 style="color: var(--accent-green); margin: 0 0 5px 0; display: flex; align-items: center; gap: 8px;">
                                <span></span> COA Auto-Import
                            </h3>
                            <p style="color: var(--text-secondary); font-size: 0.85rem; margin: 0;">
                                Imports test results from shared Google Drive folder
                            </p>
                        </div>
                        <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                            <button id="coaSyncBtn" onclick="syncCOAsFromDrive()" style="padding: 10px 20px; background: var(--accent-green); border: none; border-radius: 8px; color: black; font-weight: 600; cursor: pointer;">
                                 Sync COAs
                            </button>
                        </div>
                    </div>
                    <div id="coaSyncResults" style="margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--border);">
                        <div style="font-size: 0.85rem; color: var(--text-secondary);">
                            Last sync: <span id="coaLastSync">Never</span> |
                            COAs imported: <span id="coaImportCount">0</span>
                        </div>
                    </div>
                </div>

                <div class="form-group">
                    <label>Select Batch for Test Results</label>
                    <select id="testingBatchSelect" required>
                        <option value="">Select a batch...</option>
                    </select>
                </div>
                
                <div id="testingForm" style="display: none;">
                    <!-- Current Batch Info -->
                    <div id="currentTestInfo" style="background: var(--bg-tertiary); padding: 15px; border-radius: 10px; margin-bottom: 20px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <div>
                                <span style="color: var(--text-secondary); font-size: 0.85rem;">Current Batch</span>
                                <div id="currentBatchIdDisplay" style="font-family: 'Space Mono', monospace; font-size: 1.4rem; font-weight: 700; color: var(--accent-green);"></div>
                            </div>
                            <div id="testingBatchStatus" style="text-align: right;"></div>
                        </div>
                        <div id="testBatchDetails"></div>
                    </div>

                    <!-- RTA Alert (shown when full panel needed) -->
                    <div id="rtaAlertBanner" style="display: none; background: linear-gradient(135deg, rgba(239, 68, 68, 0.2), rgba(245, 158, 11, 0.2)); border: 2px solid var(--accent-red); padding: 15px; border-radius: 10px; margin-bottom: 20px;">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <span style="font-size: 1.5rem;"></span>
                            <div>
                                <strong style="color: var(--accent-red);">RTA Full Panel Required</strong>
                                <p style="margin: 5px 0 0 0; color: var(--text-secondary); font-size: 0.9rem;">This product type requires a full panel test for RTA qualification.</p>
                            </div>
                        </div>
                    </div>

                    <!-- Simplified Submit to Testing Form -->
                    <div style="background: linear-gradient(135deg, rgba(59, 130, 246, 0.15), rgba(147, 51, 234, 0.15)); padding: 20px; border-radius: 12px; margin-bottom: 25px; border: 2px solid var(--accent-blue);">
                        <h3 style="color: var(--accent-blue); margin-bottom: 15px; display: flex; align-items: center; gap: 10px;">
                            <span></span> Submit to Testing
                        </h3>

                        <div class="form-grid" style="margin-bottom: 15px;">
                            <div class="form-group" style="margin-bottom: 0;">
                                <label>Product Name</label>
                                <input type="text" id="finalProductName" placeholder="e.g., Blue Dream Live Resin" required>
                                <div class="help-text">Final wholesale product name</div>
                            </div>
                            <div class="form-group" style="margin-bottom: 0;">
                                <label>Batch ID</label>
                                <input type="text" id="newBatchId" placeholder="e.g., 10.3.1212" style="font-family: 'Space Mono', monospace; font-size: 1.2rem; font-weight: 700;" oninput="parseBatchId(this.value)">
                                <div class="help-text">Format: M.D.XXXX (expiration month.day.METRC last 4)</div>
                            </div>
                        </div>

                        <!-- Auto-parsed info display -->
                        <div id="parsedBatchInfo" style="display: none; background: var(--bg-secondary); padding: 12px; border-radius: 8px; margin-bottom: 15px;">
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; font-size: 0.9rem;">
                                <div>
                                    <span style="color: var(--text-secondary);">Expiration Date:</span>
                                    <strong id="parsedExpiration" style="color: var(--accent-green); margin-left: 8px;"></strong>
                                </div>
                                <div>
                                    <span style="color: var(--text-secondary);">METRC Tag (last 4):</span>
                                    <strong id="parsedMetrc" style="color: var(--accent-purple); margin-left: 8px; font-family: 'Space Mono', monospace;"></strong>
                                </div>
                            </div>
                        </div>

                        <div class="form-group" style="margin-bottom: 15px;">
                            <label>RTA Full Panel?</label>
                            <select id="isRTA" required onchange="updateTestResultVisibility()">
                                <option value="no">No - Standard Potency Only</option>
                                <option value="yes">Yes - Full Panel RTA</option>
                            </select>
                        </div>

                        <!-- Hidden field - auto-set to today -->
                        <input type="hidden" id="testSubmittedDate">

                        <!-- Hidden fields for compatibility -->
                        <input type="hidden" id="testExpirationDate">
                        <input type="hidden" id="metrcLast4">
                        <input type="hidden" id="finalConsistency">
                        <input type="hidden" id="finalStrainType">

                        <button type="button" id="submitToTestingBtn" onclick="submitToTesting()" style="background: linear-gradient(135deg, var(--accent-blue), var(--accent-purple)); color: white; border: none; padding: 14px 24px; border-radius: 8px; cursor: pointer; font-weight: 600; display: flex; align-items: center; justify-content: center; gap: 10px; width: 100%; font-size: 1.1rem;">
                            <span></span> Submit Batch to Lab
                        </button>
                    </div>

                    <!-- Test Results Section (shown after COA sync populates data) -->
                    <div id="testResultsSection" style="display: none; background: linear-gradient(135deg, rgba(16, 185, 129, 0.15), rgba(59, 130, 246, 0.15)); padding: 20px; border-radius: 12px; margin-bottom: 25px; border: 2px solid var(--accent-green);">
                        <h3 style="color: var(--accent-green); margin-bottom: 15px; display: flex; align-items: center; gap: 10px;">
                            <span></span> Test Results Received
                        </h3>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 15px; margin-bottom: 15px;">
                            <div style="background: var(--bg-secondary); padding: 15px; border-radius: 8px; text-align: center;">
                                <div style="color: var(--text-secondary); font-size: 0.8rem; margin-bottom: 5px;">THC</div>
                                <div id="displayThc" style="font-size: 1.8rem; font-weight: 700; color: var(--accent-green);">--</div>
                            </div>
                            <div style="background: var(--bg-secondary); padding: 15px; border-radius: 8px; text-align: center;">
                                <div style="color: var(--text-secondary); font-size: 0.8rem; margin-bottom: 5px;">CBD</div>
                                <div id="displayCbd" style="font-size: 1.8rem; font-weight: 700; color: var(--accent-blue);">--</div>
                            </div>
                            <div style="background: var(--bg-secondary); padding: 15px; border-radius: 8px; text-align: center;">
                                <div style="color: var(--text-secondary); font-size: 0.8rem; margin-bottom: 5px;">Status</div>
                                <div id="displayStatus" style="font-size: 1.2rem; font-weight: 700; color: var(--accent-purple);">Pending</div>
                            </div>
                        </div>
                        <div id="testResultsNotes" style="font-size: 0.9rem; color: var(--text-secondary); padding: 10px; background: var(--bg-secondary); border-radius: 8px;"></div>
                    </div>

                    <!-- Full Panel Result (for RTA tracking) -->
                    <div class="form-group" id="testResultGroup" style="display: none; margin-bottom: 20px;">
                        <label>Full Panel Test Result</label>
                        <select id="fullPanelResult">
                            <option value="pending">Pending - Awaiting Results</option>
                            <option value="pass"> PASSED - All Tests Clear</option>
                            <option value="fail"> FAILED - Contamination Found</option>
                        </select>
                        <div class="help-text">Update when lab results arrive</div>
                    </div>

                </div>

                                <!-- RTA Qualification Status -->
                <div id="rtaQualificationSection" style="margin-top: 30px; background: var(--bg-tertiary); padding: 20px; border-radius: 12px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                        <h3 style="margin: 0; color: var(--accent-purple);"> RTA Status</h3>
                        <button class="btn" style="padding: 8px 15px; font-size: 0.9rem;" onclick="openRTAManager()">Manage</button>
                    </div>
                    <div id="rtaQuickStatus" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px;">
                        <!-- Populated by JS -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Labeling Station -->
        <div class="station-content" id="labeling">
            <button class="mobile-back-btn" onclick="closeMobileStation()"> Back</button>
            <div class="form-section">
                <h2> Label Printing & Application</h2>
                
                <div class="form-group">
                    <label>Select Batch to Label</label>
                    <select id="labelingBatchSelect" required>
                        <option value="">Select a batch...</option>
                    </select>
                </div>
                
                <div id="labelingForm" style="display: none;">
                    <!-- Batch Info Display -->
                    <div style="background: var(--bg-tertiary); padding: 20px; border-radius: 10px; margin-bottom: 20px; border-left: 4px solid var(--accent-purple);">
                        <h3 style="color: var(--accent-purple); margin-bottom: 15px;">Label Information</h3>
                        <div id="labelPreview" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                            <!-- Auto-populated from batch data -->
                        </div>
                    </div>

                    <!-- Units Labeled -->
                    <div style="background: rgba(16, 185, 129, 0.1); padding: 20px; border-radius: 10px; margin-bottom: 20px; border: 2px solid var(--accent-green);">
                        <h3 style="color: var(--accent-green); margin-bottom: 15px;"> Units Labeled</h3>

                        <!-- 1g Units -->
                        <div id="units1gSection" style="display: none; margin-bottom: 20px;">
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; align-items: end;">
                                <div class="form-group" style="margin: 0;">
                                    <label>1g Units Labeled</label>
                                    <input type="number" id="units1gLabeled" step="1" min="0" placeholder="Enter 1g units" style="font-size: 1.2rem;">
                                </div>
                                <div style="padding: 10px; background: var(--bg-tertiary); border-radius: 8px; text-align: center;">
                                    <div style="color: var(--text-secondary); font-size: 0.8rem;">Expected from Packaging</div>
                                    <div id="expected1gUnits" style="font-size: 1.3rem; font-weight: 700; color: var(--accent-blue);">0</div>
                                </div>
                            </div>
                        </div>

                        <!-- 4g Units -->
                        <div id="units4gSection" style="display: none; margin-bottom: 20px;">
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; align-items: end;">
                                <div class="form-group" style="margin: 0;">
                                    <label>4g Units Labeled</label>
                                    <input type="number" id="units4gLabeled" step="1" min="0" placeholder="Enter 4g units" style="font-size: 1.2rem;">
                                </div>
                                <div style="padding: 10px; background: var(--bg-tertiary); border-radius: 8px; text-align: center;">
                                    <div style="color: var(--text-secondary); font-size: 0.8rem;">Expected from Packaging</div>
                                    <div id="expected4gUnits" style="font-size: 1.3rem; font-weight: 700; color: var(--accent-blue);">0</div>
                                </div>
                            </div>
                        </div>

                        <!-- Fallback for batches without 1g/4g breakdown -->
                        <div id="unitsGenericSection" style="display: none;">
                            <div class="form-group">
                                <label>How many units did you label?</label>
                                <input type="number" id="unitsLabeled" step="1" min="0" placeholder="Enter number of units labeled">
                            </div>
                            <div style="padding: 10px; background: var(--bg-tertiary); border-radius: 8px; text-align: center; margin-top: 10px;">
                                <div style="color: var(--text-secondary); font-size: 0.8rem;">Expected from Packaging</div>
                                <div id="expectedUnits" style="font-size: 1.3rem; font-weight: 700; color: var(--accent-blue);">0</div>
                            </div>
                        </div>

                        <!-- Totals Summary -->
                        <div id="labelingTotalsDisplay" style="padding: 15px; background: var(--bg-primary); border-radius: 8px; margin-top: 15px;">
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                                <div>
                                    <div style="color: var(--text-secondary); font-size: 0.9rem;">Total Expected</div>
                                    <div id="totalExpectedUnits" style="font-size: 1.5rem; font-weight: 700; color: var(--accent-blue); font-family: 'Space Mono', monospace;">-</div>
                                </div>
                                <div>
                                    <div style="color: var(--text-secondary); font-size: 0.9rem;">Total Labeled</div>
                                    <div id="totalLabeledUnits" style="font-size: 1.5rem; font-weight: 700; color: var(--accent-green); font-family: 'Space Mono', monospace;">-</div>
                                </div>
                            </div>
                            <div id="discrepancyAlert" style="display: none; margin-top: 15px; padding: 15px; background: rgba(239, 68, 68, 0.2); border: 2px solid var(--accent-red); border-radius: 8px;">
                                <div style="color: var(--accent-red); font-weight: 700; margin-bottom: 10px;"> Unit Count Discrepancy</div>
                                <div id="discrepancyDetails" style="color: var(--text-primary); margin-bottom: 15px;"></div>
                                <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                                    <input type="checkbox" id="acceptDiscrepancy" style="width: 20px; height: 20px;">
                                    <span style="font-weight: 600;">I verify this count is correct and accept the discrepancy</span>
                                </label>
                            </div>
                        </div>
                    </div>

                    <!-- Print Product Labels Section -->
                    <div style="background: rgba(139, 92, 246, 0.1); padding: 20px; border-radius: 10px; margin-bottom: 20px; border: 2px solid var(--accent-purple);">
                        <h3 style="color: var(--accent-purple); margin-bottom: 15px;"> Print Product Labels (1.25" Round)</h3>

                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                            <div id="print1gSection" style="display: none;">
                                <div class="form-group" style="margin: 0;">
                                    <label>1g Labels to Print</label>
                                    <input type="number" id="print1gQty" step="1" min="0" placeholder="Quantity" style="font-size: 1.1rem;">
                                </div>
                            </div>
                            <div id="print4gSection" style="display: none;">
                                <div class="form-group" style="margin: 0;">
                                    <label>4g Labels to Print</label>
                                    <input type="number" id="print4gQty" step="1" min="0" placeholder="Quantity" style="font-size: 1.1rem;">
                                </div>
                            </div>
                        </div>

                        <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                            <button type="button" class="btn" style="background: var(--accent-purple); flex: 1;" onclick="printProductLabelsFromStation()">
                                 Print Labels
                            </button>
                            <button type="button" class="btn" style="background: var(--bg-tertiary); border: 2px solid var(--accent-purple); flex: 1;" onclick="previewProductLabel()">
                                 Preview Label
                            </button>
                        </div>

                        <div id="labelPrintStatus" style="display: none; margin-top: 15px; padding: 12px; border-radius: 8px; text-align: center;"></div>
                    </div>

                    <!-- Mark as Labeled -->
                    <div class="form-group">
                        <label>Labeling Notes</label>
                        <textarea id="labelingNotes" placeholder="Any issues with labeling, printer problems, etc..."></textarea>
                    </div>

                    <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                        <button type="button" class="btn" style="background: var(--accent-blue); flex: 1; min-width: 200px;" onclick="startLabeling()"> Start Labeling</button>
                        <button type="button" class="btn" id="pauseLabelingBtn" style="background: var(--accent-orange); flex: 1; min-width: 200px; display: none;" onclick="togglePauseLabeling()"> Pause</button>
                        <button type="button" class="btn" style="background: var(--accent-green); flex: 1; min-width: 200px;" onclick="markAsLabeled()"> Complete Labeling</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Waste Log -->
        <!-- Analytics -->
        <div class="station-content" id="analytics">
            <button class="mobile-back-btn" onclick="closeMobileStation()"> Back</button>
            <h2 style="margin-bottom: 30px;"> Completed Batches Analytics</h2>
            
            <!-- Summary Stats -->
            <div class="stats-grid" style="margin-bottom: 40px;">
                <div class="stat-card">
                    <div class="stat-value" id="avgYield">0%</div>
                    <div class="stat-label">Average Yield</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="avgThc">0%</div>
                    <div class="stat-label">Average THC</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="avgProcessingTime">0d</div>
                    <div class="stat-label">Avg Processing Time</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="avgCostPerGram">$0</div>
                    <div class="stat-label">Avg Cost Per Gram</div>
                </div>
            </div>

            <!-- Filter Bar -->
            <div class="filter-bar" style="margin-bottom: 30px;">
                <button class="filter-btn active" data-filter-analytics="all" onclick="filterAnalytics('all')">All Completed</button>
                <button class="filter-btn" data-filter-analytics="thisMonth" onclick="filterAnalytics('thisMonth')">This Month</button>
                <button class="filter-btn" data-filter-analytics="lastMonth" onclick="filterAnalytics('lastMonth')">Last Month</button>
            </div>

            <!-- Batch Cards Grid -->
            <div id="completedBatchesGrid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(350px, 1fr)); gap: 20px;"></div>
        </div>

        <!-- Batch Details Modal -->
        <div id="batchDetailsModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); z-index: 10000; overflow-y: auto;">
            <div style="max-width: 1000px; margin: 50px auto; background: var(--bg-secondary); border-radius: 16px; padding: 30px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 30px;">
                    <h2 id="modalBatchId" style="color: var(--accent-green); font-family: 'Space Mono', monospace;">WM-1001</h2>
                    <button onclick="closeBatchDetails()" style="background: none; border: none; color: var(--text-primary); font-size: 2.5rem; cursor: pointer; padding: 0; width: 50px; height: 50px; line-height: 40px;">&times;</button>
                </div>
                
                <!-- Batch Overview -->
                <div id="modalBatchOverview" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 30px;"></div>
<!-- Batch Tracking Details -->                <div style="background: var(--bg-tertiary); padding: 20px; border-radius: 12px; margin-bottom: 30px;">                    <h3 style="color: var(--accent-blue); margin-bottom: 20px;"> Batch Tracking</h3>                    <div id="modalTracking"></div>                </div>
                
                <!-- Processing Timeline Visualization -->
                <div style="background: var(--bg-tertiary); padding: 20px; border-radius: 12px; margin-bottom: 30px;">
                    <h3 style="color: var(--accent-purple); margin-bottom: 20px;"> Processing Timeline</h3>
                    <div id="modalTimeline"></div>
                </div>
                
                <!-- Performance Metrics -->
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin-bottom: 30px;">
                    <div style="background: var(--bg-tertiary); padding: 20px; border-radius: 12px;">
                        <h4 style="color: var(--accent-green); margin-bottom: 15px;"> Economics</h4>
                        <div id="modalEconomics"></div>
                    </div>
                    <div style="background: var(--bg-tertiary); padding: 20px; border-radius: 12px;">
                        <h4 style="color: var(--accent-blue); margin-bottom: 15px;"> Testing Results</h4>
                        <div id="modalTesting"></div>
                    </div>
                    <div style="background: var(--bg-tertiary); padding: 20px; border-radius: 12px;">
                        <h4 style="color: var(--accent-orange); margin-bottom: 15px;"> Production</h4>
                        <div id="modalProduction"></div>
                    </div>
                </div>
                
                <!-- Team Members -->
                <div style="background: var(--bg-tertiary); padding: 20px; border-radius: 12px;">
                    <h3 style="color: var(--accent-purple); margin-bottom: 15px;"> Team Members</h3>
                    <div id="modalTeam"></div>
                </div>
            </div>
        </div>

                <!-- Performance Station -->
        <div class="station-content" id="performance">
            <button class="mobile-back-btn" onclick="closeMobileStation()"> Back</button>
            <div class="form-section">
                <h2>Team Performance</h2>
                <p style="color: var(--text-secondary); margin-bottom: 20px;">Click any employee card for detailed performance view</p>

                <!-- Time Period Selector -->
                <div style="display: flex; gap: 15px; margin-bottom: 25px; flex-wrap: wrap; align-items: center;">
                    <div class="form-group" style="margin: 0; min-width: 180px;">
                        <select id="performanceTimeRange" onchange="renderPerformanceAnalytics()" style="padding: 10px 15px; font-size: 1rem;">
                            <option value="1">Today</option>
                            <option value="7">Last 7 Days</option>
                            <option value="14">Last 14 Days</option>
                            <option value="30" selected>Last 30 Days</option>
                            <option value="60">Last 60 Days</option>
                            <option value="90">Last 90 Days</option>
                        </select>
                    </div>
                    <span id="performanceDateRange" style="color: var(--text-secondary); font-size: 0.9rem;"></span>
                    <!-- Hidden for backwards compatibility -->
                    <select id="performanceFilter" style="display: none;"><option value="all">All</option></select>
                    <select id="performanceViewMode" style="display: none;"><option value="overview">Overview</option></select>
                </div>

                <!-- Employee Cards Grid -->
                <div id="employeeCardsGrid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 20px; margin-bottom: 30px;"></div>

                <!-- Hidden containers for backwards compatibility -->
                <div id="performanceStats" style="display: none;"></div>
                <div id="staffingRecommendations" style="display: none;"></div>
                <div id="todayDate" style="display: none;"></div>
                <div id="todayTrimExtracted" style="display: none;"></div>
                <div id="todayTrimBatches" style="display: none;"></div>
                <div id="todayFinished" style="display: none;"></div>
                <div id="todayFinishedBatches" style="display: none;"></div>
                <div id="todayPackaged" style="display: none;"></div>
                <div id="todayPackagedWeight" style="display: none;"></div>
                <div id="todayLabeled" style="display: none;"></div>
                <div id="todayLabeledWeight" style="display: none;"></div>
                <div id="activeUsers" style="display: none;"></div>
                <div id="recentLogins" style="display: none;"></div>
                <div id="companyPeriodRange" style="display: none;"></div>
                <div id="companyTrimExtracted" style="display: none;"></div>
                <div id="companyTrimBatches" style="display: none;"></div>
                <div id="companyFinished" style="display: none;"></div>
                <div id="companyFinishedBatches" style="display: none;"></div>
                <div id="companyPackaged" style="display: none;"></div>
                <div id="companyPackagedWeight" style="display: none;"></div>
                <div id="companyLabeled" style="display: none;"></div>
                <div id="companyLabeledWeight" style="display: none;"></div>
            </div>

            <!-- Collapsible Settings Section -->
            <div class="form-section">
                <div onclick="var content = this.nextElementSibling; content.style.display = content.style.display === 'none' ? 'block' : 'none'; this.querySelector('.settings-toggle').textContent = content.style.display === 'none' ? 'Show Settings' : 'Hide Settings';" style="cursor: pointer; display: flex; justify-content: space-between; align-items: center;">
                    <h2 style="margin: 0;">Production Targets</h2>
                    <span class="settings-toggle" style="font-size: 0.9rem; color: var(--accent-blue);">Show Settings</span>
                </div>
                <div class="settings-content" style="display: none; margin-top: 20px;">
                    <div style="background: var(--bg-tertiary); padding: 20px; border-radius: 12px;">
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                            <div>
                                <label style="display: block; margin-bottom: 5px; font-size: 0.9rem;">Packaging (units/day)</label>
                                <input type="number" id="targetPackagingUnits" value="200" min="0" style="width: 100%; padding: 10px; background: var(--bg-primary); border: 2px solid var(--border); border-radius: 8px; color: var(--text-primary);" onchange="saveTargets(); renderPerformanceAnalytics();">
                            </div>
                            <div>
                                <label style="display: block; margin-bottom: 5px; font-size: 0.9rem;">Labeling (units/day)</label>
                                <input type="number" id="targetLabelingUnits" value="300" min="0" style="width: 100%; padding: 10px; background: var(--bg-primary); border: 2px solid var(--border); border-radius: 8px; color: var(--text-primary);" onchange="saveTargets(); renderPerformanceAnalytics();">
                            </div>
                            <div>
                                <label style="display: block; margin-bottom: 5px; font-size: 0.9rem;">Extraction (g/day)</label>
                                <input type="number" id="targetExtractionTrim" value="11200" min="0" step="100" style="width: 100%; padding: 10px; background: var(--bg-primary); border: 2px solid var(--border); border-radius: 8px; color: var(--text-primary);" onchange="saveTargets(); renderPerformanceAnalytics();">
                            </div>
                        </div>
                    </div>
                </div>
                <div id="capacityPlanning" style="display: none;"></div>
                <div id="activityLog" style="display: none;"></div>
            </div>
        </div>

        <!-- Dashboard -->
        <div class="station-content" id="dashboard">
            <button class="mobile-back-btn" onclick="closeMobileStation()"> Back</button>
            <!-- Dashboard Needs Section -->
            <div id="dashboardNeedsSection" style="margin-bottom: 20px;">
                <div class="foh-box" style="border-left: 4px solid #F59E0B; background: var(--bg-secondary); border-radius: 12px; padding: 12px;">
                    <h4 style="color: #F59E0B; margin: 0 0 10px 0; font-size: 1rem; font-weight: 600; text-align: center;">What We Need</h4>
                    <div id="dashboardNeedsGrid" class="foh-items" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px;"></div>
                </div>
            </div>

            <!-- Personal Quick Stats -->
            <div id="personalStats" style="background: linear-gradient(135deg, rgba(147, 51, 234, 0.2), rgba(59, 130, 246, 0.2)); padding: 20px; border-radius: 12px; margin-bottom: 25px; border: 2px solid var(--accent-purple);">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <h2 style="color: var(--accent-purple); margin: 0; display: flex; align-items: center; gap: 10px;">
                        <span></span>
                        <span id="personalStatsTitle">Your Workload</span>
                    </h2>
                    <div style="display: flex; gap: 10px;">
                        <button class="btn" style="background: var(--accent-orange); padding: 10px 20px;" onclick="recalculateAllSubBatchYields()">
                             Fix Sub-Batch Yields
                        </button>
                        <button class="btn" style="background: var(--accent-green); padding: 10px 20px;" onclick="showDailyReportPopup()">
                             Daily Report
                        </button>
                    </div>
                </div>
                <div id="personalStatsGrid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                    <!-- Populated dynamically -->
                </div>
            </div>

            <!-- System-Wide Stats -->
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-value" id="totalBatches">0</div>
                    <div class="stat-label">Total Batches</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="activeBatches">0</div>
                    <div class="stat-label">In Progress</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="completedBatches">0</div>
                    <div class="stat-label">Completed</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="totalGramsIn">0g</div>
                    <div class="stat-label">Total Trim In</div>
                </div>
                <div class="stat-card" id="weightDiscrepancyCard" style="display: none;">
                    <div class="stat-value" id="totalWeightLoss" style="color: var(--accent-orange);">0g</div>
                    <div class="stat-label"> Weight Loss (BulkLabel)</div>
                </div>
            </div>

            <!-- Waste Log Section - Collapsible -->
            <div style="margin: 30px 0;">
                <div onclick="document.getElementById('wasteLogContent').style.display = document.getElementById('wasteLogContent').style.display === 'none' ? 'block' : 'none'; this.querySelector('.waste-arrow').textContent = document.getElementById('wasteLogContent').style.display === 'none' ? '' : '';"
                     style="display: flex; justify-content: space-between; align-items: center; padding: 15px 20px; background: var(--bg-secondary); border-radius: 12px; cursor: pointer; box-shadow: 0 2px 4px rgba(0,0,0,0.2);">
                    <div style="display: flex; align-items: center; gap: 12px;">
                        <span class="waste-arrow" style="font-size: 1rem;"></span>
                        <h2 style="margin: 0; font-size: 1.3rem;"> Trim Waste Log</h2>
                    </div>
                    <div style="display: flex; gap: 15px; align-items: center;" onclick="event.stopPropagation();">
                        <div style="background: var(--bg-tertiary); padding: 8px 15px; border-radius: 8px;">
                            <span style="color: var(--text-secondary);">Pending:</span>
                            <span id="wastePendingCount" style="color: var(--accent-orange); font-weight: 600;">0</span>
                        </div>
                        <div style="background: var(--bg-tertiary); padding: 8px 15px; border-radius: 8px;">
                            <span style="color: var(--text-secondary);">Total:</span>
                            <span id="wasteTotalWeight" style="color: var(--accent-green); font-weight: 600;">0g</span>
                        </div>
                        <div style="background: var(--bg-tertiary); padding: 8px 15px; border-radius: 8px;">
                            <span style="color: var(--text-secondary);">Next Disposal:</span>
                            <span id="wasteNextDisposal" style="color: var(--accent-blue); font-weight: 600;">--</span>
                        </div>
                        <button onclick="exportWasteLog()" style="background: var(--accent-green); border: none; padding: 8px 15px; border-radius: 8px; color: white; cursor: pointer; font-weight: 600;"> Export</button>
                    </div>
                </div>

                <div id="wasteLogContent" style="display: none; margin-top: 10px;">
                    <div style="background: var(--bg-primary); border-radius: 12px; overflow: hidden; border: 1px solid var(--border);">
                        <div style="max-height: 400px; overflow-y: auto;">
                            <table style="width: 100%; border-collapse: collapse; font-size: 0.85rem;">
                                <thead style="position: sticky; top: 0; background: var(--bg-tertiary); z-index: 1;">
                                    <tr>
                                        <th style="padding: 12px 8px; text-align: left; color: var(--text-secondary);">Batch</th>
                                        <th style="padding: 12px 8px; text-align: left; color: var(--text-secondary);">Strain</th>
                                        <th style="padding: 12px 8px; text-align: right; color: var(--text-secondary);">Trim</th>
                                        <th style="padding: 12px 8px; text-align: right; color: var(--text-secondary);">Waste</th>
                                        <th style="padding: 12px 8px; text-align: center; color: var(--text-secondary);">Extraction</th>
                                        <th style="padding: 12px 8px; text-align: center; color: var(--text-secondary);">Disposal</th>
                                        <th style="padding: 12px 8px; text-align: center; color: var(--text-secondary);">METRC</th>
                                        <th style="padding: 12px 8px; text-align: center; color: var(--text-secondary);">Mixed</th>
                                        <th style="padding: 12px 8px; text-align: center; color: var(--text-secondary);">Facility</th>
                                    </tr>
                                </thead>
                                <tbody id="wasteLogTableBody">
                                    <tr><td colspan="9" style="padding: 30px; text-align: center; color: var(--text-secondary);">Loading...</td></tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>

            <div class="batch-list">
                <h2> All Production Batches</h2>
                <div class="filter-bar">
                    <button class="filter-btn active" data-filter="all">All</button>
                    <button class="filter-btn" data-filter="intake">Intake</button>
                    <button class="filter-btn" data-filter="extraction">Extraction</button>
                    <button class="filter-btn" data-filter="finishing">Post Extraction</button>
                    <button class="filter-btn" data-filter="packaging">Packaging</button>
                    <button class="filter-btn" data-filter="testing">Testing</button>
                    <button class="filter-btn" data-filter="labeling">Labeling</button>
                    <button class="filter-btn" data-filter="complete">Complete</button>
                    <div class="search-box">
                        <input type="text" id="searchBatches" placeholder="Search batches...">
                    </div>
                </div>
                <div id="batchesList"></div>
            </div>
        </div>

        <!-- Front of House Station -->
        <div class="station-content" id="frontofhouse">
            <button class="mobile-back-btn" onclick="closeMobileStation()"> Back</button>
            <div class="form-section">
                <!-- Pipeline, Inventory, Needs Sections -->
                <style>
                    .foh-wrapper { display: flex; flex-direction: column; gap: 15px; margin-bottom: 20px; }
                    @media (min-width: 768px) { .foh-wrapper { flex-direction: row; } .foh-box { flex: 1; } }
                    .foh-box { background: var(--bg-secondary); border-radius: 12px; padding: 12px; }
                    .foh-box h4 { margin: 0 0 10px 0; font-size: 1rem; font-weight: 600; text-align: center; }
                    .foh-items { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; }
                    @media (max-width: 500px) { .foh-items { grid-template-columns: repeat(2, 1fr); } }
                    .foh-btn { background: var(--bg-primary); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; padding: 12px 8px; cursor: pointer; text-align: center; width: 100%; transition: all 0.2s; }
                    .foh-btn:hover { transform: scale(1.02); background: rgba(255,255,255,0.05); }
                    .foh-btn-name { font-size: 0.95rem; font-weight: 600; color: #fff; margin-bottom: 4px; }
                    .foh-btn-num { font-size: 1.6rem; font-weight: 700; color: #111; line-height: 1; text-shadow: 0 0 8px #fff, 0 0 15px #fff, 0 0 25px #fff, 0 0 40px #fff; animation: num-glow 2s ease-in-out infinite; }
                    .foh-needs-num { animation: none !important; }
                    .foh-btn-sub { font-size: 0.8rem; color: rgba(255,255,255,0.7); margin-top: 4px; }
                    @keyframes num-glow { 0%, 100% { text-shadow: 0 0 8px #fff, 0 0 15px #fff, 0 0 25px #fff; } 50% { text-shadow: 0 0 10px #fff, 0 0 20px #fff, 0 0 35px #fff, 0 0 50px #fff; } }
                </style>
                <div class="foh-wrapper">
                    <!-- Needs -->
                    <div class="foh-box" style="border-left: 4px solid #F59E0B;">
                        <h4 style="color: #F59E0B;">Needs</h4>
                        <div id="inlineNeedsGrid" class="foh-items"></div>
                    </div>
                    <!-- Pipeline -->
                    <div class="foh-box" style="border-left: 4px solid #10B981;">
                        <h4 style="color: #10B981;">Pipeline</h4>
                        <div id="inlinePipelineGrid" class="foh-items"></div>
                    </div>
                    <!-- Inventory -->
                    <div class="foh-box" style="border-left: 4px solid #8B5CF6;">
                        <h4 style="color: #8B5CF6;">Inventory</h4>
                        <div id="inlineInventoryGrid" class="foh-items"></div>
                    </div>
                </div>

                <!-- Blog Generator Toggle Button -->
                <div style="display: flex; gap: 10px; margin-bottom: 20px;">
                    <button onclick="toggleBlogGenerator()" class="btn" style="background: linear-gradient(135deg, var(--accent-purple), var(--accent-blue)); padding: 15px 30px; font-size: 1.1rem; flex: 1;"> Blog Generator</button>
                    <a href="/blog" target="_blank" class="btn" style="background: var(--accent-blue); padding: 15px 30px; font-size: 1.1rem; text-decoration: none; display: flex; align-items: center; justify-content: center;"> View Blog</a>
                </div>
                
                <!-- Blog Generator Section (hidden by default) -->
                <div id="blogGeneratorSection" style="display: none;">
                
                <!-- Quick Update Section -->
                <div style="background: linear-gradient(135deg, rgba(0, 240, 255, 0.1), rgba(191, 0, 255, 0.1)); border: 2px solid var(--accent-blue); border-radius: 16px; padding: 25px; margin-bottom: 30px;">
                    <h3 style="color: var(--accent-blue); margin: 0 0 10px 0; display: flex; align-items: center; gap: 10px;">
                        <span></span> Quick Update
                    </h3>
                    <p style="color: var(--text-secondary); margin: 0 0 15px 0;">Type a quick note and I'll turn it into an engaging post. Mention partners and they'll be auto-tagged!</p>

                    <div class="foh-generate-container" style="display: flex; flex-wrap: wrap; gap: 15px; margin-bottom: 15px;">
                        <input type="text" id="fohQuickInput" placeholder="e.g., Grabbed some fire GMO trim from In The Flow..." style="flex: 1 1 100%; min-width: 0; padding: 15px; font-size: 1.1rem; border-radius: 10px; border: 2px solid var(--border); background: var(--bg-primary); color: var(--text-primary); box-sizing: border-box;">
                        <button onclick="generateBlogPost()" class="btn foh-generate-btn" style="background: linear-gradient(135deg, var(--accent-purple), var(--accent-blue)); padding: 15px 30px; font-size: 1.1rem; flex: 1 1 100%;">
                             Generate Post
                        </button>
                    </div>

                    <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                        <span style="color: var(--text-secondary); font-size: 0.9rem;">Quick tags:</span>
                        <button onclick="addQuickTag('new hardware')" class="quick-tag-btn"> Equipment</button>
                        <button onclick="addQuickTag('fresh batch')" class="quick-tag-btn"> New Batch</button>
                        <button onclick="addQuickTag('new strain')" class="quick-tag-btn"> New Strain</button>
                        <button onclick="addQuickTag('lab update')" class="quick-tag-btn"> Lab Update</button>
                    </div>
                </div>

                <!-- Generated Preview -->
                <div id="fohGeneratedPreview" style="display: none; background: var(--bg-secondary); border-radius: 16px; padding: 25px; margin-bottom: 30px; border: 2px solid var(--accent-green);">
                    <div style="display: flex; flex-wrap: wrap; justify-content: space-between; align-items: center; margin-bottom: 15px; gap: 10px;">
                        <h3 style="color: var(--accent-green); margin: 0;"> Generated Post Preview</h3>
                        <div style="display: flex; flex-wrap: wrap; gap: 10px;">
                            <button onclick="regenerateBlogPost()" class="btn" style="background: var(--bg-tertiary); flex: 1 1 auto;"> Regenerate</button>
                            <button onclick="editBlogPost()" class="btn" style="background: var(--accent-orange); flex: 1 1 auto;"> Edit</button>
                            <button onclick="publishBlogPost()" class="btn" style="background: var(--accent-green); flex: 1 1 auto;"> Publish</button>
                        </div>
                    </div>
                    <div id="fohPartnerInfo"></div>
                    <h4 id="fohPreviewTitle" style="font-size: 1.4rem; margin: 0 0 15px 0;"></h4>
                    <div id="fohPreviewContent" style="color: var(--text-secondary); line-height: 1.6;"></div>
                </div>

                <!-- Recent Completed Batches for Blog -->
                <div style="background: var(--bg-secondary); border-radius: 16px; padding: 25px; margin-bottom: 30px;">
                    <h3 style="margin: 0 0 20px 0; display: flex; align-items: center; gap: 10px;">
                        <span></span> Recent Completed Batches
                        <span style="font-size: 0.8rem; color: var(--text-secondary); font-weight: normal;">Click to create post</span>
                    </h3>
                    <div id="fohRecentBatches" style="display: grid; gap: 15px;">
                        <!-- Populated dynamically -->
                        <div style="text-align: center; padding: 40px; color: var(--text-secondary);">Loading batches...</div>
                    </div>
                </div>
                </div>


                <!-- Published Posts -->
                <div style="background: var(--bg-secondary); border-radius: 16px; padding: 25px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <h3 style="margin: 0; display: flex; align-items: center; gap: 10px;">
                            <span></span> Recent Blog Posts
                        </h3>
                        <button onclick="loadFOHPosts()" class="btn" style="background: var(--bg-tertiary); padding: 8px 15px;"> Refresh</button>
                    </div>
                    <div id="fohPostsList">
                        <div style="text-align: center; padding: 40px; color: var(--text-secondary);">Loading posts...</div>
                    </div>
                </div>
            </div>
        </div>

        </div><!-- end appContent -->

        <!-- Sales Station -->
        <div class="station-content" id="sales">
            <button class="mobile-back-btn" onclick="closeMobileStation()"> Back</button>
            <div class="form-section">
                <!-- Sales Dashboard Header -->
                <div style="background: linear-gradient(135deg, rgba(255, 215, 0, 0.1), rgba(147, 51, 234, 0.1)); border: 2px solid #FFD700; border-radius: 16px; padding: 25px; margin-bottom: 30px;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; flex-wrap: wrap; gap: 15px;">
                        <div>
                            <h3 style="margin: 0; display: flex; align-items: center; gap: 10px; color: #FFD700;">
                                <span></span> Sales Dashboard
                            </h3>
                            <p style="color: var(--text-secondary); margin: 5px 0 0 0; font-size: 0.9rem;">Click any card to view the underlying orders</p>
                        </div>
                        <div style="display: flex; flex-wrap: wrap; gap: 10px; align-items: center;">
                            <button onclick="openDropCalendarModal()" class="btn" style="background: linear-gradient(135deg, #10B981, #059669); padding: 10px 20px; font-weight: 600; flex: 1 1 auto;">Calendar</button>
                            <select id="salesRepFilterSales" onchange="updateSalesDashboardSales()" style="background: var(--bg-primary); border: 1px solid var(--border-color); color: var(--text-primary); padding: 10px 15px; border-radius: 8px; min-width: 0; flex: 1 1 160px;">
                                <option value="all">All Sales Reps</option>
                            </select>
                            <button onclick="forceRefreshSalesDashboard()" class="btn" style="background: #FFD700; color: #000; padding: 10px 20px; font-weight: 600; flex: 1 1 auto;">Refresh</button>
                        </div>
                    </div>

                    <!-- Date Range Filter -->
                    <div style="display: flex; gap: 8px; margin-bottom: 20px; flex-wrap: wrap;">
                        <button onclick="setSalesDateRange(7)" id="salesRange7" class="sales-range-btn" style="background: var(--bg-tertiary); border: 1px solid var(--border-color); color: var(--text-primary); padding: 8px 16px; border-radius: 8px; cursor: pointer; font-weight: 500; transition: all 0.2s;">7 Days</button>
                        <button onclick="setSalesDateRange('month')" id="salesRangemonth" class="sales-range-btn" style="background: var(--bg-tertiary); border: 1px solid var(--border-color); color: var(--text-primary); padding: 8px 16px; border-radius: 8px; cursor: pointer; font-weight: 500; transition: all 0.2s;">This Month</button>
                        <button onclick="setSalesDateRange(30)" id="salesRange30" class="sales-range-btn active" style="background: #FFD700; border: 1px solid #FFD700; color: #000; padding: 8px 16px; border-radius: 8px; cursor: pointer; font-weight: 600; transition: all 0.2s;">30 Days</button>
                        <button onclick="setSalesDateRange(365)" id="salesRange365" class="sales-range-btn" style="background: var(--bg-tertiary); border: 1px solid var(--border-color); color: var(--text-primary); padding: 8px 16px; border-radius: 8px; cursor: pointer; font-weight: 500; transition: all 0.2s;">365 Days</button>
                        <span id="salesDateRangeLabel" style="margin-left: auto; color: var(--text-secondary); font-size: 0.85rem; align-self: center;"></span>
                    </div>

                    <!-- Clickable Sales Stats Grid -->
                    <style>
                        .sales-stat-card {
                            background: var(--bg-primary);
                            padding: 20px;
                            border-radius: 12px;
                            text-align: center;
                            cursor: pointer;
                            transition: all 0.3s ease;
                            border-left: 4px solid;
                        }
                        .sales-stat-card:hover {
                            transform: translateY(-3px);
                            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
                        }
                        .sales-stat-card:active {
                            transform: translateY(-1px);
                        }
                        .sales-stat-value {
                            font-size: 2.2rem;
                            font-weight: 700;
                        }
                        .sales-stat-label {
                            color: var(--text-secondary);
                            font-size: 0.85rem;
                        }
                        .sales-stat-hint {
                            font-size: 0.7rem;
                            color: var(--text-secondary);
                            margin-top: 8px;
                            opacity: 0.6;
                        }
                    </style>
                    <div id="salesDashboardStatsSales" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(160px, 1fr)); gap: 15px; margin-bottom: 25px;">
                        <!-- Total Orders (ALL) -->
                        <div class="sales-stat-card" style="border-left-color: var(--accent-blue);" onclick="showInvoiceList('all')" title="Click to view all orders">
                            <div class="sales-stat-value" style="color: var(--accent-blue);" id="salesStatTotalOrdersSales">--</div>
                            <div class="sales-stat-label">Total Orders</div>
                            <div class="sales-stat-hint">All LeafLink orders</div>
                        </div>
                        <!-- Total Order Value -->
                        <div class="sales-stat-card" style="border-left-color: #FFD700;" onclick="showInvoiceList('all')" title="Click to view all orders">
                            <div class="sales-stat-value" style="color: #FFD700;" id="salesStatTotalValueSales">--</div>
                            <div class="sales-stat-label">Order Value</div>
                            <div class="sales-stat-hint">All orders total</div>
                        </div>
                        <!-- Shipped Orders -->
                        <div class="sales-stat-card" style="border-left-color: #10B981;" onclick="showInvoiceList('shipped')" title="Click to view shipped orders">
                            <div class="sales-stat-value" style="color: #10B981;" id="salesStatShippedOrdersSales">--</div>
                            <div class="sales-stat-label">Shipped</div>
                            <div class="sales-stat-hint">Accepted/Shipped/Complete</div>
                        </div>
                        <!-- Revenue (Shipped) -->
                        <div class="sales-stat-card" style="border-left-color: var(--accent-green);" onclick="showInvoiceList('shipped')" title="Click to view shipped orders">
                            <div class="sales-stat-value" style="color: var(--accent-green);" id="salesStatRevenueSales">--</div>
                            <div class="sales-stat-label">Revenue</div>
                            <div class="sales-stat-hint">Shipped orders value</div>
                        </div>
                        <!-- Paid Orders -->
                        <div class="sales-stat-card" style="border-left-color: #22c55e;" onclick="showInvoiceList('paid')" title="Click to view paid orders">
                            <div class="sales-stat-value" style="color: #22c55e;" id="salesStatPaidOrdersSales">--</div>
                            <div class="sales-stat-label">Paid</div>
                            <div class="sales-stat-amount" style="font-size: 0.9rem; font-weight: 600; color: #22c55e; margin-top: 4px;" id="salesStatPaidAmountSales">$0</div>
                        </div>
                        <!-- Unpaid Orders -->
                        <div class="sales-stat-card" style="border-left-color: var(--accent-orange);" onclick="showInvoiceList('unpaid')" title="Click to view unpaid orders">
                            <div class="sales-stat-value" style="color: var(--accent-orange);" id="salesStatUnpaidOrdersSales">--</div>
                            <div class="sales-stat-label">Unpaid</div>
                            <div class="sales-stat-amount" style="font-size: 0.9rem; font-weight: 600; color: var(--accent-orange); margin-top: 4px;" id="salesStatUnpaidAmountSales">$0</div>
                        </div>
                        <!-- Not Yet Due -->
                        <div class="sales-stat-card" style="border-left-color: var(--accent-purple);" onclick="showInvoiceList('notDue')" title="Click to view accounts not yet due">
                            <div class="sales-stat-value" style="color: var(--accent-purple);" id="salesStatNotDueSales">--</div>
                            <div class="sales-stat-label">Not Yet Due</div>
                            <div class="sales-stat-amount" style="font-size: 0.9rem; font-weight: 600; color: var(--accent-purple); margin-top: 4px;" id="salesStatNotDueAmountSales">$0</div>
                        </div>
                        <!-- Overdue -->
                        <div class="sales-stat-card" style="border-left-color: #ef4444;" onclick="showInvoiceList('overdue')" title="Click to view overdue accounts">
                            <div class="sales-stat-value" style="color: #ef4444;" id="salesStatOverdueSales">--</div>
                            <div class="sales-stat-label">Overdue</div>
                            <div class="sales-stat-amount" style="font-size: 0.9rem; font-weight: 600; color: #ef4444; margin-top: 4px;" id="salesStatOverdueAmountSales">$0</div>
                        </div>
                    </div>

                    <!-- Commission Calculator Section -->
                    <div style="background: linear-gradient(135deg, rgba(147, 51, 234, 0.15), rgba(168, 85, 247, 0.1)); border: 1px solid rgba(147, 51, 234, 0.4); border-radius: 12px; padding: 20px; margin-bottom: 20px;">
                        <h4 style="margin: 0 0 15px 0; color: var(--accent-purple); display: flex; align-items: center; gap: 10px;">
                            <span></span> Commission Calculator (8% on Paid Invoices)
                        </h4>
                        <div id="commissionCalculatorGridSales" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px;">
                            <div style="background: var(--bg-primary); padding: 20px; border-radius: 10px; text-align: center; cursor: pointer; transition: all 0.3s ease;" onclick="showCommissionDetails('prevMonth')" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(16, 185, 129, 0.3)';" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none';">
                                <div style="font-size: 0.8rem; color: var(--text-secondary); margin-bottom: 5px;">Last Month</div>
                                <div style="font-size: 1.8rem; font-weight: 700; color: var(--accent-green);" id="commissionPrevMonthSales">$0.00</div>
                                <div style="font-size: 0.75rem; color: var(--text-secondary); margin-top: 5px;" id="commissionPrevMonthLabelSales">December 2024</div>
                                <div style="font-size: 0.65rem; color: var(--text-secondary); margin-top: 8px; opacity: 0.7;">Click for details</div>
                            </div>
                            <div style="background: var(--bg-primary); padding: 20px; border-radius: 10px; text-align: center; cursor: pointer; transition: all 0.3s ease;" onclick="showCommissionDetails('currentMonth')" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(147, 51, 234, 0.3)';" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none';">
                                <div style="font-size: 0.8rem; color: var(--text-secondary); margin-bottom: 5px;">This Month</div>
                                <div style="font-size: 1.8rem; font-weight: 700; color: var(--accent-purple);" id="commissionCurrentMonthSales">$0.00</div>
                                <div style="font-size: 0.75rem; color: var(--text-secondary); margin-top: 5px;" id="commissionCurrentMonthLabelSales">January 2025</div>
                                <div style="font-size: 0.65rem; color: var(--text-secondary); margin-top: 8px; opacity: 0.7;">Click for details</div>
                            </div>
                        </div>
                        <div style="margin-top: 15px; padding: 12px; background: var(--bg-tertiary); border-radius: 8px; font-size: 0.85rem; color: var(--text-secondary);">
                            <strong style="color: var(--accent-purple);">Pay Schedule:</strong> Commission paid on the first paycheck of each month for the previous month's paid invoices.
                        </div>
                    </div>

                    <!-- Bubbleman Royalty Calculator Section -->
                    <div id="royaltyCalculatorSection" style="display: none; background: linear-gradient(135deg, rgba(245, 158, 11, 0.15), rgba(249, 115, 22, 0.1)); border: 1px solid rgba(245, 158, 11, 0.4); border-radius: 12px; padding: 20px; margin-bottom: 20px;">
                        <h4 style="margin: 0 0 15px 0; color: var(--accent-orange); display: flex; align-items: center; gap: 10px;">
                            <span>Bubbleman Royalty Calculator</span>
                        </h4>
                        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px;">
                            <!-- 1-11 LLC Card -->
                            <div style="background: var(--bg-primary); padding: 15px; border-radius: 10px; border: 1px solid var(--border);">
                                <div style="font-size: 0.9rem; font-weight: 600; color: var(--text-primary); margin-bottom: 12px;">1-11 LLC (92%)</div>
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                                    <div style="background: var(--bg-tertiary); padding: 12px; border-radius: 8px; text-align: center; cursor: pointer; transition: all 0.3s ease;" onclick="showRoyaltyDetails('1-11 LLC', 'prevMonth')" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(245, 158, 11, 0.3)';" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none';">
                                        <div style="font-size: 0.7rem; color: var(--text-secondary); margin-bottom: 3px;">Last Month</div>
                                        <div style="font-size: 1.3rem; font-weight: 700; color: var(--accent-orange);" id="royalty1_11PrevMonth">$0.00</div>
                                        <div style="font-size: 0.65rem; color: var(--text-secondary); margin-top: 3px;" id="royalty1_11PrevMonthLabel">December 2024</div>
                                        <div style="font-size: 0.6rem; color: var(--text-secondary); margin-top: 5px; opacity: 0.7;">Click for details</div>
                                    </div>
                                    <div style="background: var(--bg-tertiary); padding: 12px; border-radius: 8px; text-align: center; cursor: pointer; transition: all 0.3s ease;" onclick="showRoyaltyDetails('1-11 LLC', 'currentMonth')" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(245, 158, 11, 0.3)';" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none';">
                                        <div style="font-size: 0.7rem; color: var(--text-secondary); margin-bottom: 3px;">This Month</div>
                                        <div style="font-size: 1.3rem; font-weight: 700; color: var(--accent-orange);" id="royalty1_11CurrentMonth">$0.00</div>
                                        <div style="font-size: 0.65rem; color: var(--text-secondary); margin-top: 3px;" id="royalty1_11CurrentMonthLabel">January 2025</div>
                                        <div style="font-size: 0.6rem; color: var(--text-secondary); margin-top: 5px; opacity: 0.7;">Click for details</div>
                                    </div>
                                </div>
                                <div style="margin-top: 10px; font-size: 0.75rem; color: var(--text-secondary);">
                                    Products: Bubble Hash, Cold Cure, Rosin
                                </div>
                            </div>
                            <!-- Ted Card -->
                            <div style="background: var(--bg-primary); padding: 15px; border-radius: 10px; border: 1px solid var(--border);">
                                <div style="font-size: 0.9rem; font-weight: 600; color: var(--text-primary); margin-bottom: 12px;">Ted (Per Unit)</div>
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                                    <div style="background: var(--bg-tertiary); padding: 12px; border-radius: 8px; text-align: center; cursor: pointer; transition: all 0.3s ease;" onclick="showRoyaltyDetails('Ted', 'prevMonth')" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(245, 158, 11, 0.3)';" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none';">
                                        <div style="font-size: 0.7rem; color: var(--text-secondary); margin-bottom: 3px;">Last Month</div>
                                        <div style="font-size: 1.3rem; font-weight: 700; color: var(--accent-orange);" id="royaltyTedPrevMonth">$0.00</div>
                                        <div style="font-size: 0.65rem; color: var(--text-secondary); margin-top: 3px;" id="royaltyTedPrevMonthLabel">December 2024</div>
                                        <div style="font-size: 0.6rem; color: var(--text-secondary); margin-top: 5px; opacity: 0.7;">Click for details</div>
                                    </div>
                                    <div style="background: var(--bg-tertiary); padding: 12px; border-radius: 8px; text-align: center; cursor: pointer; transition: all 0.3s ease;" onclick="showRoyaltyDetails('Ted', 'currentMonth')" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(245, 158, 11, 0.3)';" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='none';">
                                        <div style="font-size: 0.7rem; color: var(--text-secondary); margin-bottom: 3px;">This Month</div>
                                        <div style="font-size: 1.3rem; font-weight: 700; color: var(--accent-orange);" id="royaltyTedCurrentMonth">$0.00</div>
                                        <div style="font-size: 0.65rem; color: var(--text-secondary); margin-top: 3px;" id="royaltyTedCurrentMonthLabel">January 2025</div>
                                        <div style="font-size: 0.6rem; color: var(--text-secondary); margin-top: 5px; opacity: 0.7;">Click for details</div>
                                    </div>
                                </div>
                                <div style="margin-top: 10px; font-size: 0.75rem; color: var(--text-secondary);">
                                    Brick Hash 4g: $2.90/unit | Hash Hits: $1.80/unit
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Monthly Breakdown -->
                    <div style="background: var(--bg-primary); border-radius: 12px; padding: 20px;">
                        <h4 style="margin: 0 0 15px 0; color: var(--text-primary); display: flex; align-items: center; gap: 10px;">
                            <span></span> Monthly Sales Breakdown
                        </h4>
                        <div id="salesMonthlyBreakdownSales" style="max-height: 300px; overflow-y: auto;">
                            <div style="text-align: center; padding: 30px; color: var(--text-secondary);">
                                Loading sales data...
                            </div>
                        </div>
                    </div>

                    <!-- Sales Bar Chart -->
                    <div style="background: var(--bg-primary); border-radius: 12px; padding: 20px; margin-top: 20px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                            <h4 style="margin: 0; color: var(--text-primary); display: flex; align-items: center; gap: 10px;">
                                Sales Trends (Last 6 Months)
                            </h4>
                            <div style="display: flex; gap: 8px;">
                                <button onclick="setSalesChartTypeSales('revenue')" id="chartTypeRevenueSales" class="btn" style="background: var(--accent-orange); padding: 6px 12px; font-size: 0.8rem;">Revenue</button>
                                <button onclick="setSalesChartTypeSales('orders')" id="chartTypeOrdersSales" class="btn" style="background: var(--bg-tertiary); padding: 6px 12px; font-size: 0.8rem;">Orders</button>
                            </div>
                        </div>
                        <div id="salesBarChartSales" style="min-height: 200px;">
                            <div style="text-align: center; padding: 40px; color: var(--text-secondary);">Loading chart...</div>
                        </div>
                        <!-- Data cache status -->
                        <div id="salesCacheStatusSales" style="margin-top: 15px; padding: 10px; background: var(--bg-tertiary); border-radius: 8px; font-size: 0.8rem; color: var(--text-secondary); display: flex; justify-content: space-between; align-items: center;">
                            <span id="cacheStatusTextSales">Data not cached</span>
                            <button onclick="forceSyncSalesData()" class="btn" style="background: var(--accent-purple); padding: 5px 10px; font-size: 0.75rem;">Sync to Cloud</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

    </div>

    <!-- Invoice List Modal -->
    <div id="invoiceListModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); z-index: 10000; overflow-y: auto;">
        <div style="max-width: 1000px; margin: 30px auto; background: var(--bg-secondary); border-radius: 16px; padding: 25px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; flex-wrap: wrap; gap: 10px;">
                <h2 id="invoiceListTitle" style="margin: 0; color: var(--accent-blue);">Orders</h2>
                <button onclick="closeInvoiceListModal()" style="background: none; border: none; color: var(--text-primary); font-size: 2rem; cursor: pointer; padding: 0; width: 40px; height: 40px;">&times;</button>
            </div>

            <!-- Controls -->
            <div style="display: flex; flex-wrap: wrap; gap: 10px; margin-bottom: 15px;">
                <input type="text" id="invoiceSearch" placeholder="Search by customer or invoice #..." oninput="filterInvoiceTable()" style="flex: 1; min-width: 200px; padding: 10px 15px; border-radius: 8px; border: 1px solid var(--border-color); background: var(--bg-primary); color: var(--text-primary);">
                <select id="invoiceSortBy" onchange="sortInvoiceTable()" style="padding: 10px 15px; border-radius: 8px; border: 1px solid var(--border-color); background: var(--bg-primary); color: var(--text-primary);">
                    <option value="date-desc">Newest First</option>
                    <option value="date-asc">Oldest First</option>
                    <option value="amount-desc">Highest Amount</option>
                    <option value="amount-asc">Lowest Amount</option>
                    <option value="customer">Customer A-Z</option>
                    <option value="status">Status</option>
                </select>
            </div>

            <!-- Summary -->
            <div style="display: flex; gap: 20px; margin-bottom: 20px; padding: 15px; background: var(--bg-primary); border-radius: 10px; flex-wrap: wrap;">
                <div>
                    <span style="color: var(--text-secondary);">Showing: </span>
                    <strong id="invoiceListCount" style="color: var(--accent-blue);">0 orders</strong>
                </div>
                <div>
                    <span style="color: var(--text-secondary);">Total: </span>
                    <strong id="invoiceListTotal" style="color: var(--accent-green);">$0.00</strong>
                </div>
            </div>

            <!-- Table -->
            <div style="overflow-x: auto;">
                <table id="invoiceListTable" style="width: 100%; border-collapse: collapse;">
                    <thead>
                        <tr style="background: var(--bg-tertiary);">
                            <th style="padding: 12px; text-align: left; border-bottom: 2px solid var(--border-color);">Order #</th>
                            <th style="padding: 12px; text-align: left; border-bottom: 2px solid var(--border-color);">Customer</th>
                            <th style="padding: 12px; text-align: left; border-bottom: 2px solid var(--border-color);">Date</th>
                            <th style="padding: 12px; text-align: right; border-bottom: 2px solid var(--border-color);">Amount</th>
                            <th style="padding: 12px; text-align: center; border-bottom: 2px solid var(--border-color);">Status</th>
                            <th style="padding: 12px; text-align: center; border-bottom: 2px solid var(--border-color);">Paid</th>
                            <th style="padding: 12px; text-align: left; border-bottom: 2px solid var(--border-color);">Due Date</th>
                        </tr>
                    </thead>
                    <tbody id="invoiceListBody">
                        <!-- Populated by JavaScript -->
                    </tbody>
                </table>
            </div>
        </div>
    </div>

    <!-- Edit Batch Modal -->
    <div id="editBatchModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.8); z-index: 10000; overflow-y: auto;">
        <div style="max-width: 800px; margin: 50px auto; background: var(--bg-secondary); border-radius: 16px; padding: 30px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h2 style="color: var(--accent-orange);"> Edit Batch</h2>
                <button onclick="closeEditBatch()" style="background: none; border: none; color: var(--text-primary); font-size: 2rem; cursor: pointer; padding: 0; width: 40px; height: 40px;">&times;</button>
            </div>
            
            <div id="editBatchForm">
                <input type="hidden" id="originalBatchId">
                
                <div class="form-grid">
                    <div class="form-group">
                        <label>Batch ID</label>
                        <input type="text" id="editBatchId" style="font-family: 'Space Mono', monospace; font-weight: 700; font-size: 1.2rem;">
                        <div class="help-text">Format: M.D.XXXX (e.g., 9.15.5678)</div>
                    </div>
                </div>
                
                <!-- Auto-Parsed Information -->
                <div style="background: linear-gradient(135deg, rgba(16, 185, 129, 0.1), rgba(59, 130, 246, 0.1)); padding: 20px; border-radius: 12px; margin-bottom: 20px; border: 2px solid var(--accent-green);">
                    <h3 style="color: var(--accent-green); margin-bottom: 15px; display: flex; align-items: center; gap: 10px;">
                        <span></span> Auto-Parsed from Batch ID
                    </h3>
                    <div class="form-grid">
                        <div class="form-group" style="margin: 0;">
                            <label>METRC Last 4 Digits</label>
                            <input type="text" id="parsedMetrcLast4" readonly style="background: var(--bg-primary); color: var(--accent-green); font-family: 'Space Mono', monospace; font-size: 1.3rem; font-weight: 700; text-align: center;">
                            <div class="help-text">Extracted from batch ID</div>
                        </div>
                        <div class="form-group" style="margin: 0;">
                            <label>Expiration Date</label>
                            <input type="date" id="parsedExpirationDate" readonly style="background: var(--bg-primary); color: var(--accent-green); font-size: 1.1rem; font-weight: 700;">
                            <div class="help-text">Calculated from batch ID month.day</div>
                        </div>
                    </div>
                </div>
                
                <!-- Strain Name at Top -->
                <div style="background: var(--bg-tertiary); padding: 20px; border-radius: 12px; margin-bottom: 25px; border-left: 4px solid var(--accent-purple);">
                    <div class="form-group" style="margin: 0;">
                        <label>Strain Name</label>
                        <input type="text" id="editStrainName" style="font-size: 1.4rem; font-weight: 700; padding: 16px;">
                    </div>
                </div>
                
                <div class="form-grid">
                    <div class="form-group">
                        <label>Status</label>
                        <select id="editBatchStatus">
                            <option value="intake">Intake</option>
                            <option value="extraction">Extraction</option>
                            <option value="finishing">Post-Extraction</option>
                            <option value="packaging">Packaging</option>
                            <option value="complete">Complete</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                            <input type="checkbox" id="editLabelsApplied" style="width: 18px; height: 18px;">
                            Labels Applied
                        </label>
                        <div class="help-text">Uncheck to send back to labeling queue</div>
                    </div>
                    <div class="form-group">
                        <label>Strain Type</label>
                        <select id="editStrainType">
                            <option value="Indica">Indica (Blue Lid)</option>
                            <option value="Sativa">Sativa (Red Lid)</option>
                            <option value="Hybrid">Hybrid (Green Lid)</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Product Type</label>
                        <select id="editProductType">
                            <option value="">-- Not Set --</option>
                            <option value="Wax">Wax</option>
                            <option value="Sugar Wax">Sugar Wax</option>
                            <option value="Shatter">Shatter</option>
                            <option value="Badder">Badder</option>
                            <option value="Diamonds">Diamonds</option>
                            <option value="Sauce">Sauce</option>
                            <option value="Live Resin Carts">Live Resin Carts</option>
                            <option value="Live Resin AIOs">Live Resin AIOs</option>
                            <option value="Brick Hash">Brick Hash</option>
                            <option value="Bubble Hash">Bubble Hash</option>
                            <option value="Hash Hits">Hash Hits</option>
                            <option value="Rosin">Rosin</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Trim Weight (g)</label>
                        <input type="number" id="editTrimWeight" step="0.1">
                    </div>
                    <div class="form-group">
                        <label>Socks Remaining</label>
                        <input type="number" id="editSocksRemaining" min="0">
                        <div class="help-text">Socks left to extract</div>
                    </div>
                    <div class="form-group">
                        <label>Bulk Weight (g)</label>
                        <input type="number" id="editBulkWeight" step="0.1">
                        <div class="help-text">Post-extraction final weight</div>
                    </div>
                    <div class="form-group">
                        <label>Material Cost ($)</label>
                        <input type="number" id="editMaterialCost" step="0.01">
                    </div>
                    <div class="form-group">
                        <label>Cultivation License</label>
                        <input type="text" id="editCultivationLicense">
                    </div>
                    <div class="form-group">
                        <label>Grower Name</label>
                        <input type="text" id="editGrowerName">
                    </div>
                    <div class="form-group">
                        <label>METRC Tags</label>
                        <input type="text" id="editMetrcTags" placeholder="12345, 67890">
                    </div>
                </div>

                <!-- Packaging Unit Counts -->
                <div style="background: rgba(168, 85, 247, 0.1); padding: 20px; border-radius: 12px; margin-bottom: 20px; border: 2px solid var(--accent-purple);">
                    <h3 style="color: var(--accent-purple); margin-bottom: 15px;"> Packaging Unit Counts</h3>
                    <div class="form-grid">
                        <div class="form-group" style="margin: 0;">
                            <label>1g Units (Packaged)</label>
                            <input type="number" id="editUnits1g" min="0" step="1">
                            <div class="help-text">Number of 1 gram units packaged</div>
                        </div>
                        <div class="form-group" style="margin: 0;">
                            <label>4g Units (Packaged)</label>
                            <input type="number" id="editUnits4g" min="0" step="1">
                            <div class="help-text">Number of 4 gram units packaged</div>
                        </div>
                        <div class="form-group" style="margin: 0;">
                            <label>Total Units Packaged</label>
                            <input type="number" id="editUnitsPackaged" min="0" step="1" readonly style="background: var(--bg-primary);">
                            <div class="help-text">Auto-calculated from 1g + 4g</div>
                        </div>
                    </div>
                </div>

                <div class="form-group">
                    <label>Edit Notes (Why are you making this change?)</label>
                    <textarea id="editNotes" placeholder="Explain what you're changing and why..." required></textarea>
                </div>
                
                <div style="display: flex; gap: 10px; margin-top: 20px;">
                    <button class="btn" style="background: var(--accent-green); flex: 1;" onclick="saveEditedBatch()"> Save Changes</button>
                    <button class="btn" style="background: var(--bg-tertiary); flex: 1;" onclick="closeEditBatch()">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Create Sub-Batch Modal -->
    <div id="createSubBatchModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.8); z-index: 10000; overflow-y: auto;">
        <div style="max-width: 800px; margin: 50px auto; background: var(--bg-secondary); border-radius: 16px; padding: 30px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h2 style="color: var(--accent-green);"> Create Retroactive Sub-Batch</h2>
                <button onclick="closeCreateSubBatch()" style="background: none; border: none; color: var(--text-primary); font-size: 2rem; cursor: pointer; padding: 0; width: 40px; height: 40px;">&times;</button>
            </div>
            
            <div style="background: rgba(59, 130, 246, 0.15); border-left: 4px solid var(--accent-blue); padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                <strong> About Retroactive Sub-Batches:</strong>
                <p style="margin: 8px 0 0 0; line-height: 1.6;">
                    Use this when a batch was split into multiple products, but wasn't recorded as sub-batches during production. 
                    This creates a new sub-batch with its own ID, product type, and weight from the parent batch's final weight.
                </p>
            </div>

            <div id="subBatchParentInfo" style="background: var(--bg-tertiary); padding: 15px; border-radius: 10px; margin-bottom: 20px;">
                <h3 style="color: var(--accent-purple); margin-bottom: 10px;">Parent Batch Info</h3>
                <div id="subBatchParentDetails"></div>
            </div>
            
            <div id="createSubBatchForm">
                <input type="hidden" id="subBatchParentId">
                
                <div class="form-grid">
                    <div class="form-group">
                        <label>Sub-Batch ID</label>
                        <input type="text" id="newSubBatchId" readonly style="background: var(--bg-primary); font-family: 'Space Mono', monospace; font-weight: 700; color: var(--accent-green);">
                        <div class="help-text">Auto-generated from parent batch</div>
                    </div>
                    <div class="form-group">
                        <label>Product Type</label>
                        <select id="subBatchProductType" required>
                            <option value="">Select Product Type</option>
                            <option value="Wax">Wax</option>
                            <option value="Sugar Wax">Sugar Wax</option>
                            <option value="Shatter">Shatter</option>
                            <option value="Live Resin Carts">Live Resin Carts</option>
                            <option value="Live Resin AIOs">Live Resin AIOs</option>
                            <option value="Brick Hash">Brick Hash</option>
                            <option value="Hash Hits">Hash Hits</option>
                            <option value="RSO">RSO</option>
                        </select>
                        <div class="help-text">What product was this portion made into?</div>
                    </div>
                </div>
                
                <div style="background: rgba(245, 158, 11, 0.2); border-left: 4px solid var(--accent-orange); padding: 15px; border-radius: 8px; margin: 20px 0;">
                    <strong style="color: var(--accent-orange);"> Post-Processing Required</strong>
                    <p style="margin: 8px 0 0 0; color: var(--text-secondary);">
                        This sub-batch will be created at <strong>extraction</strong> status. The post-processor must complete it on the <strong>Post Extraction</strong> page to enter weights and finish it properly.
                    </p>
                </div>
                
                <div class="form-group">
                    <label>Notes / Reason for Retroactive Creation</label>
                    <textarea id="subBatchNotes" placeholder="Why is this sub-batch being created retroactively? What happened?" required></textarea>
                </div>
                
                <div style="display: flex; gap: 10px; margin-top: 20px;">
                    <button class="btn" style="background: var(--accent-green); flex: 1;" onclick="saveSubBatch()"> Create Sub-Batch (Needs Post-Processing)</button>
                    <button class="btn" style="background: var(--bg-tertiary); flex: 1;" onclick="closeCreateSubBatch()">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Batch Print Menu (Dropdown) -->
    <div id="batchPrintMenu" style="display: none; position: fixed; background: var(--bg-secondary); border: 2px solid var(--accent-purple); border-radius: 12px; padding: 10px; z-index: 10001; box-shadow: 0 10px 40px rgba(0,0,0,0.5); min-width: 200px;">
        <div style="color: var(--text-secondary); font-size: 0.8rem; padding: 5px 10px; border-bottom: 1px solid var(--border); margin-bottom: 5px;">Print Label</div>
        <button onclick="printBatchLabel('intake')" style="display: block; width: 100%; text-align: left; padding: 10px 15px; background: none; border: none; color: var(--text-primary); cursor: pointer; border-radius: 8px; font-size: 0.95rem;" onmouseover="this.style.background='var(--bg-tertiary)'" onmouseout="this.style.background='none'"> Intake Label</button>
        <button onclick="printBatchLabel('postprod')" style="display: block; width: 100%; text-align: left; padding: 10px 15px; background: none; border: none; color: var(--text-primary); cursor: pointer; border-radius: 8px; font-size: 0.95rem;" onmouseover="this.style.background='var(--bg-tertiary)'" onmouseout="this.style.background='none'"> Post-Production Label</button>
        <button onclick="printBatchLabel('labeling')" style="display: block; width: 100%; text-align: left; padding: 10px 15px; background: none; border: none; color: var(--text-primary); cursor: pointer; border-radius: 8px; font-size: 0.95rem;" onmouseover="this.style.background='var(--bg-tertiary)'" onmouseout="this.style.background='none'"> Labeling Complete</button>
    </div>

    <!-- METRC Manifest Import Modal -->
    <div id="metrcImportModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); z-index: 10000; overflow-y: auto;">
        <div style="max-width: 1200px; margin: 30px auto; background: var(--bg-secondary); border-radius: 20px; padding: 40px; border: 3px solid var(--accent-blue);">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 30px;">
                <div>
                    <h2 style="color: var(--accent-blue); margin-bottom: 5px;"> Import from METRC Manifest</h2>
                    <p style="color: var(--text-secondary); font-size: 0.9rem;">Pull incoming transfers and select tags for batch intake</p>
                </div>
                <button onclick="closeMetrcImport()" style="background: none; border: none; color: var(--text-primary); font-size: 2.5rem; cursor: pointer; padding: 0; width: 50px; height: 50px; line-height: 40px;">&times;</button>
            </div>
            
            <!-- METRC API Configuration -->
            <div id="metrcConfigSection" style="background: rgba(59, 130, 246, 0.1); border: 2px solid var(--accent-blue); padding: 25px; border-radius: 15px; margin-bottom: 30px;">
                <h3 style="color: var(--accent-blue); margin-bottom: 20px; display: flex; align-items: center; gap: 10px;">
                    <span></span> METRC API Credentials
                    <span id="metrcConfigStatus" style="margin-left: auto; font-size: 0.85rem; padding: 5px 12px; border-radius: 15px;"></span>
                </h3>
                
                <div style="background: rgba(59, 130, 246, 0.15); border-left: 4px solid var(--accent-blue); padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                    <strong> METRC Requires Two API Keys:</strong>
                    <ol style="margin: 10px 0 0 20px; line-height: 1.8;">
                        <li><strong>Integrator/Software API Key</strong> - Your company's key from METRC Connect
                            <div style="font-size: 0.9rem; color: var(--text-secondary); margin-top: 3px;">This stays the same for all users</div>
                        </li>
                        <li><strong>User API Key</strong> - Created by the user in their METRC account
                            <div style="font-size: 0.9rem; color: var(--text-secondary); margin-top: 3px;">Settings  Integrations  User API Keys</div>
                        </li>
                    </ol>
                </div>

                <div style="background: rgba(239, 68, 68, 0.1); border-left: 4px solid var(--accent-red); padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                    <strong> Browser CORS Limitation:</strong>
                    <ul style="margin: 10px 0 0 20px; line-height: 1.6;">
                        <li>Direct API calls from browsers are blocked by CORS security</li>
                        <li>Even with correct keys, browser connections will likely fail</li>
                        <li><strong>Recommended:</strong> Use Manual Entry tab or set up a server proxy</li>
                    </ul>
                </div>

                <form id="metrcCredentialsForm" onsubmit="event.preventDefault(); saveMetrcConfig();">
                    <div class="form-grid">
                        <div class="form-group">
                            <label>Integrator API Key (Software Key)</label>
                            <input type="password" id="metrcIntegratorKey" placeholder="Your White Mousse integrator key" autocomplete="off">
                            <div class="help-text">From METRC Connect - stays the same for all users</div>
                        </div>
                        <div class="form-group">
                            <label>User API Key</label>
                            <input type="password" id="metrcUserKey" placeholder="Individual user's API key" autocomplete="off">
                            <div class="help-text">Created in METRC: Settings  Integrations  User API Keys</div>
                        </div>
                        <div class="form-group">
                            <label>Manufacturing License Number</label>
                            <input type="text" id="metrcLicenseNumber" value="404R-00016" readonly style="opacity: 0.7; background: var(--bg-tertiary);">
                            <div class="help-text">Your White Mousse manufacturing license (locked)</div>
                        </div>
                    </div>
                    
                    <div style="display: flex; gap: 10px; margin-top: 15px;">
                        <button type="submit" class="btn" style="background: var(--accent-blue); flex: 1;">
                             Save Credentials
                        </button>
                        <button type="button" class="btn" style="background: var(--accent-green); flex: 1;" onclick="testMetrcConnection()">
                             Test Connection
                        </button>
                    </div>
                </form>
                <div id="metrcTestResult" style="margin-top: 15px; display: none;"></div>
            </div>

            <!-- Tab switcher for API vs Manual -->
            <div style="display: flex; gap: 10px; margin-bottom: 20px; border-bottom: 2px solid var(--border);">
                <button class="metrc-tab-btn" data-tab="api" onclick="switchMetrcTab('api')" 
                        style="flex: 1; padding: 15px; background: none; border: none; border-bottom: 3px solid transparent; color: var(--text-secondary); font-weight: 700; cursor: pointer; transition: all 0.3s;">
                     API Import (Advanced)
                </button>
                <button class="metrc-tab-btn active" data-tab="manual" onclick="switchMetrcTab('manual')"
                        style="flex: 1; padding: 15px; background: none; border: none; border-bottom: 3px solid var(--accent-purple); color: var(--accent-purple); font-weight: 700; cursor: pointer; transition: all 0.3s;">
                     Manual Entry (Recommended)
                </button>
            </div>

            <!-- API Load Section -->
            <div id="metrcLoadSection" style="display: none;">
                <div style="display: flex; gap: 15px; margin-bottom: 25px; align-items: end;">
                    <div class="form-group" style="flex: 1; margin: 0;">
                        <label>Start Date</label>
                        <input type="date" id="metrcStartDate" style="width: 100%;">
                    </div>
                    <div class="form-group" style="flex: 1; margin: 0;">
                        <label>End Date</label>
                        <input type="date" id="metrcEndDate" style="width: 100%;">
                    </div>
                    <button class="btn" style="background: var(--accent-green); white-space: nowrap;" onclick="loadMetrcManifests()">
                         Load Incoming Transfers
                    </button>
                </div>

                <div id="metrcLoadingIndicator" style="display: none; text-align: center; padding: 40px; color: var(--accent-blue);">
                    <div style="font-size: 3rem; margin-bottom: 10px;"></div>
                    <div>Loading manifests from METRC...</div>
                </div>

                <div id="metrcError" style="display: none; background: rgba(239, 68, 68, 0.2); border: 2px solid var(--accent-red); color: var(--accent-red); padding: 20px; border-radius: 10px; margin-bottom: 20px;"></div>

                <!-- Manifests List -->
                <div id="metrcManifestsList" style="display: none;">
                    <h3 style="color: var(--accent-purple); margin-bottom: 20px;">Select a Manifest to Import</h3>
                    <div id="manifestsContainer"></div>
                </div>

                <!-- Selected Manifest Details -->
                <div id="manifestDetailsSection" style="display: none;">
                    <div style="background: linear-gradient(135deg, rgba(147, 51, 234, 0.15), rgba(59, 130, 246, 0.15)); padding: 25px; border-radius: 15px; margin-bottom: 25px; border: 2px solid var(--accent-purple);">
                        <h3 style="color: var(--accent-purple); margin-bottom: 15px;"> Manifest Details</h3>
                        <div id="manifestInfo" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px;"></div>
                    </div>

                    <h3 style="color: var(--accent-green); margin-bottom: 20px;">Select Tags for Batch</h3>
                    <div id="tagsContainer" style="display: grid; gap: 10px; margin-bottom: 25px;"></div>

                    <div style="background: var(--bg-tertiary); padding: 20px; border-radius: 12px; margin-bottom: 25px;">
                        <h4 style="color: var(--accent-orange); margin-bottom: 15px;">Selected Tags Summary</h4>
                        <div id="selectedTagsSummary"></div>
                    </div>

                    <div style="display: flex; gap: 15px;">
                        <button class="btn" style="background: var(--accent-green); flex: 1;" onclick="importManifestToBatch()">
                             Import to Batch Intake Form
                        </button>
                        <button class="btn" style="background: var(--bg-tertiary); flex: 1;" onclick="clearManifestSelection()">
                             Back to Manifests
                        </button>
                    </div>
                </div>
            </div>

            <!-- Manual Entry Section -->
            <div id="metrcManualSection">
                <div style="background: rgba(16, 185, 129, 0.1); border: 2px solid var(--accent-green); padding: 20px; border-radius: 12px; margin-bottom: 20px;">
                    <h3 style="color: var(--accent-green); margin-bottom: 10px;"> Recommended Method</h3>
                    <p style="color: var(--text-secondary); font-size: 0.95rem; line-height: 1.6;">
                        This is the most reliable way to import manifest data. Simply open METRC in another tab, 
                        view your incoming transfer, and copy the information here. Fast, simple, and always works!
                    </p>
                </div>

                <div class="form-grid" style="margin-bottom: 20px;">
                    <div class="form-group">
                        <label>Manifest Number</label>
                        <input type="text" id="manualManifestNumber" placeholder="e.g., 0000123456">
                    </div>
                    <div class="form-group">
                        <label>Received Date</label>
                        <input type="date" id="manualReceivedDate">
                    </div>
                    <div class="form-group">
                        <label>Shipper Facility Name</label>
                        <input type="text" id="manualShipperName" placeholder="e.g., ABC Cultivation">
                    </div>
                    <div class="form-group">
                        <label>Shipper License (403R/404R)</label>
                        <input type="text" id="manualShipperLicense" placeholder="403R-00000 or 404R-00000">
                    </div>
                </div>

                <div style="background: var(--bg-tertiary); padding: 20px; border-radius: 12px; margin-bottom: 20px;">
                    <h4 style="color: var(--accent-green); margin-bottom: 15px;">Add Package Tags</h4>
                    <p style="color: var(--text-secondary); font-size: 0.9rem; margin-bottom: 15px;">
                        Enter each package tag from the manifest. You can add multiple packages.
                    </p>
                    
                    <div id="manualPackagesContainer">
                        <div class="manual-package-row" style="display: grid; grid-template-columns: 2fr 1fr 1fr auto; gap: 10px; margin-bottom: 10px; align-items: end;">
                            <div class="form-group" style="margin: 0;">
                                <label>METRC Tag Number</label>
                                <input type="text" class="manual-tag-number" placeholder="1A4060300001234567890">
                            </div>
                            <div class="form-group" style="margin: 0;">
                                <label>Weight (g)</label>
                                <input type="number" class="manual-tag-weight" step="0.1" placeholder="0">
                            </div>
                            <div class="form-group" style="margin: 0;">
                                <label>Strain/Product</label>
                                <input type="text" class="manual-tag-strain" placeholder="OG Kush Trim">
                            </div>
                        </div>
                    </div>
                    
                    <button class="btn" style="background: var(--accent-green); margin-top: 10px;" onclick="addManualPackageRow()">
                         Add Another Package
                    </button>
                </div>

                <div style="background: var(--bg-primary); padding: 20px; border-radius: 12px; margin-bottom: 20px;">
                    <h4 style="color: var(--accent-orange); margin-bottom: 10px;">Summary</h4>
                    <div id="manualSummary" style="color: var(--text-secondary); font-style: italic;">
                        Enter package details above to see summary
                    </div>
                </div>

                <button class="btn" style="background: var(--accent-purple); width: 100%;" onclick="importManualManifest()">
                     Import Manual Entry to Batch Form
                </button>
            </div>
        </div>
    </div>

    <!-- Personal Stats Modal -->
    <div id="personalStatsModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); z-index: 10001; overflow-y: auto;">
        <div style="max-width: 1000px; margin: 30px auto; background: var(--bg-secondary); border-radius: 20px; padding: 0; box-shadow: 0 20px 60px rgba(147, 51, 234, 0.4);">
            <!-- Header -->
            <div style="background: linear-gradient(135deg, var(--accent-purple), var(--accent-blue)); padding: 30px; border-radius: 20px 20px 0 0;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <h2 style="color: white; margin: 0 0 10px 0; font-size: 2rem;">
                             <span id="modalPersonalStatName">Your Workload</span>
                        </h2>
                        <p style="color: rgba(255,255,255,0.9); margin: 0;">Your tasks and progress for today</p>
                    </div>
                    <button onclick="closePersonalStatsModal()" style="background: rgba(255,255,255,0.2); border: none; color: white; font-size: 2rem; cursor: pointer; padding: 5px 15px; border-radius: 10px; transition: all 0.3s ease;">&times;</button>
                </div>
            </div>
            
            <!-- Content -->
            <div style="padding: 30px;">
                <!-- What's Next Section -->
                <div id="whatsNextSection" style="background: linear-gradient(135deg, rgba(16, 185, 129, 0.2), rgba(59, 130, 246, 0.2)); padding: 25px; border-radius: 12px; margin-bottom: 25px; border: 2px solid var(--accent-green);">
                    <h3 style="color: var(--accent-green); margin: 0 0 15px 0; font-size: 1.3rem;"> What's Next</h3>
                    <div id="whatsNextContent">
                        <!-- Populated dynamically -->
                    </div>
                </div>
                
                <!-- Today's Progress -->
                <div style="background: linear-gradient(135deg, rgba(147, 51, 234, 0.2), rgba(59, 130, 246, 0.2)); padding: 25px; border-radius: 12px; margin-bottom: 25px; border: 2px solid var(--accent-purple);">
                    <h3 style="color: var(--accent-purple); margin: 0 0 15px 0; font-size: 1.3rem;"> Today's Progress</h3>
                    <div id="todayProgressContent" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px;">
                        <!-- Populated dynamically -->
                    </div>
                </div>
                
                <!-- Quick Time Selector -->
                <div style="display: flex; gap: 10px; justify-content: center; margin-bottom: 20px; flex-wrap: wrap;">
                    <button class="personal-time-btn active" data-period="today" onclick="updatePersonalStats('today')">Today</button>
                    <button class="personal-time-btn" data-period="week" onclick="updatePersonalStats('week')">This Week</button>
                    <button class="personal-time-btn" data-period="month" onclick="updatePersonalStats('month')">This Month</button>
                    <button class="personal-time-btn" data-period="all" onclick="updatePersonalStats('all')">All Time</button>
                </div>
                
                <!-- Stats Grid -->
                <div id="personalStatsContent" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 20px; margin-bottom: 30px;">
                    <!-- Populated dynamically -->
                </div>

                <!-- Sales Overdue Placeholder (hidden by default) -->
                <div id="myBatchesSection" style="display: none; margin-top: 30px; padding-top: 30px; border-top: 2px solid var(--border);"></div>

                <!-- Personal Records -->
                <div id="personalRecords" style="padding-top: 30px; border-top: 2px solid var(--border); margin-top: 30px;">
                    <h3 style="color: var(--accent-purple); margin-bottom: 20px; text-align: center; font-size: 1.5rem;"> Your Best Days</h3>
                    <div id="personalRecordsContent" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                        <!-- Populated dynamically -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Compliance Modal -->
    <div id="complianceModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); z-index: 10003; overflow-y: auto;">
        <div style="max-width: 900px; margin: 30px auto; background: var(--bg-secondary); border-radius: 20px; padding: 0; box-shadow: 0 20px 60px rgba(16, 185, 129, 0.3);">
            <!-- Header -->
            <div style="background: linear-gradient(135deg, #10B981, #059669); padding: 25px 30px; border-radius: 20px 20px 0 0; display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <h2 style="margin: 0; color: white; font-size: 1.8rem;"> Compliance Assistant</h2>
                    <p style="margin: 5px 0 0 0; color: rgba(255,255,255,0.8); font-size: 0.95rem;">Colorado MED Rules (1 CCR 212-3) - Effective Jan 5, 2026</p>
                </div>
                <button onclick="closeComplianceModal()" style="background: rgba(255,255,255,0.2); border: none; color: white; font-size: 2rem; cursor: pointer; padding: 5px 15px; border-radius: 10px;">&times;</button>
            </div>

            <!-- Search Section -->
            <div style="padding: 25px 30px; border-bottom: 2px solid var(--border);">
                <div style="display: flex; gap: 15px; flex-wrap: wrap;">
                    <input type="text" id="complianceSearchInput" placeholder="Search rules... (e.g., waste log, METRC, labeling)"
                        style="flex: 1; min-width: 250px; padding: 15px 20px; border-radius: 10px; border: 2px solid var(--border); background: var(--bg-tertiary); color: var(--text-primary); font-size: 1rem;"
                        onkeyup="if(event.key === 'Enter') searchComplianceRules()">
                    <button onclick="searchComplianceRules()" class="btn" style="background: var(--accent-green); border-color: var(--accent-green); padding: 15px 30px;"> Search</button>
                </div>

                <!-- Quick Topics -->
                <div style="margin-top: 15px; display: flex; gap: 10px; flex-wrap: wrap;">
                    <span style="color: var(--text-secondary); padding: 8px 0;">Quick topics:</span>
                    <button onclick="searchComplianceTopic('waste')" class="compliance-topic-btn">Waste Disposal</button>
                    <button onclick="searchComplianceTopic('metrc')" class="compliance-topic-btn">METRC/Tracking</button>
                    <button onclick="searchComplianceTopic('label')" class="compliance-topic-btn">Labeling</button>
                    <button onclick="searchComplianceTopic('security')" class="compliance-topic-btn">Security</button>
                    <button onclick="searchComplianceTopic('transport')" class="compliance-topic-btn">Transport</button>
                    <button onclick="searchComplianceTopic('testing')" class="compliance-topic-btn">Testing</button>
                    <button onclick="searchComplianceTopic('reducedtesting')" class="compliance-topic-btn">Reduced Testing</button>
                </div>
            </div>

            <!-- Results Section -->
            <div id="complianceResults" style="padding: 25px 30px; max-height: 500px; overflow-y: auto;">
                <div style="text-align: center; color: var(--text-secondary); padding: 40px;">
                    <div style="font-size: 3rem; margin-bottom: 15px;"></div>
                    <p>Search Colorado MED rules or select a quick topic above.</p>
                    <p style="font-size: 0.9rem; margin-top: 10px;">Covers: Definitions, Licensing, Operations, Cultivation, Manufacturing, Testing, Retail, Inventory Tracking, Waste, Labeling, Transportation</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Commission Details Modal -->
    <div id="commissionDetailsModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); z-index: 10002; overflow-y: auto;">
        <div style="max-width: 1100px; margin: 30px auto; background: var(--bg-secondary); border-radius: 20px; padding: 0; box-shadow: 0 20px 60px rgba(147, 51, 234, 0.4);">
            <!-- Header -->
            <div id="commissionModalHeader" style="background: linear-gradient(135deg, var(--accent-purple), var(--accent-green)); padding: 30px; border-radius: 20px 20px 0 0;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <h2 style="color: white; margin: 0 0 10px 0; font-size: 1.8rem;" id="commissionModalTitle">Commission Details</h2>
                        <p style="color: rgba(255,255,255,0.9); margin: 0;" id="commissionModalSubtitle">Payments from Dec 6, 2024 to Jan 5, 2025</p>
                    </div>
                    <button onclick="closeCommissionDetailsModal()" style="background: rgba(255,255,255,0.2); border: none; color: white; font-size: 2rem; cursor: pointer; padding: 5px 15px; border-radius: 10px; transition: all 0.3s ease;">&times;</button>
                </div>
            </div>

            <!-- Content -->
            <div style="padding: 30px;">
                <!-- Action Buttons -->
                <div style="display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap;">
                    <button onclick="copyCommissionToClipboard()" class="btn" style="background: var(--accent-blue); padding: 10px 20px; display: flex; align-items: center; gap: 8px;">
                        <span></span> Copy to Clipboard
                    </button>
                    <span id="commissionCopyStatus" style="color: var(--accent-green); display: none; align-self: center;">Copied!</span>
                </div>

                <!-- Table Container -->
                <div style="background: var(--bg-primary); border-radius: 12px; overflow: hidden; border: 1px solid var(--border);">
                    <div style="max-height: 500px; overflow-y: auto;">
                        <table id="commissionDetailsTable" style="width: 100%; border-collapse: collapse; font-size: 0.9rem;">
                            <thead style="position: sticky; top: 0; background: var(--bg-tertiary); z-index: 1;">
                                <tr>
                                    <th style="padding: 15px 12px; text-align: left; color: var(--text-secondary); font-weight: 600; border-bottom: 2px solid var(--border);">Invoice Number</th>
                                    <th style="padding: 15px 12px; text-align: left; color: var(--text-secondary); font-weight: 600; border-bottom: 2px solid var(--border);">Store</th>
                                    <th style="padding: 15px 12px; text-align: right; color: var(--text-secondary); font-weight: 600; border-bottom: 2px solid var(--border);">Amount</th>
                                    <th style="padding: 15px 12px; text-align: right; color: var(--text-secondary); font-weight: 600; border-bottom: 2px solid var(--border);">Pay Amount (8%)</th>
                                    <th style="padding: 15px 12px; text-align: left; color: var(--text-secondary); font-weight: 600; border-bottom: 2px solid var(--border);">Paid Date</th>
                                </tr>
                            </thead>
                            <tbody id="commissionDetailsBody">
                                <!-- Populated dynamically -->
                            </tbody>
                        </table>
                    </div>
                </div>

                <!-- Totals Footer -->
                <div id="commissionTotalsFooter" style="margin-top: 20px; padding: 20px; background: linear-gradient(135deg, rgba(147, 51, 234, 0.15), rgba(16, 185, 129, 0.15)); border-radius: 12px; border: 2px solid var(--accent-purple);">
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; text-align: center;">
                        <div>
                            <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 5px;">Total Orders</div>
                            <div style="font-size: 1.5rem; font-weight: 700; color: var(--text-primary);" id="commissionTotalOrders">0</div>
                        </div>
                        <div>
                            <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 5px;">Total Amount</div>
                            <div style="font-size: 1.5rem; font-weight: 700; color: var(--accent-blue);" id="commissionTotalAmount">$0.00</div>
                        </div>
                        <div>
                            <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 5px;">Total Commission (8%)</div>
                            <div style="font-size: 1.8rem; font-weight: 700; color: var(--accent-green);" id="commissionTotalPay">$0.00</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Costing Station -->
    <div class="station-content" id="costing">
        <button class="mobile-back-btn" onclick="closeMobileStation()"> Back</button>
        <div class="form-section">
            <!-- Costing Dashboard Header -->
            <div style="background: linear-gradient(135deg, rgba(16, 185, 129, 0.1), rgba(59, 130, 246, 0.1)); border: 2px solid #10B981; border-radius: 16px; padding: 25px; margin-bottom: 30px;">
                <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 15px;">
                    <div>
                        <h3 style="margin: 0; display: flex; align-items: center; gap: 10px; color: #10B981;">
                            <span></span> Costing & Profitability
                        </h3>
                        <p style="color: var(--text-secondary); margin: 5px 0 0 0; font-size: 0.9rem;">Configure costs, labor rates, and target margins</p>
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <button onclick="recalculateAllBatchCOGS()" class="btn" style="background: var(--accent-blue); padding: 10px 20px;">Recalculate All COGS</button>
                        <button onclick="loadCostingData()" class="btn" style="background: #10B981; padding: 10px 20px;">Refresh</button>
                    </div>
                </div>
            </div>

            <!-- Costing Sub-tabs -->
            <div style="display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap;">
                <button onclick="showCostingSection('config')" id="costingTabConfig" class="costing-subtab active" style="background: #10B981; border: none; color: white; padding: 10px 20px; border-radius: 8px; cursor: pointer; font-weight: 600;">Cost Configuration</button>
                <button onclick="showCostingSection('labor')" id="costingTabLabor" class="costing-subtab" style="background: var(--bg-tertiary); border: 1px solid var(--border-color); color: var(--text-primary); padding: 10px 20px; border-radius: 8px; cursor: pointer;">Labor Rates</button>
                <button onclick="showCostingSection('margins')" id="costingTabMargins" class="costing-subtab" style="background: var(--bg-tertiary); border: 1px solid var(--border-color); color: var(--text-primary); padding: 10px 20px; border-radius: 8px; cursor: pointer;">Target Margins</button>
                <button onclick="showCostingSection('analysis')" id="costingTabAnalysis" class="costing-subtab" style="background: var(--bg-tertiary); border: 1px solid var(--border-color); color: var(--text-primary); padding: 10px 20px; border-radius: 8px; cursor: pointer;">Profitability Analysis</button>
            </div>

            <!-- Cost Configuration Section -->
            <div id="costingConfigSection" class="costing-section">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                    <!-- Consumables -->
                    <div style="background: var(--bg-primary); border-radius: 12px; padding: 20px; border: 1px solid var(--border-color);">
                        <h4 style="color: var(--accent-blue); margin: 0 0 15px 0; display: flex; align-items: center; gap: 8px;">
                            <span></span> Consumable Costs
                        </h4>
                        <div id="consumablesCostGrid" style="display: grid; gap: 12px;">
                            <!-- Populated by JS -->
                        </div>
                    </div>

                    <!-- Overhead -->
                    <div style="background: var(--bg-primary); border-radius: 12px; padding: 20px; border: 1px solid var(--border-color);">
                        <h4 style="color: var(--accent-orange); margin: 0 0 15px 0; display: flex; align-items: center; gap: 8px;">
                            <span></span> Monthly Overhead
                        </h4>
                        <div id="overheadCostGrid" style="display: grid; gap: 12px;">
                            <!-- Populated by JS -->
                        </div>
                        <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--border-color);">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <span style="color: var(--text-secondary);">Total Monthly Overhead:</span>
                                <span id="totalMonthlyOverhead" style="font-size: 1.2rem; font-weight: 700; color: var(--accent-orange);">$0.00</span>
                            </div>
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 8px;">
                                <span style="color: var(--text-secondary);">Avg Batches/Month:</span>
                                <span id="avgBatchesPerMonthDisplay" style="color: var(--text-primary); font-weight: 600;">--</span>
                            </div>
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 8px;">
                                <span style="color: var(--text-secondary);">Avg Grams/Month:</span>
                                <span id="avgMonthlyGramsDisplay" style="color: var(--text-primary); font-weight: 600;">--</span>
                            </div>
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 8px; font-size: 0.8rem; opacity: 0.7;">
                                <span> Auto-calculated from last 3 months</span>
                            </div>
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 8px;">
                                <span style="color: var(--text-secondary);">Overhead Per Batch:</span>
                                <span id="overheadPerBatch" style="font-size: 1.1rem; font-weight: 600; color: var(--accent-green);">$0.00</span>
                            </div>
                        </div>
                    </div>
                </div>
                <button onclick="saveCostConfig()" class="btn" style="background: var(--accent-green); margin-top: 20px; padding: 12px 30px;">Save Cost Configuration</button>
            </div>

            <!-- Labor Rates Section -->
            <div id="costingLaborSection" class="costing-section" style="display: none;">
                <div style="background: var(--bg-primary); border-radius: 12px; padding: 20px; border: 1px solid var(--border-color);">
                    <h4 style="color: var(--accent-purple); margin: 0 0 15px 0; display: flex; align-items: center; gap: 8px;">
                        <span></span> Employee Hourly Rates
                    </h4>
                    <p style="color: var(--text-secondary); margin-bottom: 15px; font-size: 0.9rem;">Set hourly rates for each employee. These are used to calculate labor costs on batches.</p>
                    <div id="laborRatesGrid" style="display: grid; gap: 10px;">
                        <!-- Populated by JS -->
                    </div>
                </div>
                <button onclick="saveLaborRates()" class="btn" style="background: var(--accent-green); margin-top: 20px; padding: 12px 30px;">Save Labor Rates</button>
            </div>

            <!-- Target Margins Section -->
            <div id="costingMarginsSection" class="costing-section" style="display: none;">
                <div style="background: var(--bg-primary); border-radius: 12px; padding: 20px; border: 1px solid var(--border-color);">
                    <h4 style="color: #FFD700; margin: 0 0 15px 0; display: flex; align-items: center; gap: 8px;">
                        <span></span> Target Margins by Product Type
                    </h4>
                    <p style="color: var(--text-secondary); margin-bottom: 15px; font-size: 0.9rem;">Set your target profit margin for each product type. The system will calculate suggested pricing.</p>
                    <div style="overflow-x: auto;">
                        <table id="targetMarginsTable" style="width: 100%; border-collapse: collapse;">
                            <thead>
                                <tr style="background: var(--bg-tertiary);">
                                    <th style="padding: 12px; text-align: left; color: var(--text-secondary);">Product Type</th>
                                    <th style="padding: 12px; text-align: center; color: var(--text-secondary);">Target Margin %</th>
                                    <th style="padding: 12px; text-align: right; color: var(--text-secondary);">Avg COGS/Unit</th>
                                    <th style="padding: 12px; text-align: right; color: var(--text-secondary);">Suggested Price</th>
                                    <th style="padding: 12px; text-align: right; color: var(--text-secondary);">Current Price</th>
                                    <th style="padding: 12px; text-align: center; color: var(--text-secondary);">Actual Margin</th>
                                </tr>
                            </thead>
                            <tbody id="targetMarginsBody">
                                <!-- Populated by JS -->
                            </tbody>
                        </table>
                    </div>
                </div>
                <div style="display: flex; gap: 10px; margin-top: 20px;">
                    <button onclick="saveTargetMargins()" class="btn" style="background: var(--accent-green); padding: 12px 30px;">Save Target Margins</button>
                </div>
            </div>

            <!-- Profitability Analysis Section -->
            <div id="costingAnalysisSection" class="costing-section" style="display: none;">
                <div style="display: flex; gap: 10px; margin-bottom: 20px; align-items: center;">
                    <span style="color: var(--text-secondary);">Analysis Period:</span>
                    <select id="analysisperiod" onchange="updateProfitabilityAnalysis()" style="background: var(--bg-primary); border: 1px solid var(--border-color); color: var(--text-primary); padding: 10px 15px; border-radius: 8px;">
                        <option value="all" selected>All Time</option>
                        <option value="week">This Week</option>
                        <option value="month">This Month</option>
                        <option value="quarter">This Quarter</option>
                        <option value="year">This Year</option>
                    </select>
                </div>

                <!-- Summary Cards -->
                <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px; margin-bottom: 20px;">
                    <div style="background: var(--bg-primary); border-radius: 12px; padding: 20px; text-align: center; border-left: 4px solid var(--accent-blue);">
                        <div style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 5px;">Total Revenue</div>
                        <div id="analysisRevenue" style="font-size: 1.8rem; font-weight: 700; color: var(--accent-blue);">$0.00</div>
                    </div>
                    <div style="background: var(--bg-primary); border-radius: 12px; padding: 20px; text-align: center; border-left: 4px solid var(--accent-orange);">
                        <div style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 5px;">Total COGS</div>
                        <div id="analysisCOGS" style="font-size: 1.8rem; font-weight: 700; color: var(--accent-orange);">$0.00</div>
                    </div>
                    <div style="background: var(--bg-primary); border-radius: 12px; padding: 20px; text-align: center; border-left: 4px solid var(--accent-green);">
                        <div style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 5px;">Gross Profit</div>
                        <div id="analysisProfit" style="font-size: 1.8rem; font-weight: 700; color: var(--accent-green);">$0.00</div>
                    </div>
                    <div style="background: var(--bg-primary); border-radius: 12px; padding: 20px; text-align: center; border-left: 4px solid var(--accent-purple);">
                        <div style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 5px;">Gross Margin</div>
                        <div id="analysisMargin" style="font-size: 1.8rem; font-weight: 700; color: var(--accent-purple);">0%</div>
                    </div>
                </div>

                <!-- By Product Breakdown -->
                <div style="background: var(--bg-primary); border-radius: 12px; padding: 20px; border: 1px solid var(--border-color); margin-bottom: 20px;">
                    <h4 style="color: var(--text-primary); margin: 0 0 15px 0;">Profitability by Product Type</h4>
                    <div style="overflow-x: auto;">
                        <table style="width: 100%; border-collapse: collapse;">
                            <thead>
                                <tr style="background: var(--bg-tertiary);">
                                    <th style="padding: 12px; text-align: left; color: var(--text-secondary);">Product Type</th>
                                    <th style="padding: 12px; text-align: right; color: var(--text-secondary);">Units Sold</th>
                                    <th style="padding: 12px; text-align: right; color: var(--text-secondary);">Revenue</th>
                                    <th style="padding: 12px; text-align: right; color: var(--text-secondary);">COGS</th>
                                    <th style="padding: 12px; text-align: right; color: var(--text-secondary);">Profit</th>
                                    <th style="padding: 12px; text-align: center; color: var(--text-secondary);">Margin</th>
                                </tr>
                            </thead>
                            <tbody id="productProfitabilityBody">
                                <!-- Populated by JS -->
                            </tbody>
                        </table>
                    </div>
                </div>

                <!-- Cost Breakdown -->
                <div style="background: var(--bg-primary); border-radius: 12px; padding: 20px; border: 1px solid var(--border-color);">
                    <h4 style="color: var(--text-primary); margin: 0 0 15px 0;">Cost Category Breakdown</h4>
                    <div id="costBreakdownChart" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px;">
                        <div style="text-align: center;">
                            <div style="height: 100px; background: linear-gradient(to top, var(--accent-blue) 0%, transparent 100%); border-radius: 8px; display: flex; align-items: flex-end; justify-content: center; padding-bottom: 10px;">
                                <span id="costBreakdownMaterial" style="color: white; font-weight: 700;">$0</span>
                            </div>
                            <div style="color: var(--text-secondary); margin-top: 8px; font-size: 0.85rem;">Materials</div>
                            <div id="costBreakdownMaterialPct" style="color: var(--accent-blue); font-weight: 600;">0%</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="height: 100px; background: linear-gradient(to top, var(--accent-orange) 0%, transparent 100%); border-radius: 8px; display: flex; align-items: flex-end; justify-content: center; padding-bottom: 10px;">
                                <span id="costBreakdownConsumables" style="color: white; font-weight: 700;">$0</span>
                            </div>
                            <div style="color: var(--text-secondary); margin-top: 8px; font-size: 0.85rem;">Consumables</div>
                            <div id="costBreakdownConsumablesPct" style="color: var(--accent-orange); font-weight: 600;">0%</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="height: 100px; background: linear-gradient(to top, var(--accent-purple) 0%, transparent 100%); border-radius: 8px; display: flex; align-items: flex-end; justify-content: center; padding-bottom: 10px;">
                                <span id="costBreakdownLabor" style="color: white; font-weight: 700;">$0</span>
                            </div>
                            <div style="color: var(--text-secondary); margin-top: 8px; font-size: 0.85rem;">Labor</div>
                            <div id="costBreakdownLaborPct" style="color: var(--accent-purple); font-weight: 600;">0%</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="height: 100px; background: linear-gradient(to top, var(--accent-green) 0%, transparent 100%); border-radius: 8px; display: flex; align-items: flex-end; justify-content: center; padding-bottom: 10px;">
                                <span id="costBreakdownOverhead" style="color: white; font-weight: 700;">$0</span>
                            </div>
                            <div style="color: var(--text-secondary); margin-top: 8px; font-size: 0.85rem;">Overhead</div>
                            <div id="costBreakdownOverheadPct" style="color: var(--accent-green); font-weight: 600;">0%</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Royalty Details Modal -->
    <div id="royaltyDetailsModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); z-index: 10002; overflow-y: auto;">
        <div style="max-width: 1100px; margin: 30px auto; background: var(--bg-secondary); border-radius: 20px; padding: 0; box-shadow: 0 20px 60px rgba(245, 158, 11, 0.4);">
            <!-- Header -->
            <div id="royaltyModalHeader" style="background: linear-gradient(135deg, var(--accent-orange), #f97316); padding: 30px; border-radius: 20px 20px 0 0;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <h2 style="color: white; margin: 0 0 10px 0; font-size: 1.8rem;" id="royaltyModalTitle">Royalty Details</h2>
                        <p style="color: rgba(255,255,255,0.9); margin: 0;" id="royaltyModalSubtitle">January 2025</p>
                    </div>
                    <button onclick="closeRoyaltyDetailsModal()" style="background: rgba(255,255,255,0.2); border: none; color: white; font-size: 2rem; cursor: pointer; padding: 5px 15px; border-radius: 10px; transition: all 0.3s ease;">&times;</button>
                </div>
            </div>

            <!-- Content -->
            <div style="padding: 30px;">
                <!-- Action Buttons -->
                <div style="display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap;">
                    <button onclick="copyRoyaltyToClipboard()" class="btn" style="background: var(--accent-blue); padding: 10px 20px; display: flex; align-items: center; gap: 8px;">
                        <span>Copy to Clipboard</span>
                    </button>
                    <span id="royaltyCopyStatus" style="color: var(--accent-green); display: none; align-self: center;">Copied!</span>
                </div>

                <!-- Table Container -->
                <div style="background: var(--bg-primary); border-radius: 12px; overflow: hidden; border: 1px solid var(--border);">
                    <div style="max-height: 500px; overflow-y: auto;">
                        <table id="royaltyDetailsTable" style="width: 100%; border-collapse: collapse; font-size: 0.9rem;">
                            <thead style="position: sticky; top: 0; background: var(--bg-tertiary); z-index: 1;">
                                <tr>
                                    <th style="padding: 15px 12px; text-align: left; color: var(--text-secondary); font-weight: 600; border-bottom: 2px solid var(--border);">Invoice #</th>
                                    <th style="padding: 15px 12px; text-align: left; color: var(--text-secondary); font-weight: 600; border-bottom: 2px solid var(--border);">Customer</th>
                                    <th style="padding: 15px 12px; text-align: left; color: var(--text-secondary); font-weight: 600; border-bottom: 2px solid var(--border);">Product</th>
                                    <th style="padding: 15px 12px; text-align: right; color: var(--text-secondary); font-weight: 600; border-bottom: 2px solid var(--border);">Qty</th>
                                    <th style="padding: 15px 12px; text-align: right; color: var(--text-secondary); font-weight: 600; border-bottom: 2px solid var(--border);">Amount</th>
                                    <th style="padding: 15px 12px; text-align: right; color: var(--text-secondary); font-weight: 600; border-bottom: 2px solid var(--border);">Royalty</th>
                                    <th style="padding: 15px 12px; text-align: left; color: var(--text-secondary); font-weight: 600; border-bottom: 2px solid var(--border);">Paid Date</th>
                                </tr>
                            </thead>
                            <tbody id="royaltyDetailsBody">
                                <!-- Populated dynamically -->
                            </tbody>
                        </table>
                    </div>
                </div>

                <!-- Totals Footer -->
                <div id="royaltyTotalsFooter" style="margin-top: 20px; padding: 20px; background: linear-gradient(135deg, rgba(245, 158, 11, 0.15), rgba(249, 115, 22, 0.15)); border-radius: 12px; border: 2px solid var(--accent-orange);">
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 20px; text-align: center;">
                        <div>
                            <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 5px;">Line Items</div>
                            <div style="font-size: 1.5rem; font-weight: 700; color: var(--text-primary);" id="royaltyTotalItems">0</div>
                        </div>
                        <div>
                            <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 5px;">Total Quantity</div>
                            <div style="font-size: 1.5rem; font-weight: 700; color: var(--text-primary);" id="royaltyTotalQty">0</div>
                        </div>
                        <div>
                            <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 5px;">Total Amount</div>
                            <div style="font-size: 1.5rem; font-weight: 700; color: var(--accent-blue);" id="royaltyTotalAmount">$0.00</div>
                        </div>
                        <div>
                            <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 5px;">Total Royalty</div>
                            <div style="font-size: 1.8rem; font-weight: 700; color: var(--accent-orange);" id="royaltyTotalPay">$0.00</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Inventory Management Modal -->
    <div id="inventoryModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); z-index: 10001; overflow-y: auto;">
        <div style="max-width: 600px; margin: 50px auto; background: var(--bg-secondary); border-radius: 20px; padding: 0; box-shadow: 0 20px 60px rgba(245, 158, 11, 0.4);">
            <!-- Header -->
            <div style="background: linear-gradient(135deg, var(--accent-orange), var(--accent-red)); padding: 30px; border-radius: 20px 20px 0 0;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <h2 style="color: white; margin: 0 0 10px 0; font-size: 2rem;">
                             Update Supply Inventory
                        </h2>
                        <p style="color: rgba(255,255,255,0.9); margin: 0;">Track butane and nitrogen levels</p>
                    </div>
                    <button onclick="closeInventoryModal()" style="background: rgba(255,255,255,0.2); border: none; color: white; font-size: 2rem; cursor: pointer; padding: 5px 15px; border-radius: 10px; transition: all 0.3s ease;">&times;</button>
                </div>
            </div>

            <!-- Content -->
            <div style="padding: 30px;">
                <p style="text-align: center; color: var(--text-secondary);">Use the Gas Logging button in the Extraction tab to manage butane.</p>
            </div>
        </div>
    </div>
    
    <!-- Pull Batch Modal -->
    <div id="pullBatchModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); z-index: 10003; overflow-y: auto;">
        <div style="max-width: 600px; margin: 50px auto; background: var(--bg-secondary); border-radius: 20px; padding: 0; box-shadow: 0 20px 60px rgba(16, 185, 129, 0.4);">
            <div style="background: linear-gradient(135deg, var(--accent-green), var(--accent-blue)); padding: 30px; border-radius: 20px 20px 0 0;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <h2 style="color: white; margin: 0; font-size: 1.8rem;" id="pullBatchModalTitle"> Pull Batch from Pot</h2>
                    <button onclick="closePullBatchModal()" style="background: rgba(255,255,255,0.2); border: none; color: white; font-size: 2rem; cursor: pointer; padding: 5px 15px; border-radius: 10px;">&times;</button>
                </div>
            </div>
            <div style="padding: 30px;">
                <!-- Current Pot Info -->
                <div id="pullBatchInfo" style="background: var(--bg-tertiary); padding: 20px; border-radius: 10px; margin-bottom: 25px; text-align: center;">
                    <div style="font-size: 0.9rem; color: var(--text-secondary); margin-bottom: 5px;">Batch in Pot</div>
                    <div id="pullBatchNumber" style="font-size: 1.8rem; font-weight: 700; color: var(--accent-blue); margin-bottom: 5px;">-</div>
                    <div id="pullBatchStrain" style="font-size: 1.3rem; font-weight: 600; color: var(--accent-purple); margin-bottom: 10px;">-</div>
                    <div id="pullBatchRuns" style="font-size: 1.1rem; color: var(--text-primary); margin-bottom: 15px;">0 runs collected</div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; text-align: center; padding-top: 15px; border-top: 1px solid var(--border);">
                        <div>
                            <div style="font-size: 0.8rem; color: var(--text-secondary);">Trim in Pot</div>
                            <div id="pullBatchTrimWeight" style="font-size: 1.4rem; font-weight: 700; color: var(--text-primary);">0g</div>
                        </div>
                        <div>
                            <div style="font-size: 0.8rem; color: var(--text-secondary);">Projected Yield</div>
                            <div id="pullBatchProjectedYield" style="font-size: 1.4rem; font-weight: 700; color: var(--accent-green);">0g</div>
                        </div>
                    </div>
                </div>
                
                <form id="pullBatchForm" onsubmit="event.preventDefault(); submitPullBatch();">
                    <!-- Product Type Selection -->
                    <div class="form-group">
                        <label>Product Type Pulled</label>
                        <select id="pullProductType" required onchange="updatePullFields()">
                            <option value="">Select product type...</option>
                            <option value="shatter">Shatter (count slabs)</option>
                            <option value="wax">Wax (count bowls)</option>
                            <option value="sugar_wax">Sugar Wax (count bowls)</option>
                            <option value="live_resin">Live Resin Oil (count bowls)</option>
                        </select>
                    </div>
                    
                    <!-- Shatter Fields -->
                    <div id="shatterFields" style="display: none;">
                        <div class="form-group">
                            <label>Number of Slabs</label>
                            <input type="number" id="pullSlabs" min="0" placeholder="0">
                            <div class="help-text">How many slabs of shatter were pulled?</div>
                        </div>
                    </div>
                    
                    <!-- Wax / Sugar Wax Fields (1g & 4g) -->
                    <div id="waxFields" style="display: none;">
                        <div class="form-group">
                            <label>Number of Bowls</label>
                            <input type="number" id="pullBowls" min="0" placeholder="0">
                            <div class="help-text">How many bowls of wax/sugar wax were pulled?</div>
                        </div>
                    </div>
                    
                    <!-- Notes -->
                    <div class="form-group">
                        <label>Notes (Optional)</label>
                        <textarea id="pullNotes" placeholder="Consistency, color, any observations..."></textarea>
                    </div>
                    
                    <button type="submit" class="btn" style="background: var(--accent-green); width: 100%; font-size: 1.1rem;">
                         Record Pull & Empty Pot
                    </button>
                </form>
            </div>
        </div>
    </div>
    
    <!-- Machine Status Modal -->
    <div id="machineModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); z-index: 10003; overflow-y: auto;">
        <div style="max-width: 600px; margin: 50px auto; background: var(--bg-secondary); border-radius: 20px; padding: 0; box-shadow: 0 20px 60px rgba(147, 51, 234, 0.4);">
            <div style="background: linear-gradient(135deg, var(--accent-blue), var(--accent-purple)); padding: 30px; border-radius: 20px 20px 0 0;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <h2 style="color: white; margin: 0; font-size: 1.8rem;" id="machineModalTitle"> Machine Status</h2>
                    <button onclick="closeMachineModal()" style="background: rgba(255,255,255,0.2); border: none; color: white; font-size: 2rem; cursor: pointer; padding: 5px 15px; border-radius: 10px;">&times;</button>
                </div>
            </div>
            <div style="padding: 30px;">
                <form id="machineForm" onsubmit="event.preventDefault(); saveMachineStatus();">
                    <!-- Dynamic Columns (generated based on machine config) -->
                    <div id="machineColumnsContainer">
                        <!-- Populated by openMachineModal() based on machine config -->
                    </div>

                    <!-- Pot Status (BHO only) -->
                    <div id="machinePotSection" style="background: rgba(147, 51, 234, 0.1); border-left: 4px solid var(--accent-purple); padding: 20px; border-radius: 8px; margin-bottom: 20px;">
                        <h3 style="color: var(--accent-purple); margin: 0 0 15px 0;"> Pot</h3>
                        <div id="potLedgerDisplay" style="display: none; background: var(--bg-tertiary); padding: 12px; border-radius: 8px; margin-bottom: 15px; font-size: 0.9rem;">
                            <!-- Populated by JS -->
                        </div>
                        <div class="form-grid">
                            <div class="form-group">
                                <label>Batch in Pot</label>
                                <input type="text" id="machinePotBatchDisplay" readonly style="background: var(--bg-tertiary);" placeholder="Empty">
                                <input type="hidden" id="machinePotBatch" value="">
                            </div>
                            <div class="form-group">
                                <label>Runs in Pot</label>
                                <input type="number" id="machinePotRuns" min="0" placeholder="0" readonly style="background: var(--bg-tertiary);">
                            </div>
                        </div>
                        <button type="button" id="modalPullBatchBtn" class="btn" style="display: none; background: linear-gradient(135deg, #FFD700, #FFA500); color: #1a1a2e; width: 100%; margin-top: 15px; padding: 15px; font-size: 1.1rem; font-weight: 700; box-shadow: 0 0 20px rgba(255, 215, 0, 0.4);" onclick="openPullBatchFromModal()">
                             Pull Batch from Pot
                        </button>
                    </div>

                    <!-- Filter Status (BHO only) -->
                    <div id="machineFilterSection" style="background: rgba(16, 185, 129, 0.1); border-left: 4px solid var(--accent-green); padding: 20px; border-radius: 8px; margin-bottom: 20px;">
                        <h3 style="color: var(--accent-green); margin: 0 0 15px 0;">Filter Column</h3>
                        <div class="help-text" style="margin-bottom: 15px;">Filter media stack (top to bottom)</div>

                        <!-- Filter stack inputs -->
                        <div style="display: flex; flex-direction: column; gap: 2px; margin-bottom: 20px;">
                            <div class="form-group" style="margin: 0; background: var(--bg-tertiary); padding: 12px 15px; border-radius: 8px 8px 0 0; border-left: 3px solid var(--accent-blue);">
                                <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 6px;">
                                    <span style="color: var(--accent-blue); font-size: 0.75rem; font-weight: 700; background: rgba(0, 85, 255, 0.2); padding: 2px 6px; border-radius: 4px;">TOP</span>
                                    <span>Silica (cups)</span>
                                </label>
                                <input type="number" id="machineFilterSilicaTop" step="0.5" min="0" placeholder="0">
                            </div>
                            <div class="form-group" style="margin: 0; background: var(--bg-tertiary); padding: 12px 15px; border-left: 3px solid var(--accent-orange);">
                                <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 6px;">
                                    <span style="color: var(--accent-orange); font-size: 0.75rem; font-weight: 700; background: rgba(255, 107, 0, 0.2); padding: 2px 6px; border-radius: 4px;">MID</span>
                                    <span>Clay (cups)</span>
                                </label>
                                <input type="number" id="machineFilterClay" step="0.5" min="0" placeholder="0">
                            </div>
                            <div class="form-group" style="margin: 0; background: var(--bg-tertiary); padding: 12px 15px; border-radius: 0 0 8px 8px; border-left: 3px solid var(--accent-blue);">
                                <label style="display: flex; align-items: center; gap: 8px; margin-bottom: 6px;">
                                    <span style="color: var(--accent-blue); font-size: 0.75rem; font-weight: 700; background: rgba(0, 85, 255, 0.2); padding: 2px 6px; border-radius: 4px;">BTM</span>
                                    <span>Silica (cups)</span>
                                </label>
                                <input type="number" id="machineFilterSilicaBottom" step="0.5" min="0" placeholder="0">
                            </div>
                        </div>

                        <div class="form-group" style="margin-bottom: 0;">
                            <label>Runs Through Filter</label>
                            <input type="number" id="machineFilterRuns" min="0" placeholder="0">
                            <div class="help-text">How many runs have been processed through this filter?</div>
                        </div>
                    </div>
                    
                    <div id="machineFormButtons" style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                        <button type="button" class="btn" style="background: var(--accent-red);" onclick="clearMachineStatus()"> Clear All</button>
                        <button type="submit" class="btn" style="background: var(--accent-green);"> Save Status</button>
                    </div>
                </form>
            </div>
        </div>
    </div>
    
    <!-- Extraction Supplies Modal -->
    <div id="suppliesModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); z-index: 10002; overflow-y: auto;">
        <div style="max-width: 700px; margin: 50px auto; background: var(--bg-secondary); border-radius: 20px; padding: 0; box-shadow: 0 20px 60px rgba(245, 158, 11, 0.4);">
            <div style="background: linear-gradient(135deg, var(--accent-orange), var(--accent-red)); padding: 30px; border-radius: 20px 20px 0 0;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <h2 style="color: white; margin: 0; font-size: 1.8rem;"> Extraction Supplies</h2>
                    <button onclick="closeSuppliesModal()" style="background: rgba(255,255,255,0.2); border: none; color: white; font-size: 2rem; cursor: pointer; padding: 5px 15px; border-radius: 10px;">&times;</button>
                </div>
            </div>
            <div style="padding: 30px;">
                <!-- Current Levels -->
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 30px;">
                    <div style="text-align: center; background: var(--bg-tertiary); padding: 20px; border-radius: 10px;">
                        <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 5px;"> Butane Bulk Tank</div>
                        <div id="modalButaneDisplay" style="font-size: 2.5rem; font-weight: 700; color: var(--accent-blue);">0 lbs</div>
                    </div>
                    <div style="text-align: center; background: var(--bg-tertiary); padding: 20px; border-radius: 10px;">
                        <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 5px;"> Nitrogen Tanks</div>
                        <div id="modalNitrogenDisplay" style="font-size: 2.5rem; font-weight: 700; color: var(--accent-purple);">0</div>
                    </div>
                </div>
                
                <!-- Withdraw Section -->
                <div style="background: rgba(239, 68, 68, 0.1); border-left: 4px solid var(--accent-red); padding: 20px; border-radius: 8px; margin-bottom: 25px;">
                    <h3 style="color: var(--accent-red); margin: 0 0 15px 0;"> Withdraw Supplies</h3>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                        <div>
                            <label style="display: block; margin-bottom: 8px; font-weight: 600;">Butane (lbs)</label>
                            <input type="number" id="modalWithdrawButane" step="0.1" min="0" placeholder="0.0" style="width: 100%; padding: 12px; font-size: 1.1rem; background: var(--bg-primary); border: 2px solid var(--border); border-radius: 8px; color: var(--text-primary); margin-bottom: 10px;">
                            <button class="btn" style="background: var(--accent-red); padding: 12px; width: 100%;" onclick="withdrawButaneFromModal()">Take</button>
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 8px; font-weight: 600;">Nitrogen (tanks)</label>
                            <input type="number" id="modalWithdrawNitrogen" step="0.5" min="0" placeholder="0.0" style="width: 100%; padding: 12px; font-size: 1.1rem; background: var(--bg-primary); border: 2px solid var(--border); border-radius: 8px; color: var(--text-primary); margin-bottom: 10px;">
                            <button class="btn" style="background: var(--accent-red); padding: 12px; width: 100%;" onclick="withdrawNitrogenFromModal()">Take</button>
                        </div>
                    </div>
                </div>
                
                <!-- Action Buttons -->
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px;">
                    <button class="btn" style="background: var(--accent-green); padding: 12px 10px; font-size: 0.9rem;" onclick="openAddButaneModal()"> Add Butane</button>
                    <button class="btn" style="background: var(--accent-green); padding: 12px 10px; font-size: 0.9rem;" onclick="openAddNitrogenModal()"> Add N</button>
                    <button class="btn" style="background: var(--accent-orange); padding: 12px 10px; font-size: 0.9rem;" onclick="openEditButaneModal()"> Edit Butane</button>
                    <button class="btn" style="background: var(--accent-orange); padding: 12px 10px; font-size: 0.9rem;" onclick="openEditNitrogenModal()"> Edit N</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Add Shipment Modal (Butane) -->
    <div id="addShipmentModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); z-index: 10002; overflow-y: auto;">
        <div style="max-width: 500px; margin: 100px auto; background: var(--bg-secondary); border-radius: 20px; padding: 0; box-shadow: 0 20px 60px rgba(16, 185, 129, 0.4);">
            <div style="background: linear-gradient(135deg, var(--accent-green), var(--accent-blue)); padding: 30px; border-radius: 20px 20px 0 0;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <h2 style="color: white; margin: 0; font-size: 1.8rem;"> Add Butane Shipment</h2>
                    <button onclick="closeAddButaneModal()" style="background: rgba(255,255,255,0.2); border: none; color: white; font-size: 2rem; cursor: pointer; padding: 5px 15px; border-radius: 10px;">&times;</button>
                </div>
            </div>
            <div style="padding: 30px;">
                <form onsubmit="event.preventDefault(); addButaneShipment();">
                    <div class="form-group">
                        <label>Butane Received (lbs)</label>
                        <input type="number" id="butaneShipmentAmount" step="0.1" min="0" placeholder="110" required autofocus style="font-size: 1.2rem; padding: 15px;">
                        <div class="help-text">Typically 110 lbs per tank</div>
                    </div>
                    <div class="form-group">
                        <label>Notes (Optional)</label>
                        <textarea id="butaneShipmentNotes" placeholder="Delivery info, vendor, etc..."></textarea>
                    </div>
                    <button type="submit" class="btn" style="background: var(--accent-green); width: 100%; font-size: 1.1rem;">
                         Add to Bulk Tank
                    </button>
                </form>
            </div>
        </div>
    </div>
    
    <!-- Edit Bulk Weight Modal (Butane) -->
    <div id="editBulkModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); z-index: 10002; overflow-y: auto;">
        <div style="max-width: 500px; margin: 100px auto; background: var(--bg-secondary); border-radius: 20px; padding: 0; box-shadow: 0 20px 60px rgba(245, 158, 11, 0.4);">
            <div style="background: linear-gradient(135deg, var(--accent-orange), var(--accent-red)); padding: 30px; border-radius: 20px 20px 0 0;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <h2 style="color: white; margin: 0; font-size: 1.8rem;"> Edit Butane Tank Weight</h2>
                    <button onclick="closeEditButaneModal()" style="background: rgba(255,255,255,0.2); border: none; color: white; font-size: 2rem; cursor: pointer; padding: 5px 15px; border-radius: 10px;">&times;</button>
                </div>
            </div>
            <div style="padding: 30px;">
                <div style="background: rgba(239, 68, 68, 0.1); padding: 15px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid var(--accent-red);">
                    <strong> Use with caution</strong>
                    <p style="margin: 5px 0 0 0; font-size: 0.9rem; color: var(--text-secondary);">Only use this to correct errors or set initial inventory</p>
                </div>
                <div style="text-align: center; margin-bottom: 20px;">
                    <div style="font-size: 1.6rem; font-weight: 700; color: ${statusColor};">Current Bulk Tank</div>
                    <div id="editButaneCurrentDisplay" style="font-size: 2rem; font-weight: 700; color: var(--accent-blue);">0 lbs</div>
                </div>
                <form onsubmit="event.preventDefault(); setButaneWeight();">
                    <div class="form-group">
                        <label>Set Bulk Tank To (lbs)</label>
                        <input type="number" id="butaneSetAmount" step="0.1" min="0" placeholder="Enter exact amount" required autofocus style="font-size: 1.2rem; padding: 15px;">
                    </div>
                    <div class="form-group">
                        <label>Reason for Change</label>
                        <textarea id="butaneSetNotes" placeholder="Why are you manually changing this?" required></textarea>
                    </div>
                    <button type="submit" class="btn" style="background: var(--accent-orange); width: 100%; font-size: 1.1rem;">
                         Update Bulk Tank
                    </button>
                </form>
            </div>
        </div>
    </div>
    
    <!-- Add Nitrogen Modal -->
    <div id="addNitrogenModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); z-index: 10002; overflow-y: auto;">
        <div style="max-width: 500px; margin: 100px auto; background: var(--bg-secondary); border-radius: 20px; padding: 0; box-shadow: 0 20px 60px rgba(147, 51, 234, 0.4);">
            <div style="background: linear-gradient(135deg, var(--accent-purple), var(--accent-blue)); padding: 30px; border-radius: 20px 20px 0 0;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <h2 style="color: white; margin: 0; font-size: 1.8rem;"> Add Nitrogen Tanks</h2>
                    <button onclick="closeAddNitrogenModal()" style="background: rgba(255,255,255,0.2); border: none; color: white; font-size: 2rem; cursor: pointer; padding: 5px 15px; border-radius: 10px;">&times;</button>
                </div>
            </div>
            <div style="padding: 30px;">
                <form onsubmit="event.preventDefault(); addNitrogenShipment();">
                    <div class="form-group">
                        <label>Nitrogen Tanks Received</label>
                        <input type="number" id="nitrogenShipmentAmount" step="0.5" min="0" placeholder="Number of tanks" required autofocus style="font-size: 1.2rem; padding: 15px;">
                        <div class="help-text">Full or partial tanks (e.g., 5, 2.5, 10)</div>
                    </div>
                    <div class="form-group">
                        <label>Notes (Optional)</label>
                        <textarea id="nitrogenShipmentNotes" placeholder="Delivery info, vendor, etc..."></textarea>
                    </div>
                    <button type="submit" class="btn" style="background: var(--accent-purple); width: 100%; font-size: 1.1rem;">
                         Add Tanks
                    </button>
                </form>
            </div>
        </div>
    </div>
    
    <!-- Edit Nitrogen Modal -->
    <div id="editNitrogenModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); z-index: 10002; overflow-y: auto;">
        <div style="max-width: 500px; margin: 100px auto; background: var(--bg-secondary); border-radius: 20px; padding: 0; box-shadow: 0 20px 60px rgba(245, 158, 11, 0.4);">
            <div style="background: linear-gradient(135deg, var(--accent-orange), var(--accent-red)); padding: 30px; border-radius: 20px 20px 0 0;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <h2 style="color: white; margin: 0; font-size: 1.8rem;"> Edit Nitrogen Inventory</h2>
                    <button onclick="closeEditNitrogenModal()" style="background: rgba(255,255,255,0.2); border: none; color: white; font-size: 2rem; cursor: pointer; padding: 5px 15px; border-radius: 10px;">&times;</button>
                </div>
            </div>
            <div style="padding: 30px;">
                <div style="background: rgba(239, 68, 68, 0.1); padding: 15px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid var(--accent-red);">
                    <strong> Use with caution</strong>
                    <p style="margin: 5px 0 0 0; font-size: 0.9rem; color: var(--text-secondary);">Only use this to correct errors or set initial inventory</p>
                </div>
                <div style="text-align: center; margin-bottom: 20px;">
                    <div style="font-size: 1.6rem; font-weight: 700; color: ${statusColor};">Current Nitrogen Tanks</div>
                    <div id="editNitrogenCurrentDisplay" style="font-size: 2rem; font-weight: 700; color: var(--accent-purple);">0 tanks</div>
                </div>
                <form onsubmit="event.preventDefault(); setNitrogenAmount();">
                    <div class="form-group">
                        <label>Set Nitrogen To (tanks)</label>
                        <input type="number" id="nitrogenSetAmount" step="0.5" min="0" placeholder="Enter exact amount" required autofocus style="font-size: 1.2rem; padding: 15px;">
                    </div>
                    <div class="form-group">
                        <label>Reason for Change</label>
                        <textarea id="nitrogenSetNotes" placeholder="Why are you manually changing this?" required></textarea>
                    </div>
                    <button type="submit" class="btn" style="background: var(--accent-orange); width: 100%; font-size: 1.1rem;">
                         Update Nitrogen Inventory
                    </button>
                </form>
            </div>
        </div>
    </div>

    <!-- Machine Run Log Modal -->
    <div id="machineLogModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); z-index: 10002; overflow-y: auto;">
        <div style="max-width: 1000px; margin: 30px auto; background: var(--bg-secondary); border-radius: 20px; padding: 0; box-shadow: 0 20px 60px rgba(0, 85, 255, 0.4);">
            <div style="background: linear-gradient(135deg, var(--accent-blue), var(--accent-purple)); padding: 30px; border-radius: 20px 20px 0 0;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <h2 style="color: white; margin: 0 0 5px 0; font-size: 1.8rem;">Machine Run Log</h2>
                        <p style="color: rgba(255,255,255,0.8); margin: 0; font-size: 0.9rem;">Cross-Contamination Tracking</p>
                    </div>
                    <button onclick="closeMachineLogModal()" style="background: rgba(255,255,255,0.2); border: none; color: white; font-size: 2rem; cursor: pointer; padding: 5px 15px; border-radius: 10px;">&times;</button>
                </div>
            </div>
            <div style="padding: 30px;">
                <!-- Filter Controls -->
                <div style="display: flex; gap: 15px; margin-bottom: 20px; flex-wrap: wrap;">
                    <select id="machineLogFilterMachine" onchange="filterMachineLog()" style="padding: 10px 15px; border-radius: 8px; border: 1px solid var(--border); background: var(--bg-tertiary); color: var(--text-primary);">
                        <option value="all">All Machines</option>
                        <option value="left">Machine 1 (Left)</option>
                        <option value="right">Machine 2 (Right)</option>
                    </select>
                    <select id="machineLogFilterDays" onchange="filterMachineLog()" style="padding: 10px 15px; border-radius: 8px; border: 1px solid var(--border); background: var(--bg-tertiary); color: var(--text-primary);">
                        <option value="7">Last 7 Days</option>
                        <option value="14">Last 14 Days</option>
                        <option value="30">Last 30 Days</option>
                        <option value="all">All Time</option>
                    </select>
                    <input type="text" id="machineLogSearch" placeholder="Search strain or batch..." oninput="filterMachineLog()" style="flex: 1; min-width: 200px; padding: 10px 15px; border-radius: 8px; border: 1px solid var(--border); background: var(--bg-tertiary); color: var(--text-primary);">
                </div>

                <!-- Log Table -->
                <div style="background: var(--bg-primary); border-radius: 12px; overflow: hidden; border: 1px solid var(--border);">
                    <div style="max-height: 500px; overflow-y: auto;">
                        <table id="machineLogTable" style="width: 100%; border-collapse: collapse; font-size: 0.85rem;">
                            <thead style="position: sticky; top: 0; background: var(--bg-tertiary); z-index: 1;">
                                <tr>
                                    <th style="padding: 12px 10px; text-align: left; color: var(--text-secondary); font-weight: 600; border-bottom: 2px solid var(--border);">Date/Time</th>
                                    <th style="padding: 12px 10px; text-align: left; color: var(--text-secondary); font-weight: 600; border-bottom: 2px solid var(--border);">Machine</th>
                                    <th style="padding: 12px 10px; text-align: left; color: var(--text-secondary); font-weight: 600; border-bottom: 2px solid var(--border);">Batch</th>
                                    <th style="padding: 12px 10px; text-align: left; color: var(--text-secondary); font-weight: 600; border-bottom: 2px solid var(--border);">Strain</th>
                                    <th style="padding: 12px 10px; text-align: center; color: var(--text-secondary); font-weight: 600; border-bottom: 2px solid var(--border);">Socks</th>
                                    <th style="padding: 12px 10px; text-align: left; color: var(--text-secondary); font-weight: 600; border-bottom: 2px solid var(--border);">Operator</th>
                                    <th style="padding: 12px 10px; text-align: left; color: var(--text-secondary); font-weight: 600; border-bottom: 2px solid var(--border);">Filter State</th>
                                </tr>
                            </thead>
                            <tbody id="machineLogBody">
                                <!-- Populated dynamically -->
                            </tbody>
                        </table>
                    </div>
                </div>

                <!-- Summary -->
                <div style="margin-top: 20px; padding: 15px; background: var(--bg-tertiary); border-radius: 10px; display: flex; justify-content: space-between; flex-wrap: wrap; gap: 15px;">
                    <div>
                        <span style="color: var(--text-secondary);">Total Runs: </span>
                        <strong id="machineLogTotalRuns" style="color: var(--accent-blue);">0</strong>
                    </div>
                    <div>
                        <span style="color: var(--text-secondary);">Total Socks: </span>
                        <strong id="machineLogTotalSocks" style="color: var(--accent-green);">0</strong>
                    </div>
                    <div>
                        <span style="color: var(--text-secondary);">Unique Strains: </span>
                        <strong id="machineLogUniqueStrains" style="color: var(--accent-purple);">0</strong>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <style>
        .personal-time-btn {
            padding: 10px 20px;
            background: var(--bg-secondary);
            border: 2px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .personal-time-btn:hover {
            border-color: var(--accent-purple);
            background: rgba(147, 51, 234, 0.1);
            transform: translateY(-2px);
        }
        
        .personal-time-btn.active {
            background: var(--accent-purple);
            border-color: var(--accent-purple);
            color: white;
        }

        .overdue-sort-btn.active {
            background: rgba(239, 68, 68, 0.2) !important;
            border-color: var(--accent-red) !important;
            color: var(--accent-red) !important;
        }

        .overdue-sort-btn:hover {
            background: rgba(239, 68, 68, 0.1);
            border-color: var(--accent-red);
            color: var(--accent-red);
        }
        
        
        .compliance-topic-btn {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-secondary);
            padding: 8px 15px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: all 0.2s ease;
        }
        .compliance-topic-btn:hover {
            background: rgba(16, 185, 129, 0.1);
            border-color: var(--accent-green);
            color: var(--accent-green);
        }
        .compliance-result {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 15px;
        }
        .compliance-result h4 {
            color: var(--accent-green);
            margin: 0 0 10px 0;
            font-size: 1.1rem;
        }
        .compliance-result p {
            color: var(--text-primary);
            margin: 0;
            line-height: 1.6;
        }
        .compliance-rule-num {
            background: rgba(16, 185, 129, 0.2);
            color: var(--accent-green);
            padding: 3px 10px;
            border-radius: 15px;
            font-size: 0.8rem;
            font-weight: 600;
            margin-right: 10px;
        }

        .stat-box {
            background: var(--bg-tertiary);
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            border: 2px solid var(--border);
            transition: all 0.3s ease;
        }
        
        .stat-box:hover {
            border-color: var(--accent-purple);
            transform: translateY(-2px);
        }
        
        .stat-number {
            font-size: 2.5rem;
            font-weight: 700;
            background: linear-gradient(135deg, var(--accent-purple), var(--accent-blue));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 5px;
        }
        
        .stat-label {
            color: var(--text-secondary);
            font-size: 0.9rem;
            font-weight: 600;
        }
        
        .record-box {
            background: var(--bg-secondary);
            padding: 15px;
            border-radius: 10px;
            border-left: 4px solid var(--accent-green);
        }
        
        #myStatsBtn:hover {
            transform: translateY(-2px);
            box-shadow: 0 0 20px rgba(191, 0, 255, 0.5), 0 0 40px rgba(191, 0, 255, 0.3), inset 0 0 15px rgba(191, 0, 255, 0.1);
        }

        /* Front of House Styles */
        .quick-tag-btn {
            background: transparent;
            border: 2px solid var(--accent-blue);
            color: var(--accent-blue);
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 0 8px rgba(0, 240, 255, 0.3), inset 0 0 6px rgba(0, 240, 255, 0.05);
        }
        .quick-tag-btn:hover {
            background: rgba(0, 240, 255, 0.15);
            border-color: var(--accent-blue);
            box-shadow: 0 0 15px rgba(0, 240, 255, 0.5), 0 0 30px rgba(0, 240, 255, 0.3), inset 0 0 10px rgba(0, 240, 255, 0.1);
        }
        .foh-batch-card {
            background: var(--bg-tertiary);
            border: 2px solid var(--border);
            border-radius: 12px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .foh-batch-card:hover {
            border-color: var(--accent-purple);
            transform: translateY(-2px);
        }
        .foh-post-card {
            background: var(--bg-tertiary);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .foh-post-status {
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 600;
        }
        .foh-post-status.published {
            background: rgba(57, 255, 20, 0.2);
            color: var(--accent-green);
        }
        .foh-post-status.draft {
            background: rgba(255, 107, 0, 0.2);
            color: var(--accent-orange);
        }
    </style>

    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <!-- PDF.js for COA parsing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <!-- Google Identity Services for Drive API -->
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <script src="https://apis.google.com/js/api.js" async defer></script>
    <!-- Time Clock Modal -->
    <div id="timeClockModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); z-index: 10001; overflow-y: auto;">
        <div style="max-width: 500px; margin: 50px auto; background: var(--bg-secondary); border-radius: 20px; padding: 0; box-shadow: 0 20px 60px rgba(57, 255, 20, 0.4);">
            <!-- Header -->
            <div style="background: linear-gradient(135deg, var(--accent-green), #00aa00); padding: 30px; border-radius: 20px 20px 0 0;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <h2 style="color: white; margin: 0 0 10px 0; font-size: 2rem;">
                            Time Clock
                        </h2>
                        <p style="color: rgba(255,255,255,0.9); margin: 0;" id="timeClockUserName">Welcome!</p>
                    </div>
                    <button onclick="closeTimeClockModal()" style="background: rgba(255,255,255,0.2); border: none; color: white; font-size: 2rem; cursor: pointer; padding: 5px 15px; border-radius: 10px; transition: all 0.3s ease;">&times;</button>
                </div>
            </div>

            <!-- Content -->
            <div style="padding: 30px;">
                <!-- Current Status -->
                <div id="clockStatusDisplay" style="background: var(--bg-tertiary); padding: 25px; border-radius: 15px; margin-bottom: 25px; text-align: center;">
                    <div style="font-size: 0.9rem; color: var(--text-secondary); margin-bottom: 5px;">Current Status</div>
                    <div id="clockStatusText" style="font-size: 2rem; font-weight: 700; color: var(--accent-red);">Clocked Out</div>
                    <div id="clockLastPunch" style="font-size: 0.9rem; color: var(--text-secondary); margin-top: 10px;">Last punch: --</div>
                </div>

                <!-- Current Time Display -->
                <div style="text-align: center; margin-bottom: 25px;">
                    <div id="currentTimeDisplay" style="font-family: 'Space Mono', monospace; font-size: 2.5rem; color: var(--accent-blue);"></div>
                    <div id="currentDateDisplay" style="font-size: 1rem; color: var(--text-secondary);"></div>
                </div>

                <!-- Clock In/Out Button -->
                <div style="text-align: center; margin-bottom: 30px;">
                    <button id="clockActionBtn" onclick="performClockAction()" style="width: 200px; height: 200px; border-radius: 50%; font-size: 1.5rem; font-weight: 700; cursor: pointer; transition: all 0.3s ease; border: 4px solid var(--accent-green); background: linear-gradient(135deg, var(--accent-green), #00aa00); color: white; box-shadow: 0 10px 40px rgba(57, 255, 20, 0.4);">
                        CLOCK IN
                    </button>
                </div>

                <!-- IP Status -->
                <div id="ipStatusDisplay" style="background: var(--bg-tertiary); padding: 15px; border-radius: 10px; margin-bottom: 20px; text-align: center; font-size: 0.85rem;">
                    <span style="color: var(--text-secondary);">IP Status: </span>
                    <span id="ipStatusText" style="color: var(--accent-orange);">Checking...</span>
                </div>

                <!-- Hours Summary -->
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                    <div style="background: var(--bg-tertiary); padding: 20px; border-radius: 12px; text-align: center;">
                        <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 5px;">Today's Hours</div>
                        <div id="todayHours" style="font-size: 1.8rem; font-weight: 700; color: var(--accent-blue);">0.00</div>
                    </div>
                    <div style="background: var(--bg-tertiary); padding: 20px; border-radius: 12px; text-align: center;">
                        <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 5px;">Pay Period Hours</div>
                        <div id="payPeriodHours" style="font-size: 1.8rem; font-weight: 700; color: var(--accent-purple);">0.00</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Timecards Admin Modal -->
    <div id="timecardsModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); z-index: 10001; overflow-y: auto;">
        <div style="max-width: 1200px; margin: 30px auto; background: var(--bg-secondary); border-radius: 20px; padding: 0; box-shadow: 0 20px 60px rgba(255, 107, 0, 0.4);">
            <!-- Header -->
            <div style="background: linear-gradient(135deg, var(--accent-orange), #cc5500); padding: 30px; border-radius: 20px 20px 0 0;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <h2 style="color: white; margin: 0 0 10px 0; font-size: 2rem;">
                            Employee Timecards
                        </h2>
                        <p style="color: rgba(255,255,255,0.9); margin: 0;">View and manage employee time records</p>
                    </div>
                    <button onclick="closeTimecardsModal()" style="background: rgba(255,255,255,0.2); border: none; color: white; font-size: 2rem; cursor: pointer; padding: 5px 15px; border-radius: 10px; transition: all 0.3s ease;">&times;</button>
                </div>
            </div>

            <!-- Content -->
            <div style="padding: 30px;">
                <!-- Currently Clocked In Section -->
                <div style="background: linear-gradient(135deg, rgba(57, 255, 20, 0.15), rgba(0, 200, 150, 0.15)); padding: 20px; border-radius: 15px; margin-bottom: 25px; border: 2px solid var(--accent-green);">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                        <h3 style="color: var(--accent-green); margin: 0; font-size: 1.3rem;">
                            Currently Clocked In
                        </h3>
                        <button onclick="renderCurrentlyClockedIn()" style="background: var(--bg-tertiary); border: 1px solid var(--border); padding: 8px 15px; border-radius: 6px; color: var(--text-secondary); cursor: pointer; font-size: 0.85rem;">
                            Refresh
                        </button>
                    </div>
                    <div id="currentlyClockedInContainer">
                        <div style="text-align: center; padding: 20px; color: var(--text-secondary);">
                            Loading...
                        </div>
                    </div>
                </div>

                <!-- Employee Selector -->
                <div style="display: flex; gap: 15px; margin-bottom: 25px; flex-wrap: wrap;">
                    <select id="timecardEmployeeSelect" onchange="loadEmployeeTimecard()" style="flex: 1; min-width: 200px; padding: 12px; background: var(--bg-tertiary); border: 2px solid var(--border); border-radius: 8px; color: var(--text-primary); font-size: 1rem;">
                        <option value="">Select Employee...</option>
                    </select>
                    <select id="timecardPayPeriodSelect" onchange="loadEmployeeTimecard()" style="flex: 1; min-width: 200px; padding: 12px; background: var(--bg-tertiary); border: 2px solid var(--border); border-radius: 8px; color: var(--text-primary); font-size: 1rem;">
                        <option value="current">Current Pay Period</option>
                        <option value="previous">Previous Pay Period</option>
                    </select>
                    <button onclick="printTimecard()" style="padding: 12px 24px; background: transparent; border: 2px solid var(--accent-blue); border-radius: 8px; color: var(--accent-blue); font-weight: 600; cursor: pointer; box-shadow: 0 0 15px rgba(0, 240, 255, 0.4), 0 0 30px rgba(0, 240, 255, 0.2);">
                        Print/Export
                    </button>
                    <button onclick="exportAllTimecards()" style="padding: 12px 24px; background: transparent; border: 2px solid var(--accent-green); border-radius: 8px; color: var(--accent-green); font-weight: 600; cursor: pointer; box-shadow: 0 0 15px rgba(57, 255, 20, 0.4), 0 0 30px rgba(57, 255, 20, 0.2);">
                         Export Summary
                    </button>
                    <button onclick="exportForQuickBooks()" style="padding: 12px 24px; background: transparent; border: 2px solid #2CA01C; border-radius: 8px; color: #2CA01C; font-weight: 600; cursor: pointer; box-shadow: 0 0 15px rgba(44, 160, 28, 0.4), 0 0 30px rgba(44, 160, 28, 0.2);">
                         Export for QuickBooks
                    </button>
                    <button onclick="openAddSickDayModal()" style="padding: 12px 24px; background: transparent; border: 2px solid var(--accent-orange); border-radius: 8px; color: var(--accent-orange); font-weight: 600; cursor: pointer; box-shadow: 0 0 15px rgba(255, 107, 0, 0.4), 0 0 30px rgba(255, 107, 0, 0.2);">
                         Add Sick Day
                    </button>
                </div>

                <!-- Pay Period Info -->
                <div id="timecardPeriodInfo" style="background: linear-gradient(135deg, rgba(147, 51, 234, 0.2), rgba(59, 130, 246, 0.2)); padding: 20px; border-radius: 12px; margin-bottom: 25px; text-align: center; border: 2px solid var(--accent-purple);">
                    <div style="font-size: 1.6rem; font-weight: 700; color: ${statusColor};">Pay Period</div>
                    <div id="timecardPeriodDates" style="font-size: 1.3rem; font-weight: 600; color: var(--accent-purple);">--</div>
                </div>

                <!-- Timecard Table -->
                <div style="background: var(--bg-primary); border-radius: 12px; overflow: hidden; border: 1px solid var(--border);">
                    <div style="max-height: 500px; overflow-y: auto;">
                        <table id="timecardTable" style="width: 100%; border-collapse: collapse; font-size: 0.95rem;">
                            <thead style="position: sticky; top: 0; background: var(--bg-tertiary); z-index: 1;">
                                <tr>
                                    <th style="padding: 15px 12px; text-align: left; color: var(--text-secondary); font-weight: 600; border-bottom: 2px solid var(--border);">Date</th>
                                    <th style="padding: 15px 12px; text-align: center; color: var(--text-secondary); font-weight: 600; border-bottom: 2px solid var(--border);">Clock In</th>
                                    <th style="padding: 15px 12px; text-align: center; color: var(--text-secondary); font-weight: 600; border-bottom: 2px solid var(--border);">Clock Out</th>
                                    <th style="padding: 15px 12px; text-align: right; color: var(--text-secondary); font-weight: 600; border-bottom: 2px solid var(--border);">Hours</th>
                                    <th style="padding: 15px 12px; text-align: right; color: var(--text-secondary); font-weight: 600; border-bottom: 2px solid var(--border);">Daily Total</th>
                                    <th style="padding: 15px 12px; text-align: center; color: var(--text-secondary); font-weight: 600; border-bottom: 2px solid var(--border);">Notes</th>
                                    <th style="padding: 15px 12px; text-align: center; color: var(--text-secondary); font-weight: 600; border-bottom: 2px solid var(--border);">Actions</th>
                                </tr>
                            </thead>
                            <tbody id="timecardTableBody">
                                <tr>
                                    <td colspan="7" style="padding: 40px; text-align: center; color: var(--text-secondary);">Select an employee to view their timecard</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>

                <!-- Summary Section -->
                <div id="timecardSummary" style="display: none; margin-top: 25px; background: linear-gradient(135deg, rgba(57, 255, 20, 0.1), rgba(0, 240, 255, 0.1)); padding: 25px; border-radius: 12px; border: 2px solid var(--accent-green);">
                    <h3 style="color: var(--accent-green); margin: 0 0 20px 0; text-align: center;">Pay Period Summary</h3>
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 20px;">
                        <div style="text-align: center;">
                            <div style="font-size: 0.85rem; color: var(--text-secondary);">Regular Hours</div>
                            <div id="summaryRegularHours" style="font-size: 1.8rem; font-weight: 700; color: var(--accent-blue);">0.00</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="font-size: 0.85rem; color: var(--text-secondary);">Overtime Hours</div>
                            <div id="summaryOvertimeHours" style="font-size: 1.8rem; font-weight: 700; color: var(--accent-orange);">0.00</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="font-size: 0.85rem; color: var(--text-secondary);">Total Hours</div>
                            <div id="summaryTotalHours" style="font-size: 1.8rem; font-weight: 700; color: var(--accent-green);">0.00</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="font-size: 0.85rem; color: var(--text-secondary);">Days Worked</div>
                            <div id="summaryDaysWorked" style="font-size: 1.8rem; font-weight: 700; color: var(--accent-purple);">0</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Deleted Batches (Trash) Modal -->
    <div id="trashModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); z-index: 10001; overflow-y: auto;">
        <div style="max-width: 900px; margin: 30px auto; background: var(--bg-secondary); border-radius: 20px; padding: 0; box-shadow: 0 20px 60px rgba(239, 68, 68, 0.4);">
            <!-- Header -->
            <div style="background: linear-gradient(135deg, #ef4444, #b91c1c); padding: 30px; border-radius: 20px 20px 0 0;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <h2 style="color: white; margin: 0 0 10px 0; font-size: 2rem;">
                             Deleted Batches
                        </h2>
                        <p style="color: rgba(255,255,255,0.9); margin: 0;">Batches that have been removed from production</p>
                    </div>
                    <button onclick="closeTrashModal()" style="background: rgba(255,255,255,0.2); border: none; color: white; font-size: 2rem; cursor: pointer; padding: 5px 15px; border-radius: 10px; transition: all 0.3s ease;">&times;</button>
                </div>
            </div>

            <!-- Content -->
            <div style="padding: 30px;">
                <div id="trashBatchesList">
                    <div style="text-align: center; padding: 40px; color: var(--text-secondary);">
                        Loading deleted batches...
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Delete Batch Confirmation Modal -->
    <div id="deleteBatchModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); z-index: 10006; overflow-y: auto;">
        <div style="max-width: 500px; margin: 80px auto; background: var(--bg-secondary); border-radius: 20px; padding: 30px; box-shadow: 0 20px 60px rgba(239, 68, 68, 0.4); border: 2px solid #ef4444;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 25px;">
                <h2 style="color: #ef4444; margin: 0;"> Delete Batch</h2>
                <button onclick="closeDeleteBatchModal()" style="background: none; border: none; color: var(--text-secondary); font-size: 1.5rem; cursor: pointer;"></button>
            </div>

            <div style="background: var(--bg-tertiary); padding: 15px; border-radius: 10px; margin-bottom: 20px;">
                <div style="font-size: 1.6rem; font-weight: 700; color: ${statusColor};">Batch to delete:</div>
                <div id="deleteBatchId" style="font-weight: 700; font-size: 1.3rem; color: #ef4444; margin-top: 5px;"></div>
                <div id="deleteBatchInfo" style="font-size: 0.9rem; color: var(--text-secondary); margin-top: 5px;"></div>
            </div>

            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 8px; color: var(--text-secondary); font-size: 0.9rem;">Reason for deletion (required)</label>
                <textarea id="deleteNoteInput" rows="3" placeholder="Why is this batch being deleted?" style="width: 100%; padding: 12px; background: var(--bg-tertiary); border: 2px solid var(--border); border-radius: 8px; color: var(--text-primary); font-size: 1rem; resize: vertical;"></textarea>
            </div>

            <div style="display: flex; gap: 10px;">
                <button onclick="closeDeleteBatchModal()" style="flex: 1; padding: 12px; background: var(--bg-tertiary); border: 1px solid var(--border); border-radius: 8px; color: var(--text-primary); cursor: pointer;">Cancel</button>
                <button onclick="confirmDeleteBatch()" style="flex: 1; padding: 12px; background: #ef4444; border: none; border-radius: 8px; color: white; font-weight: 600; cursor: pointer;">Delete Batch</button>
            </div>
        </div>
    </div>

    <!-- Edit Punch Time Modal -->
    <div id="editPunchModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); z-index: 10006; overflow-y: auto;">
        <div style="max-width: 500px; margin: 80px auto; background: var(--bg-secondary); border-radius: 20px; padding: 30px; box-shadow: 0 20px 60px rgba(255, 107, 0, 0.4); border: 2px solid var(--accent-orange);">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 25px;">
                <h2 style="color: var(--accent-orange); margin: 0;"> Edit Punch Time</h2>
                <button onclick="closeEditPunchModal()" style="background: none; border: none; color: var(--text-secondary); font-size: 1.5rem; cursor: pointer;"></button>
            </div>
            
            <div style="background: var(--bg-tertiary); padding: 15px; border-radius: 10px; margin-bottom: 20px;">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                    <div>
                        <div style="font-size: 0.8rem; color: var(--text-secondary);">Employee</div>
                        <div id="editPunchEmployee" style="font-weight: 600; color: var(--text-primary);"></div>
                    </div>
                    <div>
                        <div style="font-size: 0.8rem; color: var(--text-secondary);">Punch Type</div>
                        <div id="editPunchType" style="font-weight: 600;"></div>
                    </div>
                </div>
            </div>
            
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 8px; color: var(--text-secondary); font-size: 0.9rem;">Original Time</label>
                <div id="editPunchOriginal" style="padding: 12px; background: var(--bg-tertiary); border-radius: 8px; color: var(--text-primary);"></div>
            </div>
            
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 8px; color: var(--text-secondary); font-size: 0.9rem;">New Date & Time</label>
                <input type="datetime-local" id="editPunchNewTime" style="width: 100%; padding: 12px; background: var(--bg-tertiary); border: 2px solid var(--border); border-radius: 8px; color: var(--text-primary); font-size: 1rem;">
            </div>
            
            <div style="margin-bottom: 25px;">
                <label style="display: block; margin-bottom: 8px; color: var(--text-secondary); font-size: 0.9rem;">Reason for Adjustment <span style="color: var(--accent-red);">*</span></label>
                <textarea id="editPunchReason" rows="3" placeholder="Explain why this time needs to be adjusted..." style="width: 100%; padding: 12px; background: var(--bg-tertiary); border: 2px solid var(--border); border-radius: 8px; color: var(--text-primary); font-size: 1rem; resize: vertical;"></textarea>
            </div>
            
            <input type="hidden" id="editPunchId">
            
            <div style="display: flex; gap: 15px;">
                <button onclick="saveEditedPunch()" style="flex: 1; padding: 15px; background: var(--accent-green); border: none; border-radius: 10px; color: white; font-size: 1rem; font-weight: 600; cursor: pointer;"> Save Changes</button>
                <button onclick="closeEditPunchModal()" style="flex: 1; padding: 15px; background: var(--bg-tertiary); border: 2px solid var(--border); border-radius: 10px; color: var(--text-primary); font-size: 1rem; cursor: pointer;">Cancel</button>
            </div>
        </div>
    </div>
    <!-- Edit Shift Modal -->
    <div id="editShiftModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); z-index: 10006; overflow-y: auto;">
        <div style="max-width: 500px; margin: 80px auto; background: var(--bg-secondary); border-radius: 20px; padding: 30px; box-shadow: 0 20px 60px rgba(255, 107, 0, 0.4); border: 2px solid var(--accent-orange);">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 25px;">
                <h2 style="color: var(--accent-orange); margin: 0;"> Edit Shift</h2>
                <button onclick="closeEditShiftModal()" style="background: none; border: none; color: var(--text-secondary); font-size: 1.5rem; cursor: pointer;"></button>
            </div>
            <div style="background: var(--bg-tertiary); padding: 15px; border-radius: 10px; margin-bottom: 20px;">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                    <div>
                        <div style="font-size: 0.8rem; color: var(--text-secondary);">Employee</div>
                        <div id="editShiftEmployee" style="font-weight: 600; color: var(--text-primary);"></div>
                    </div>
                    <div>
                        <div style="font-size: 0.8rem; color: var(--text-secondary);">Date</div>
                        <div id="editShiftDate" style="font-weight: 600; color: var(--text-primary);"></div>
                    </div>
                </div>
            </div>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 20px;">
                <div>
                    <label style="display: block; margin-bottom: 8px; color: var(--accent-green); font-size: 0.9rem; font-weight: 600;">Clock In</label>
                    <input type="datetime-local" id="editShiftInTime" style="width: 100%; padding: 12px; background: var(--bg-tertiary); border: 2px solid var(--accent-green); border-radius: 8px; color: var(--text-primary); font-size: 1rem;">
                </div>
                <div>
                    <label style="display: block; margin-bottom: 8px; color: var(--accent-orange); font-size: 0.9rem; font-weight: 600;">Clock Out</label>
                    <input type="datetime-local" id="editShiftOutTime" style="width: 100%; padding: 12px; background: var(--bg-tertiary); border: 2px solid var(--accent-orange); border-radius: 8px; color: var(--text-primary); font-size: 1rem;">
                </div>
            </div>
            <div style="margin-bottom: 25px;">
                <label style="display: block; margin-bottom: 8px; color: var(--text-secondary); font-size: 0.9rem;">Reason for Adjustment <span style="color: var(--accent-red);">*</span></label>
                <textarea id="editShiftReason" rows="2" placeholder="e.g., Forgot to clock out, incorrect time entry" style="width: 100%; padding: 12px; background: var(--bg-tertiary); border: 2px solid var(--border); border-radius: 8px; color: var(--text-primary); font-size: 1rem; resize: vertical;"></textarea>
            </div>
            <input type="hidden" id="editShiftInPunchId">
            <input type="hidden" id="editShiftOutPunchId">
            <div style="display: flex; gap: 15px;">
                <button onclick="saveEditedShift()" style="flex: 1; padding: 15px; background: var(--accent-green); border: none; border-radius: 10px; color: white; font-size: 1rem; font-weight: 600; cursor: pointer;"> Save Changes</button>
                <button onclick="closeEditShiftModal()" style="flex: 1; padding: 15px; background: var(--bg-tertiary); border: 2px solid var(--border); border-radius: 10px; color: var(--text-primary); font-size: 1rem; cursor: pointer;">Cancel</button>
            </div>
        </div>
    </div>
    <!-- Add Sick Day Modal -->
    <div id="addSickDayModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); z-index: 10006; overflow-y: auto;">
        <div style="max-width: 500px; margin: 50px auto; background: var(--bg-secondary); border-radius: 15px; padding: 25px; border: 2px solid var(--accent-blue);">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h2 style="color: var(--accent-blue); margin: 0;"> Add Sick Day</h2>
                <button onclick="closeAddSickDayModal()" style="background: none; border: none; color: var(--text-secondary); font-size: 1.5rem; cursor: pointer;"></button>
            </div>
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 8px; color: var(--text-secondary); font-size: 0.9rem;">Employee</label>
                <select id="sickDayEmployee" style="width: 100%; padding: 12px; background: var(--bg-tertiary); border: 2px solid var(--border); border-radius: 8px; color: var(--text-primary); font-size: 1rem;">
                </select>
            </div>
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 8px; color: var(--text-secondary); font-size: 0.9rem;">Date</label>
                <input type="date" id="sickDayDate" style="width: 100%; padding: 12px; background: var(--bg-tertiary); border: 2px solid var(--border); border-radius: 8px; color: var(--text-primary); font-size: 1rem;">
            </div>
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 8px; color: var(--text-secondary); font-size: 0.9rem;">Hours (default 8)</label>
                <input type="number" id="sickDayHours" value="8" min="1" max="12" style="width: 100%; padding: 12px; background: var(--bg-tertiary); border: 2px solid var(--border); border-radius: 8px; color: var(--text-primary); font-size: 1rem;">
            </div>
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 8px; color: var(--text-secondary); font-size: 0.9rem;">Notes (optional)</label>
                <textarea id="sickDayNotes" rows="2" placeholder="e.g., Called in sick, Doctor appointment" style="width: 100%; padding: 12px; background: var(--bg-tertiary); border: 2px solid var(--border); border-radius: 8px; color: var(--text-primary); font-size: 1rem; resize: vertical;"></textarea>
            </div>
            <div style="display: flex; gap: 10px;">
                <button onclick="saveSickDay()" style="flex: 1; padding: 15px; background: var(--accent-blue); border: none; border-radius: 10px; color: white; font-size: 1rem; font-weight: 600; cursor: pointer;"> Add Sick Day</button>
                <button onclick="closeAddSickDayModal()" style="flex: 1; padding: 15px; background: var(--bg-tertiary); border: 2px solid var(--border); border-radius: 10px; color: var(--text-primary); font-size: 1rem; cursor: pointer;">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Add Clock Out Modal -->
    <div id="addClockOutModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); z-index: 10006; overflow-y: auto;">
        <div style="max-width: 500px; margin: 80px auto; background: var(--bg-secondary); border-radius: 20px; padding: 30px; box-shadow: 0 20px 60px rgba(255, 107, 0, 0.4); border: 2px solid var(--accent-orange);">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 25px;">
                <h2 style="color: var(--accent-orange); margin: 0;"> Add Clock Out</h2>
                <button onclick="closeAddClockOutModal()" style="background: none; border: none; color: var(--text-secondary); font-size: 1.5rem; cursor: pointer;"></button>
            </div>
            <div style="background: var(--bg-tertiary); padding: 15px; border-radius: 10px; margin-bottom: 20px;">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                    <div>
                        <div style="font-size: 0.8rem; color: var(--text-secondary);">Employee</div>
                        <div id="addClockOutEmployee" style="font-weight: 600; color: var(--text-primary);"></div>
                    </div>
                    <div>
                        <div style="font-size: 0.8rem; color: var(--text-secondary);">Clocked In At</div>
                        <div id="addClockOutClockInTime" style="font-weight: 600; color: var(--accent-green);"></div>
                    </div>
                </div>
            </div>
            <div style="margin-bottom: 20px;">
                <label style="display: block; margin-bottom: 8px; color: var(--text-secondary); font-size: 0.9rem;">Clock Out Time</label>
                <input type="datetime-local" id="addClockOutTime" style="width: 100%; padding: 12px; background: var(--bg-tertiary); border: 2px solid var(--border); border-radius: 8px; color: var(--text-primary); font-size: 1rem;">
            </div>
            <div style="margin-bottom: 25px;">
                <label style="display: block; margin-bottom: 8px; color: var(--text-secondary); font-size: 0.9rem;">Reason <span style="color: var(--accent-red);">*</span></label>
                <textarea id="addClockOutReason" rows="2" placeholder="e.g., Forgot to clock out" style="width: 100%; padding: 12px; background: var(--bg-tertiary); border: 2px solid var(--border); border-radius: 8px; color: var(--text-primary); font-size: 1rem; resize: vertical;"></textarea>
            </div>
            <input type="hidden" id="addClockOutClockInId">
            <div style="display: flex; gap: 15px;">
                <button onclick="saveAddClockOut()" style="flex: 1; padding: 15px; background: var(--accent-green); border: none; border-radius: 10px; color: white; font-size: 1rem; font-weight: 600; cursor: pointer;"> Add Clock Out</button>
                <button onclick="closeAddClockOutModal()" style="flex: 1; padding: 15px; background: var(--bg-tertiary); border: 2px solid var(--border); border-radius: 10px; color: var(--text-primary); font-size: 1rem; cursor: pointer;">Cancel</button>
            </div>
        </div>
    </div>
    <!-- Overtime Alert Modal -->
    <div id="overtimeAlertModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); z-index: 10005; overflow-y: auto;">
        <div style="max-width: 400px; margin: 100px auto; background: var(--bg-secondary); border-radius: 20px; padding: 0; box-shadow: 0 20px 60px rgba(255, 107, 0, 0.6); border: 3px solid var(--accent-orange);">
            <div style="background: linear-gradient(135deg, var(--accent-orange), var(--accent-red)); padding: 30px; border-radius: 17px 17px 0 0; text-align: center;">
                <div style="font-size: 4rem; margin-bottom: 10px;">!</div>
                <h2 style="color: white; margin: 0; font-size: 1.8rem;">Overtime Alert</h2>
            </div>
            <div style="padding: 30px; text-align: center;">
                <p id="overtimeAlertMessage" style="font-size: 1.2rem; color: var(--text-primary); margin-bottom: 25px;">You have exceeded normal hours.</p>
                <button onclick="closeOvertimeAlert()" style="padding: 15px 40px; background: var(--accent-orange); border: none; border-radius: 10px; color: white; font-size: 1.1rem; font-weight: 600; cursor: pointer;">
                    Acknowledge
                </button>
            </div>
        </div>
    </div>

    <!-- Sales Pipeline Modal -->
    <div id="salesPipelineModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); z-index: 10001; overflow-y: auto;">
        <div style="max-width: 800px; margin: 50px auto; background: var(--bg-secondary); border-radius: 20px; padding: 0; box-shadow: 0 20px 60px rgba(16, 185, 129, 0.4);">
            <!-- Header -->
            <div style="background: linear-gradient(135deg, #10B981, #3B82F6); padding: 25px 30px; border-radius: 20px 20px 0 0;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <h2 style="color: white; margin: 0; font-size: 1.5rem;">Pipeline</h2>
                    <button onclick="closeSalesPipelineModal()" style="background: rgba(255,255,255,0.2); border: none; color: white; font-size: 1.5rem; cursor: pointer; padding: 5px 12px; border-radius: 8px;">&times;</button>
                </div>
            </div>

            <!-- Content -->
            <div style="padding: 30px;">
                <!-- Product Category Grid -->
                <div id="pipelineCategoryGrid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 15px;">
                    <!-- Populated dynamically -->
                </div>
            </div>
        </div>
    </div>

    <!-- Pipeline Strains Popup -->
    <div id="pipelineStrainsPopup" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); z-index: 10002; overflow-y: auto;">
        <div style="max-width: 500px; margin: 80px auto; background: var(--bg-secondary); border-radius: 16px; padding: 0; box-shadow: 0 20px 60px rgba(0,0,0,0.5);">
            <div style="background: var(--bg-tertiary); padding: 20px 25px; border-radius: 16px 16px 0 0; display: flex; justify-content: space-between; align-items: center;">
                <h3 id="pipelinePopupTitle" style="margin: 0; color: var(--text-primary); font-size: 1.2rem;">Strains</h3>
                <button onclick="closePipelineStrainsPopup()" style="background: none; border: none; color: var(--text-secondary); font-size: 1.5rem; cursor: pointer;">&times;</button>
            </div>
            <div id="pipelinePopupContent" style="padding: 20px 25px; max-height: 400px; overflow-y: auto;">
                <!-- Populated dynamically -->
            </div>
        </div>
    </div>

    <!-- Drop Calendar Modal -->
    <div id="dropCalendarModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); z-index: 10001; overflow-y: auto;">
        <div style="max-width: 900px; margin: 50px auto; background: var(--bg-secondary); border-radius: 20px; padding: 0; box-shadow: 0 20px 60px rgba(16, 185, 129, 0.4);">
            <!-- Header -->
            <div style="background: linear-gradient(135deg, #10B981, #059669); padding: 25px 30px; border-radius: 20px 20px 0 0;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <h2 style="color: white; margin: 0; font-size: 1.5rem;">Drop Calendar</h2>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <button onclick="loadDropCalendar()" style="background: rgba(255,255,255,0.2); border: none; color: white; padding: 8px 16px; border-radius: 8px; cursor: pointer; font-weight: 600;">Refresh</button>
                        <button onclick="closeDropCalendarModal()" style="background: rgba(255,255,255,0.2); border: none; color: white; font-size: 1.5rem; cursor: pointer; padding: 5px 12px; border-radius: 8px;">&times;</button>
                    </div>
                </div>
                <p style="color: rgba(255,255,255,0.8); margin: 10px 0 0 0; font-size: 0.9rem;">Customer deliveries from LeafLink</p>
            </div>

            <!-- Content -->
            <div style="padding: 30px;">
                <!-- Calendar Stats -->
                <div id="dropCalendarStats" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px; margin-bottom: 20px;">
                    <div style="background: var(--bg-primary); padding: 15px; border-radius: 10px; text-align: center;">
                        <div style="font-size: 2rem; font-weight: 700; color: var(--accent-blue);" id="statTotalDrops">--</div>
                        <div style="color: var(--text-secondary); font-size: 0.85rem;">Total Drops</div>
                    </div>
                    <div style="background: var(--bg-primary); padding: 15px; border-radius: 10px; text-align: center;">
                        <div style="font-size: 2rem; font-weight: 700; color: var(--accent-green);" id="statUniqueCustomers">--</div>
                        <div style="color: var(--text-secondary); font-size: 0.85rem;">Customers</div>
                    </div>
                    <div style="background: var(--bg-primary); padding: 15px; border-radius: 10px; text-align: center;">
                        <div style="font-size: 2rem; font-weight: 700; color: var(--accent-purple);" id="statThisWeek">--</div>
                        <div style="color: var(--text-secondary); font-size: 0.85rem;">This Week</div>
                    </div>
                    <div style="background: var(--bg-primary); padding: 15px; border-radius: 10px; text-align: center;">
                        <div style="font-size: 2rem; font-weight: 700; color: var(--accent-orange);" id="statTotalProducts">--</div>
                        <div style="color: var(--text-secondary); font-size: 0.85rem;">Products Moved</div>
                    </div>
                </div>

                <!-- Calendar View Toggle -->
                <div style="display: flex; gap: 10px; margin-bottom: 20px;">
                    <button onclick="setCalendarView('calendar')" id="viewCalendarBtn" class="btn" style="background: var(--accent-blue); padding: 8px 16px;">Calendar</button>
                    <button onclick="setCalendarView('list')" id="viewListBtn" class="btn" style="background: var(--bg-tertiary); padding: 8px 16px;">Customer List</button>
                    <button onclick="setCalendarView('frequency')" id="viewFreqBtn" class="btn" style="background: var(--bg-tertiary); padding: 8px 16px;">Frequency</button>
                </div>

                <!-- Calendar Content -->
                <div id="dropCalendarContent" style="background: var(--bg-primary); border-radius: 12px; padding: 20px; min-height: 300px;">
                    <div style="text-align: center; padding: 60px; color: var(--text-secondary);">
                        <div style="font-size: 3rem; margin-bottom: 10px;"></div>
                        Click "Refresh" to load drop data from LeafLink
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Blog Post View Modal -->
    <div id="blogPostViewModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); z-index: 10001; overflow-y: auto;">
        <div style="max-width: 800px; margin: 50px auto; background: var(--bg-secondary); border-radius: 20px; padding: 0; box-shadow: 0 20px 60px rgba(59, 130, 246, 0.4);">
            <!-- Header -->
            <div style="background: linear-gradient(135deg, var(--accent-blue), var(--accent-purple)); padding: 30px; border-radius: 20px 20px 0 0;">
                <div style="display: flex; justify-content: space-between; align-items: flex-start;">
                    <div style="flex: 1;">
                        <h2 id="blogPostViewTitle" style="color: white; margin: 0 0 10px 0; font-size: 1.8rem;"></h2>
                        <p id="blogPostViewMeta" style="color: rgba(255,255,255,0.8); margin: 0; font-size: 0.9rem;"></p>
                    </div>
                    <button onclick="closeBlogPostView()" style="background: rgba(255,255,255,0.2); border: none; color: white; font-size: 2rem; cursor: pointer; padding: 5px 15px; border-radius: 10px; transition: all 0.3s ease;">&times;</button>
                </div>
            </div>
            <!-- Content -->
            <div style="padding: 30px;">
                <div id="blogPostViewContent" style="color: var(--text-primary); line-height: 1.8; font-size: 1.1rem; white-space: pre-wrap;"></div>
            </div>
        </div>
    </div>

    <script>
        // Role configuration - loaded from database on init
        // Demo user is hardcoded as fallback, all others from wm_employees table
        let ROLES = {
            demo: {
                name: 'Demo User',
                displayName: 'Demo User',
                pin: '0000',
                tabs: ['dashboard', 'intake', 'extraction', 'finishing', 'packaging', 'testing', 'labeling', 'analytics', 'performance', 'frontofhouse', 'sales'],
                access: ['dashboard', 'intake', 'extraction', 'finishing', 'packaging', 'testing', 'labeling', 'analytics', 'performance', 'frontofhouse', 'sales'],
                readOnly: true,
                salary: true,
                isDemo: true
            }
        };

        // Load employees from database and populate ROLES object
        async function loadEmployees() {
            try {
                const { data, error } = await supabaseClient
                    .from('wm_employees')
                    .select('*')
                    .eq('is_active', true);

                if (error) {
                    console.error('Error loading employees:', error);
                    return;
                }

                // Convert database rows to ROLES format
                data.forEach(emp => {
                    const key = emp.name.toLowerCase().replace(/[^a-z]/g, '');
                    ROLES[key] = {
                        id: emp.id,
                        name: emp.name,
                        displayName: emp.is_admin ? emp.name + ' (Admin)' : emp.name,
                        pin: emp.pin,
                        tabs: emp.stations || [],
                        access: emp.stations || [],
                        readOnly: emp.read_only || false,
                        salary: emp.is_salary || false,
                        isAdmin: emp.is_admin || false,
                        canEditBatches: emp.can_edit_batches || emp.is_admin || false
                    };
                });

                console.log('Loaded ' + data.length + ' employees from database');
            } catch (err) {
                console.error('Failed to load employees:', err);
            }
        }

        // ==================== DEMO MODE ====================
        // Demo mode (PIN: 0000) provides realistic fake data for client demonstrations
        //
        // Demo Data Components:
        // 1. generateDemoBatches() - Fake production batches with realistic weights, strains, and test results
        // 2. generateDemoLeafLinkOrders() - Fake sales orders from LeafLink
        // 3. generateDemoBlogPosts() - Fake blog posts for Front of House section
        // 4. demoFOHPartners - Fake partner/grower database for auto-tagging
        //
        // Features:
        // - All company names and partners are clearly fake (use "example.com" domains)
        // - Demo banner displayed prominently at top of app
        // - Publishing/editing disabled with helpful alerts
        // - Data persists only in memory (no database writes)
        // - Realistic enough for professional client demos
        // ====================================================

        function isDemoMode() {
            return currentRole && currentRole.isDemo === true;
        }

        // Block database writes in demo mode - returns true if blocked, false if allowed
        function blockDemoWrite(actionName = 'This action') {
            if (isDemoMode() || DEMO_MODE) {
                alert(` DEMO MODE\n\n${actionName} is disabled in demo mode.\n\nNo changes will be saved to the database.`);
                return true; // Blocked
            }
            return false; // Allowed
        }

        function hidePINsForDemo() {
            if (!isDemoMode()) return;

            // Hide PINs in performance filter dropdown
            const performanceFilter = document.getElementById('performanceFilter');
            if (performanceFilter) {
                Array.from(performanceFilter.options).forEach(option => {
                    option.text = option.text.replace(/ - PIN: \d+/, '');
                });
            }

            // Hide any other PIN displays in the UI
            document.querySelectorAll('[data-pin]').forEach(el => {
                el.textContent = el.textContent.replace(/PIN: \d+/, 'PIN: ****');
            });

            // Add demo banner
            const header = document.querySelector('.header');
            if (header && !document.querySelector('.demo-banner')) {
                const demoBanner = document.createElement('div');
                demoBanner.className = 'demo-banner';
                demoBanner.style.cssText = 'background: linear-gradient(135deg, #ff6b00, #ff0055); color: white; padding: 10px; text-align: center; font-weight: 600; border-radius: 8px; margin-bottom: 15px;';
                demoBanner.innerHTML = ' DEMO MODE - All data is fake for demonstration purposes';
                header.after(demoBanner);
            }
        }

        // ==================== EMPLOYEE MANAGEMENT ====================

        function openEmployeeManagement() {
            document.getElementById('employeeManagementModal').style.display = 'block';
            renderEmployeeList();
        }

        function closeEmployeeManagement() {
            document.getElementById('employeeManagementModal').style.display = 'none';
        }

        async function renderEmployeeList() {
            const container = document.getElementById('employeeListContent');
            container.innerHTML = 'Loading...';

            try {
                const { data, error } = await supabaseClient
                    .from('wm_employees')
                    .select('*')
                    .eq('is_active', true)
                    .order('name');

                if (error) throw error;

                if (data.length === 0) {
                    container.innerHTML = '<p style="color: var(--text-secondary);">No employees found.</p>';
                    return;
                }

                container.innerHTML = data.map(emp => `
                    <div style="background: var(--bg-tertiary); border-radius: 12px; padding: 15px; margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <div style="font-size: 1.1rem; font-weight: 600; color: var(--text-primary);">
                                ${emp.name} ${emp.is_admin ? '<span style="color: var(--accent-purple); font-size: 0.85rem;">(Admin)</span>' : ''}
                            </div>
                            <div style="color: var(--text-secondary); font-size: 0.9rem; margin-top: 4px;">
                                PIN: ${emp.pin} | ${(emp.stations || []).length} stations
                                ${emp.is_salary ? ' | Salary' : ''}
                                ${emp.read_only ? ' | Read Only' : ''}
                            </div>
                        </div>
                        <button onclick="openEditEmployee('${emp.id}')" style="background: var(--accent-blue); color: white; border: none; padding: 8px 16px; border-radius: 6px; cursor: pointer;">Edit</button>
                    </div>
                `).join('');
            } catch (err) {
                console.error('Error loading employees:', err);
                container.innerHTML = '<p style="color: var(--accent-red);">Error loading employees.</p>';
            }
        }

        function openAddEmployee() {
            document.getElementById('employeeFormTitle').textContent = 'Add Employee';
            document.getElementById('employeeEditId').value = '';
            document.getElementById('employeeName').value = '';
            document.getElementById('employeePIN').value = '';
            document.getElementById('employeeIsAdmin').checked = false;
            document.getElementById('employeeIsSalary').checked = false;
            document.getElementById('employeeReadOnly').checked = false;
            document.getElementById('employeeCanEditBatches').checked = false;
            document.querySelectorAll('.station-checkbox').forEach(cb => cb.checked = false);
            document.getElementById('deactivateEmployeeBtn').style.display = 'none';
            document.getElementById('employeeFormModal').style.display = 'block';
        }

        async function openEditEmployee(id) {
            document.getElementById('employeeFormTitle').textContent = 'Edit Employee';
            document.getElementById('employeeEditId').value = id;
            document.getElementById('deactivateEmployeeBtn').style.display = 'block';

            try {
                const { data, error } = await supabaseClient
                    .from('wm_employees')
                    .select('*')
                    .eq('id', id)
                    .single();

                if (error) throw error;

                document.getElementById('employeeName').value = data.name || '';
                document.getElementById('employeePIN').value = data.pin || '';
                document.getElementById('employeeIsAdmin').checked = data.is_admin || false;
                document.getElementById('employeeIsSalary').checked = data.is_salary || false;
                document.getElementById('employeeReadOnly').checked = data.read_only || false;
                document.getElementById('employeeCanEditBatches').checked = data.can_edit_batches || false;

                document.querySelectorAll('.station-checkbox').forEach(cb => {
                    cb.checked = (data.stations || []).includes(cb.value);
                });

                document.getElementById('employeeFormModal').style.display = 'block';
            } catch (err) {
                console.error('Error loading employee:', err);
                alert('Error loading employee data');
            }
        }

        function closeEmployeeForm() {
            document.getElementById('employeeFormModal').style.display = 'none';
        }

        async function saveEmployee() {
            if (blockDemoWrite('Managing employees')) return;

            const id = document.getElementById('employeeEditId').value;
            const name = document.getElementById('employeeName').value.trim();
            const pin = document.getElementById('employeePIN').value.trim();
            const isAdmin = document.getElementById('employeeIsAdmin').checked;
            const isSalary = document.getElementById('employeeIsSalary').checked;
            const readOnly = document.getElementById('employeeReadOnly').checked;
            const canEditBatches = document.getElementById('employeeCanEditBatches').checked;
            const stations = Array.from(document.querySelectorAll('.station-checkbox:checked')).map(cb => cb.value);

            if (!name) {
                alert('Please enter a name');
                return;
            }
            if (!pin || pin.length !== 4 || !/^\d{4}$/.test(pin)) {
                alert('Please enter a 4-digit PIN');
                return;
            }
            if (stations.length === 0) {
                alert('Please select at least one station');
                return;
            }

            const employeeData = {
                name,
                pin,
                is_admin: isAdmin,
                is_salary: isSalary,
                read_only: readOnly,
                can_edit_batches: canEditBatches,
                stations,
                updated_at: new Date().toISOString()
            };

            try {
                let result;
                if (id) {
                    // Update existing
                    result = await supabaseClient
                        .from('wm_employees')
                        .update(employeeData)
                        .eq('id', id);
                } else {
                    // Insert new
                    employeeData.is_active = true;
                    employeeData.created_at = new Date().toISOString();
                    result = await supabaseClient
                        .from('wm_employees')
                        .insert(employeeData);
                }

                if (result.error) throw result.error;

                // Reload employees into ROLES
                await loadEmployees();

                closeEmployeeForm();
                renderEmployeeList();
                alert(id ? 'Employee updated!' : 'Employee added!');
            } catch (err) {
                console.error('Error saving employee:', err);
                alert('Error saving employee: ' + err.message);
            }
        }

        async function deactivateEmployee() {
            const id = document.getElementById('employeeEditId').value;
            const name = document.getElementById('employeeName').value;

            if (!confirm('Are you sure you want to deactivate ' + name + '? They will no longer be able to log in.')) {
                return;
            }

            try {
                const { error } = await supabaseClient
                    .from('wm_employees')
                    .update({ is_active: false, updated_at: new Date().toISOString() })
                    .eq('id', id);

                if (error) throw error;

                // Reload employees into ROLES
                await loadEmployees();

                closeEmployeeForm();
                renderEmployeeList();
                alert('Employee deactivated');
            } catch (err) {
                console.error('Error deactivating employee:', err);
                alert('Error deactivating employee: ' + err.message);
            }
        }

        // ==================== COSTING FUNCTIONS ====================
        let costConfig = {};
        let targetMargins = {};

        // Default cost configuration
        const defaultCostConfig = {
            // Consumables
            butane_per_lb: { value: 3.50, unit: 'lb', label: 'Butane (per lb)' },
            nitrogen_per_tank: { value: 45.00, unit: 'tank', label: 'Nitrogen (per tank)' },
            silica_per_gram: { value: 0.05, unit: 'gram', label: 'Silica (per gram)' },
            clay_per_gram: { value: 0.03, unit: 'gram', label: 'Clay (per gram)' },
            jar_1g: { value: 0.25, unit: 'each', label: '1g Jar' },
            jar_4g: { value: 0.40, unit: 'each', label: '4g Jar' },
            lid: { value: 0.10, unit: 'each', label: 'Lid' },
            label: { value: 0.05, unit: 'each', label: 'Label' },
            cart_hardware: { value: 2.50, unit: 'each', label: 'Cart Hardware' },
            aio_hardware: { value: 5.00, unit: 'each', label: 'AIO Hardware' },
            // Overhead
            rent_monthly: { value: 0, unit: 'month', label: 'Rent' },
            utilities_monthly: { value: 0, unit: 'month', label: 'Utilities' },
            equipment_monthly: { value: 0, unit: 'month', label: 'Equipment/Depreciation' },
            insurance_monthly: { value: 0, unit: 'month', label: 'Insurance' }
        };

        function showCostingSection(section) {
            // Update subtab buttons
            document.querySelectorAll('.costing-subtab').forEach(btn => {
                btn.style.background = 'var(--bg-tertiary)';
                btn.style.border = '1px solid var(--border-color)';
                btn.style.color = 'var(--text-primary)';
            });
            const activeBtn = document.getElementById('costingTab' + section.charAt(0).toUpperCase() + section.slice(1));
            if (activeBtn) {
                activeBtn.style.background = '#10B981';
                activeBtn.style.border = 'none';
                activeBtn.style.color = 'white';
            }

            // Show/hide sections
            document.querySelectorAll('.costing-section').forEach(s => s.style.display = 'none');
            const sectionEl = document.getElementById('costing' + section.charAt(0).toUpperCase() + section.slice(1) + 'Section');
            if (sectionEl) sectionEl.style.display = 'block';

            // Load section-specific data
            if (section === 'labor') loadLaborRates();
            if (section === 'margins') loadTargetMargins();
            if (section === 'analysis') updateProfitabilityAnalysis();
        }

        async function loadCostingData() {
            if (!supabaseClient) return;

            // Ensure batches are loaded (needed for analysis and margins)
            if (!batches || batches.length === 0) {
                await loadBatches();
            }

            // Calculate production averages from last 3 months
            calculateProductionAverages();

            // Get business ID (use first business if 'all' selected)
            let bizId = currentBusinessId;
            if (bizId === 'all' && businessesList.length > 0) {
                bizId = businessesList[0].id;
            }

            try {
                // Load cost config
                const { data: configData, error: configError } = await supabaseClient
                    .from('wm_cost_config')
                    .select('*')
                    .eq('business_id', bizId);

                if (!configError && configData) {
                    configData.forEach(c => {
                        costConfig[c.config_key] = c.config_value;
                    });
                }

                // Merge with defaults
                Object.keys(defaultCostConfig).forEach(key => {
                    if (costConfig[key] === undefined) {
                        costConfig[key] = defaultCostConfig[key].value;
                    }
                });

                renderCostConfigForm();
                updateOverheadPerBatch();

            } catch (err) {
                console.error('Error loading cost config:', err);
            }
        }

        function renderCostConfigForm() {
            const consumablesGrid = document.getElementById('consumablesCostGrid');
            const overheadGrid = document.getElementById('overheadCostGrid');
            if (!consumablesGrid || !overheadGrid) return;

            // Consumables
            const consumableKeys = ['butane_per_lb', 'nitrogen_per_tank', 'silica_per_gram', 'clay_per_gram', 'jar_1g', 'jar_4g', 'lid', 'label', 'cart_hardware', 'aio_hardware'];
            consumablesGrid.innerHTML = consumableKeys.map(key => {
                const def = defaultCostConfig[key];
                const val = costConfig[key] !== undefined ? costConfig[key] : def.value;
                return `
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <label style="color: var(--text-primary);">${def.label}</label>
                        <div style="display: flex; align-items: center; gap: 5px;">
                            <span style="color: var(--text-secondary);">$</span>
                            <input type="number" step="0.01" value="${val}" data-cost-key="${key}" class="cost-config-input" style="width: 80px; background: var(--bg-tertiary); border: 1px solid var(--border-color); color: var(--text-primary); padding: 5px 10px; border-radius: 4px; text-align: right;">
                            <span style="color: var(--text-secondary); font-size: 0.8rem;">/${def.unit}</span>
                        </div>
                    </div>
                `;
            }).join('');

            // Overhead
            const overheadKeys = ['rent_monthly', 'utilities_monthly', 'equipment_monthly', 'insurance_monthly'];
            overheadGrid.innerHTML = overheadKeys.map(key => {
                const def = defaultCostConfig[key];
                const val = costConfig[key] !== undefined ? costConfig[key] : def.value;
                return `
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <label style="color: var(--text-primary);">${def.label}</label>
                        <div style="display: flex; align-items: center; gap: 5px;">
                            <span style="color: var(--text-secondary);">$</span>
                            <input type="number" step="0.01" value="${val}" data-cost-key="${key}" class="cost-config-input overhead-input" style="width: 100px; background: var(--bg-tertiary); border: 1px solid var(--border-color); color: var(--text-primary); padding: 5px 10px; border-radius: 4px; text-align: right;" onchange="updateOverheadPerBatch()">
                        </div>
                    </div>
                `;
            }).join('');
        }

        function updateOverheadPerBatch() {
            const overheadInputs = document.querySelectorAll('.overhead-input');
            let totalOverhead = 0;
            overheadInputs.forEach(input => {
                totalOverhead += parseFloat(input.value) || 0;
            });

            const avgBatches = parseFloat(document.getElementById('avgBatchesPerMonth')?.value) || 30;
            const perBatch = totalOverhead / avgBatches;

            const totalEl = document.getElementById('totalMonthlyOverhead');
            const perBatchEl = document.getElementById('overheadPerBatch');
            if (totalEl) totalEl.textContent = '$' + totalOverhead.toFixed(2);
            if (perBatchEl) perBatchEl.textContent = '$' + perBatch.toFixed(2);
        }

        async function saveCostConfig() {
            if (!supabaseClient) {
                alert('Database not connected');
                return;
            }

            // Get business ID
            let bizId = currentBusinessId;
            if (bizId === 'all' && businessesList.length > 0) {
                bizId = businessesList[0].id;
            }

            try {
                const inputs = document.querySelectorAll('.cost-config-input');
                const updates = [];

                inputs.forEach(input => {
                    const key = input.dataset.costKey;
                    const value = parseFloat(input.value) || 0;
                    costConfig[key] = value;

                    updates.push({
                        business_id: bizId,
                        config_type: key.includes('monthly') ? 'overhead' : 'consumable',
                        config_key: key,
                        config_value: value,
                        unit: defaultCostConfig[key]?.unit || 'each'
                    });
                });

                // Upsert all config values
                const { error } = await supabaseClient
                    .from('wm_cost_config')
                    .upsert(updates, { onConflict: 'business_id,config_type,config_key' });

                if (error) throw error;

                alert('Cost configuration saved!');
            } catch (err) {
                console.error('Error saving cost config:', err);
                alert('Error saving: ' + err.message);
            }
        }

        async function loadLaborRates() {
            if (!supabaseClient) return;

            const grid = document.getElementById('laborRatesGrid');
            if (!grid) return;

            try {
                // Load employees (no business filter - employees are global)
                const { data: employees, error } = await supabaseClient
                    .from('wm_employees')
                    .select('id, name, hourly_rate, annual_salary, is_salary, is_active')
                    .eq('is_active', true)
                    .order('name');

                if (error) throw error;

                if (!employees || employees.length === 0) {
                    grid.innerHTML = '<p style="color: var(--text-secondary);">No employees found. Add employees in the login screen.</p>';
                    return;
                }

                grid.innerHTML = employees.map(emp => {
                    const isSalary = emp.is_salary || false;
                    const effectiveHourly = isSalary && emp.annual_salary ? (emp.annual_salary / 2080).toFixed(2) : (emp.hourly_rate || 0);

                    if (isSalary) {
                        return `
                            <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px; background: var(--bg-tertiary); border-radius: 8px; border-left: 3px solid var(--accent-purple);">
                                <div>
                                    <span style="color: var(--text-primary); font-weight: 500;">${emp.name}</span>
                                    <span style="color: var(--accent-purple); font-size: 0.75rem; margin-left: 8px;">SALARY</span>
                                </div>
                                <div style="display: flex; align-items: center; gap: 10px;">
                                    <div style="display: flex; align-items: center; gap: 5px;">
                                        <span style="color: var(--text-secondary);">$</span>
                                        <input type="number" step="1000" value="${emp.annual_salary || 0}" data-employee-id="${emp.id}" data-is-salary="true" class="labor-rate-input" style="width: 100px; background: var(--bg-primary); border: 1px solid var(--border-color); color: var(--text-primary); padding: 8px 12px; border-radius: 4px; text-align: right;" onchange="updateEffectiveHourly(this)">
                                        <span style="color: var(--text-secondary);">/yr</span>
                                    </div>
                                    <span style="color: var(--text-secondary); font-size: 0.8rem;"> $<span class="effective-hourly">${effectiveHourly}</span>/hr</span>
                                </div>
                            </div>
                        `;
                    } else {
                        return `
                            <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px; background: var(--bg-tertiary); border-radius: 8px;">
                                <div>
                                    <span style="color: var(--text-primary); font-weight: 500;">${emp.name}</span>
                                    <span style="color: var(--accent-green); font-size: 0.75rem; margin-left: 8px;">HOURLY</span>
                                </div>
                                <div style="display: flex; align-items: center; gap: 5px;">
                                    <span style="color: var(--text-secondary);">$</span>
                                    <input type="number" step="0.50" value="${emp.hourly_rate || 0}" data-employee-id="${emp.id}" data-is-salary="false" class="labor-rate-input" style="width: 80px; background: var(--bg-primary); border: 1px solid var(--border-color); color: var(--text-primary); padding: 8px 12px; border-radius: 4px; text-align: right;">
                                    <span style="color: var(--text-secondary);">/hr</span>
                                </div>
                            </div>
                        `;
                    }
                }).join('');

            } catch (err) {
                console.error('Error loading labor rates:', err);
                grid.innerHTML = '<p style="color: var(--accent-red);">Error loading employees</p>';
            }
        }

        function updateEffectiveHourly(input) {
            const annualSalary = parseFloat(input.value) || 0;
            const effectiveHourly = (annualSalary / 2080).toFixed(2); // 2080 = 40hrs * 52 weeks
            const span = input.closest('div').parentElement.querySelector('.effective-hourly');
            if (span) span.textContent = effectiveHourly;
        }

        async function saveLaborRates() {
            if (!supabaseClient) {
                alert('Database not connected');
                return;
            }

            try {
                const inputs = document.querySelectorAll('.labor-rate-input');
                let savedCount = 0;

                for (const input of inputs) {
                    const employeeId = input.dataset.employeeId;
                    const isSalary = input.dataset.isSalary === 'true';
                    const value = parseFloat(input.value) || 0;

                    let updateData;
                    if (isSalary) {
                        // Save annual salary and calculate effective hourly rate
                        const effectiveHourly = value / 2080; // 40hrs * 52 weeks
                        updateData = { annual_salary: value, hourly_rate: effectiveHourly };
                    } else {
                        // Save hourly rate directly
                        updateData = { hourly_rate: value };
                    }

                    const { error } = await supabaseClient
                        .from('wm_employees')
                        .update(updateData)
                        .eq('id', employeeId);

                    if (!error) savedCount++;
                }

                alert(`Saved labor rates for ${savedCount} employees!`);
            } catch (err) {
                console.error('Error saving labor rates:', err);
                alert('Error saving: ' + err.message);
            }
        }

        async function loadTargetMargins() {
            if (!supabaseClient) return;

            const tbody = document.getElementById('targetMarginsBody');
            if (!tbody) return;

            // Get business ID
            let bizId = currentBusinessId;
            if (bizId === 'all' && businessesList.length > 0) {
                bizId = businessesList[0].id;
            }

            try {
                // Get product types from actual batch data + LeafLink mappings
                const batchProductTypes = new Set();
                batches.forEach(b => {
                    if (b.packaged_product_type) batchProductTypes.add(b.packaged_product_type);
                    if (b.product_made) batchProductTypes.add(b.product_made);
                });

                // Also get product types from LeafLink mappings
                const { data: productMappings } = await supabaseClient
                    .from('leaflink_product_mappings')
                    .select('app_product_type')
                    .eq('business_id', bizId);

                if (productMappings) {
                    productMappings.forEach(m => batchProductTypes.add(m.app_product_type));
                }

                // Convert to array and sort
                const productTypes = [...batchProductTypes].filter(pt => pt && pt !== 'Bulk Sale').sort();
                console.log('Product types found:', productTypes);

                // Load saved margins
                const { data: margins, error: marginsError } = await supabaseClient
                    .from('wm_target_margins')
                    .select('*')
                    .eq('business_id', bizId);

                if (!marginsError && margins) {
                    margins.forEach(m => {
                        targetMargins[m.product_type] = m.target_margin_pct;
                    });
                }

                // Load current prices from LeafLink mappings (these are CASE prices, 10 units/case)
                const { data: mappings } = await supabaseClient
                    .from('leaflink_product_mappings')
                    .select('app_product_type, price_per_unit')
                    .eq('business_id', bizId);

                const UNITS_PER_CASE = 10;
                const casePriceMap = {};
                if (mappings) {
                    mappings.forEach(m => {
                        casePriceMap[m.app_product_type] = m.price_per_unit;
                    });
                }

                // Calculate avg COGS per product type from batches
                const avgCOGS = await calculateAvgCOGSByProductType();
                console.log('Avg COGS by product type:', avgCOGS);

                // Render table
                tbody.innerHTML = productTypes.map(pt => {
                    const margin = targetMargins[pt] !== undefined ? targetMargins[pt] : 40;
                    const avgCost = avgCOGS[pt] || 0; // Cost per unit

                    // Suggested price per unit to achieve target margin
                    const suggestedUnitPrice = avgCost > 0 ? avgCost / (1 - margin / 100) : 0;

                    // Current prices (LeafLink is per case, convert to per unit)
                    const casePrice = casePriceMap[pt] || 0;
                    const unitPrice = casePrice / UNITS_PER_CASE;

                    // Calculate actual margin: (revenue - cost) / revenue
                    const actualMargin = unitPrice > 0 && avgCost > 0 ? ((unitPrice - avgCost) / unitPrice * 100) : 0;
                    const isProfit = actualMargin > 0;
                    const marginColor = actualMargin >= margin ? 'var(--accent-green)' : isProfit ? 'var(--accent-orange)' : 'var(--accent-red)';

                    return `
                        <tr style="border-bottom: 1px solid var(--border-color);">
                            <td style="padding: 12px; color: var(--text-primary);">${pt}</td>
                            <td style="padding: 12px; text-align: center;">
                                <input type="number" step="1" value="${margin}" min="0" max="100" data-product-type="${pt}" class="target-margin-input" style="width: 60px; background: var(--bg-tertiary); border: 1px solid var(--border-color); color: var(--text-primary); padding: 5px; border-radius: 4px; text-align: center;" onchange="updateMarginRow(this)">%
                            </td>
                            <td style="padding: 12px; text-align: right; color: var(--text-secondary);">${avgCost > 0 ? '$' + avgCost.toFixed(2) : 'N/A'}</td>
                            <td style="padding: 12px; text-align: right; color: var(--accent-blue); font-weight: 600;">${suggestedUnitPrice > 0 ? '$' + suggestedUnitPrice.toFixed(2) : 'N/A'}</td>
                            <td style="padding: 12px; text-align: right; color: var(--text-primary);">${unitPrice > 0 ? '$' + unitPrice.toFixed(2) + ' <span style="font-size:0.75rem;opacity:0.6">($' + casePrice + '/case)</span>' : 'Not set'}</td>
                            <td style="padding: 12px; text-align: center; color: ${marginColor}; font-weight: 600;">${avgCost > 0 && unitPrice > 0 ? actualMargin.toFixed(1) + '%' : 'N/A'}</td>
                        </tr>
                    `;
                }).join('');

            } catch (err) {
                console.error('Error loading target margins:', err);
            }
        }

        function updateMarginRow(input) {
            // Recalculate suggested price when margin changes
            loadTargetMargins();
        }

        async function calculateAvgCOGSByProductType() {
            // Calculate average COGS per unit for each product type from all batches
            const avgCOGS = {};

            console.log('=== Calculate Avg COGS Debug ===');
            console.log('Total batches:', batches?.length);

            if (!batches || batches.length === 0) {
                console.log('No batches available!');
                return avgCOGS;
            }

            // Load employee rates for COGS calculation
            const employeeRates = await loadEmployeeRates();

            // Include all non-sub-batches that have units (completed packaging)
            const relevantBatches = batches.filter(b => {
                if (b.is_sub_batch) return false;
                const units = b.labels_applied_quantity || b.units_packaged || 0;
                return units > 0;
            });
            console.log('Relevant batches (with units):', relevantBatches.length);

            // Debug: Show all product types found in batches
            const allProductTypes = {};
            batches.forEach(b => {
                const pt = b.packaged_product_type || b.product_made || 'NO TYPE';
                allProductTypes[pt] = (allProductTypes[pt] || 0) + 1;
            });
            console.log('Product types in ALL batches:', allProductTypes);

            const byType = {};
            console.log('=== DETAILED BATCH COGS CALCULATIONS ===');
            console.log('Cost Config:', JSON.stringify(costConfig, null, 2));
            console.log('Employee Rates:', employeeRates);
            console.log('Avg Monthly Grams:', window.calculatedAvgMonthlyGrams);
            console.log('');

            relevantBatches.forEach(b => {
                // Use packaged_product_type, fallback to product_made
                const pt = b.packaged_product_type || b.product_made || 'Other';
                if (!pt || pt === 'Other') return;

                if (!byType[pt]) byType[pt] = { totalCost: 0, totalUnits: 0, batches: [] };

                // Calculate COGS dynamically for this batch
                const cogs = calculateBatchCOGS(b, employeeRates);

                // Get units (adjust for 50/50 splits)
                let units = b.labels_applied_quantity || b.units_packaged || 0;
                const isSplit = b.material_agreement === '50-50 Split' || b.material_agreement === '50/50 Split';
                if (isSplit) {
                    units = units * 0.5;
                }

                if (cogs.calculated_cogs > 0 && units > 0) {
                    byType[pt].totalCost += cogs.calculated_cogs;
                    byType[pt].totalUnits += units;
                    byType[pt].batches.push({
                        id: b.id,
                        strain: b.strain_name,
                        cogs: cogs.calculated_cogs,
                        units: units,
                        costPerUnit: cogs.cost_per_unit
                    });

                    // Log detailed breakdown for each batch
                    console.log(`BATCH: ${b.strain_name} (${pt})`);
                    console.log(`  ID: ${b.id}`);
                    console.log(`  Material Cost: $${cogs.material_cost.toFixed(2)} (from batch.material_cost: ${b.material_cost})`);
                    console.log(`  Consumables: $${cogs.consumables_cost.toFixed(2)}`);
                    if (cogs.breakdown.consumables.butane?.cost > 0) {
                        console.log(`    - Butane: ${cogs.breakdown.consumables.butane.qty} lb  $${costConfig.butane_per_lb || 3.50}/lb = $${cogs.breakdown.consumables.butane.cost.toFixed(2)}`);
                    }
                    if (cogs.breakdown.consumables.nitrogen?.cost > 0) {
                        console.log(`    - Nitrogen: ${cogs.breakdown.consumables.nitrogen.qty} tanks  $${costConfig.nitrogen_per_tank || 45}/tank = $${cogs.breakdown.consumables.nitrogen.cost.toFixed(2)}`);
                    }
                    if (cogs.breakdown.consumables.filter_media?.cost > 0) {
                        console.log(`    - Filter Media: silica ${cogs.breakdown.consumables.filter_media.silica}g, clay ${cogs.breakdown.consumables.filter_media.clay}g = $${cogs.breakdown.consumables.filter_media.cost.toFixed(2)}`);
                    }
                    if (cogs.breakdown.consumables.packaging) {
                        const pkg = cogs.breakdown.consumables.packaging;
                        if (pkg.type) {
                            console.log(`    - Packaging (${pkg.type}): ${pkg.qty} units = $${pkg.cost.toFixed(2)}`);
                        } else if (pkg.total_cost) {
                            console.log(`    - Jars 1g: ${pkg.jars_1g?.qty || 0}  $${costConfig.jar_1g || 0.25} = $${(pkg.jars_1g?.cost || 0).toFixed(2)}`);
                            console.log(`    - Jars 4g: ${pkg.jars_4g?.qty || 0}  $${costConfig.jar_4g || 0.40} = $${(pkg.jars_4g?.cost || 0).toFixed(2)}`);
                            console.log(`    - Lids: ${pkg.lids?.qty || 0}  $${costConfig.lid || 0.10} = $${(pkg.lids?.cost || 0).toFixed(2)}`);
                            console.log(`    - Labels: ${pkg.labels?.qty || 0}  $${costConfig.label || 0.05} = $${(pkg.labels?.cost || 0).toFixed(2)}`);
                        }
                    }
                    console.log(`  Labor: $${cogs.labor_cost.toFixed(2)}`);
                    Object.entries(cogs.breakdown.labor).forEach(([stage, data]) => {
                        console.log(`    - ${stage}: ${data.user}  ${data.hours}hr  $${data.rate}/hr = $${data.cost.toFixed(2)}`);
                    });
                    console.log(`  Overhead: $${cogs.overhead_allocated.toFixed(2)} (${cogs.breakdown.grams_produced}g / ${window.calculatedAvgMonthlyGrams}g monthly)`);
                    console.log(`  ---`);
                    console.log(`  TOTAL COGS: $${cogs.calculated_cogs.toFixed(2)}`);
                    console.log(`  Units: ${b.units_packaged || b.labels_applied_quantity}${isSplit ? ` (50/50 split  ${units} kept)` : ''}`);
                    console.log(`  COST PER UNIT: $${cogs.cost_per_unit.toFixed(2)}`);
                    console.log('');
                }
            });

            // Log summary by type
            console.log('=== SUMMARY BY PRODUCT TYPE ===');
            Object.keys(byType).forEach(pt => {
                const data = byType[pt];
                if (data.totalUnits > 0) {
                    avgCOGS[pt] = data.totalCost / data.totalUnits;
                    console.log(`${pt}: $${avgCOGS[pt].toFixed(2)}/unit (${data.batches.length} batches, ${data.totalUnits} total units, $${data.totalCost.toFixed(2)} total cost)`);
                }
            });

            return avgCOGS;
        }

        async function saveTargetMargins() {
            if (!supabaseClient) {
                alert('Database not connected');
                return;
            }

            // Get business ID
            let bizId = currentBusinessId;
            if (bizId === 'all' && businessesList.length > 0) {
                bizId = businessesList[0].id;
            }

            try {
                const inputs = document.querySelectorAll('.target-margin-input');
                const updates = [];

                inputs.forEach(input => {
                    const productType = input.dataset.productType;
                    const marginPct = parseFloat(input.value) || 40;
                    targetMargins[productType] = marginPct;

                    updates.push({
                        business_id: bizId,
                        product_type: productType,
                        target_margin_pct: marginPct
                    });
                });

                const { error } = await supabaseClient
                    .from('wm_target_margins')
                    .upsert(updates, { onConflict: 'business_id,product_type' });

                if (error) throw error;

                alert('Target margins saved!');
            } catch (err) {
                console.error('Error saving margins:', err);
                alert('Error saving: ' + err.message);
            }
        }

        // Cache for employee rates (loaded once)
        let employeeRatesCache = {};

        // Calculate production averages from batch data
        function calculateProductionAverages() {
            if (!batches || batches.length === 0) return;

            const threeMonthsAgo = new Date();
            threeMonthsAgo.setMonth(threeMonthsAgo.getMonth() - 3);

            const recentBatches = batches.filter(b => {
                if (b.is_sub_batch) return false;
                const batchDate = new Date(b.packaging_date || b.labeling_date || b.completed_at || b.created_at);
                return batchDate >= threeMonthsAgo;
            });

            // Sum grams produced in last 3 months
            let totalGramsLast3Months = 0;
            recentBatches.forEach(b => {
                const grams = parseFloat(b.total_grams_packaged) ||
                             parseFloat(b.final_weight) ||
                             parseFloat(b.crude_weight) || 0;
                totalGramsLast3Months += grams;
            });

            // Calculate monthly averages
            window.calculatedAvgMonthlyGrams = totalGramsLast3Months / 3 || 15000;
            window.calculatedAvgBatchesPerMonth = recentBatches.length / 3 || 30;

            // Update display elements if they exist
            const batchesDisplay = document.getElementById('avgBatchesPerMonthDisplay');
            const gramsDisplay = document.getElementById('avgMonthlyGramsDisplay');
            if (batchesDisplay) batchesDisplay.textContent = window.calculatedAvgBatchesPerMonth.toFixed(1);
            if (gramsDisplay) gramsDisplay.textContent = window.calculatedAvgMonthlyGrams.toLocaleString(undefined, { maximumFractionDigits: 0 }) + 'g';

            console.log(`Production averages: ${window.calculatedAvgBatchesPerMonth.toFixed(1)} batches/mo, ${window.calculatedAvgMonthlyGrams.toFixed(0)}g/mo (from ${recentBatches.length} batches)`);
        }

        async function loadEmployeeRates() {
            if (Object.keys(employeeRatesCache).length > 0) return employeeRatesCache;

            try {
                const { data } = await supabaseClient
                    .from('wm_employees')
                    .select('name, hourly_rate, annual_salary, is_salary')
                    .eq('is_active', true);

                if (data) {
                    data.forEach(emp => {
                        // Calculate effective hourly rate
                        let rate = parseFloat(emp.hourly_rate) || 0;
                        if (emp.is_salary && emp.annual_salary) {
                            rate = parseFloat(emp.annual_salary) / 2080; // 40hrs  52 weeks
                        }
                        employeeRatesCache[emp.name] = rate || 18; // Default $18/hr
                    });
                }
            } catch (e) {
                console.log('Could not load employee rates:', e);
            }

            return employeeRatesCache;
        }

        function calculateBatchCOGS(batch, employeeRates = {}) {
            // ============================================
            // 1. MATERIAL COST - Direct from batch
            // ============================================
            const materialCost = parseFloat(batch.material_cost) || 0;

            // ============================================
            // 2. CONSUMABLES COST - Actual usage from batch
            // ============================================
            let consumablesCost = 0;
            const consumablesBreakdown = {};

            // Butane (per lb)
            const butaneUsed = parseFloat(batch.butane_used) || 0;
            const butaneCost = butaneUsed * (costConfig.butane_per_lb || 3.50);
            consumablesCost += butaneCost;
            consumablesBreakdown.butane = { qty: butaneUsed, unit: 'lb', cost: butaneCost };

            // Nitrogen (per tank)
            const nitrogenUsed = parseFloat(batch.nitrogen_tanks_used) || 0;
            const nitrogenCost = nitrogenUsed * (costConfig.nitrogen_per_tank || 45);
            consumablesCost += nitrogenCost;
            consumablesBreakdown.nitrogen = { qty: nitrogenUsed, unit: 'tank', cost: nitrogenCost };

            // Filter media (from JSON field)
            if (batch.filter_media_used) {
                try {
                    const fm = typeof batch.filter_media_used === 'string'
                        ? JSON.parse(batch.filter_media_used)
                        : batch.filter_media_used;

                    const silicaTop = parseFloat(fm.silica_top) || 0;
                    const silicaBottom = parseFloat(fm.silica_bottom) || 0;
                    const clay = parseFloat(fm.t5_clay || fm.clay) || 0;

                    const silicaCost = (silicaTop + silicaBottom) * (costConfig.silica_per_gram || 0.05);
                    const clayCost = clay * (costConfig.clay_per_gram || 0.03);

                    consumablesCost += silicaCost + clayCost;
                    consumablesBreakdown.filter_media = {
                        silica: silicaTop + silicaBottom,
                        clay: clay,
                        cost: silicaCost + clayCost
                    };
                } catch (e) {
                    console.log('Could not parse filter_media_used:', e);
                }
            }

            // Packaging materials (based on actual units packaged)
            if (batch.units_packaged) {
                const productType = batch.packaged_product_type || '';
                let packagingCost = 0;

                if (productType.includes('Cart')) {
                    // Cartridges
                    packagingCost = batch.units_packaged * (costConfig.cart_hardware || 2.50);
                    consumablesBreakdown.packaging = { type: 'carts', qty: batch.units_packaged, cost: packagingCost };
                } else if (productType.includes('AIO')) {
                    // All-in-ones
                    packagingCost = batch.units_packaged * (costConfig.aio_hardware || 5.00);
                    consumablesBreakdown.packaging = { type: 'aio', qty: batch.units_packaged, cost: packagingCost };
                } else {
                    // Jars (1g and 4g) + lids + labels
                    const jars1g = parseInt(batch.units_1g) || 0;
                    const jars4g = parseInt(batch.units_4g) || 0;
                    const totalJars = jars1g + jars4g || batch.units_packaged;

                    const jar1gCost = jars1g * (costConfig.jar_1g || 0.25);
                    const jar4gCost = jars4g * (costConfig.jar_4g || 0.40);
                    const lidCost = totalJars * (costConfig.lid || 0.10);
                    const labelCost = totalJars * (costConfig.label || 0.05);

                    packagingCost = jar1gCost + jar4gCost + lidCost + labelCost;
                    consumablesBreakdown.packaging = {
                        jars_1g: { qty: jars1g, cost: jar1gCost },
                        jars_4g: { qty: jars4g, cost: jar4gCost },
                        lids: { qty: totalJars, cost: lidCost },
                        labels: { qty: totalJars, cost: labelCost },
                        total_cost: packagingCost
                    };
                }
                consumablesCost += packagingCost;
            }

            // ============================================
            // 3. LABOR COST - From timeline + employee rates
            // ============================================
            let laborCost = 0;
            const laborBreakdown = {};
            const timeline = batch.timeline || [];

            // Method 1: Calculate from timeline entries with timestamps
            if (timeline.length > 0) {
                // Group timeline entries by stage
                const stageEntries = {};
                timeline.forEach((entry, idx) => {
                    const stage = entry.stage || 'unknown';
                    if (!stageEntries[stage]) stageEntries[stage] = [];
                    stageEntries[stage].push({
                        ...entry,
                        timestamp: new Date(entry.timestamp || entry.date),
                        nextTimestamp: timeline[idx + 1] ? new Date(timeline[idx + 1].timestamp || timeline[idx + 1].date) : null
                    });
                });

                // Calculate time spent per stage
                Object.entries(stageEntries).forEach(([stage, entries]) => {
                    let stageHours = 0;
                    let stageUser = entries[0]?.user || 'Unknown';

                    // If we have start/end timestamps, calculate actual time
                    entries.forEach(entry => {
                        if (entry.timestamp && entry.nextTimestamp) {
                            const hours = (entry.nextTimestamp - entry.timestamp) / (1000 * 60 * 60);
                            // Cap at 8 hours per entry (reasonable workday)
                            stageHours += Math.min(hours, 8);
                        }
                    });

                    // If no time calculated, estimate based on stage type
                    if (stageHours === 0) {
                        const trimWeight = parseFloat(batch.trim_weight) || 0;
                        switch (stage) {
                            case 'extraction':
                                // ~1 hour per 10 lbs of trim
                                stageHours = Math.max(0.5, trimWeight / 10);
                                break;
                            case 'finishing':
                                // ~30 min per batch
                                stageHours = 0.5;
                                break;
                            case 'packaging':
                                // ~5 min per 10 units
                                stageHours = Math.max(0.25, (batch.units_packaged || 0) / 120);
                                break;
                            case 'labeling':
                                // ~3 min per 10 units
                                stageHours = Math.max(0.15, (batch.units_packaged || 0) / 200);
                                break;
                            default:
                                stageHours = 0.25;
                        }
                    }

                    // Get employee's hourly rate
                    const hourlyRate = employeeRates[stageUser] || 18;
                    const stageCost = stageHours * hourlyRate;

                    laborCost += stageCost;
                    laborBreakdown[stage] = {
                        user: stageUser,
                        hours: parseFloat(stageHours.toFixed(2)),
                        rate: hourlyRate,
                        cost: parseFloat(stageCost.toFixed(2))
                    };
                });
            } else {
                // Method 2: Estimate from stage completion fields
                const stages = [
                    { name: 'extraction', userField: 'extraction_user', weight: 1.0 },
                    { name: 'finishing', userField: 'finishing_user', weight: 0.5 },
                    { name: 'packaging', userField: 'packaging_user', weight: 0.5 },
                    { name: 'labeling', userField: 'labeling_user', weight: 0.25 }
                ];

                stages.forEach(({ name, userField, weight }) => {
                    const user = batch[userField];
                    if (user) {
                        const rate = employeeRates[user] || 18;
                        const hours = weight;
                        const stageCost = hours * rate;
                        laborCost += stageCost;
                        laborBreakdown[name] = { user, hours, rate, cost: stageCost };
                    }
                });
            }

            // ============================================
            // 4. OVERHEAD ALLOCATION - By production weight
            // ============================================
            const monthlyOverhead = (costConfig.rent_monthly || 0) +
                                   (costConfig.utilities_monthly || 0) +
                                   (costConfig.equipment_monthly || 0) +
                                   (costConfig.insurance_monthly || 0);

            // Allocate overhead by grams produced (fairer than per-batch)
            const batchGrams = parseFloat(batch.total_grams_packaged) ||
                              parseFloat(batch.final_weight) ||
                              parseFloat(batch.crude_weight) || 0;

            // Use cached monthly grams (calculated in recalculateAllBatchCOGS)
            const avgMonthlyGrams = window.calculatedAvgMonthlyGrams || 15000;
            const overheadAllocated = batchGrams > 0 && avgMonthlyGrams > 0
                ? monthlyOverhead * (batchGrams / avgMonthlyGrams)
                : monthlyOverhead / 30; // Fallback to per-batch

            // ============================================
            // 5. TOTAL COGS
            // ============================================
            const calculatedCOGS = materialCost + consumablesCost + laborCost + overheadAllocated;

            // ============================================
            // 6. COST PER UNIT - Adjust for split agreements
            // ============================================
            let unitsKept = batch.labels_applied_quantity || batch.units_packaged || 0;

            // 50/50 Split: Customer gets half, you keep half
            if (batch.material_agreement === '50-50 Split' || batch.material_agreement === '50/50 Split') {
                unitsKept = unitsKept * 0.5;
            }

            const costPerUnit = unitsKept > 0 ? calculatedCOGS / unitsKept : 0;

            return {
                material_cost: materialCost,
                consumables_cost: consumablesCost,
                labor_cost: laborCost,
                overhead_allocated: overheadAllocated,
                calculated_cogs: calculatedCOGS,
                cost_per_unit: costPerUnit,
                breakdown: {
                    consumables: consumablesBreakdown,
                    labor: laborBreakdown,
                    units_produced: batch.units_packaged || 0,
                    units_kept: unitsKept,
                    grams_produced: batchGrams
                }
            };
        }

        async function recalculateAllBatchCOGS() {
            if (!supabaseClient || !batches) {
                alert('No data available');
                return;
            }

            const confirm = window.confirm('This will recalculate COGS for all batches using actual labor rates and consumables. Continue?');
            if (!confirm) return;

            // Load employee rates first
            const employeeRates = await loadEmployeeRates();
            console.log('Loaded employee rates:', employeeRates);

            // Calculate production averages for overhead allocation
            calculateProductionAverages();

            let updated = 0;
            let skipped = 0;
            for (const batch of batches) {
                // Skip sub-batches (they inherit from parent)
                if (batch.is_sub_batch) {
                    skipped++;
                    continue;
                }

                const cogs = calculateBatchCOGS(batch, employeeRates);
                // Detailed logging for high-cost batches
                if (cogs.consumables_cost > 5000 || cogs.labor_cost > 5000) {
                    console.warn(` HIGH COST Batch ${batch.id}:`, {
                        consumables: cogs.breakdown?.consumables,
                        labor: cogs.breakdown?.labor,
                        butane_used: batch.butane_used,
                        nitrogen_tanks: batch.nitrogen_tanks_used,
                        units: batch.units_packaged,
                        costConfig: { butane: costConfig.butane_per_lb, jar_1g: costConfig.jar_1g, jar_4g: costConfig.jar_4g }
                    });
                }
                console.log(`Batch ${batch.id} COGS:`, cogs);

                const { error } = await supabaseClient
                    .from('wm_batches')
                    .update({
                        calculated_cogs: cogs.calculated_cogs,
                        labor_cost: cogs.labor_cost,
                        consumables_cost: cogs.consumables_cost,
                        overhead_allocated: cogs.overhead_allocated,
                        cost_per_unit: cogs.cost_per_unit
                    })
                    .eq('id', batch.id);

                if (!error) updated++;
            }

            alert(`Recalculated COGS for ${updated} batches! (${skipped} sub-batches skipped)`);
            loadBatches();
        }

        async function updateProfitabilityAnalysis() {
            const period = document.getElementById('analysisperiod')?.value || 'month';

            // Calculate date range
            const now = new Date();
            let startDate = null;
            switch (period) {
                case 'all':
                    startDate = null; // No date filter
                    break;
                case 'week':
                    startDate = new Date(now);
                    startDate.setDate(now.getDate() - 7);
                    break;
                case 'month':
                    startDate = new Date(now.getFullYear(), now.getMonth(), 1);
                    break;
                case 'quarter':
                    const quarter = Math.floor(now.getMonth() / 3);
                    startDate = new Date(now.getFullYear(), quarter * 3, 1);
                    break;
                case 'year':
                    startDate = new Date(now.getFullYear(), 0, 1);
                    break;
            }

            // Filter batches - only include packaged batches (have units)
            const periodBatches = batches.filter(b => {
                // Skip sub-batches (they're part of parent batch)
                if (b.is_sub_batch) return false;

                // Must have been packaged (has units)
                if (!b.units_packaged || b.units_packaged <= 0) return false;

                // If no date filter (all time), include all packaged batches
                if (!startDate) return true;

                // Use best available date: completed_at > labeling_date > packaging_date > created_at
                const batchDate = b.completed_at || b.labeling_date || b.packaging_date || b.created_at;
                if (!batchDate) return true; // Include if no date at all

                const date = new Date(batchDate);
                return date >= startDate && date <= now;
            });

            // Debug logging
            console.log('=== Profitability Analysis Debug ===');
            console.log('Total batches loaded:', batches.length);
            console.log('Period batches (after filter):', periodBatches.length);

            // Count batches excluded for having no units
            const excludedCount = batches.filter(b => !b.is_sub_batch && (!b.units_packaged || b.units_packaged <= 0)).length;
            console.log(`Excluded ${excludedCount} batches without units_packaged`);

            // Show product type distribution
            const productTypeCounts = {};
            periodBatches.forEach(b => {
                const pt = b.packaged_product_type || b.product_made || 'NOT SET';
                productTypeCounts[pt] = (productTypeCounts[pt] || 0) + 1;
            });
            console.log('Product types in batches:', productTypeCounts);

            // Show first 5 batches with their product types and units
            console.log('First 5 packaged batches:');
            periodBatches.slice(0, 5).forEach(b => {
                const pt = b.packaged_product_type || b.product_made || 'NO TYPE';
                const units1g = b.units_1g_labeled || b.units_1g || 0;
                const units4g = b.units_4g_labeled || b.units_4g || 0;
                const actualUnits = b.labels_applied_quantity || b.units_packaged || 0;
                const breakdown = (units1g || units4g) ? `(${units1g}x1g + ${units4g}x4g)` : '';
                console.log(`  ${b.id}: ${pt} - ${actualUnits} units ${breakdown}`);
            });

            // Get business ID for price mappings
            let bizId = currentBusinessId;
            if (bizId === 'all' && businessesList.length > 0) {
                bizId = businessesList[0].id;
            }

            // Load LeafLink price mappings as fallback
            const priceMap = {};
            try {
                const { data: mappings } = await supabaseClient
                    .from('leaflink_product_mappings')
                    .select('app_product_type, price_per_unit')
                    .eq('business_id', bizId);
                if (mappings) {
                    mappings.forEach(m => {
                        priceMap[m.app_product_type] = m.price_per_unit;
                    });
                }
            } catch (e) {
                console.log('Could not load price mappings:', e);
            }

            console.log('Price mappings loaded:', priceMap);

            // Load employee rates for COGS calculation
            const employeeRates = await loadEmployeeRates();

            // Calculate totals
            let totalRevenue = 0;
            let totalCOGS = 0;
            let totalMaterial = 0;
            let totalConsumables = 0;
            let totalLabor = 0;
            let totalOverhead = 0;

            const byProduct = {};

            periodBatches.forEach(b => {
                // Use stored COGS if available, otherwise calculate fresh
                let cogs;
                if (b.calculated_cogs > 0) {
                    cogs = {
                        calculated_cogs: parseFloat(b.calculated_cogs) || 0,
                        material_cost: parseFloat(b.material_cost) || 0,
                        consumables_cost: parseFloat(b.consumables_cost) || 0,
                        labor_cost: parseFloat(b.labor_cost) || 0,
                        overhead_allocated: parseFloat(b.overhead_allocated) || 0
                    };
                } else {
                    cogs = calculateBatchCOGS(b, employeeRates);
                }

                // Use actual labeled quantity if available, otherwise packaged
                const actualUnits = b.labels_applied_quantity || b.units_packaged || 0;

                // Get product type
                const pt = b.packaged_product_type || b.product_made || 'Other';

                // Calculate revenue based on 1g/4g breakdown if available
                // LeafLink prices are per CASE (10 units per case)
                const UNITS_PER_CASE = 10;
                let revenue = 0;
                const units1g = b.units_1g_labeled || b.units_1g || 0;
                const units4g = b.units_4g_labeled || b.units_4g || 0;

                if (units1g > 0 || units4g > 0) {
                    // Has size breakdown - calculate revenue by size
                    // Prices are per case, so divide units by 10 to get cases
                    const casePrice1g = priceMap[pt] || priceMap[pt + ' 1g'] || 60;
                    const casePrice4g = priceMap[pt + ' 4g'] || priceMap[pt + ' 4G'] || 220;
                    const cases1g = units1g / UNITS_PER_CASE;
                    const cases4g = units4g / UNITS_PER_CASE;
                    revenue = (cases1g * casePrice1g) + (cases4g * casePrice4g);
                } else {
                    // No breakdown - use wholesale_price or mapping (assume case price)
                    let casePrice = parseFloat(b.wholesale_price) || 0;
                    if (casePrice === 0 && priceMap[pt]) {
                        casePrice = priceMap[pt];
                    }
                    const cases = actualUnits / UNITS_PER_CASE;
                    revenue = cases * casePrice;
                }

                totalRevenue += revenue;
                totalCOGS += cogs.calculated_cogs;
                totalMaterial += cogs.material_cost;
                totalConsumables += cogs.consumables_cost;
                totalLabor += cogs.labor_cost;
                totalOverhead += cogs.overhead_allocated;

                if (!byProduct[pt]) byProduct[pt] = { units: 0, revenue: 0, cogs: 0, units1g: 0, units4g: 0 };
                byProduct[pt].units += actualUnits;
                byProduct[pt].units1g += units1g;
                byProduct[pt].units4g += units4g;
                byProduct[pt].revenue += revenue;
                byProduct[pt].cogs += cogs.calculated_cogs;
            });

            const grossProfit = totalRevenue - totalCOGS;
            const grossMargin = totalRevenue > 0 ? (grossProfit / totalRevenue * 100) : 0;

            console.log('Calculated totals:', {
                totalRevenue,
                totalCOGS,
                grossProfit,
                grossMargin,
                byProduct
            });

            // Update summary cards
            document.getElementById('analysisRevenue').textContent = '$' + totalRevenue.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
            document.getElementById('analysisCOGS').textContent = '$' + totalCOGS.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
            document.getElementById('analysisProfit').textContent = '$' + grossProfit.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
            document.getElementById('analysisMargin').textContent = grossMargin.toFixed(1) + '%';

            // Update by-product table
            const tbody = document.getElementById('productProfitabilityBody');
            if (tbody) {
                tbody.innerHTML = Object.entries(byProduct).map(([pt, data]) => {
                    const profit = data.revenue - data.cogs;
                    const margin = data.revenue > 0 ? (profit / data.revenue * 100) : 0;
                    const marginColor = margin >= 40 ? 'var(--accent-green)' : margin >= 20 ? 'var(--accent-orange)' : 'var(--accent-red)';
                    // Show unit breakdown if available
                    let unitsDisplay = data.units.toLocaleString();
                    if (data.units1g > 0 || data.units4g > 0) {
                        unitsDisplay = `${data.units1g.toLocaleString()} (1g) + ${data.units4g.toLocaleString()} (4g)`;
                    }
                    return `
                        <tr style="border-bottom: 1px solid var(--border-color);">
                            <td style="padding: 12px; color: var(--text-primary);">${pt}</td>
                            <td style="padding: 12px; text-align: right; color: var(--text-secondary);">${unitsDisplay}</td>
                            <td style="padding: 12px; text-align: right; color: var(--accent-blue);">$${data.revenue.toLocaleString(undefined, { minimumFractionDigits: 2 })}</td>
                            <td style="padding: 12px; text-align: right; color: var(--accent-orange);">$${data.cogs.toLocaleString(undefined, { minimumFractionDigits: 2 })}</td>
                            <td style="padding: 12px; text-align: right; color: var(--accent-green);">$${profit.toLocaleString(undefined, { minimumFractionDigits: 2 })}</td>
                            <td style="padding: 12px; text-align: center; color: ${marginColor}; font-weight: 600;">${margin.toFixed(1)}%</td>
                        </tr>
                    `;
                }).join('') || '<tr><td colspan="6" style="padding: 20px; text-align: center; color: var(--text-secondary);">No completed batches in this period</td></tr>';
            }

            // Update cost breakdown
            const costTotal = totalMaterial + totalConsumables + totalLabor + totalOverhead;
            const materialPct = costTotal > 0 ? (totalMaterial / costTotal * 100) : 0;
            const consumablesPct = costTotal > 0 ? (totalConsumables / costTotal * 100) : 0;
            const laborPct = costTotal > 0 ? (totalLabor / costTotal * 100) : 0;
            const overheadPct = costTotal > 0 ? (totalOverhead / costTotal * 100) : 0;

            document.getElementById('costBreakdownMaterial').textContent = '$' + totalMaterial.toFixed(0);
            document.getElementById('costBreakdownMaterialPct').textContent = materialPct.toFixed(0) + '%';
            document.getElementById('costBreakdownConsumables').textContent = '$' + totalConsumables.toFixed(0);
            document.getElementById('costBreakdownConsumablesPct').textContent = consumablesPct.toFixed(0) + '%';
            document.getElementById('costBreakdownLabor').textContent = '$' + totalLabor.toFixed(0);
            document.getElementById('costBreakdownLaborPct').textContent = laborPct.toFixed(0) + '%';
            document.getElementById('costBreakdownOverhead').textContent = '$' + totalOverhead.toFixed(0);
            document.getElementById('costBreakdownOverheadPct').textContent = overheadPct.toFixed(0) + '%';
        }

        function generateDemoBatches() {
            const strains = ['GMO Cookies', 'Wedding Cake', 'Gelato', 'Blue Dream', 'OG Kush', 'Sour Diesel', 'Purple Punch', 'Zkittlez', 'Skywalker OG', 'Strawberry Cough'];
            const suppliers = ['Boulder Built Farms', 'Wonderland Cannabis', 'In The Flow Farms', 'Loud Seeds', 'Green Valley Farms'];
            const statuses = ['intake', 'extraction', 'finishing', 'packaging', 'testing', 'labeling', 'completed'];
            const machines = ['left', 'right'];
            const materialTypes = ['Trim', 'Fresh Frozen', 'Whole Flower'];

            const demoBatches = [];
            const now = Date.now();

            // Create more completed batches for FOH showcase (first 10 batches)
            for (let i = 0; i < 10; i++) {
                const strain = strains[Math.floor(Math.random() * strains.length)];
                const supplier = suppliers[Math.floor(Math.random() * suppliers.length)];
                const trimWeight = Math.floor(Math.random() * 5000) + 2000;
                const yieldPercent = (Math.random() * 8 + 15).toFixed(2); // 15-23% yield
                const bulkWeight = (trimWeight * yieldPercent / 100).toFixed(1);
                const materialType = materialTypes[Math.floor(Math.random() * materialTypes.length)];

                demoBatches.push({
                    id: `WM${1000 + i}`,
                    strain: strain,
                    supplier: supplier,
                    material_type: materialType,
                    trim_weight_grams: trimWeight,
                    status: 'completed',
                    stage: 'complete',
                    machine: null,
                    bulk_weight_grams: bulkWeight,
                    final_weight: bulkWeight,
                    jar_count: Math.floor(Math.random() * 50) + 20,
                    created_at: new Date(now - (i + 2) * 24 * 60 * 60 * 1000).toISOString(),
                    updated_at: new Date(now - i * 24 * 60 * 60 * 1000).toISOString(),
                    completed_at: new Date(now - i * 24 * 60 * 60 * 1000).toISOString(),
                    created_by: 'Demo User',
                    notes: 'Excellent quality material',
                    test_results: JSON.stringify({
                        thc: (Math.random() * 20 + 65).toFixed(2),
                        cbd: (Math.random() * 2).toFixed(2),
                        terpenes: (Math.random() * 5 + 3).toFixed(2)
                    })
                });
            }

            // Add regular mix of batches (remaining 15)
            for (let i = 10; i < 25; i++) {
                const strain = strains[Math.floor(Math.random() * strains.length)];
                const supplier = suppliers[Math.floor(Math.random() * suppliers.length)];
                const status = statuses[Math.floor(Math.random() * statuses.length)];
                const trimWeight = Math.floor(Math.random() * 5000) + 1000;
                const yieldPercent = (Math.random() * 15 + 10).toFixed(2);
                const bulkWeight = status === 'completed' ? (trimWeight * yieldPercent / 100).toFixed(1) : null;
                const materialType = materialTypes[Math.floor(Math.random() * materialTypes.length)];

                demoBatches.push({
                    id: `WM${1000 + i}`,
                    strain: strain,
                    supplier: supplier,
                    material_type: materialType,
                    trim_weight_grams: trimWeight,
                    status: status,
                    stage: status === 'completed' ? 'complete' : status,
                    machine: status === 'extraction' ? machines[Math.floor(Math.random() * machines.length)] : null,
                    bulk_weight_grams: bulkWeight,
                    final_weight: bulkWeight,
                    jar_count: status === 'completed' ? Math.floor(Math.random() * 50) + 10 : null,
                    created_at: new Date(now - Math.random() * 30 * 24 * 60 * 60 * 1000).toISOString(),
                    updated_at: new Date(now - Math.random() * 7 * 24 * 60 * 60 * 1000).toISOString(),
                    created_by: 'Demo User',
                    notes: i % 3 === 0 ? 'Looking good!' : null,
                    test_results: status === 'completed' ? JSON.stringify({
                        thc: (Math.random() * 30 + 60).toFixed(2),
                        cbd: (Math.random() * 2).toFixed(2)
                    }) : null
                });
            }

            return demoBatches;
        }

        function generateDemoLeafLinkOrders() {
            const companies = ['Green Valley Dispensary', 'Mountain High', 'Coastal Cannabis', 'Urban Leaf', 'Valley Verde'];
            const salesReps = ['Ryan Thompson', 'Drew Martinez', 'Sarah Johnson'];
            const demoOrders = [];
            const now = Date.now();

            for (let i = 0; i < 50; i++) {
                const company = companies[Math.floor(Math.random() * companies.length)];
                const orderDate = new Date(now - Math.random() * 60 * 24 * 60 * 60 * 1000);
                const total = (Math.random() * 5000 + 500).toFixed(2);

                demoOrders.push({
                    id: `DEMO-${1000 + i}`,
                    number: `WM${1000 + i}`,
                    company: { name: company },
                    customer: { company_name: company },
                    status: Math.random() > 0.3 ? 'Complete' : 'Shipped',
                    seller_company: { name: 'White Mousse' },
                    created_on: orderDate.toISOString(),
                    total: total,
                    total_paid: Math.random() > 0.2 ? total : (parseFloat(total) * 0.5).toFixed(2),
                    payment_status: Math.random() > 0.2 ? 'Paid' : 'Unpaid',
                    sales_rep: { name: salesReps[Math.floor(Math.random() * salesReps.length)] },
                    line_items: [
                        {
                            product: { name: 'Live Resin - ' + ['GMO', 'Wedding Cake', 'Gelato'][Math.floor(Math.random() * 3)] },
                            quantity: Math.floor(Math.random() * 10) + 1,
                            unit_price: (Math.random() * 50 + 20).toFixed(2)
                        }
                    ]
                });
            }

            return demoOrders;
        }

        // Generate realistic demo blog posts for Front of House section
        // These posts showcase the social media content generation features
        // and partner auto-tagging functionality in demo mode
        function generateDemoBlogPosts() {
            const now = Date.now();
            const demoPosts = [];

            const postTemplates = [
                {
                    title: ' Fresh Heat Incoming: Skywalker OG Live Resin',
                    content: `The terp hunters have spoken!\n\nSo here's the deal: Just grabbed some fire Skywalker OG trim from Boulder Built Farms. And let me tell you, it's absolutely fire!\n\nWhen you prioritize terps and quality, the results are always fire.\n\n---\n\n** Shoutouts**\n\nHuge shoutout to Boulder Built Farms for this incredible material! @boulderbuilt\n\nKeep your eyes peeled at your local dispensary! \n\n---\n#WhiteMousse #ColoradoConcentrates #LiveResin #Terps #CannabisCommunity #BoulderBuilt #SkywalkerOG`,
                    excerpt: 'The terp hunters have spoken! So here\'s the deal: Just grabbed some fire Skywalker OG trim from Boulder...',
                    category: 'strains',
                    emoji: '',
                    status: 'published',
                    daysAgo: 2
                },
                {
                    title: ' Fresh Batch Alert: Purple Punch Live Resin',
                    content: `The extractors have been BUSY!\n\nBig news from the lab: Just wrapped up a fresh batch of Purple Punch. We're honestly so hyped about this one.\n\nAnother batch, another banger. When you prioritize terps and quality, the results are always fire.\n\n---\n\n** Shoutouts**\n\nThis fire came straight from Wonderland Cannabis! @wonderlandcannabis\n\nAsk your budtender about White Mousse! \n\n---\n#WhiteMousse #ColoradoConcentrates #LiveResin #Terps #CannabisCommunity #WonderlandCannabis #PurplePunch`,
                    excerpt: 'The extractors have been BUSY! Big news from the lab: Just wrapped up a fresh batch of Purple Punch...',
                    category: 'update',
                    emoji: '',
                    status: 'published',
                    daysAgo: 5
                },
                {
                    title: ' Quality Check: PASSED - GMO Cookies',
                    content: `Another day, another chance to serve the terps!\n\nHad to share this with y'all: Our GMO Cookies batch just came back from testing. The quality is next level.\n\nThe nose on this one is INSANE. Test results came back at 78.4% THC with an incredible terpene profile.\n\n---\n\n** Shoutouts**\n\nHuge shoutout to In The Flow Farms for this incredible material! @intheflow_farms\n\nKeep an eye out at your local spot! \n\n---\n#WhiteMousse #ColoradoConcentrates #LiveResin #Terps #CannabisCommunity #InTheFlowFarms #GMOCookies`,
                    excerpt: 'Another day, another chance to serve the terps! Had to share this with y\'all: Our GMO Cookies batch...',
                    category: 'update',
                    emoji: '',
                    status: 'published',
                    daysAgo: 7
                },
                {
                    title: ' New Tech in the Lab',
                    content: `When you're obsessed with quality, you never stop upgrading.\n\nSo here's the deal: Just added some new hardware to dial in our extraction process. And let me tell you, it's game-changing!\n\nBetter equipment = better terps. We're always pushing our extraction game to the next level.\n\nStay tuned for even better concentrates! \n\n---\n#WhiteMousse #ColoradoConcentrates #LiveResin #Terps #CannabisCommunity #ExtractionTech`,
                    excerpt: 'When you\'re obsessed with quality, you never stop upgrading. So here\'s the deal: Just added some new...',
                    category: 'update',
                    emoji: '',
                    status: 'published',
                    daysAgo: 10
                },
                {
                    title: ' Strain Alert: Wedding Cake x Gelato',
                    content: `Sometimes a strain walks in and you just KNOW it's gonna be special.\n\nBig news from the lab: Grabbed some Wedding Cake x Gelato from our partners. We're honestly so hyped about this one.\n\nThe terpene profile on this one is chef's kiss. Beautiful blend of sweet, creamy terps with that classic cake finish.\n\n---\n\n** Shoutouts**\n\nThis fire came straight from Loud Seeds! @loudseeds\n\nComing soon to a dispo near you! \n\n---\n#WhiteMousse #ColoradoConcentrates #LiveResin #Terps #CannabisCommunity #LoudSeeds #WeddingCake #Gelato`,
                    excerpt: 'Sometimes a strain walks in and you just KNOW it\'s gonna be special. Big news from the lab: Grabbed...',
                    category: 'strains',
                    emoji: '',
                    status: 'published',
                    daysAgo: 14
                },
                {
                    title: ' Lab Update: December Recap',
                    content: `Just had to hop on and share what's happening at the lab!\n\nWhat a month! We processed over 15 batches, worked with some incredible flower from our amazing partners, and maintained our commitment to quality over quantity.\n\nYou know we're always cooking up something special. Thanks for rocking with White Mousse!\n\nMore updates coming soon. Stay lifted! \n\n---\n#WhiteMousse #ColoradoConcentrates #LiveResin #Terps #CannabisCommunabis #YearEndRecap`,
                    excerpt: 'Just had to hop on and share what\'s happening at the lab! What a month! We processed over 15 batches...',
                    category: 'update',
                    emoji: '',
                    status: 'published',
                    daysAgo: 21
                },
                {
                    title: ' Gear Upgrade Alert: New Extraction System',
                    content: `The lab just got a serious upgrade, fam!\n\nHad to share this with y'all: We just installed a new closed-loop extraction system. The quality is premium.\n\nWe're always pushing our extraction game to the next level. This new setup is going to let us dial in terpene preservation like never before.\n\nBetter equipment = better terps. Stay tuned for even better concentrates! \n\n---\n#WhiteMousse #ColoradoConcentrates #LiveResin #Terps #CannabisCommunity #LabUpgrade`,
                    excerpt: 'The lab just got a serious upgrade, fam! Had to share this with y\'all: We just installed a new...',
                    category: 'update',
                    emoji: '',
                    status: 'published',
                    daysAgo: 28
                },
                {
                    title: ' Behind the Scenes: Extraction Process',
                    content: `Ever wonder what goes into making premium live resin?\n\nBig news from the lab: Thought we'd pull back the curtain a bit. We're honestly so hyped about this one.\n\nFrom fresh frozen material to final product, every step matters. Temperature control, solvent quality, purge times - it's all dialed in to preserve those precious terpenes.\n\nThe results speak for themselves. Keep your eyes peeled at your local dispensary! \n\n---\n#WhiteMousse #ColoradoConcentrates #LiveResin #Terps #CannabisCommunity #BehindTheScenes #ProcessMatters`,
                    excerpt: 'Ever wonder what goes into making premium live resin? Big news from the lab: Thought we\'d pull back...',
                    category: 'update',
                    emoji: '',
                    status: 'published',
                    daysAgo: 35
                }
            ];

            // Generate posts with proper IDs and timestamps
            postTemplates.forEach((template, idx) => {
                const postDate = new Date(now - template.daysAgo * 24 * 60 * 60 * 1000);
                demoPosts.push({
                    id: `demo-post-${1000 + idx}`,
                    title: template.title,
                    content: template.content,
                    excerpt: template.excerpt,
                    category: template.category,
                    emoji: template.emoji,
                    status: template.status,
                    created_at: postDate.toISOString(),
                    updated_at: postDate.toISOString()
                });
            });

            return demoPosts;
        }

        // Demo partners database (fake versions of real partners)
        const demoFOHPartners = {
            'boulder built': { name: 'Boulder Built Farms', instagram: '@boulderbuilt', website: 'https://example.com/boulderbuilt', type: 'farm', hashtags: ['#BoulderBuilt', '#ColoradoGrown'] },
            'wonderland': { name: 'Wonderland Cannabis', instagram: '@wonderlandcannabis', website: 'https://example.com/wonderland', type: 'farm', hashtags: ['#WonderlandCannabis', '#DenverGrown'] },
            'in the flow': { name: 'In The Flow Farms', instagram: '@intheflow_farms', website: 'https://example.com/intheflow', type: 'farm', hashtags: ['#InTheFlowFarms', '#OrganicGrown'] },
            'loud seeds': { name: 'Loud Seeds', instagram: '@loudseeds', website: null, type: 'farm', hashtags: ['#LoudSeeds'] },
            'green valley': { name: 'Green Valley Dispensary', instagram: '@greenvalleydispensary', website: 'https://example.com/greenvalley', type: 'dispensary', hashtags: ['#GreenValley'] },
            'mountain high': { name: 'Mountain High', instagram: '@mountainhighdispensary', website: 'https://example.com/mountainhigh', type: 'dispensary', hashtags: ['#MountainHigh'] }
        };

        let supabaseClient = null;
        let batches = [];
        let currentRole = null;
        let currentMachine = null; // 'left' or 'right' for machine modal
        let currentPullMachine = null; // 'left' or 'right' for pull batch modal
        let batchCounter = 1000;
        let realtimeChannel = null;

        // Multi-tenant business support
        let businessesList = [];
        let currentBusinessId = localStorage.getItem('selectedBusinessId') || 'all'; // 'all' or specific business UUID

        async function loadBusinesses() {
            if (!supabaseClient) return;
            try {
                const { data, error } = await supabaseClient
                    .from('businesses')
                    .select('id, name, slug, display_name, logo_url, primary_color, is_active')
                    .eq('is_active', true)
                    .order('name');
                if (error) throw error;
                businessesList = data || [];

                // Update business selector dropdown
                const selector = document.getElementById('businessFilter');
                if (selector && businessesList.length > 1) {
                    selector.innerHTML = '<option value="all">All Businesses</option>';
                    businessesList.forEach(biz => {
                        selector.innerHTML += `<option value="${biz.id}" style="color: ${biz.primary_color}">${biz.display_name}</option>`;
                    });
                    // Restore saved selection
                    selector.value = currentBusinessId;
                    document.getElementById('businessSelector').style.display = 'block';

                    // Update logo for saved business
                    const logo = document.getElementById('headerLogo');
                    if (currentBusinessId !== 'all') {
                        const biz = businessesList.find(b => b.id === currentBusinessId);
                        if (biz && biz.logo_url && logo) {
                            logo.src = biz.logo_url;
                            logo.alt = biz.display_name;
                        }
                    }
                }
            } catch (err) {
                console.error('Error loading businesses:', err);
            }
        }

        function switchBusiness(businessId) {
            // Save selected business and refresh page to ensure clean state
            localStorage.setItem('selectedBusinessId', businessId);
            window.location.reload();
        }

        function getBusinessBadge(businessId) {
            if (!businessId || businessesList.length <= 1) return '';
            const biz = businessesList.find(b => b.id === businessId);
            if (!biz) return '';
            return `<span style="background: ${biz.primary_color}22; color: ${biz.primary_color}; padding: 2px 8px; border-radius: 4px; font-size: 0.7rem; font-weight: 600; border: 1px solid ${biz.primary_color}44;">${biz.display_name}</span>`;
        }

        // ==================== DEMO MODE ====================
        let DEMO_MODE = false;

        const DEMO_BATCHES = [
            { id: 'DEMO-001', strain: 'Blue Dream', partner: 'Demo Farm', status: 'intake', trim_weight: 500, socks_total: 10, socks_remaining: 10, material_type: 'Trim', metrc_source_tag: 'DEMO123456', pre_sift: 'no', created_at: new Date().toISOString() },
            { id: 'DEMO-002', strain: 'OG Kush', partner: 'Demo Farm', status: 'intake', trim_weight: 750, socks_total: 15, socks_remaining: 15, material_type: 'Trim', metrc_source_tag: 'DEMO789012', pre_sift: 'yes', created_at: new Date().toISOString() },
            { id: 'DEMO-003', strain: 'Gelato', partner: 'Test Partner', status: 'intake', trim_weight: 300, socks_total: 6, socks_remaining: 6, material_type: 'Trim', metrc_source_tag: 'DEMO345678', pre_sift: 'yes', created_at: new Date().toISOString() },
            { id: 'DEMO-004', strain: 'Purple Punch', partner: 'Test Partner', status: 'intake', trim_weight: 1000, socks_total: 20, socks_remaining: 20, material_type: 'Whole Flower', metrc_source_tag: 'DEMO901234', pre_sift: 'no', created_at: new Date().toISOString() }
        ];

        function toggleDemoMode() {
            DEMO_MODE = !DEMO_MODE;
            const btn = document.getElementById('demoModeBtn');
            const indicator = document.getElementById('demoIndicator');

            if (DEMO_MODE) {
                // Load demo data
                batches = [...DEMO_BATCHES];
                CONFIG.machines = [
                    { id: 'demo-bho', name: 'Demo BHO', position: 'Left', machine_type: 'bho', config: { columns: 6, socks_per_run: 6 }, is_active: true },
                    { id: 'demo-resinator', name: 'Demo Resinator', position: 'Resinator', machine_type: 'resinator', config: { second_sift: true }, is_active: true }
                ];
                CONFIG.loaded = true;

                if (btn) {
                    btn.textContent = ' Exit Demo';
                    btn.style.background = 'var(--accent-red)';
                }
                if (indicator) indicator.style.display = 'block';

                // Re-render UI
                renderMachineButtons();
                populateExtractionQueue();
                alert(' DEMO MODE ACTIVE\n\nUsing mock data - no database changes will be made.\n\nDemo batches and machines loaded.');
            } else {
                if (btn) {
                    btn.textContent = ' Demo Mode';
                    btn.style.background = 'var(--accent-purple)';
                }
                if (indicator) indicator.style.display = 'none';

                alert('Demo mode disabled. Refresh to reconnect to live database.');
                location.reload();
            }
        }

        // Demo mode storage helpers
        function demoGetMachineStatus(machineKey) {
            const stored = localStorage.getItem(`demo_machine_${machineKey}`);
            return stored ? JSON.parse(stored) : {};
        }

        function demoSaveMachineStatus(machineKey, status) {
            localStorage.setItem(`demo_machine_${machineKey}`, JSON.stringify(status));
            return Promise.resolve({ error: null });
        }

        function demoUpdateBatch(batchId, updates) {
            const batch = batches.find(b => b.id === batchId);
            if (batch) {
                Object.assign(batch, updates);
            }
            return Promise.resolve({ error: null });
        }

        // ==================== ADMIN CONFIG ====================
        let CONFIG = {
            machines: [],
            productTypes: [],
            materialTypes: [],
            loaded: false
        };

        const CONFIG_DEFAULTS = {
            machines: [
                { id: 'default-1', name: 'Machine 1', position: 'Left', machine_type: 'bho', config: { columns: 6, socks_per_run: 6 }, is_active: true },
                { id: 'default-2', name: 'Machine 2', position: 'Right', machine_type: 'bho', config: { columns: 6, socks_per_run: 6 }, is_active: true }
            ],
            productTypes: [
                { name: 'Wax', category: 'concentrate', unit_sizes: [{size: 1, label: '1g'}, {size: 4, label: '4g'}], packaging_type: 'jar', is_live_resin: false },
                { name: 'Sugar Wax', category: 'concentrate', unit_sizes: [{size: 1, label: '1g'}, {size: 4, label: '4g'}], packaging_type: 'jar', is_live_resin: false },
                { name: 'Shatter', category: 'concentrate', unit_sizes: [{size: 1, label: '1g'}], packaging_type: 'slab', is_live_resin: false },
                { name: 'Live Resin Carts', category: 'cart', unit_sizes: [{size: 1, label: '1g'}], packaging_type: 'cart', is_live_resin: true },
                { name: 'Live Resin AIOs', category: 'cart', unit_sizes: [{size: 1, label: '1g'}], packaging_type: 'aio', is_live_resin: true },
                { name: 'Brick Hash', category: 'concentrate', unit_sizes: [{size: 1, label: '1g'}, {size: 4, label: '4g'}], packaging_type: 'jar', is_live_resin: false }
            ],
            materialTypes: [
                { name: 'Trim', expected_yield: 13.00 },
                { name: 'Fresh Frozen', expected_yield: 3.50 },
                { name: 'Whole Flower', expected_yield: 18.00 }
            ]
        };

        async function loadConfig() {
            if (!supabaseClient) return;
            try {
                const { data: machines } = await supabaseClient.from('wm_machines').select('*').eq('is_active', true).order('sort_order');
                if (machines && machines.length > 0) {
                    CONFIG.machines = machines.map(m => ({ ...m, config: typeof m.config === 'string' ? JSON.parse(m.config) : (m.config || {}) }));
                } else { CONFIG.machines = CONFIG_DEFAULTS.machines; }

                const { data: products } = await supabaseClient.from('wm_product_types').select('*').eq('is_active', true).order('sort_order');
                if (products && products.length > 0) {
                    CONFIG.productTypes = products.map(p => ({ ...p, unit_sizes: typeof p.unit_sizes === 'string' ? JSON.parse(p.unit_sizes) : (p.unit_sizes || []) }));
                } else { CONFIG.productTypes = CONFIG_DEFAULTS.productTypes; }

                const { data: materials } = await supabaseClient.from('wm_material_types').select('*').eq('is_active', true).order('sort_order');
                if (materials && materials.length > 0) { CONFIG.materialTypes = materials; }
                else { CONFIG.materialTypes = CONFIG_DEFAULTS.materialTypes; }

                CONFIG.loaded = true;
                console.log('Admin Config loaded:', CONFIG);
                populateProductDropdowns();
                renderMachineButtons();
            } catch (err) {
                console.error('Error loading config:', err);
                CONFIG.machines = CONFIG_DEFAULTS.machines;
                CONFIG.productTypes = CONFIG_DEFAULTS.productTypes;
                CONFIG.materialTypes = CONFIG_DEFAULTS.materialTypes;
                CONFIG.loaded = true;
                // Still render buttons even with defaults
                populateProductDropdowns();
                renderMachineButtons();
            }
        }

        function populateProductDropdowns() {
            const selectors = ['#editFinalProductType', '#subBatchProductType', '#finalConsistency', '#packagingProductType'];
            selectors.forEach(sel => {
                const dd = document.querySelector(sel);
                if (dd && CONFIG.productTypes.length > 0) {
                    const val = dd.value;
                    dd.innerHTML = CONFIG.productTypes.filter(p => p.is_active !== false).map(p => '<option value="' + p.name + '">' + p.name + '</option>').join('');
                    if (val) dd.value = val;
                }
            });
        }

        function renderMachineButtons() {
            const machineContainer = document.getElementById('machineButtonsContainer');

            if (!machineContainer) return;

            // Use CONFIG.machines or defaults
            const machines = CONFIG.machines.length > 0 ? CONFIG.machines : CONFIG_DEFAULTS.machines;

            // Render machine status buttons
            machineContainer.innerHTML = machines.map((machine, idx) => {
                const machineKey = (machine.position?.toLowerCase() || machine.name.toLowerCase()).replace(/[^a-z0-9]/g, '');
                const machineType = machine.machine_type || 'bho';
                const config = machine.config || {};

                // Get icon based on machine type
                const icon = machineType === 'bho' ? '' : machineType === 'rosin' ? '' : '';

                // Build status display based on machine type
                let statusHtml = '';
                if (machineType === 'bho') {
                    // Dynamic column layout based on config
                    const numCols = Math.min(6, Math.max(2, config.columns || 6));
                    const columnLabels = ['A', 'B', 'C', 'D', 'E', 'F'].slice(0, numCols);
                    const colSize = numCols <= 3 ? 85 : 75;

                    // Build column circles - stack in rows of 3 for 4+ columns
                    let columnsHtml = '';
                    if (numCols <= 3) {
                        // Single row for 2-3 columns
                        columnsHtml = '<div style="display: flex; justify-content: center; gap: 10px; margin-bottom: 12px;">';
                        columnLabels.forEach(col => {
                            columnsHtml += '<button id="' + machineKey + 'Col' + col + 'Btn" onclick="event.stopPropagation(); openComponentSelector(\'' + machineKey + '\', \'column' + col + '\')" style="width: ' + colSize + 'px; height: ' + colSize + 'px; border-radius: 50%; border: 3px solid var(--accent-blue); background: linear-gradient(145deg, rgba(59,130,246,0.25) 0%, rgba(59,130,246,0.1) 100%); cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 5px; box-shadow: 0 4px 12px rgba(59,130,246,0.3);">' +
                                '<div style="font-weight: 700; color: var(--text-secondary); font-size: 0.7rem; margin-bottom: 2px;">' + col + '</div>' +
                                '<div id="' + machineKey + 'Col' + col + 'Strain" style="font-size: 0.7rem; font-weight: 600; color: var(--text-primary); text-align: center; line-height: 1.2; word-wrap: break-word; max-width: 90%; overflow: hidden;">-</div></button>';
                        });
                        columnsHtml += '</div>';
                    } else {
                        // Two rows for 4-6 columns (split evenly or 3+remainder)
                        const firstRowCount = Math.ceil(numCols / 2);
                        const firstRow = columnLabels.slice(0, firstRowCount);
                        const secondRow = columnLabels.slice(firstRowCount);

                        columnsHtml = '<div style="display: flex; justify-content: center; gap: 8px; margin-bottom: 8px;">';
                        firstRow.forEach(col => {
                            columnsHtml += '<button id="' + machineKey + 'Col' + col + 'Btn" onclick="event.stopPropagation(); openComponentSelector(\'' + machineKey + '\', \'column' + col + '\')" style="width: ' + colSize + 'px; height: ' + colSize + 'px; border-radius: 50%; border: 3px solid var(--accent-blue); background: linear-gradient(145deg, rgba(59,130,246,0.25) 0%, rgba(59,130,246,0.1) 100%); cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 5px; box-shadow: 0 4px 12px rgba(59,130,246,0.3);">' +
                                '<div style="font-weight: 700; color: var(--text-secondary); font-size: 0.7rem; margin-bottom: 2px;">' + col + '</div>' +
                                '<div id="' + machineKey + 'Col' + col + 'Strain" style="font-size: 0.7rem; font-weight: 600; color: var(--text-primary); text-align: center; line-height: 1.2; word-wrap: break-word; max-width: 90%; overflow: hidden;">-</div></button>';
                        });
                        columnsHtml += '</div><div style="display: flex; justify-content: center; gap: 8px; margin-bottom: 12px;">';
                        secondRow.forEach(col => {
                            columnsHtml += '<button id="' + machineKey + 'Col' + col + 'Btn" onclick="event.stopPropagation(); openComponentSelector(\'' + machineKey + '\', \'column' + col + '\')" style="width: ' + colSize + 'px; height: ' + colSize + 'px; border-radius: 50%; border: 3px solid var(--accent-blue); background: linear-gradient(145deg, rgba(59,130,246,0.25) 0%, rgba(59,130,246,0.1) 100%); cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 5px; box-shadow: 0 4px 12px rgba(59,130,246,0.3);">' +
                                '<div style="font-weight: 700; color: var(--text-secondary); font-size: 0.7rem; margin-bottom: 2px;">' + col + '</div>' +
                                '<div id="' + machineKey + 'Col' + col + 'Strain" style="font-size: 0.7rem; font-weight: 600; color: var(--text-primary); text-align: center; line-height: 1.2; word-wrap: break-word; max-width: 90%; overflow: hidden;">-</div></button>';
                        });
                        columnsHtml += '</div>';
                    }

                    // Pot and filter row
                    statusHtml = '<div style="margin-top: 10px;">' + columnsHtml +
                        '<div style="display: flex; justify-content: center; align-items: center; gap: 20px;">' +
                        // Pot circle
                        '<button id="' + machineKey + 'PotBtn" onclick="event.stopPropagation(); openComponentSelector(\'' + machineKey + '\', \'pot\')" style="width: 120px; height: 120px; border-radius: 50%; border: 4px solid var(--accent-purple); background: linear-gradient(145deg, rgba(147,51,234,0.3) 0%, rgba(147,51,234,0.1) 100%); cursor: pointer; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 8px; box-shadow: 0 6px 20px rgba(147,51,234,0.4);">' +
                        '<div id="' + machineKey + 'PotStrain" style="font-size: 0.8rem; font-weight: 700; color: var(--text-primary); text-align: center; line-height: 1.2;">Empty</div>' +
                        '<div id="' + machineKey + 'PotRuns" style="font-size: 0.7rem; color: var(--text-secondary); margin-top: 2px;"></div>' +
                        '<div id="' + machineKey + 'PotYield" style="font-size: 0.75rem; font-weight: 600; color: var(--accent-green); margin-top: 2px;"></div></button>' +
                        // Filter circle
                        '<button id="' + machineKey + 'FilterBtn" onclick="event.stopPropagation(); openComponentSelector(\'' + machineKey + '\', \'filter\')" style="width: 60px; height: 60px; border-radius: 50%; border: 3px solid var(--accent-green); background: linear-gradient(145deg, rgba(16,185,129,0.25) 0%, rgba(16,185,129,0.1) 100%); cursor: pointer; display: flex; align-items: center; justify-content: center; box-shadow: 0 4px 12px rgba(16,185,129,0.3);">' +
                        '<div id="' + machineKey + 'FilterRuns" style="font-size: 1rem; font-weight: 700; color: var(--text-primary);">0</div></button>' +
                        '</div></div>';
                } else if (machineType === 'rosin') {
                    statusHtml = '<div>Wash 1: <span id="' + machineKey + 'Wash1">Empty</span></div>';
                    if (config.second_wash === true) {
                        statusHtml += '<div>Wash 2: <span id="' + machineKey + 'Wash2">Empty</span></div>';
                    }
                } else if (machineType === 'resinator') {
                    statusHtml = '<div>Sift 1: <span id="' + machineKey + 'Sift1">Empty</span></div>';
                    if (config.second_sift === true) {
                        statusHtml += '<div>Sift 2: <span id="' + machineKey + 'Sift2">Empty</span></div>';
                    }
                }

                // For BHO machines with circular buttons, use a div container instead of button
                if (machineType === 'bho') {
                    return '<div class="btn" onclick="openMachineModal(\'' + machineKey + '\')" style="cursor: pointer; background: var(--bg-secondary); border: 2px solid #C0C0C0; color: #E8E8E8; padding: 15px; text-align: left; box-shadow: 0 0 15px rgba(192, 192, 192, 0.4), 0 0 30px rgba(192, 192, 192, 0.2), inset 0 0 15px rgba(192, 192, 192, 0.05); border-radius: 16px;">' +
                        '<div style="font-weight: 700; margin-bottom: 5px; text-align: center;">' + icon + ' ' + machine.name + '</div>' +
                        '<div id="' + machineKey + 'MachineStatus" style="font-size: 0.85rem;">' + statusHtml + '</div>' +
                    '</div>';
                }
                return '<button class="btn" style="background: transparent; border: 2px solid #C0C0C0; color: #E8E8E8; padding: 20px; text-align: left; box-shadow: 0 0 15px rgba(192, 192, 192, 0.4), 0 0 30px rgba(192, 192, 192, 0.2), inset 0 0 15px rgba(192, 192, 192, 0.05);" onclick="openMachineModal(\'' + machineKey + '\')">' +
                    '<div style="font-weight: 700; margin-bottom: 8px;">' + icon + ' ' + machine.name + '</div>' +
                    '<div id="' + machineKey + 'MachineStatus" style="font-size: 0.85rem; opacity: 0.9;">' + statusHtml + '</div>' +
                '</button>';
            }).join('');
        }

        function getExpectedYieldFromConfig(materialType) {
            const mat = CONFIG.materialTypes.find(m => m.name.toLowerCase() === materialType?.toLowerCase());
            return mat ? parseFloat(mat.expected_yield) : 13;
        }

        

        // Initialize on load
        document.addEventListener('DOMContentLoaded', function() {
            // Fetch version from GitHub
            fetch('https://api.github.com/repos/wmconcentrates/wm-tracker/commits/main')
                .then(r => r.json())
                .then(data => {
                    const shortHash = data.sha ? data.sha.substring(0, 7) : 'unknown';
                    document.getElementById('versionTag').textContent = 'v' + shortHash;
                })
                .catch(() => {
                    document.getElementById('versionTag').textContent = 'v?';
                });

            // Setup PIN login
            const pinInput = document.getElementById('pinInput');
            const loginBtn = document.getElementById('loginBtn');
            
            if (pinInput) {
                pinInput.addEventListener('input', function() {
                    this.value = this.value.replace(/[^0-9]/g, '');
                });
            }
            
            // Check for existing session
            const savedRole = localStorage.getItem('wmRole');
            const sessionTime = localStorage.getItem('wmSession');
            
            // Session expires after 12 hours
            if (savedRole && sessionTime && (Date.now() - parseInt(sessionTime)) < 12 * 60 * 60 * 1000) {
                currentRole = ROLES[savedRole];
                if (currentRole) {
                    document.getElementById('pinInput').style.display = 'none';
                    document.getElementById('loginBtn').style.display = 'none';
                    document.getElementById('actionsMenu').style.display = 'block';
                    document.getElementById('userLogin').style.display = 'none';
                    document.getElementById('appContent').style.display = 'block';
                    document.getElementById('myStatsBtn').style.display = 'block';
                document.getElementById('logoutBtn').style.display = 'block'; if(!currentRole.salary){document.getElementById('timeClockBtn').style.display = 'block';} const isAdminUser = currentRole.isAdmin || currentRole.name.includes('Admin') || currentRole.name === 'Ryan' || currentRole.name === 'Alex'; if(isAdminUser){document.getElementById('viewTimecardsBtn').style.display = 'block'; document.getElementById('manageEmployeesBtn').style.display = 'block'; document.getElementById('adminConfigBtn').style.display = 'block'; document.getElementById('loginHistoryBtn').style.display = 'block'; document.getElementById('viewTrashBtn').style.display = 'block'; document.getElementById('leaflinkApprovalsBtn').style.display = 'block';}
                    document.getElementById('complianceBtn').style.display = 'block';
                    applyRolePermissions();
                    hidePINsForDemo(); // Hide PINs if in demo mode
                }
            }
            
            const savedUrl = localStorage.getItem('supabaseUrl');
            const savedKey = localStorage.getItem('supabaseKey');
            
            // Auto-connect with hardcoded credentials
            const SUPABASE_URL = 'https://nspmwcpvukehaqswaewt.supabase.co';
            const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im5zcG13Y3B2dWtlaGFxc3dhZXd0Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjE0NzE2NDQsImV4cCI6MjA3NzA0NzY0NH0.JGYZ4223nhgO_Er619DkB0tOXrIJzfldG9yNkaHCdtI';
            
            if (SUPABASE_URL !== 'YOUR_SUPABASE_URL_HERE' && SUPABASE_KEY !== 'YOUR_SUPABASE_KEY_HERE') {
                // Use hardcoded credentials
                connectSupabase(SUPABASE_URL, SUPABASE_KEY);
            } else if (savedUrl && savedKey) {
                // Fallback to saved credentials
                connectSupabase(savedUrl, savedKey);
            } else {
                // Show setup form
                document.getElementById('setupSection').classList.remove('hidden');
            }
        });

        // Credentials form
        document.getElementById('credentialsForm').addEventListener('submit', async function(e) {
            e.preventDefault();
            const url = document.getElementById('supabaseUrl').value.trim();
            const key = document.getElementById('supabaseKey').value.trim();
            
            localStorage.setItem('supabaseUrl', url);
            localStorage.setItem('supabaseKey', key);
            
            await connectSupabase(url, key);
        });

        async function connectSupabase(url, key) {
            try {
                updateConnectionStatus('connecting', 'Connecting...');
                
                supabaseClient = window.supabase.createClient(url, key);
                
                // Test connection and setup table
                try {
                    await setupDatabase();
                } catch (dbError) {
                    console.error('Database setup error:', dbError);
                    throw new Error('Database setup failed: ' + dbError.message);
                }
                
                // Load employees from database
                try {
                    await loadEmployees();
                    console.log('Employees loaded from database');
                } catch (empError) {
                    console.error('Error loading employees:', empError);
                }

                // Load admin config (machines, products, materials)
                try {
                    await loadConfig();
                } catch (configError) {
                    console.error("Error loading config:", configError);
                }

                // Load businesses for multi-tenant support
                try {
                    await loadBusinesses();
                } catch (bizError) {
                    console.error("Error loading businesses:", bizError);
                }

                // Load batches
                try {
                    await loadBatches();
                    updateMachineDisplays(); // Load machine status
                    updateSuppliesButton(); // Load inventory levels
                } catch (loadError) {
                    console.error('Load batches error:', loadError);
                    throw new Error('Failed to load batches: ' + loadError.message);
                }
                
                // Setup realtime subscription
                setupRealtime();
                
                // Show app
                document.getElementById('setupSection').classList.add('hidden');
                document.getElementById('appContainer').classList.add('active');
                
                updateConnectionStatus('connected', 'Connected');
                
                // Initialize app
                initializeApp(); initializeTimeclock();

                // Re-check saved session now that employees are loaded from database
                const savedRole = localStorage.getItem('wmRole');
                const sessionTime = localStorage.getItem('wmSession');
                if (savedRole && sessionTime && (Date.now() - parseInt(sessionTime)) < 12 * 60 * 60 * 1000) {
                    if (ROLES[savedRole] && !currentRole) {
                        currentRole = ROLES[savedRole];
                        document.getElementById('pinInput').style.display = 'none';
                        document.getElementById('loginBtn').style.display = 'none';
                        document.getElementById('actionsMenu').style.display = 'block';
                        document.getElementById('userLogin').style.display = 'none';
                        document.getElementById('appContent').style.display = 'block';
                        document.getElementById('myStatsBtn').style.display = 'block';
                        document.getElementById('logoutBtn').style.display = 'block';
                        if(!currentRole.salary) document.getElementById('timeClockBtn').style.display = 'block';
                        const isAdminCheck = currentRole.isAdmin || currentRole.name.includes('Admin') || currentRole.name === 'Ryan' || currentRole.name === 'Alex';
                        if(isAdminCheck) {
                            document.getElementById('viewTimecardsBtn').style.display = 'block';
                            document.getElementById('manageEmployeesBtn').style.display = 'block'; document.getElementById('adminConfigBtn').style.display = 'block';
                            document.getElementById('loginHistoryBtn').style.display = 'block';
                            document.getElementById('viewTrashBtn').style.display = 'block';
                            document.getElementById('leaflinkApprovalsBtn').style.display = 'block';
                        }
                        document.getElementById('complianceBtn').style.display = 'block';
                        applyRolePermissions();
                        hidePINsForDemo();
                    }
                }
                
            } catch (error) {
                console.error('Connection error:', error);
                updateConnectionStatus('disconnected', 'Connection Failed');
                alert('Failed to connect to Supabase.\n\nError: ' + error.message + '\n\nPlease check:\n1. URL is correct (https://xxxxx.supabase.co)\n2. Anon key is correct\n3. Project is not paused');
            }
        }

        async function setupDatabase() {
            // Check if table exists by trying to query it
            const { data, error } = await supabaseClient
                .from('wm_batches')
                .select('id')
                .limit(1);
            
            if (error && error.code === '42P01') {
                // Table doesn't exist, create it
                console.log('Creating wm_batches table...');
                
                // We can't create tables via JS client, so show instructions
                const createTableSQL = `
CREATE TABLE wm_batches (
    id TEXT PRIMARY KEY,
    strain TEXT NOT NULL,
    strain_type TEXT NOT NULL,
    trim_weight DECIMAL(10,2) NOT NULL,
    material_cost DECIMAL(10,2) NOT NULL,
    material_agreement TEXT,
    cultivation_license TEXT NOT NULL,
    grower_name TEXT,
    metrc_tags TEXT,
    intake_date DATE NOT NULL,
    planned_products JSONB NOT NULL,
    intake_notes TEXT,
    status TEXT NOT NULL DEFAULT 'intake',
    intake_user TEXT NOT NULL,
    timeline JSONB NOT NULL DEFAULT '[]'::jsonb,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    -- Extraction fields
    extraction_date DATE,
    extraction_method TEXT,
    extraction_machine TEXT,
    extraction_runs INTEGER,
    extraction_slabs INTEGER,
    extraction_bowls INTEGER,
    extraction_notes TEXT,
    butane_used DECIMAL(10,2),
    nitrogen_tanks_used DECIMAL(5,2),
    product_made TEXT,
    crude_weight DECIMAL(10,2),
    extraction_user TEXT,
    extraction_yield DECIMAL(5,2),
    extraction_paused BOOLEAN DEFAULT FALSE,
    bulk_jars_count INTEGER,
    shatter_slabs_count INTEGER,
    sift_weight DECIMAL(10,2),
    adjusted_trim_weight DECIMAL(10,2),
    sift_sub_batch_created BOOLEAN DEFAULT FALSE,
    sift_sub_batch_id TEXT,
    parent_batch_id TEXT,
    is_sub_batch BOOLEAN DEFAULT FALSE,
    consumed_by TEXT,
    combined_trim_weight DECIMAL(10,2),
    total_socks_extracted INTEGER,
    pre_sift TEXT,
    
    -- Finishing fields
    finishing_date DATE,
    final_weight DECIMAL(10,2),
    sample_weight DECIMAL(10,2),
    test_results_expected_date DATE,
    finishing_notes TEXT,
    finishing_user TEXT,
    net_weight DECIMAL(10,2),
    
    -- Test results fields
    test_results_received_date DATE,
    test_thc_percent DECIMAL(5,2),
    test_cbd_percent DECIMAL(5,2),
    test_lab_name TEXT,
    test_sample_id TEXT,
    test_results_notes TEXT,
    
    -- Packaging fields
    packaging_date DATE,
    packaged_product_type TEXT,
    units_packaged INTEGER,
    units_1g INTEGER,
    units_4g INTEGER,
    total_grams_packaged DECIMAL(10,2),
    packaging_breakdown TEXT,
    packaging_paused BOOLEAN DEFAULT FALSE,
    thc_percent DECIMAL(5,2),
    cbd_percent DECIMAL(5,2),
    ready_to_list TEXT,
    wholesale_price DECIMAL(10,2),
    leaflink_description TEXT,
    packaging_notes TEXT,
    packaging_user TEXT,
    
    -- Labeling fields
    labeling_paused BOOLEAN DEFAULT FALSE,

    -- COGS fields (for costing tab)
    calculated_cogs DECIMAL(10,2),
    labor_cost DECIMAL(10,2),
    consumables_cost DECIMAL(10,2),
    overhead_allocated DECIMAL(10,2),
    cost_per_unit DECIMAL(10,4),

    completed_at TIMESTAMP WITH TIME ZONE
);

-- Enable realtime
ALTER PUBLICATION supabase_realtime ADD TABLE wm_batches;

-- =============================================
-- COSTING TABLES (run these in Supabase SQL Editor)
-- =============================================

-- Cost configuration table
CREATE TABLE IF NOT EXISTS wm_cost_config (
    id SERIAL PRIMARY KEY,
    business_id UUID REFERENCES wm_businesses(id),
    config_type TEXT NOT NULL,
    config_key TEXT NOT NULL,
    config_value DECIMAL(10,2),
    unit TEXT,
    updated_at TIMESTAMPTZ DEFAULT NOW(),
    UNIQUE(business_id, config_type, config_key)
);

-- Target margins table
CREATE TABLE IF NOT EXISTS wm_target_margins (
    id SERIAL PRIMARY KEY,
    business_id UUID REFERENCES wm_businesses(id),
    product_type TEXT NOT NULL,
    target_margin_pct DECIMAL(5,2) DEFAULT 40.00,
    UNIQUE(business_id, product_type)
);

-- Add hourly_rate to employees
ALTER TABLE wm_employees ADD COLUMN IF NOT EXISTS hourly_rate DECIMAL(10,2) DEFAULT 0;

-- Add COGS columns to batches (if not already present)
ALTER TABLE wm_batches ADD COLUMN IF NOT EXISTS calculated_cogs DECIMAL(10,2);
ALTER TABLE wm_batches ADD COLUMN IF NOT EXISTS labor_cost DECIMAL(10,2);
ALTER TABLE wm_batches ADD COLUMN IF NOT EXISTS consumables_cost DECIMAL(10,2);
ALTER TABLE wm_batches ADD COLUMN IF NOT EXISTS overhead_allocated DECIMAL(10,2);
ALTER TABLE wm_batches ADD COLUMN IF NOT EXISTS cost_per_unit DECIMAL(10,4);
                `;
                
                alert(`Please run this SQL in your Supabase SQL Editor:\n\n${createTableSQL}\n\nThen refresh this page.`);
                throw new Error('Table setup required');
            }
            
            // Get the highest batch number
            const { data: maxBatch } = await supabaseClient
                .from('wm_batches')
                .select('id')
                .order('id', { ascending: false })
                .limit(1);
            
            if (maxBatch && maxBatch.length > 0) {
                const lastId = maxBatch[0].id;
                const num = parseInt(lastId.split('-')[1]);
                batchCounter = num + 1;
            }
        }

        // Update pause button visibility and text based on current batch selection
        function updatePauseButtons() {
            // Update extraction pause button
            const extractionBatchId = document.getElementById('extractionBatchSelect')?.value;
            const extractionBatch = batches.find(b => b.id === extractionBatchId);
            const extractionPauseBtn = document.getElementById('pauseExtractionBtn');
            
            if (extractionPauseBtn && extractionBatch) {
                // Show button only if batch has been started (has extraction_method or timeline entry)
                const hasStarted = extractionBatch.extraction_method || 
                                  (extractionBatch.timeline || []).some(t => t.stage === 'extraction');
                
                if (hasStarted && extractionBatch.status === 'intake') {
                    extractionPauseBtn.style.display = 'block';
                    const isPaused = extractionBatch.extraction_paused || false;
                    extractionPauseBtn.innerHTML = isPaused ? ' Resume' : ' Pause';
                    extractionPauseBtn.style.background = isPaused ? 'var(--accent-blue)' : 'var(--accent-orange)';
                } else {
                    extractionPauseBtn.style.display = 'none';
                }
            }
            
            // Update packaging pause button
            const packagingBatchId = document.getElementById('packagingBatchSelect')?.value;
            const packagingBatch = batches.find(b => b.id === packagingBatchId);
            const packagingPauseBtn = document.getElementById('pausePackagingBtn');
            
            if (packagingPauseBtn && packagingBatch) {
                const hasStarted = packagingBatch.product_type || 
                                  (packagingBatch.timeline || []).some(t => t.stage === 'packaging');
                
                if (hasStarted && packagingBatch.status === 'finishing') {
                    packagingPauseBtn.style.display = 'block';
                    const isPaused = packagingBatch.packaging_paused || false;
                    packagingPauseBtn.innerHTML = isPaused ? ' Resume' : ' Pause';
                    packagingPauseBtn.style.background = isPaused ? 'var(--accent-blue)' : 'var(--accent-orange)';
                } else {
                    packagingPauseBtn.style.display = 'none';
                }
            }
            
            // Update labeling pause button
            const labelingBatchId = document.getElementById('labelingBatchSelect')?.value;
            const labelingBatch = batches.find(b => b.id === labelingBatchId);
            const labelingPauseBtn = document.getElementById('pauseLabelingBtn');

            if (labelingPauseBtn && labelingBatch) {
                const hasStarted = labelingBatch.labeling_user || (labelingBatch.timeline || []).some(t => t.stage === 'labeling');

                if (hasStarted && labelingBatch.status === 'complete' && !labelingBatch.labels_applied) {
                    labelingPauseBtn.style.display = 'block';
                    const isPaused = labelingBatch.labeling_paused || false;
                    labelingPauseBtn.innerHTML = isPaused ? ' Resume' : ' Pause';
                    labelingPauseBtn.style.background = isPaused ? 'var(--accent-blue)' : 'var(--accent-orange)';
                } else {
                    labelingPauseBtn.style.display = 'none';
                }
            }
        }

        // Admin helper to fix batch status (call from console: fixBatchStatus('9.30.5622', 'finishing'))
        window.fixBatchStatus = async function(batchId, newStatus) {
            if (!supabaseClient) {
                console.error('Supabase not connected');
                return;
            }
            const validStatuses = ['intake', 'extraction', 'finishing', 'packaging', 'complete'];
            if (!validStatuses.includes(newStatus)) {
                console.error('Invalid status. Use one of:', validStatuses);
                return;
            }
            const { error } = await supabaseClient
                .from('wm_batches')
                .update({ status: newStatus })
                .eq('id', batchId);
            if (error) {
                console.error('Error updating batch:', error);
            } else {
                console.log(`Batch ${batchId} status updated to "${newStatus}". Refreshing...`);
                await loadBatches();
                alert(`Batch ${batchId} status reset to "${newStatus}"`);
            }
        };
        
        // Admin helper to revert batch to testing status (call from console: revertToTesting('9.30.5622'))
        window.revertToTesting = async function(batchId) {
            if (!supabaseClient) {
                console.error('Supabase not connected');
                return;
            }
            const batch = batches.find(b => b.id === batchId);
            if (!batch) {
                console.error('Batch not found:', batchId);
                return;
            }
            const timeline = batch.timeline || [];
            timeline.push({
                stage: 'admin_revert',
                user: currentRole ? currentRole.name : 'Admin',
                date: new Date().toISOString(),
                action: 'Batch reverted to testing queue'
            });
            const { error } = await supabaseClient
                .from('wm_batches')
                .update({
                    status: 'packaging',
                    labels_applied: false,
                    labeling_date: null,
                    labeling_user: null,
                    labeling_notes: null,
                    completed_at: null,
                    timeline: timeline
                })
                .eq('id', batchId);
            if (error) {
                console.error('Error reverting batch:', error);
            } else {
                console.log('Batch ' + batchId + ' reverted to testing. Refreshing...');
                await loadBatches();
                alert('Batch ' + batchId + ' has been reverted to Testing queue');
            }
        };

        async function loadBatches() {
            // Use demo data if in demo mode
            if (isDemoMode()) {
                batches = generateDemoBatches();
                updateDashboard();
                renderBatches();
                updateSuppliesButton();
                updateMachineDisplays();
                populateExtractionQueue(); // Refresh extraction queue

                if (!window.searchFiltersInitialized) {
                    setTimeout(() => {
                        addDropdownSearchFilters();
                        window.searchFiltersInitialized = true;
                    }, 500);
                }
                return;
            }

            let query = supabaseClient
                .from('wm_batches')
                .select('*')
                .neq('status', 'deleted');

            // Filter by business if one is selected
            if (currentBusinessId && currentBusinessId !== 'all') {
                query = query.eq('business_id', currentBusinessId);
            }

            const { data, error } = await query.order('created_at', { ascending: false });

            if (error) {
                console.error('Error loading batches:', error);
                return;
            }

            batches = data || [];
            updateDashboard();
            renderBatches();
            renderWasteLog(); // Update waste log display
            updateSuppliesButton(); // Update supplies button display
            updateMachineDisplays(); // Update machine status displays
            populateExtractionQueue(); // Refresh extraction queue

            // Initialize dropdown search filters (only once)
            if (!window.searchFiltersInitialized) {
                setTimeout(() => {
                    addDropdownSearchFilters();
                    window.searchFiltersInitialized = true;
                }, 500);
            }
        }

        function setupRealtime() {
            if (realtimeChannel) {
                realtimeChannel.unsubscribe();
            }
            
            realtimeChannel = supabaseClient
                .channel('wm_batches_changes')
                .on('postgres_changes',
                    { event: '*', schema: 'public', table: 'wm_batches' },
                    () => {
                        loadBatches(); // Reload on any change
                    }
                )
                .subscribe();
        }

        // Celebration function for completed tasks
        function showCelebration(options = {}) {
            // Remove any existing celebrations first
            document.querySelectorAll('.celebration-overlay').forEach(el => el.remove());
            document.querySelectorAll('.confetti-piece').forEach(el => el.remove());
            document.querySelectorAll('.laser-container').forEach(el => el.remove());
            document.querySelectorAll('.fire-container').forEach(el => el.remove());

            const {
                emoji = '',
                title = 'Great Job!',
                message = 'Task completed successfully!',
                stats = [],
                confettiCount = 50,
                laserCount = 8,
                showFire = true,
                buttonText = 'Awesome!'
            } = options;

            // Create confetti - neon laser colors
            const colors = ['#39ff14', '#0055ff', '#ff10f0', '#bf00ff', '#ff0055', '#ff6b00'];
            const shapes = ['square', 'circle'];

            for (let i = 0; i < confettiCount; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'confetti-piece';
                const color = colors[Math.floor(Math.random() * colors.length)];
                confetti.style.left = Math.random() * 100 + 'vw';
                confetti.style.background = color;
                confetti.style.boxShadow = `0 0 6px ${color}, 0 0 10px ${color}`;
                confetti.style.borderRadius = shapes[Math.floor(Math.random() * shapes.length)] === 'circle' ? '50%' : '2px';
                confetti.style.width = (Math.random() * 10 + 5) + 'px';
                confetti.style.height = (Math.random() * 10 + 5) + 'px';
                confetti.style.animationDuration = (Math.random() * 2 + 2) + 's';
                confetti.style.animationDelay = (Math.random() * 0.5) + 's';
                document.body.appendChild(confetti);

                // Remove confetti after animation
                setTimeout(() => confetti.remove(), 4500);
            }

            // Create laser show from top
            const laserContainer = document.createElement('div');
            laserContainer.className = 'laser-container';
            document.body.appendChild(laserContainer);

            const laserColors = ['#39ff14', '#0055ff', '#ff10f0', '#bf00ff', '#ff0055', '#ff6b00'];

            for (let i = 0; i < laserCount; i++) {
                const laser = document.createElement('div');
                laser.className = 'laser-beam';
                const color = laserColors[i % laserColors.length];
                laser.style.background = `linear-gradient(to bottom, ${color}, transparent 70%)`;
                laser.style.color = color;
                laser.style.boxShadow = `0 0 15px ${color}, 0 0 30px ${color}`;

                // Position lasers across the top, fanning out
                const spreadAngle = 120; // degrees of spread
                const startAngle = -spreadAngle / 2;
                const angleStep = spreadAngle / (laserCount - 1 || 1);
                const angle = startAngle + (i * angleStep);

                laser.style.left = `${10 + (i / laserCount) * 80}%`;
                laser.style.top = '0';
                laser.style.transformOrigin = 'top center';
                laser.style.transform = `rotate(${angle}deg)`;
                laser.style.animation = `laser-pulse ${0.8 + Math.random() * 0.4}s ease-in-out infinite`;

                // Sweep animation
                let currentAngle = angle;
                const sweepSpeed = (Math.random() - 0.5) * 4;
                const rotateInterval = setInterval(() => {
                    currentAngle += sweepSpeed;
                    // Bounce back at limits
                    if (currentAngle > 60 || currentAngle < -60) {
                        currentAngle = Math.max(-60, Math.min(60, currentAngle));
                    }
                    laser.style.transform = `rotate(${currentAngle}deg)`;
                }, 50);

                laserContainer.appendChild(laser);

                setTimeout(() => clearInterval(rotateInterval), 5000);
            }

            // Remove laser container after animation
            setTimeout(() => laserContainer.remove(), 5000);

            // Create fire cannons (if enabled)
            if (showFire) {
            const fireContainer = document.createElement('div');
            fireContainer.className = 'fire-container';
            document.body.appendChild(fireContainer);

            // Fire cannon positions (left and right corners, and center)
            const cannonPositions = [10, 50, 90];
            const fireColors = ['#ff6b00', '#ff0055', '#ffff00', '#ff10f0'];

            // Create base cannon glow
            cannonPositions.forEach(pos => {
                const cannon = document.createElement('div');
                cannon.className = 'fire-cannon';
                cannon.style.left = `${pos - 3}%`;
                fireContainer.appendChild(cannon);
                setTimeout(() => cannon.remove(), 3000);
            });

            // Shoot fire particles
            const shootParticles = () => {
                cannonPositions.forEach(pos => {
                    for (let i = 0; i < 5; i++) {
                        const particle = document.createElement('div');
                        particle.className = 'fire-particle';
                        const color = fireColors[Math.floor(Math.random() * fireColors.length)];
                        const size = 10 + Math.random() * 20;
                        particle.style.width = size + 'px';
                        particle.style.height = size + 'px';
                        particle.style.left = `${pos + (Math.random() - 0.5) * 10}%`;
                        particle.style.background = `radial-gradient(circle, ${color}, transparent)`;
                        particle.style.boxShadow = `0 0 ${size}px ${color}, 0 0 ${size * 2}px ${color}`;
                        particle.style.animationDuration = (0.8 + Math.random() * 0.5) + 's';
                        particle.style.animationDelay = (Math.random() * 0.1) + 's';
                        fireContainer.appendChild(particle);

                        setTimeout(() => particle.remove(), 1500);
                    }
                });
            };

            // Shoot multiple bursts
            shootParticles();
            setTimeout(shootParticles, 300);
            setTimeout(shootParticles, 600);
            setTimeout(shootParticles, 900);
            setTimeout(shootParticles, 1200);

            // Remove fire container after animation
            setTimeout(() => fireContainer.remove(), 3000);
            }

            // Build stats HTML
            let statsHtml = '';
            if (stats.length > 0) {
                statsHtml = `<div class="celebration-stats">
                    ${stats.map(s => `
                        <div class="celebration-stat">
                            <div class="celebration-stat-value">${s.value}</div>
                            <div class="celebration-stat-label">${s.label}</div>
                        </div>
                    `).join('')}
                </div>`;
            }

            // Create celebration overlay
            const overlay = document.createElement('div');
            overlay.className = 'celebration-overlay';
            overlay.innerHTML = `
                <div class="celebration-content">
                    <div class="celebration-emoji">${emoji}</div>
                    <div class="celebration-title">${title}</div>
                    <div class="celebration-message">${message}</div>
                    ${statsHtml}
                    <button class="celebration-btn" onclick="this.closest('.celebration-overlay').remove()">
                        ${buttonText}
                    </button>
                </div>
            `;
            document.body.appendChild(overlay);

            // Auto-close after 10 seconds
            setTimeout(() => {
                if (overlay.parentNode) overlay.remove();
            }, 10000);

            // Close on overlay click (not content)
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) overlay.remove();
            });
        }

        function updateConnectionStatus(status, text) {
            const statusEl = document.getElementById('connectionStatus');
            const textEl = document.getElementById('statusText');
            
            statusEl.className = `connection-status ${status}`;
            textEl.textContent = text;
        }

        // PIN Login
        function login() {
            const pin = document.getElementById('pinInput').value;
            const errorMsg = document.getElementById('loginError');
            
            if (pin.length !== 4) {
                errorMsg.textContent = 'Please enter a 4-digit PIN';
                errorMsg.style.display = 'block';
                setTimeout(() => errorMsg.style.display = 'none', 3000);
                return;
            }
            
            // Find role by PIN
            const roleKey = Object.keys(ROLES).find(key => ROLES[key].pin === pin);
            
            if (roleKey) {
                // Successful login
                currentRole = ROLES[roleKey];

                // Enable DEMO_MODE if demo user logs in (blocks all database writes)
                if (currentRole.isDemo) {
                    DEMO_MODE = true;
                    document.getElementById('demoIndicator').style.display = 'block';
                }

                localStorage.setItem('wmRole', roleKey);
                const sessionId = Date.now();
                localStorage.setItem('wmSession', sessionId);
                localStorage.setItem('wmSessionId', sessionId); // Store session ID for logout tracking
                
                document.getElementById('pinInput').style.display = 'none';
                document.getElementById('loginBtn').style.display = 'none';
                document.getElementById('actionsMenu').style.display = 'block';
                document.getElementById('userLogin').style.display = 'none';
                document.getElementById('appContent').style.display = 'block';
                document.getElementById('myStatsBtn').style.display = 'block'; document.getElementById('logoutBtn').style.display = 'block'; if(!currentRole.salary){document.getElementById('timeClockBtn').style.display = 'block';} const isAdmin = currentRole.isAdmin || currentRole.name.includes('Admin') || currentRole.name === 'Ryan' || currentRole.name === 'Alex'; if(isAdmin){document.getElementById('viewTimecardsBtn').style.display = 'block'; document.getElementById('manageEmployeesBtn').style.display = 'block'; document.getElementById('adminConfigBtn').style.display = 'block'; document.getElementById('loginHistoryBtn').style.display = 'block'; document.getElementById('viewTrashBtn').style.display = 'block'; document.getElementById('leaflinkApprovalsBtn').style.display = 'block';}
                errorMsg.style.display = 'none';

                // Log login to database with IP (including demo mode)
                    // Fetch IP address and log login
                    console.log('Attempting to fetch IP...');
                    fetch('https://api.ipify.org?format=json')
                        .then(r => r.json())
                        .then(ipData => {
                            console.log('Got IP:', ipData.ip);
                            return supabaseClient
                                .from('wm_login_history')
                                .insert({
                                    user_name: currentRole.name,
                                    login_time: new Date().toISOString(),
                                    ip_address: ipData.ip
                                })
                                .select();
                        })
                        .then(({ data, error }) => {
                            console.log('Login insert result:', { data, error });
                            if (error) {
                                console.error('Error logging login:', error);
                            } else if (data && data.length > 0) {
                                // Store the login record ID for logout tracking
                                localStorage.setItem('wmLoginRecordId', data[0].id);
                            }
                        })
                        .catch(err => {
                            // If IP fetch fails, log without IP
                            console.error('IP FETCH FAILED:', err);
                            supabaseClient
                                .from('wm_login_history')
                                .insert({
                                    user_name: currentRole.name,
                                    login_time: new Date().toISOString()
                                })
                                .select()
                                .then(({ data, error }) => {
                                    if (!error && data && data.length > 0) {
                                        localStorage.setItem('wmLoginRecordId', data[0].id);
                                    }
                                });
                        });

                // Start activity tracking - update last_activity every 30 seconds when user is active
                startActivityTracking();

                applyRolePermissions();
                hidePINsForDemo(); // Hide PINs if in demo mode

                // Welcome celebration with random messages
                const welcomeMessages = [
                    // Original messages
                    "Ready to crush it today? Let's get to work!",
                    "Time to make some magic happen! ",
                    "Another day, another dab! ",
                    "May your yields be high and your temps be low! ",
                    "Time to turn trim into triumph! ",
                    // Movie quotes
                    "I'm kind of a big deal.  Anchorman",
                    "That's what she said.  The Office",
                    "I'm not even supposed to be here today!  Clerks",
                    "Alright, alright, alright.  Dazed and Confused",
                    "I'm gonna need you to come in on Saturday.  Office Space",
                    "So you're telling me there's a chance?  Dumb and Dumber",
                    "The Dude abides.  The Big Lebowski",
                    "Did we just become best friends?!  Step Brothers",
                    "Life moves pretty fast. If you don't stop and look around once in a while, you could miss it.  Ferris Bueller",
                    "I've got a fever, and the only prescription is more cowbell!  SNL",
                    "It's showtime!  Beetlejuice",
                    "Be excellent to each other.  Bill & Ted",
                    "You're gonna need a bigger boat.  Jaws",
                    "I ain't afraid of no ghosts!  Ghostbusters",
                    "Cinderella story, outta nowhere!  Caddyshack",
                    "How do you like them apples?  Good Will Hunting",
                    "I'm walkin' here!  Midnight Cowboy",
                    "You had me at hello.  Jerry Maguire",
                    "Just keep swimming.  Finding Nemo",
                    "To infinity and beyond!  Toy Story"
                ];
                const welcomeButtons = [
                    "Hell yes!",
                    "Let's gooo!",
                    "I'm ready!",
                    "Heck yeah!",
                    "Let's crush it!",
                    "Born ready!",
                    "LFG! ",
                    "Oh yeahhh!",
                    "Groovy!",
                    "Excellent!",
                    "Alrighty then!",
                    "I'm on it!",
                    "Let's do this!",
                    "Party on!",
                    "Cowabunga!"
                ];
                const randomMessage = welcomeMessages[Math.floor(Math.random() * welcomeMessages.length)];
                const randomButton = welcomeButtons[Math.floor(Math.random() * welcomeButtons.length)];

                showCelebration({
                    emoji: '',
                    title: `Welcome, ${currentRole.name}!`,
                    message: randomMessage,
                    stats: [],
                    confettiCount: 0,
                    laserCount: 24,
                    showFire: false,
                    buttonText: randomButton
                });
            } else {
                // Failed login
                errorMsg.textContent = 'Invalid PIN. Please try again.';
                errorMsg.style.display = 'block';
                document.getElementById('pinInput').value = '';
                setTimeout(() => errorMsg.style.display = 'none', 3000);
            }
        }

        function logout() {
            // Hide actions menu
            document.getElementById('actionsMenu').style.display = 'none';

            // Cleanup realtime subscription
            if (realtimeChannel) {
                realtimeChannel.unsubscribe();
                realtimeChannel = null;
            }

            const loginRecordId = localStorage.getItem('wmLoginRecordId');
            const sessionStart = parseInt(localStorage.getItem('wmSession'));

            const clearAndReload = () => {
                localStorage.removeItem('wmRole');
                localStorage.removeItem('wmSession');
                localStorage.removeItem('wmSessionId');
                localStorage.removeItem('wmLoginRecordId');
                location.reload();
            };

            if (loginRecordId && sessionStart) {
                const sessionDuration = Math.floor((Date.now() - sessionStart) / 1000 / 60); // minutes

                // Update logout time and duration
                supabaseClient
                    .from('wm_login_history')
                    .update({
                        logout_time: new Date().toISOString(),
                        session_duration: sessionDuration
                    })
                    .eq('id', loginRecordId)
                    .then(clearAndReload)
                    .catch(err => {
                        console.error('Logout update failed:', err);
                        clearAndReload();
                    });
            } else {
                clearAndReload();
            }
        }

        // Activity tracking - updates last_activity timestamp when user interacts
        let lastActivityUpdate = 0;
        let activityTimeout = null;

        function startActivityTracking() {
            // Track user activity on clicks and key presses
            document.addEventListener('click', recordActivity);
            document.addEventListener('keypress', recordActivity);
            document.addEventListener('touchstart', recordActivity);

            // Also update every 30 seconds if there's been any activity
            setInterval(() => {
                if (Date.now() - lastActivityUpdate < 60000) { // Activity in last minute
                    updateLastActivity();
                }
            }, 30000);
        }

        function recordActivity() {
            lastActivityUpdate = Date.now();
            // Debounce - only actually update DB every 30 seconds max
            if (!activityTimeout) {
                activityTimeout = setTimeout(() => {
                    updateLastActivity();
                    activityTimeout = null;
                }, 5000); // Wait 5 seconds of inactivity before updating
            }
        }

        function updateLastActivity() {
            const loginRecordId = localStorage.getItem('wmLoginRecordId');
            if (!loginRecordId || !supabaseClient) return;

            supabaseClient
                .from('wm_login_history')
                .update({ last_activity: new Date().toISOString() })
                .eq('id', loginRecordId)
                .then(() => {})
                .catch(err => console.log('Activity update failed:', err));
        }

        // Close mobile station popup and return to app grid
        function closeMobileStation() {
            document.querySelectorAll('.station-content').forEach(c => c.classList.remove('active'));
            document.querySelectorAll('.station-tab').forEach(t => t.classList.remove('active'));
        }

        // Swipe gesture detection for mobile navigation
        (function initSwipeGestures() {
            let touchStartX = 0;
            let touchStartY = 0;
            let touchEndX = 0;
            let touchEndY = 0;

            document.addEventListener('touchstart', function(e) {
                touchStartX = e.changedTouches[0].screenX;
                touchStartY = e.changedTouches[0].screenY;
            }, { passive: true });

            document.addEventListener('touchend', function(e) {
                touchEndX = e.changedTouches[0].screenX;
                touchEndY = e.changedTouches[0].screenY;
                handleSwipe();
            }, { passive: true });

            function handleSwipe() {
                const diffX = touchEndX - touchStartX;
                const diffY = touchEndY - touchStartY;
                const minSwipeDistance = 100;

                // Only trigger if horizontal swipe is dominant
                if (Math.abs(diffX) > Math.abs(diffY)) {
                    // Swipe right to go back
                    if (diffX > minSwipeDistance) {
                        const activeStation = document.querySelector('.station-content.active');
                        if (activeStation && window.innerWidth <= 768) {
                            closeMobileStation();
                        }
                    }
                }
            }
        })();

        function applyRolePermissions() {
            if (!currentRole) return;
            
            // Show/hide tabs based on role
            document.querySelectorAll('.station-tab').forEach(tab => {
                const station = tab.dataset.station;
                if (currentRole.tabs.includes(station)) {
                    tab.style.display = '';
                } else {
                    tab.style.display = 'none';
                }
            });
            
            // Show first available tab (skip on mobile - let user pick from app grid)
            const isMobile = window.innerWidth <= 768;
            if (!isMobile) {
                const firstTab = document.querySelector('.station-tab[style=""]') || document.querySelector('.station-tab:not([style*="display: none"])');
                if (firstTab) {
                    firstTab.click();
                }
            }
        }

        // Station tabs
        document.querySelectorAll('.station-tab').forEach(tab => {
            tab.addEventListener('click', function() {
                const station = this.dataset.station;
                
                document.querySelectorAll('.station-tab').forEach(t => t.classList.remove('active'));
                this.classList.add('active');
                
                document.querySelectorAll('.station-content').forEach(c => c.classList.remove('active'));
                document.getElementById(station).classList.add('active');
                
                // Scroll to top when opening station on mobile
                window.scrollTo(0, 0);

                if (station === 'dashboard') {
                    updateDashboard();
                    renderBatches();
                    renderWasteLog();
                } else if (station === 'analytics') {
                    updateAnalytics();
                } else if (station === 'performance') {
                    renderPerformanceAnalytics();
                } else if (station === 'extraction') {
                    populateExtractionQueue();
                } else if (station === 'finishing') {
                    populateFinishingSelect();
                } else if (station === 'packaging') {
                    populatePackagingSelect();
                } else if (station === 'testing') {
                    populateTestingSelect();
                    checkRTAStatus();
                } else if (station === 'labeling') {
                    populateLabelingSelect();
                } else if (station === 'frontofhouse') {
                    loadFOHRecentBatches();
                    loadFOHPosts();
                    // Note: Sales dashboard moved to dedicated Sales tab
                    loadSalesDashboard(); // Still needed for Pipeline/Inventory/Needs data
                } else if (station === 'sales') {
                    loadSalesDashboardSales();
                } else if (station === 'costing') {
                    loadCostingData();
                }
            });
        });

        // Intake form submission
        document.getElementById('intakeForm').addEventListener('submit', async function(e) {
            e.preventDefault();

            // Block demo mode from creating batches
            if (blockDemoWrite('Creating batches')) return;

            if (!currentRole) {
                alert('Please select a user first!');
                return;
            }

            const products = Array.from(document.querySelectorAll('input[name="products"]:checked'))
                .map(cb => cb.value);
            
            if (products.length === 0) {
                alert('Please select at least one planned product!');
                return;
            }

            // Validate METRC tags are required
            const metrcTags = document.getElementById('metrcTags').value.trim();
            if (!metrcTags) {
                alert('METRC Tag Numbers are required!');
                document.getElementById('metrcTags').focus();
                return;
            }

            // Validate pre-sift requires hash products
            const preSift = document.getElementById('preSift').value;
            if (preSift === 'yes') {
                const hasHashProducts = products.some(p => p === 'Brick Hash' || p === 'Hash Hits');
                if (!hasHashProducts) {
                    alert('Pre-sift requires at least one hash product!\n\nPlease select:\n Brick Hash, or\n Hash Hits, or\n Both');
                    return;
                }
            }
            
            const trimWeight = parseFloat(document.getElementById('trimWeight').value);
            const socksTotal = parseInt(document.getElementById('socksTotal').value) || 1;
            const trimPerSock = Math.round((trimWeight / socksTotal) * 10) / 10; // Round to nearest tenth

            // Auto-detect material type based on Live Resin product selection
            const selectedProducts = Array.from(document.querySelectorAll('input[name="products"]:checked')).map(cb => cb.value);
            const isLiveResin = selectedProducts.some(p => p.includes('Live Resin'));
            const materialType = isLiveResin ? 'Fresh Frozen' : 'Trim';
            // Build strain name with product type(s)
            const baseStrainName = document.getElementById('strainName').value;
            const productSuffix = products.length > 0 ? ' ' + products.join('/') : '';
            const fullStrainName = baseStrainName + productSuffix;

            const batch = {
                id: `WM-${batchCounter}`,
                strain: fullStrainName,
                strain_type: document.getElementById('strainType').value,
                material_type: materialType,
                expected_yield: getExpectedYield(materialType),
                trim_weight: trimWeight,
                socks_total: socksTotal,
                socks_remaining: socksTotal,
                trim_per_sock: trimPerSock,
                material_cost: parseFloat(document.getElementById('materialCost').value),
                material_agreement: document.getElementById('materialAgreement').value,
                pre_sift: document.getElementById('preSift').value,
                cultivation_license: document.getElementById('cultivationLicense').value,
                grower_name: document.getElementById('growerName').value || document.getElementById('cultivationLicense').value,
                metrc_tags: document.getElementById('metrcTags').value || null,
                intake_date: document.getElementById('intakeDate').value,
                planned_products: products,
                intake_notes: document.getElementById('intakeNotes').value,
                status: 'intake',
                intake_user: currentRole ? currentRole.name : "Unknown",
                parent_batch_id: null,
                is_sub_batch: false,
                timeline: [{
                    stage: 'intake',
                    user: currentRole ? currentRole.name : "Unknown",
                    date: new Date().toISOString(),
                    action: `Batch created - ${document.getElementById('materialAgreement').value} - ${socksTotal} socks - Cultivated by ${document.getElementById('cultivationLicense').value}`
                }],
                created_at: new Date().toISOString()
            };
            
            const { error } = await supabaseClient
                .from('wm_batches')
                .insert([batch]);
            
            if (error) {
                console.error('Error creating batch:', error);
                alert('Error creating batch. Please try again.');
                return;
            }

            // Track 50/50 splits in Google Sheets
            if (batch.material_agreement === '50/50 Split' || batch.material_agreement === '50-50 Split') {
                try {
                    await add5050SplitToSheet(batch);
                } catch (splitError) {
                    console.error('Failed to track 50/50 split in Google Sheets:', splitError);
                    // Don't block batch creation if sheet tracking fails
                }
            }

            batchCounter++;
            
            // Auto-print batch tracking label
            printIntakeBatchLabel(batch);
            
            // Save fields we want to keep after reset
            const savedLicense = document.getElementById('cultivationLicense').value;
            const savedGrowerName = document.getElementById('growerName').value;
            const savedIntakeDate = document.getElementById('intakeDate').value;
            
            // Reset form
            this.reset();
            
            // Restore saved fields
            document.getElementById('cultivationLicense').value = savedLicense;
            document.getElementById('growerName').value = savedGrowerName;
            document.getElementById('intakeDate').value = savedIntakeDate;
            
            // Update batch ID for next submission
            document.getElementById('batchId').value = `WM-${batchCounter}`;
            
            await loadBatches();
        });

        // Test print batch label with current form data (no batch creation)
        function testPrintBatchLabel() {
            // Gather data from form - using correct field IDs
            const batchId = document.getElementById('batchId')?.value || 'WM-TEST';
            const strain = document.getElementById('strainName')?.value || 'Test Strain';
            const strainType = document.getElementById('strainType')?.value || 'Hybrid';
            const trimWeight = document.getElementById('trimWeight')?.value || '100';
            const intakeDate = document.getElementById('intakeDate')?.value || new Date().toISOString().split('T')[0];
            const cultivationLicense = document.getElementById('cultivationLicense')?.value || '403R-01007';
            const materialAgreement = document.getElementById('materialAgreement')?.value || 'Wholesale';
            
            // Get planned products
            const checkboxes = document.querySelectorAll('input[name="products"]:checked');
            const products = Array.from(checkboxes).map(cb => ({ type: cb.value }));
            
            // Create test batch object
            const testBatch = {
                id: batchId,
                strain: strain,
                strain_type: strainType,
                trim_weight: trimWeight,
                intake_date: intakeDate,
                cultivation_license: cultivationLicense,
                material_agreement: materialAgreement,
                planned_products: products
            };
            
            // Print directly to static IP
            printIntakeLabelDirectly(testBatch);
        }

        // Check if direct IP printing is available (only works on HTTP or localhost)
        function canDirectPrint() {
            const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
            const isHTTP = window.location.protocol === 'http:';
            return isLocalhost || isHTTP;
        }

        // Local print server URLs
        const LOCAL_USB_PRINT = 'http://localhost:3001/api/print-usb';
        const LOCAL_PRINT_SERVER = 'http://localhost:3001/api/print';
        const REMOTE_PRINT_SERVER = 'http://10.1.10.160:3001/api/print';
        const DIRECT_PRINTER_IP = '10.1.10.95';

        // Send ZPL to printer - tries USB first, then network, then direct IP
        async function sendZPLToPrinter(zpl, filename) {
            // Try USB print first (for locally connected Zebra)
            try {
                const usbResponse = await fetch(LOCAL_USB_PRINT, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ zpl })
                });

                if (usbResponse.ok) {
                    const result = await usbResponse.json();
                    console.log('[print] Sent via USB:', result.printer);
                    return { success: true, method: 'usb' };
                }
            } catch (error) {
                console.log('[print] USB print not available, trying network...');
            }

            // Try local print server (works from HTTPS cloud)
            try {
                const response = await fetch(LOCAL_PRINT_SERVER, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ zpl })
                });

                if (response.ok) {
                    const result = await response.json();
                    console.log('[print] Sent via local server:', result.printer);
                    return { success: true, method: 'proxy' };
                }
            } catch (error) {
                console.log('[print] Local server not available, trying direct...');
            }

            // Fall back to direct IP printing (only works on HTTP/localhost)
            try {
                await fetch(`http://${DIRECT_PRINTER_IP}:9100`, {
                    method: 'POST',
                    mode: 'no-cors',
                    body: zpl
                });
                return { success: true, method: 'direct' };
            } catch (error) {
                console.error('Print failed:', error.message);
                alert(` Print failed!\n\nCould not connect to printer.\n\nMake sure:\n1. Local server is running: node server.js\n2. Zebra printer is connected via USB\n3. Printer name matches in server.js (ZEBRA_USB_PRINTER)\n\nError: ${error.message}`);
                return { success: false, method: 'error', error: error.message };
            }
        }

        // Print directly to Zebra printer via IP
        async function printIntakeLabelDirectly(batch) {
            const zpl = generateIntakeBatchLabelZPL(batch);
            const result = await sendZPLToPrinter(zpl, `intake-${batch.id}.zpl`);
            if (result.success) {
                console.log(`Label sent to printer: ${batch.id}`);
            }
        }

        // Print label from Testing page
        window.printTestingLabel = async function() {
            const batchId = document.getElementById('testingBatchSelect').value;
            if (!batchId) {
                alert('Please select a batch first!');
                return;
            }

            const batch = batches.find(b => b.id === batchId);
            if (!batch) {
                alert('Batch not found!');
                return;
            }

            const labelType = document.getElementById('testingLabelType').value;

            if (labelType === 'intake') {
                const zpl = generateIntakeBatchLabelZPL(batch);
                const result = await sendZPLToPrinter(zpl, `intake-${batch.id}.zpl`);
                if (result.success) alert(` Intake label sent to printer!`);
            } else if (labelType === 'postprod') {
                const finalWeight = parseFloat(batch.final_weight) || parseFloat(batch.net_weight) || 0;
                const sampleWeight = parseFloat(batch.sample_weight) || 0;
                const totalBowls = batch.extraction_bowls || 1;
                let printed = false;

                for (let bowlNum = 1; bowlNum <= totalBowls; bowlNum++) {
                    const zpl = generatePostProductionLabelZPL(batch, finalWeight, sampleWeight, bowlNum, totalBowls);
                    const result = await sendZPLToPrinter(zpl, `postprod-${batch.id}-bowl${bowlNum}.zpl`);
                    if (result.success) printed = true;
                }
                if (printed) alert(` ${totalBowls} post-production label(s) sent to printer!`);
            } else if (labelType === 'labeling') {
                const labeledBy = currentRole ? currentRole.name : 'Test User';
                const units1g = batch.units_1g || 0;
                const units4g = batch.units_4g || 0;
                let labelsPrinted = 0;

                if (units1g > 0) {
                    const zpl1g = generateLabelingCompletionZPL(batch, labeledBy, 1);
                    const result = await sendZPLToPrinter(zpl1g, `labeling-${batch.id}-1g.zpl`);
                    if (result.success) labelsPrinted++;
                }

                if (units4g > 0) {
                    const zpl4g = generateLabelingCompletionZPL(batch, labeledBy, 4);
                    const result = await sendZPLToPrinter(zpl4g, `labeling-${batch.id}-4g.zpl`);
                    if (result.success) labelsPrinted++;
                }
                if (labelsPrinted > 0) alert(` ${labelsPrinted} labeling label(s) sent to printer!`);
            }
        }

        // Print labeling completion labels with alert
        async function printLabelingCompletionLabelWithAlert(batch, labeledBy) {
            const units1g = batch.units_1g || 0;
            const units4g = batch.units_4g || 0;
            let labelsPrinted = 0;

            if (units1g > 0) {
                const zpl1g = generateLabelingCompletionZPL(batch, labeledBy, 1);
                const result = await sendZPLToPrinter(zpl1g, `labeling-${batch.id}-1g.zpl`);
                if (result.success) labelsPrinted++;
            }

            if (units4g > 0) {
                const zpl4g = generateLabelingCompletionZPL(batch, labeledBy, 4);
                const result = await sendZPLToPrinter(zpl4g, `labeling-${batch.id}-4g.zpl`);
                if (result.success) labelsPrinted++;
            }

            if (labelsPrinted > 0) {
                alert(` ${labelsPrinted} label(s) sent to printer!\n\nBatch: ${batch.id}\nStrain: ${batch.strain || 'Unknown'}\n1g: ${units1g} units  |  4g: ${units4g} units`);
            }
        }

        // Print post-production label (one per bowl)
        async function printPostProductionLabelDirectly(batch, finalWeight, sampleWeight) {
            const totalBowls = batch.extraction_bowls || 1;
            let printed = false;

            for (let bowlNum = 1; bowlNum <= totalBowls; bowlNum++) {
                const zpl = generatePostProductionLabelZPL(batch, finalWeight, sampleWeight, bowlNum, totalBowls);
                const result = await sendZPLToPrinter(zpl, `postprod-${batch.id}-bowl${bowlNum}.zpl`);
                if (result.success) printed = true;
            }
            if (printed) {
                alert(` ${totalBowls} post-production label(s) sent to printer!\n\nBatch: ${batch.id}`);
            }
        }

        // Generate ZPL for labeling completion label (4" x 2" landscape)
        // unitSize: 1 for 1g labels, 4 for 4g labels
        function generateLabelingCompletionZPL(batch, labeledBy, unitSize) {
            // 4" x 2" label at 203dpi = 812 x 406 dots
            const width = 812;
            const height = 406;

            // Get data
            const strainName = (batch.strain || batch.strain_name || 'Unknown').toUpperCase();
            const batchId = batch.id || '';
            const units1g = batch.units_1g || 0;
            const units4g = batch.units_4g || 0;
            const handler = labeledBy || 'Unknown';

            // Determine unit count and label based on unitSize
            const unitCount = unitSize === 4 ? units4g : units1g;
            const unitLabel = unitSize === 4 ? '4 GRAM' : '1 GRAM';
            const gramsForSize = unitSize === 4 ? (units4g * 4) : units1g;

            // Material agreement
            let agreement = batch.material_agreement || 'Wholesale';
            if (agreement === '50-50 Split') agreement = '50/50 Split';
            if (agreement === 'Custom Buyback') agreement = 'Buyback';

            // Grower info
            const license = batch.cultivation_license || '';
            const growerName = batch.grower_name || '';

            // Date
            const today = new Date().toLocaleDateString('en-US', { month: '2-digit', day: '2-digit', year: '2-digit' });

            const zpl = `^XA
^MMT
^PW${width}
^LL${height}
^LS0
~SD25

^FO65,10^GB350,80,80^FS
^CF0,38
^FO75,30^FR^FD LABELING COMPLETE ^FS

^CF0,70
^FO630,20^FD${unitLabel}^FS

^CF0,50
^FO65,105^FD${strainName.substring(0, 25)}^FS

^CF0,35
^FO65,160^FDBatch: ${batchId}^FS
^FO500,160^FD${batch.strain_type || 'Hybrid'}^FS

^FO65,200^GB${width - 80},3,3^FS

^CF0,90
^FO65,215^FD${unitCount} UNITS^FS

^CF0,45
^FO470,230^FD${gramsForSize}g total^FS

^FO65,310^GB${width - 80},3,3^FS

^CF0,30
^FO65,330^FDLabeled: ${handler.substring(0, 12)}^FS
^FO330,330^FD${agreement}^FS
^FO530,330^FDGrower: ${license}^FS

^CF0,28
^FO65,370^FD${today}^FS
${growerName ? `^FO250,370^FD${growerName.substring(0, 35)}^FS` : ''}

^XZ`;

            return zpl;
        }

        // Generate ZPL for 1.25" round product labels (jar labels)
        // Contains: Product type, strain, THC/CBD boxes, net weight, licenses, batch ID, use-by, FDA text, serving size dot
        function generateRoundProductLabelZPL(batch, unitSize) {
            // 1.1875" diameter round label at 203 DPI = 241 dots
            // Get data
            const productType = (batch.product_made || batch.packaged_product_type || 'CONCENTRATE').toUpperCase();
            const strainName = (batch.strain || batch.strain_name || '').toUpperCase();
            const thc = batch.test_thc_percent || 0;
            const cbd = batch.test_cbd_percent || 0;
            const netWeight = unitSize === 4 ? '4 Grams' : '1 Gram';
            const opcLicense = batch.cultivation_license || '';
            const mipLicense = '404R-00016';

            // Format batch ID as date (MM.DD.YYYY from intake_date or created_at)
            const batchDate = batch.intake_date || batch.created_at;
            const batchId = batchDate ?
                new Date(batchDate).toLocaleDateString('en-US', {month: '2-digit', day: '2-digit', year: 'numeric'}).replace(/\//g, '.') : '';

            // Format use by date
            const useByDate = batch.test_expiration_date ?
                new Date(batch.test_expiration_date).toLocaleDateString('en-US', {month: '2-digit', day: '2-digit', year: '2-digit'}) : '';

            const zpl = `^XA
^MMT
^PW241
^LL241
~SD22

^A0N,18,16
^FO0,20^FB241,1,0,C^FD${productType}^FS

^FO54,36^GB134,36,2^FS
^A0N,18,16
^FO54,40^FB134,1,0,C^FDTotal THC:${thc}%^FS
^FO54,56^FB134,1,0,C^FDTotal CBD:${cbd}%^FS

^A0N,28,26
^FO0,76^FB241,1,0,C^FD${strainName}^FS

^A0N,20,18
^FO0,104^FB241,1,0,C^FDIntended Use:Inhaled Product^FS

^A0N,16,14
^FO0,124^FB241,1,0,C^FDUse By:${useByDate} Batch:${batchId}^FS

^A0N,18,16
^FO0,144^FB241,1,0,C^FD${opcLicense} ${mipLicense}^FS

^A0N,20,18
^FO0,164^FB241,1,0,C^FDNot Approved by the FDA^FS

^A0N,20,18
^FO0,184^FB241,1,0,C^FDNet Weight:${netWeight}^FS

^A0N,20,18
^FO0,204^FB241,1,0,C^FDServing Size:^FS
^FO200,202^GC16,16,B^FS

^XZ`;

            return zpl;
        }

        // Print round product labels for a batch (one design per unit size)
        async function printRoundProductLabels(batch, quantity1g, quantity4g) {
            let printed = 0;

            // Print 1g labels
            if (quantity1g > 0) {
                const zpl1g = generateRoundProductLabelZPL(batch, 1);
                // Send label with quantity command
                const zplWithQty = zpl1g.replace('^XZ', `^PQ${quantity1g}^XZ`);
                const result = await sendZPLToPrinter(zplWithQty, `product-${batch.id}-1g.zpl`);
                if (result.success) printed += quantity1g;
            }

            // Print 4g labels
            if (quantity4g > 0) {
                const zpl4g = generateRoundProductLabelZPL(batch, 4);
                const zplWithQty = zpl4g.replace('^XZ', `^PQ${quantity4g}^XZ`);
                const result = await sendZPLToPrinter(zplWithQty, `product-${batch.id}-4g.zpl`);
                if (result.success) printed += quantity4g;
            }

            return printed;
        }

        // Print product labels from the labeling station UI
        async function printProductLabelsFromStation() {
            const batchId = document.getElementById('labelingBatchSelect').value;
            if (!batchId) {
                alert('Please select a batch first!');
                return;
            }

            const batch = batches.find(b => b.id === batchId);
            if (!batch) {
                alert('Batch not found!');
                return;
            }

            const qty1g = parseInt(document.getElementById('print1gQty').value) || 0;
            const qty4g = parseInt(document.getElementById('print4gQty').value) || 0;

            if (qty1g === 0 && qty4g === 0) {
                alert('Please enter a quantity to print!');
                return;
            }

            const statusDiv = document.getElementById('labelPrintStatus');
            statusDiv.style.display = 'block';
            statusDiv.style.background = 'rgba(59, 130, 246, 0.2)';
            statusDiv.style.border = '2px solid var(--accent-blue)';
            statusDiv.innerHTML = ' Sending to printer...';

            try {
                const printed = await printRoundProductLabels(batch, qty1g, qty4g);

                if (printed > 0) {
                    statusDiv.style.background = 'rgba(16, 185, 129, 0.2)';
                    statusDiv.style.border = '2px solid var(--accent-green)';
                    statusDiv.innerHTML = ` Sent ${printed} label(s) to printer!<br><small>${qty1g > 0 ? qty1g + '  1g' : ''} ${qty4g > 0 ? qty4g + '  4g' : ''}</small>`;
                } else {
                    statusDiv.style.background = 'rgba(239, 68, 68, 0.2)';
                    statusDiv.style.border = '2px solid var(--accent-red)';
                    statusDiv.innerHTML = ' Print failed - check printer connection';
                }
            } catch (error) {
                statusDiv.style.background = 'rgba(239, 68, 68, 0.2)';
                statusDiv.style.border = '2px solid var(--accent-red)';
                statusDiv.innerHTML = ` Error: ${error.message}`;
            }
        }

        // Preview the product label in a popup
        function previewProductLabel() {
            const batchId = document.getElementById('labelingBatchSelect').value;
            if (!batchId) {
                alert('Please select a batch first!');
                return;
            }

            const batch = batches.find(b => b.id === batchId);
            if (!batch) {
                alert('Batch not found!');
                return;
            }

            // Get batch data
            const productType = (batch.product_made || batch.packaged_product_type || 'CONCENTRATE').toUpperCase();
            const strainName = (batch.strain || batch.strain_name || '').toUpperCase();
            const thc = batch.test_thc_percent || 0;
            const cbd = batch.test_cbd_percent || 0;
            const sourceLicense = batch.cultivation_license || 'N/A';
            const useByDate = batch.test_expiration_date ?
                new Date(batch.test_expiration_date).toLocaleDateString('en-US', {month: '2-digit', day: '2-digit', year: '2-digit'}) : 'N/A';

            const popup = window.open('', 'LabelPreview', 'width=400,height=500');
            popup.document.write(`
<!DOCTYPE html>
<html>
<head>
    <title>Label Preview - ${batch.id}</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: Arial, sans-serif;
            background: #1a1a1a;
            color: white;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        h3 { margin-bottom: 20px; color: #bf00ff; }
        .label-preview {
            width: 200px;
            height: 200px;
            border-radius: 50%;
            background: white;
            color: black;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 15px;
            font-size: 9px;
            text-align: center;
            line-height: 1.3;
            border: 3px solid #333;
        }
        .product-type { font-size: 12px; font-weight: bold; margin-bottom: 2px; }
        .strain { font-size: 11px; font-weight: bold; margin-bottom: 5px; }
        .thc-cbd { display: flex; gap: 8px; margin: 5px 0; }
        .thc-cbd div {
            border: 1px solid black;
            padding: 3px 6px;
            font-size: 8px;
        }
        .thc-cbd .value { font-weight: bold; font-size: 10px; }
        .net-weight { font-size: 14px; font-weight: bold; margin: 5px 0; }
        .details { font-size: 7px; line-height: 1.4; }
        .fda-text { font-size: 6px; margin-top: 3px; }
        .serving { font-size: 7px; display: flex; align-items: center; gap: 3px; }
        .dot { width: 8px; height: 8px; background: black; border-radius: 50%; }
        .license { font-size: 7px; margin-top: 2px; }
        .size-toggle { margin-top: 20px; display: flex; gap: 10px; }
        .size-toggle button {
            padding: 10px 20px;
            background: #333;
            border: 2px solid #bf00ff;
            color: white;
            cursor: pointer;
            border-radius: 5px;
        }
        .size-toggle button.active { background: #bf00ff; }
        .note { margin-top: 15px; color: #888; font-size: 11px; }
    </style>
</head>
<body>
    <h3>1.25" Round Label Preview</h3>
    <div class="label-preview">
        <div class="product-type">${productType}</div>
        <div class="strain">${strainName.length > 14 ? strainName.substring(0, 12) + '..' : strainName}</div>
        <div class="thc-cbd">
            <div>TOTAL THC<br><span class="value">${thc}%</span></div>
            <div>TOTAL CBD<br><span class="value">${cbd}%</span></div>
        </div>
        <div class="net-weight" id="netWeight">1g</div>
        <div class="details">
            Source: ${sourceLicense.substring(0, 12)}<br>
            Batch: ${batch.id}<br>
            Use By: ${useByDate}
        </div>
        <div class="fda-text">Intended Use: Inhaled Product<br>Not Approved By The FDA</div>
        <div class="serving">Serving Size: <span class="dot"></span></div>
        <div class="license">Mfg: 404R-00016</div>
    </div>
    <div class="size-toggle">
        <button class="active" onclick="setSize('1g', this)">1g Label</button>
        <button onclick="setSize('4g', this)">4g Label</button>
    </div>
    <p class="note">Actual print may vary slightly from preview</p>
    <scr` + `ipt>
        function setSize(size, btn) {
            document.getElementById('netWeight').textContent = size;
            document.querySelectorAll('.size-toggle button').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');
        }
    </scr` + `ipt>
</body>
</html>
            `);
            popup.document.close();
        }

        // Print labeling completion labels directly to Zebra IP (one for 1g, one for 4g)
        async function printLabelingCompletionLabel(batch, labeledBy) {
            const units1g = batch.units_1g || 0;
            const units4g = batch.units_4g || 0;

            // Print 1g label if there are 1g units
            if (units1g > 0) {
                const zpl1g = generateLabelingCompletionZPL(batch, labeledBy, 1);
                const result = await sendZPLToPrinter(zpl1g, `labeling-${batch.id}-1g.zpl`);
                console.log(`1g labeling label ${result.success ? 'sent to printer' : 'failed'}`);
            }

            // Print 4g label if there are 4g units
            if (units4g > 0) {
                const zpl4g = generateLabelingCompletionZPL(batch, labeledBy, 4);
                const result = await sendZPLToPrinter(zpl4g, `labeling-${batch.id}-4g.zpl`);
                console.log(`4g labeling label ${result.success ? 'sent to printer' : 'failed'}`);
            }
        }

        // Open printable intake batch label
        function openPrintableIntakeLabel(batch) {
            // Format date
            const date = new Date(batch.intake_date).toLocaleDateString('en-US', {month: '2-digit', day: '2-digit', year: 'numeric'});
            
            // Get planned products as string
            let plannedProducts = 'See notes';
            if (batch.planned_products && batch.planned_products.length > 0) {
                plannedProducts = batch.planned_products.join(', ');
            }

            // Truncate products if too long
            if (plannedProducts.length > 20) {
                plannedProducts = plannedProducts.substring(0, 17) + '...';
            }
            
            // Create popup window
            const popup = window.open('', 'PrintIntakeLabel', 'width=700,height=600');
            popup.document.write(`
<!DOCTYPE html>
<html>
<head>
    <title>Print Batch Label - ${batch.id}</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        @page {
            size: 2in 1.5in landscape;
            margin: 0mm;
        }
        
        @media print {
            html, body {
                width: 2in;
                height: 1.5in;
                margin: 0;
                padding: 0;
            }
            
            .no-print {
                display: none !important;
            }
            
            .page-wrapper {
                width: 2in;
                height: 1.5in;
                position: relative;
                page-break-after: avoid;
            }
            
            .batch-label {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
            }
        }
        
        body {
            font-family: Arial, sans-serif;
            background: #f0f0f0;
            padding: 20px;
        }
        
        .no-print {
            background: white;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            text-align: center;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
        }
        
        .no-print h1 {
            margin: 0 0 10px 0;
            color: #333;
            font-size: 20px;
        }
        
        .no-print button {
            background: #9333ea;
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 16px;
            border-radius: 6px;
            cursor: pointer;
            margin: 5px;
        }
        
        .no-print button:hover {
            background: #7c2db8;
        }
        
        .page-wrapper {
            width: 2in;
            height: 1.5in;
            margin: 0 auto;
            background: white;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        .batch-label {
            width: 100%;
            height: 100%;
            border: 3px solid #000;
            padding: 8px;
            display: flex;
            flex-direction: column;
        }
        
        .strain-name {
            font-size: 20pt;
            font-weight: bold;
            text-align: left;
            line-height: 0.9;
            text-transform: uppercase;
            border-bottom: 2px solid #000;
            padding-bottom: 2px;
            margin-bottom: 2px;
        }
        
        .batch-id {
            font-size: 16pt;
            font-weight: bold;
            text-align: left;
            border-bottom: 2px solid #000;
            padding: 2px 0;
            margin-bottom: 4px;
        }
        
        .details-row {
            display: grid;
            grid-template-columns: 0.9in 1.1in;
            gap: 0;
            font-size: 8pt;
            line-height: 1.4;
            flex: 1;
        }
        
        .left-col, .right-col {
            text-align: left;
        }
        
        .details-row div {
            margin: 0.5px 0;
        }
    </style>
</head>
<body>
    <div class="no-print">
        <h1>Intake Batch Label - ${batch.id}</h1>
        <p>Size: 2"  1.5" (Horizontal)</p>
        <div style="background: #fff3cd; padding: 10px; border-radius: 5px; margin: 10px 0; border-left: 4px solid #ff9800;">
            <strong> Important Print Settings:</strong>
            <ol style="text-align: left; margin: 10px 0 0 20px;">
                <li>In print dialog, click "More settings"</li>
                <li>Set <strong>Margins</strong> to "None"</li>
                <li>Set <strong>Scale</strong> to "Default" (100%)</li>
                <li>Uncheck "Headers and footers"</li>
                <li>Make sure orientation is <strong>Landscape</strong></li>
            </ol>
        </div>
        <button onclick="window.print()"> Print Label</button>
        <button onclick="window.close()">Close</button>
    </div>
    
    <div class="page-wrapper">
        <div class="batch-label">
            <div class="strain-name">${batch.strain.toUpperCase()}</div>
            <div class="batch-id">BATCH: ${batch.id}</div>
            <div class="details-row">
                <div class="left-col">
                    <div><strong>Type:</strong> ${batch.strain_type}</div>
                    <div><strong>Weight:</strong> ${batch.trim_weight}g</div>
                    <div><strong>Date:</strong> ${date}</div>
                </div>
                <div class="right-col">
                    <div><strong>Grower:</strong></div>
                    <div>${batch.cultivation_license}</div>
                    <div><strong>Products:</strong></div>
                    <div>${plannedProducts}</div>
                </div>
            </div>
        </div>
    </div>
</body>
</html>
            `);
            popup.document.close();
        }

        // Generate ZPL for intake batch tracking label (4" x 2" landscape)
        function generateIntakeBatchLabelZPL(batch) {
            // 4" x 2" label at 203dpi = 812 x 406 dots
            const width = 812;
            const height = 406;

            // Format date
            const date = new Date(batch.intake_date).toLocaleDateString('en-US', {month: '2-digit', day: '2-digit', year: 'numeric'});

            // Get planned products as string (abbreviate for label space)
            let plannedProducts = 'See notes';
            if (batch.planned_products && batch.planned_products.length > 0) {
                if (Array.isArray(batch.planned_products)) {
                    plannedProducts = batch.planned_products.map(p => {
                        const product = typeof p === 'object' ? p.type : p;
                        // Abbreviate for label space
                        return product
                            .replace('Live Resin Carts', 'LR Carts')
                            .replace('Live Resin AIOs', 'LR AIOs')
                            .replace('Brick Hash', 'Brick');
                    }).join(', ');
                } else {
                    plannedProducts = batch.planned_products;
                }
            }

            // Material agreement
            let agreement = batch.material_agreement || 'Wholesale';
            if (agreement === '50-50 Split') agreement = '50/50 Split';
            if (agreement === 'Custom Buyback') agreement = 'Buyback';

            // Grower info
            const growerName = batch.grower_name || '';

            const zpl = `^XA
^MMT
^PW${width}
^LL${height}
^LS0
~SD20

^FO65,10^GB180,70,70^FS
^CF0,40
^FO75,25^FR^FD INTAKE ^FS

^CF0,50
^FO620,20^FD${batch.socks_total || 1} Socks^FS

^CF0,55
^FO65,95^FD${(batch.strain || 'Unknown').toUpperCase().substring(0, 22)}^FS

^CF0,38
^FO65,155^FDBatch: ${batch.id}^FS
^FO500,155^FD${batch.strain_type || 'Hybrid'}^FS

^CF0,65
^FO65,205^FD${batch.trim_weight}g^FS
^CF0,30
^FO65,275^FDTRIM WEIGHT^FS

^CF0,32
^FO270,205^FDDate: ${date}^FS
^FO270,245^FDGrower: ${batch.cultivation_license || 'N/A'}^FS
^FO270,285^FD${agreement}^FS

^CF0,28
^FO65,325^FDProducts: ${plannedProducts.substring(0, 45)}^FS
${growerName ? `^FO500,325^FD${growerName.substring(0, 25)}^FS` : ''}

^XZ`;

            return zpl;
        }

        // Print intake batch tracking label - direct IP only
        async function printIntakeBatchLabel(batch) {
            console.log('printIntakeBatchLabel called for:', batch.id);
            const zpl = generateIntakeBatchLabelZPL(batch);
            const result = await sendZPLToPrinter(zpl, `intake-${batch.id}.zpl`);
            if (result.success) {
                console.log('Intake label sent to printer:', batch.id);
            }
        }

        // Generate ZPL for post-production label (4" x 2" landscape)
        function generatePostProductionLabelZPL(batch, finalWeight, sampleWeight, bowlNumber, totalBowls) {
            // 4" x 2" label at 203dpi = 812 x 406 dots
            const width = 812;
            const height = 406;

            // Get product name: use batch_name if set, otherwise "Strain ProductType"
            // Strip any existing product type suffix from strain name to avoid duplication
            const productTypes = ['Wax', 'Sugar Wax', 'Shatter', 'Badder', 'Diamonds', 'Sauce', 'Live Resin Carts', 'Live Resin AIOs', 'Brick Hash', 'Bubble Hash', 'Hash Hits', 'Rosin', 'Live Resin'];
            let baseStrain = batch.strain || 'Unknown';
            for (const pt of productTypes) {
                if (baseStrain.toLowerCase().endsWith(' ' + pt.toLowerCase())) {
                    baseStrain = baseStrain.slice(0, -(pt.length + 1)).trim();
                    break;
                }
            }
            const productName = batch.batch_name
                ? batch.batch_name.toUpperCase()
                : `${baseStrain} ${(batch.product_made || 'Wax')}`.toUpperCase();
            const batchId = batch.id || '';

            // Bowl numbering (e.g., "1/2", "2/2")
            const bowlLabel = totalBowls > 1 ? `${bowlNumber}/${totalBowls}` : '';

            // Weights - use combined_trim_weight (trim actually used) if available
            let sourceContributionsForTrim = batch.source_contributions || [];
            if (typeof sourceContributionsForTrim === 'string') {
                try { sourceContributionsForTrim = JSON.parse(sourceContributionsForTrim); } catch(e) { sourceContributionsForTrim = []; }
            }
            const trimFromSources = sourceContributionsForTrim.reduce((sum, s) => sum + (parseFloat(s.trim_weight) || 0), 0);
            const trimWeight = parseFloat(batch.combined_trim_weight) || trimFromSources || parseFloat(batch.trim_weight) || 0;
            const finalWt = parseFloat(finalWeight) || 0;
            const sampleWt = parseFloat(sampleWeight) || 0;

            // Calculate yield based on trim actually used
            const yieldPercent = trimWeight > 0 ? ((finalWt / trimWeight) * 100).toFixed(1) : '0.0';

            // Source contributions for METRC tags and weights
            let metrcDisplay = '';
            let partialInfo = '';
            let sourceContributions = batch.source_contributions || [];
            if (typeof sourceContributions === 'string') {
                try { sourceContributions = JSON.parse(sourceContributions); } catch(e) { sourceContributions = []; }
            }

            if (sourceContributions.length > 0) {
                // Separate full and partial sources
                const fullSources = [];
                const partialSources = [];

                sourceContributions.forEach(s => {
                    const tag = s.metrc_tag || 'N/A';
                    const weight = parseFloat(s.trim_weight) || 0;

                    if (s.is_partial) {
                        partialSources.push({ tag, weight });
                    } else {
                        fullSources.push({ tag, weight });
                    }
                });

                // Format full sources: "tag1,tag2,tag3 (combined weight)"
                if (fullSources.length > 0) {
                    const fullTags = fullSources.map(s => s.tag).join(',');
                    const fullWeight = fullSources.reduce((sum, s) => sum + s.weight, 0);
                    metrcDisplay = `${fullTags} (${fullWeight.toLocaleString()}g)`;
                }

                // Format partial sources: each listed separately with its own weight
                if (partialSources.length > 0) {
                    partialInfo = partialSources.map(p => `${p.tag} (${p.weight.toLocaleString()}g)`).join(', ');
                }

                // Truncate if too long
                if (metrcDisplay.length > 40) {
                    metrcDisplay = metrcDisplay.substring(0, 37) + '...';
                }
            } else {
                // Fallback to batch's metrc_tags field
                metrcDisplay = batch.metrc_tags || 'N/A';
                if (metrcDisplay.length > 40) {
                    metrcDisplay = metrcDisplay.substring(0, 37) + '...';
                }
            }

            // Agreement type
            let agreement = batch.material_agreement || 'Wholesale';
            if (agreement === '50-50 Split') agreement = '50/50 Split';
            if (agreement === 'Custom Buyback') agreement = 'Buyback';

            // Grower info
            const license = batch.cultivation_license || '';
            const growerName = batch.grower_name || '';

            // Date
            const today = new Date().toLocaleDateString('en-US', { month: '2-digit', day: '2-digit', year: '2-digit' });

            const zpl = `^XA
^MMT
^PW${width}
^LL${height}
^LS0
~SD25

^FO65,10^GB330,75,75^FS
^CF0,36
^FO75,27^FR^FD POST-PRODUCTION ^FS
${bowlLabel ? `^CF0,70
^FO730,15^FD${bowlLabel}^FS` : ''}

^CF0,50
^FO65,100^FD${productName.substring(0, 25)}^FS

^CF0,35
^FO65,155^FDBatch: ${batchId}^FS
^FO500,155^FD${batch.strain_type || 'Hybrid'}^FS

^FO65,195^GB${width - 80},3,3^FS

^CF0,65
^FO65,215^FD${finalWt.toFixed(1)}g^FS
^CF0,28
^FO230,235^FDFINAL^FS

^CF0,38
^FO350,215^FDTrim: ${trimWeight}g^FS
^FO350,260^FDYield: ${yieldPercent}%^FS

^CF0,38
^FO580,215^FDSample: ${sampleWt.toFixed(1)}g^FS
^CF0,30
^FO580,260^FD${today}^FS

^FO65,305^GB${width - 80},3,3^FS

^CF0,28
^FO65,325^FDMETRC: ${metrcDisplay}${partialInfo ? ` Partial: ${partialInfo}` : ''}^FS

^CF0,28
^FO65,360^FDGrower: ${license}^FS
^FO350,360^FD${agreement}^FS
${growerName ? `^FO580,360^FD${growerName.substring(0, 18)}^FS` : ''}

^XZ`;

            return zpl;
        }

        // Print post-production labels - one per bowl with numbering
        async function printPostProductionLabels(batch, finalWeight, sampleWeight, copies) {
            const totalBowls = batch.extraction_bowls || 1;
            let successCount = 0;

            for (let bowlNum = 1; bowlNum <= totalBowls; bowlNum++) {
                const zpl = generatePostProductionLabelZPL(batch, finalWeight, sampleWeight, bowlNum, totalBowls);
                const result = await sendZPLToPrinter(zpl, `postprod-${batch.id}-bowl${bowlNum}.zpl`);
                if (result.success) successCount++;
                console.log(`Post-production label ${bowlNum}/${totalBowls} ${result.success ? 'sent' : 'failed'}`);
            }

            if (successCount > 0) {
                alert(` ${successCount} post-production label(s) sent to printer!`);
            }
        }

        // Extraction functions
        
        // Finishing functions
        function populateFinishingSelect() {
            const select = document.getElementById('finishingBatchSelect');
            // Include both regular batches AND sub-batches that are at extraction status
            // (Sub-batches can be retroactively created and need post-processing)
            const extractionBatches = batches.filter(b => b.status === 'extraction');

            select.innerHTML = '<option value="">Select a batch...</option>';
            extractionBatches.forEach(batch => {
                let label;
                
                if (batch.is_sub_batch) {
                    const estYield = ((parseFloat(batch.trim_weight) || 0) * 0.13).toFixed(0);
                    label = `${batch.id} - ${batch.strain} (~${estYield}g yield) - ${batch.product_made} (SUB-BATCH)`;
                } else {
                    // Build label with jar/slab counts from pull batch
                    let counts = [];
                    if (batch.extraction_slabs && batch.extraction_slabs > 0) {
                        counts.push(`${batch.extraction_slabs} slabs`);
                    }
                    if (batch.extraction_bowls && batch.extraction_bowls > 0) {
                        counts.push(`${batch.extraction_bowls} bowls`);
                    }
                    // Fallback to old fields if they exist
                    if (!counts.length && batch.bulk_jars_count && batch.bulk_jars_count > 0) {
                        counts.push(`${batch.bulk_jars_count} jars`);
                    }
                    if (!counts.length && batch.shatter_slabs_count && batch.shatter_slabs_count > 0) {
                        counts.push(`${batch.shatter_slabs_count} slabs`);
                    }
                    
                    const countText = counts.length > 0 ? counts.join(', ') : 'no counts';
                    const estYield = ((parseFloat(batch.trim_weight) || 0) * 0.13).toFixed(0);
                    label = `${batch.id} - ${batch.strain} (~${estYield}g yield) - ${batch.product_made} (${countText})`;
                }

                const workerIndicator = batch.finishing_user ? `  ${batch.finishing_user.split(' ')[0]}` : '';
                select.innerHTML += `<option value="${batch.id}">${label}${workerIndicator}</option>`;
            });
        }

        document.getElementById('finishingBatchSelect').addEventListener('change', function() {
            const form = document.getElementById('finishingForm');
            form.style.display = this.value ? 'block' : 'none';

            // Check if Live Resin batch to show split section
            checkShowSplitSection(this.value);
            
            if (this.value) {
                const batch = batches.find(b => b.id === this.value);
                document.getElementById('finishingDate').value = new Date().toISOString().split('T')[0];
                
                // Show batch info
                let info = `
                    <p><strong>Strain:</strong> ${batch.strain} (${batch.strain_type})</p>
                    <p><strong>Product Type:</strong> ${batch.product_made}</p>
                    <p><strong>Material Agreement:</strong> ${batch.material_agreement}</p>
                `;
                
                // Show counts from pull batch
                if (batch.extraction_slabs && batch.extraction_slabs > 0) {
                    info += `<p style="background: rgba(245, 158, 11, 0.2); padding: 10px; border-radius: 8px; border-left: 4px solid var(--accent-orange); margin-top: 10px;">
                        <strong> Shatter Slabs to Process:</strong> <span style="font-size: 1.3rem; font-weight: 700; color: var(--accent-orange);">${batch.extraction_slabs}</span>
                    </p>`;
                }
                
                if (batch.extraction_bowls && batch.extraction_bowls > 0) {
                    const productName = batch.product_type === 'Sugar Wax' ? 'Sugar Wax' : batch.product_type === 'Live Resin Oil' ? 'Live Resin' : 'Wax';
                    info += `<p style="background: rgba(147, 51, 234, 0.2); padding: 10px; border-radius: 8px; border-left: 4px solid var(--accent-purple); margin-top: 10px;">
                        <strong> ${productName} Bowls to Process:</strong> <span style="font-size: 1.3rem; font-weight: 700; color: var(--accent-purple);">${batch.extraction_bowls}</span>
                    </p>`;
                }
                
                // Fallback to old fields if they exist (for legacy batches)
                if (batch.bulk_jars_count && batch.bulk_jars_count > 0 && !batch.extraction_bowls) {
                    info += `<p style="background: rgba(147, 51, 234, 0.2); padding: 10px; border-radius: 8px; border-left: 4px solid var(--accent-purple); margin-top: 10px;">
                        <strong> Bulk Jars to Process:</strong> <span style="font-size: 1.3rem; font-weight: 700; color: var(--accent-purple);">${batch.bulk_jars_count}</span>
                    </p>`;
                }
                
                if (batch.shatter_slabs_count && batch.shatter_slabs_count > 0 && !batch.extraction_slabs) {
                    info += `<p style="background: rgba(245, 158, 11, 0.2); padding: 10px; border-radius: 8px; border-left: 4px solid var(--accent-orange); margin-top: 10px;">
                        <strong> Shatter Slabs to Process:</strong> <span style="font-size: 1.3rem; font-weight: 700; color: var(--accent-orange);">${batch.shatter_slabs_count}</span>
                    </p>`;
                }
                
                if (batch.is_sub_batch) {
                    info += `<p style="color: var(--accent-purple); font-weight: 700;"><strong> RETROACTIVE SUB-BATCH</strong> of ${batch.parent_batch_id}</p>`;
                    info += `<p style="color: var(--accent-orange);"><strong>Note:</strong> Enter the actual weight of this separated material</p>`;
                } else {
                    if (batch.sift_weight) {
                        info += `<p><strong>Pre-Sift Collected:</strong> ${batch.sift_weight}g</p>`;
                    }
                    info += `<p style="color: var(--accent-orange);"><strong>Note:</strong> Actual weight will be entered below or when splitting</p>`;
                }

                document.getElementById('batchInfoContent').innerHTML = info;

                // Show/hide output containers section based on product type
                const outputSection = document.getElementById('outputContainersSection');
                const bulkJarsOutput = document.getElementById('bulkJarsOutput');
                const shatterSlabsOutput = document.getElementById('shatterSlabsOutput');
                const productMade = batch.product_made || '';

                // Check if it's a bulk product (Wax, Sugar Wax) or Shatter
                const isBulk = productMade === 'Wax' || productMade === 'Sugar Wax' ||
                               batch.extraction_bowls > 0 || batch.bulk_jars_count > 0;
                const isShatter = productMade === 'Shatter' ||
                                  batch.extraction_slabs > 0 || batch.shatter_slabs_count > 0;

                if (isBulk || isShatter) {
                    outputSection.style.display = 'block';
                    bulkJarsOutput.style.display = isBulk ? 'block' : 'none';
                    shatterSlabsOutput.style.display = isShatter ? 'block' : 'none';

                    // Set default values
                    // Bulk (wax/sugar) defaults to extraction bowls count
                    const inputBowls = batch.extraction_bowls || batch.bulk_jars_count || 1;
                    document.getElementById('outputBowlsCount').value = inputBowls;
                    // Shatter defaults to same number of input slabs
                    const inputSlabs = batch.extraction_slabs || batch.shatter_slabs_count || 1;
                    document.getElementById('outputSlabsCount').value = inputSlabs;
                } else {
                    outputSection.style.display = 'none';
                }
            }
        });

        document.getElementById('splitBatch').addEventListener('change', function() {
            const singleSection = document.getElementById('singleFinishing');
            const splitSection = document.getElementById('splitFinishing');
            
            if (this.value === 'yes') {
                singleSection.style.display = 'none';
                splitSection.style.display = 'block';
                // Make single fields not required
                document.getElementById('finalWeight').required = false;
                document.getElementById('sampleWeight').required = false;
                
                // Update split weight listeners
                updateSplitValidation();
            } else {
                singleSection.style.display = 'block';
                splitSection.style.display = 'none';
                document.getElementById('finalWeight').required = true;
                document.getElementById('sampleWeight').required = true;
            }
        });

        function addSplitProduct() {
            const container = document.getElementById('splitProducts');
            const count = container.children.length + 1;
            
            const newProduct = document.createElement('div');
            newProduct.className = 'split-product-item';
            newProduct.style.cssText = 'background: var(--bg-tertiary); padding: 20px; border-radius: 10px; margin-bottom: 15px;';
            newProduct.innerHTML = `
                <h4 style="color: var(--accent-purple); margin-bottom: 15px;">Product ${count}</h4>
                <div class="form-grid">
                    <div class="form-group">
                        <label>Product Type</label>
                        <select class="splitProductType" required>
                            <option value="">Select Product</option>
                            <option value="Wax">Wax</option>
                            <option value="Sugar Wax">Sugar Wax</option>
                            <option value="Shatter">Shatter</option>
                            <option value="Live Resin Carts">Live Resin Carts</option>
                            <option value="Live Resin AIOs">Live Resin AIOs</option>
                            <option value="Brick Hash">Brick Hash</option>
                            <option value="Hash Hits">Hash Hits</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Weight Allocated (grams)</label>
                        <input type="number" class="splitWeight" step="0.1" required>
                    </div>
                </div>
            `;
            container.appendChild(newProduct);
            
            // Add listeners to new inputs
            newProduct.querySelector('.splitWeight').addEventListener('input', updateSplitValidation);
        }

        function updateSplitValidation() {
            const weights = Array.from(document.querySelectorAll('.splitWeight'))
                .map(input => parseFloat(input.value) || 0);
            
            const totalAllocated = weights.reduce((sum, w) => sum + w, 0);
            
            const validationDiv = document.getElementById('splitValidation');
            
            if (totalAllocated > 0) {
                validationDiv.style.background = 'rgba(16, 185, 129, 0.2)';
                validationDiv.style.border = '2px solid var(--accent-green)';
                validationDiv.innerHTML = `
                    <strong style="color: var(--accent-green);"> Total weight to allocate:</strong><br>
                    ${totalAllocated.toFixed(1)}g across ${weights.filter(w => w > 0).length} products
                `;
            } else {
                validationDiv.style.background = 'rgba(245, 158, 11, 0.2)';
                validationDiv.style.border = '2px solid var(--accent-orange)';
                validationDiv.innerHTML = `
                    <strong style="color: var(--accent-orange);">Enter weights for each product</strong>
                `;
            }
        }

        // Add listeners to initial split weight inputs
        document.addEventListener('DOMContentLoaded', function() {
            document.querySelectorAll('.splitWeight').forEach(input => {
                input.addEventListener('input', updateSplitValidation);
            });
        });

        async function submitSplitBatch() {
            if (!currentRole) {
                alert('Please select a user first!');
                return;
            }

            const batchId = document.getElementById('finishingBatchSelect').value;
            const batch = batches.find(b => b.id === batchId);
            
            if (!batch) return;
            
            // Collect split data
            const splitItems = document.querySelectorAll('.split-product-item');
            const splits = [];
            
            splitItems.forEach(item => {
                const productType = item.querySelector('.splitProductType').value;
                const weight = parseFloat(item.querySelector('.splitWeight').value) || 0;
                
                if (productType && weight > 0) {
                    splits.push({ productType, weight });
                }
            });
            
            if (splits.length < 2) {
                alert('Please specify at least 2 products to split the batch');
                return;
            }
            
            const totalAllocated = splits.reduce((sum, s) => sum + s.weight, 0);
            
            // Calculate overall yield percentage from parent batch
            const parentTrimWeight = parseFloat(batch.trim_weight) || 0;
            const overallYieldPercent = parentTrimWeight > 0 ? (totalAllocated / parentTrimWeight) * 100 : 0;
            
            if (!confirm(`Create ${splits.length} sub-batches from ${batchId}?\n\nParent Trim: ${parentTrimWeight.toFixed(1)}g\nTotal Yield: ${totalAllocated.toFixed(1)}g\nYield %: ${overallYieldPercent.toFixed(2)}%\n\n${splits.map((s, i) => `${String.fromCharCode(65 + i)}: ${s.weight}g  ${s.productType}`).join('\n')}`)) {
                return;
            }
            
            // Create sub-batches
            const subBatches = [];
            const parentTimeline = batch.timeline || [];
            
            parentTimeline.push({
                stage: 'finishing',
                user: currentRole ? currentRole.name : "Unknown",
                date: new Date().toISOString(),
                action: `Split into ${splits.length} sub-batches: ${splits.map(s => s.productType).join(', ')} - Total yield: ${overallYieldPercent.toFixed(2)}%`
            });
            
            for (let i = 0; i < splits.length; i++) {
                const split = splits[i];
                const subBatchId = `${batchId}-${String.fromCharCode(65 + i)}`;
                
                // Calculate proportional trim weight based on this sub-batch's contribution to total yield
                // If overall yield is 18% and this sub-batch is 50g, then it used (50 / 0.18) = 277.8g of trim
                const subBatchTrimWeight = overallYieldPercent > 0 
                    ? (split.weight / overallYieldPercent) * 100
                    : parentTrimWeight * (split.weight / totalAllocated);
                
                const subBatch = {
                    id: subBatchId,
                    parent_batch_id: batchId,
                    is_sub_batch: true,
                    business_id: batch.business_id, // Inherit business from parent
                    strain: batch.strain,
                    strain_type: batch.strain_type,
                    trim_weight: subBatchTrimWeight, // Proportional trim weight based on actual yield
                    material_cost: batch.material_cost * (split.weight / totalAllocated), // Proportional cost
                    material_agreement: batch.material_agreement,
                    pre_sift: batch.pre_sift,
                    cultivation_license: batch.cultivation_license,
                    grower_name: batch.grower_name,
                    metrc_tags: batch.metrc_tags, // Inherit METRC tags from parent
                    intake_date: batch.intake_date,
                    planned_products: [split.productType],
                    intake_notes: `Sub-batch from ${batchId} - Allocated ${subBatchTrimWeight.toFixed(1)}g trim for ${split.weight}g final product`,
                    status: 'finishing',
                    intake_user: batch.intake_user,
                    extraction_date: batch.extraction_date,
                    extraction_method: batch.extraction_method,
                    product_made: split.productType,
                    product_type: split.productType,
                    extraction_user: batch.extraction_user,
                    finishing_date: new Date().toISOString().split('T')[0],
                    finishing_user: currentRole ? currentRole.name : "Unknown",
                    final_weight: split.weight, // The weight allocated IS the final weight
                    timeline: [
                        {
                            stage: 'split',
                            user: currentRole ? currentRole.name : "Unknown",
                            date: new Date().toISOString(),
                            action: `Created from ${batchId} - ${subBatchTrimWeight.toFixed(1)}g trim  ${split.weight}g ${split.productType} (${overallYieldPercent.toFixed(2)}% yield)`
                        }
                    ],
                    created_at: new Date().toISOString()
                };
                
                subBatches.push(subBatch);
            }
            
            // Insert all sub-batches
            const { error: insertError } = await supabaseClient
                .from('wm_batches')
                .insert(subBatches);
            
            if (insertError) {
                console.error('Error creating sub-batches:', insertError);
                alert('Error creating sub-batches. Please try again.');
                return;
            }
            
            // Update parent batch to mark as split
            const { error: updateError } = await supabaseClient
                .from('wm_batches')
                .update({
                    status: 'split',
                    timeline: parentTimeline
                })
                .eq('id', batchId);
            
            if (updateError) {
                console.error('Error updating parent batch:', updateError);
            }
            
            showCelebration({
                emoji: '',
                title: 'Batch Split Complete!',
                message: `Created ${splits.length} sub-batches from ${batchId}`,
                stats: [
                    { value: splits.length, label: 'Sub-Batches' },
                    { value: `${overallYieldPercent.toFixed(1)}%`, label: 'Overall Yield' }
                ]
            });
            // Print labels for each sub-batch
            for (const subBatch of subBatches) {
                printPostProductionLabels(subBatch, subBatch.final_weight, 0, 1);
            }

            document.getElementById('finishingForm').style.display = 'none';
            document.getElementById('finishingBatchSelect').value = '';
            
            await loadBatches();
            populateFinishingSelect();
        }

        async function submitFinishing() {
            if (blockDemoWrite('Finishing batches')) return;

            if (!currentRole) {
                alert('Please select a user first!');
                return;
            }

            const batchId = document.getElementById('finishingBatchSelect').value;
            const batch = batches.find(b => b.id === batchId);
            
            if (!batch) return;
            
            const finalWeight = parseFloat(document.getElementById('finalWeight').value);
            const sampleWeight = parseFloat(document.getElementById('sampleWeight').value);
            const netWeight = finalWeight - sampleWeight;

            // Get output container counts
            const outputBowlsCount = parseInt(document.getElementById('outputBowlsCount').value) || 1;
            const outputSlabsCount = parseInt(document.getElementById('outputSlabsCount').value) || 1;

            // Get product type change if selected
            const newProductType = document.getElementById('finishingProductType')?.value || '';

            // Determine if bulk or shatter based on product type
            const productMade = batch.product_made || '';
            const isBulk = productMade === 'Wax' || productMade === 'Sugar Wax' ||
                           batch.extraction_bowls > 0 || batch.bulk_jars_count > 0;
            const isShatter = productMade === 'Shatter' ||
                              batch.extraction_slabs > 0 || batch.shatter_slabs_count > 0;

            // Build container info for timeline
            let containerInfo = '';
            if (isBulk) {
                containerInfo = `, ${outputBowlsCount} bowl${outputBowlsCount > 1 ? 's' : ''}`;
            } else if (isShatter) {
                containerInfo = `, ${outputSlabsCount} slab${outputSlabsCount > 1 ? 's' : ''}`;
            }

            const timeline = batch.timeline || [];
            timeline.push({
                stage: 'finishing',
                user: currentRole ? currentRole.name : "Unknown",
                date: new Date().toISOString(),
                action: `Finishing completed - QC: ${finalWeight}g bulk, ${sampleWeight}g sample pulled for testing${containerInfo}`
            });

            // Build update object
            const updateData = {
                status: 'finishing',
                finishing_date: document.getElementById('finishingDate').value,
                final_weight: finalWeight,
                sample_weight: sampleWeight,
                finishing_notes: document.getElementById('finishingNotes').value,
                finishing_user: currentRole ? currentRole.name : "Unknown",
                net_weight: netWeight,
                timeline: timeline
            };

            // Update product_made if changed
            if (newProductType) {
                updateData.product_made = newProductType;
            }

            // Add output container counts - update extraction_bowls for label printing
            if (isBulk) {
                updateData.extraction_bowls = outputBowlsCount;
            }
            if (isShatter) {
                updateData.extraction_slabs = outputSlabsCount;
            }

            const { error } = await supabaseClient
                .from('wm_batches')
                .update(updateData)
                .eq('id', batchId);

            if (error) {
                console.error('Error updating batch:', error);
                alert('Error updating batch. Please try again.');
                return;
            }
            
            // Build stats array for celebration
            const celebrationStats = [
                { value: `${finalWeight}g`, label: 'Final Weight' },
                { value: `${((netWeight / batch.trim_weight) * 100).toFixed(1)}%`, label: 'Yield' }
            ];

            // Add container count to stats if applicable
            if (isBulk) {
                celebrationStats.push({ value: `${outputBowlsCount}`, label: outputBowlsCount === 1 ? 'Bowl' : 'Bowls' });
            } else if (isShatter) {
                celebrationStats.push({ value: `${outputSlabsCount}`, label: outputSlabsCount === 1 ? 'Slab' : 'Slabs' });
            }

            // Register batch for RTA qualification tracking


            const rtaProductType = getRTAProductType(batch);
            registerQualificationBatch(rtaProductType, batchId);

            showCelebration({
                emoji: '',
                title: 'Finishing Complete!',
                message: `${updateData.batch_name} (${batchId}) is ready for packaging.`,
                stats: celebrationStats
            });

            // Auto-print post-production labels (one per bowl/slab)
            const labelCount = isShatter ? outputSlabsCount : (isBulk ? outputBowlsCount : 1);
            // Pass updated batch with new batch_name, product_made, and updated bowl count
            const updatedBatch = { ...batch, ...updateData };
            printPostProductionLabels(updatedBatch, finalWeight, sampleWeight, labelCount);

            document.getElementById('finishingForm').style.display = 'none';
            document.getElementById('finishingBatchSelect').value = '';
            document.getElementById('finishingNotes').value = '';

            // Reset output containers section
            document.getElementById('outputContainersSection').style.display = 'none';
            document.getElementById('outputBowlsCount').value = 1;
            document.getElementById('outputSlabsCount').value = 1;

            await loadBatches();
            populateFinishingSelect();
        }

        // Packaging functions
        function populatePackagingSelect() {
            const select = document.getElementById('packagingBatchSelect');
            const finishingBatches = batches.filter(b => b.status === 'finishing');

            select.innerHTML = '<option value="">Select a batch...</option>';
            finishingBatches.forEach(batch => {
                const weight = batch.final_weight || batch.net_weight || 0;
                const pauseIndicator = batch.packaging_paused ? '  PAUSED' : '';
                const workerIndicator = batch.packaging_user ? `  ${batch.packaging_user.split(' ')[0]}` : '';

                // Show output container count if available
                let containerIndicator = '';
                if (batch.output_jars_count && batch.output_jars_count > 0) {
                    containerIndicator = ` [${batch.output_jars_count} jar${batch.output_jars_count > 1 ? 's' : ''}]`;
                } else if (batch.output_slabs_count && batch.output_slabs_count > 0) {
                    containerIndicator = ` [${batch.output_slabs_count} slab${batch.output_slabs_count > 1 ? 's' : ''}]`;
                }

                select.innerHTML += `<option value="${batch.id}">${batch.id} - ${batch.strain} - ${batch.product_made} (${weight}g)${containerIndicator}${workerIndicator}${pauseIndicator}</option>`;
            });
        }

        document.getElementById('packagingBatchSelect').addEventListener('change', function() {
            const form = document.getElementById('packagingForm');
            form.style.display = this.value ? 'block' : 'none';
            
            if (this.value) {
                const batch = batches.find(b => b.id === this.value);
                document.getElementById('packagingDate').value = new Date().toISOString().split('T')[0];
                
                // Show strain type with color coding
                const strainTypeAlert = document.getElementById('strainTypeAlert');
                const strainTypeName = document.getElementById('strainTypeName');
                
                if (batch.strain_type) {
                    strainTypeAlert.style.display = 'block';
                    strainTypeName.textContent = batch.strain_type;
                    
                    // Color code based on strain type
                    if (batch.strain_type === 'Indica') {
                        // BLUE for Indica
                        strainTypeAlert.style.background = 'rgba(59, 130, 246, 0.2)';
                        strainTypeAlert.style.borderColor = 'var(--accent-blue)';
                        strainTypeName.style.color = 'var(--accent-blue)';
                    } else if (batch.strain_type === 'Sativa') {
                        // RED for Sativa
                        strainTypeAlert.style.background = 'rgba(239, 68, 68, 0.2)';
                        strainTypeAlert.style.borderColor = 'var(--accent-red)';
                        strainTypeName.style.color = 'var(--accent-red)';
                    } else if (batch.strain_type === 'Hybrid') {
                        // GREEN for Hybrid
                        strainTypeAlert.style.background = 'rgba(16, 185, 129, 0.2)';
                        strainTypeAlert.style.borderColor = 'var(--accent-green)';
                        strainTypeName.style.color = 'var(--accent-green)';
                    }
                } else {
                    strainTypeAlert.style.display = 'none';
                }
                
                // Update pause button visibility
                updatePauseButtons();
            }
        });

        // Handle product type selection for multi-size vs single-size
        document.getElementById('packagedProductType').addEventListener('change', function() {
            const multiSize = document.getElementById('multiSizeSection');
            const singleSize = document.getElementById('singleSizeSection');
            const bulkSaleAlert = document.getElementById('bulkSaleAlert');
            const units1gLabel = multiSize.querySelector('label[for="units1g"]') || multiSize.querySelectorAll('label')[0];
            const units4gLabel = multiSize.querySelector('label[for="units4g"]') || multiSize.querySelectorAll('label')[1];
            
            // Show/hide bulk sale alert
            if (this.value === 'Bulk Sale') {
                bulkSaleAlert.style.display = 'block';
            } else {
                bulkSaleAlert.style.display = 'none';
            }
            
            if (this.value === 'Wax' || this.value === 'Sugar Wax' || this.value === 'Brick Hash') {
                multiSize.style.display = 'block';
                singleSize.style.display = 'none';
                document.getElementById('unitsPackaged').required = false;
                
                // Set labels for 1g/4g
                if (units1gLabel) units1gLabel.textContent = '1g Units';
                if (units4gLabel) units4gLabel.textContent = '4g Units';
                
            } else if (this.value === 'Hash Hits') {
                multiSize.style.display = 'block';
                singleSize.style.display = 'none';
                document.getElementById('unitsPackaged').required = false;
                
                // Set labels for 2-pack/5-pack
                if (units1gLabel) units1gLabel.textContent = '2-Packs';
                if (units4gLabel) units4gLabel.textContent = '5-Packs';
                
            } else {
                multiSize.style.display = 'none';
                singleSize.style.display = 'block';
                document.getElementById('unitsPackaged').required = true;
                // Reset multi-size fields
                document.getElementById('units1g').value = 0;
                document.getElementById('units4g').value = 0;
            }
        });

        // Auto-calculate totals for multi-size packaging
        function updateMultiSizeCalcs() {
            const productType = document.getElementById('packagedProductType').value;
            const units1g = parseInt(document.getElementById('units1g').value) || 0;
            const units4g = parseInt(document.getElementById('units4g').value) || 0;
            
            let totalGrams, totalUnits;
            
            if (productType === 'Hash Hits') {
                // Hash Hits: 0.2g per hit, 2-packs and 5-packs
                const totalHits = (units1g * 2) + (units4g * 5);
                totalGrams = totalHits * 0.2;
                totalUnits = units1g + units4g; // Total packs
                
                document.getElementById('totalGramsCalc').value = `${totalGrams.toFixed(1)}g (${totalHits} hits)`;
                document.getElementById('totalUnitsCalc').value = `${totalUnits} packs`;
            } else {
                // Regular 1g/4g products
                totalGrams = (units1g * 1) + (units4g * 4);
                totalUnits = units1g + units4g;
                
                document.getElementById('totalGramsCalc').value = totalGrams;
                document.getElementById('totalUnitsCalc').value = totalUnits;
            }
            
            // Update pricing when quantities change
            updatePricing();
        }

        // Calculate wholesale price based on SKU pricing (internal use only, not displayed to packagers)
        document.getElementById('units1g').addEventListener('input', updateMultiSizeCalcs);
        document.getElementById('units4g').addEventListener('input', updateMultiSizeCalcs);

        // Start packaging (marks batch as in-progress)
        async function startPackaging() {
            if (!currentRole) {
                alert('Please select a user first!');
                return;
            }

            const batchId = document.getElementById('packagingBatchSelect').value;
            const batch = batches.find(b => b.id === batchId);
            
            if (!batch) return;
            
            const packagingDate = document.getElementById('packagingDate').value;
            const productType = document.getElementById('packagedProductType').value;
            
            if (!packagingDate || !productType) {
                alert('Please select packaging date and product type');
                return;
            }
            
            const confirmation = confirm(
                `Mark batch ${batchId} as STARTED packaging?\n\n` +
                `This will:\n` +
                ` Add "Packaging Started" to timeline\n` +
                ` Keep status as "finishing" (not yet complete)\n` +
                ` Allow you to finish later\n\n` +
                `You can skip this and go straight to "Complete Packaging" for single sessions.`
            );
            
            if (!confirmation) return;
            
            const timeline = batch.timeline || [];
            timeline.push({
                stage: 'packaging',
                user: currentRole ? currentRole.name : "Unknown",
                date: new Date().toISOString(),
                action: `Packaging started - ${productType}`
            });
            
            const { error } = await supabaseClient
                .from('wm_batches')
                .update({
                    packaging_date: packagingDate,
                    packaged_product_type: productType,
                    packaging_notes: document.getElementById('packagingNotes').value || null,
                    timeline: timeline
                })
                .eq('id', batchId);
            
            if (error) {
                console.error('Error marking batch as started:', error);
                alert('Error updating batch. Please try again.');
                return;
            }
            
            alert(` Batch ${batchId} marked as packaging in progress!\n\n` +
                  `Product Type: ${productType}\n` +
                  `Started by: ${currentRole.name}\n\n` +
                  `This batch will remain in the dropdown until you click "Complete Packaging".`);
            
            // Refresh batch data but keep form open and batch selected
            await loadBatches();
            populatePackagingSelect();
            
            // Re-select the batch
            document.getElementById('packagingBatchSelect').value = batchId;
            document.getElementById('packagingForm').style.display = 'block';
        }

        // Toggle pause/resume for packaging
        async function togglePausePackaging() {
            if (!currentRole) {
                alert('Please select a user first!');
                return;
            }

            const batchId = document.getElementById('packagingBatchSelect').value;
            const batch = batches.find(b => b.id === batchId);
            
            if (!batch) {
                alert('Please select a batch first!');
                return;
            }
            
            const isPaused = batch.packaging_paused || false;
            const action = isPaused ? 'RESUME' : 'PAUSE';
            const actionVerb = isPaused ? 'Resumed' : 'Paused';
            
            const confirmation = confirm(
                `${action} packaging for batch ${batchId}?\n\n` +
                `This will:\n` +
                ` Add "${actionVerb}" to timeline\n` +
                ` ${isPaused ? 'Allow work to continue' : 'Temporarily stop work'}\n` +
                ` Keep batch in packaging stage`
            );
            
            if (!confirmation) return;
            
            const timeline = batch.timeline || [];
            timeline.push({
                stage: 'packaging',
                user: currentRole ? currentRole.name : "Unknown",
                date: new Date().toISOString(),
                action: `Packaging ${actionVerb.toLowerCase()} - ${batch.product_type || 'unknown product'}`
            });
            
            const { error } = await supabaseClient
                .from('wm_batches')
                .update({
                    packaging_paused: !isPaused,
                    timeline: timeline
                })
                .eq('id', batchId);
            
            if (error) {
                console.error('Error toggling pause:', error);
                alert('Error updating batch. Please try again.');
                return;
            }
            
            alert(` Packaging ${actionVerb.toLowerCase()} for batch ${batchId}!\n\n` +
                  `${isPaused ? 'Work can continue.' : 'Work temporarily stopped.'}\n` +
                  `${actionVerb} by: ${currentRole.name}`);
            
            await loadBatches();
            populatePackagingSelect();
            // Keep the batch selected
            document.getElementById('packagingBatchSelect').value = batchId;
            document.getElementById('packagingBatchSelect').dispatchEvent(new Event('change'));
        }

        async function submitPackaging() {
            if (blockDemoWrite('Packaging batches')) return;

            if (!currentRole) {
                alert('Please select a user first!');
                return;
            }

            const batchId = document.getElementById('packagingBatchSelect').value;
            const batch = batches.find(b => b.id === batchId);

            if (!batch) {
                alert('Batch not found. Please select a batch.');
                return;
            }

            const packagedProductType = document.getElementById('packagedProductType').value;

            if (!packagedProductType) {
                alert('Please select a product type');
                return;
            }

            let unitsPackaged, totalGrams, packagingDetails;

            // Wholesale price set to 0 (staff doesn't know this info)
            const wholesalePrice = 0;
            
            // Handle multi-size packaging
            if (packagedProductType === 'Wax' || packagedProductType === 'Sugar Wax' || packagedProductType === 'Brick Hash' || packagedProductType === 'Hash Hits') {
                const units1g = parseInt(document.getElementById('units1g').value) || 0;
                const units4g = parseInt(document.getElementById('units4g').value) || 0;
                
                if (units1g === 0 && units4g === 0) {
                    alert('Please enter at least one package size');
                    return;
                }
                
                if (packagedProductType === 'Hash Hits') {
                    // Hash Hits: 0.2g per hit
                    const totalHits = (units1g * 2) + (units4g * 5);
                    totalGrams = totalHits * 0.2;
                    unitsPackaged = units1g + units4g; // Total packs
                    
                    packagingDetails = {
                        units_1g: units1g,
                        units_4g: units4g,
                        total_grams: totalGrams,
                        packaging_breakdown: `${units1g}x 2-pack, ${units4g}x 5-pack`
                    };
                } else {
                    // Wax, Sugar Wax, or Brick Hash
                    totalGrams = (units1g * 1) + (units4g * 4);
                    unitsPackaged = units1g + units4g;
                    
                    packagingDetails = {
                        units_1g: units1g,
                        units_4g: units4g,
                        total_grams: totalGrams,
                        packaging_breakdown: `${units1g}x 1g, ${units4g}x 4g`
                    };
                }
            } else {
                // Single size packaging
                unitsPackaged = parseInt(document.getElementById('unitsPackaged').value);
                
                if (!unitsPackaged || unitsPackaged === 0) {
                    alert('Please enter units packaged');
                    return;
                }
                
                packagingDetails = {
                    units_1g: null,
                    units_4g: null,
                    total_grams: null,
                    packaging_breakdown: null
                };
            }
            
            const timeline = batch.timeline || [];
            
            // Check if this is a bulk sale
            const isBulkSale = packagedProductType === 'Bulk Sale';
            
            if (packagedProductType === 'Wax' || packagedProductType === 'Sugar Wax' || packagedProductType === 'Brick Hash') {
                timeline.push({
                    stage: 'packaging',
                    user: currentRole ? currentRole.name : "Unknown",
                    date: new Date().toISOString(),
                    action: `Packaged ${unitsPackaged} total units (${packagingDetails.packaging_breakdown} = ${totalGrams}g) - ${packagedProductType}`
                });
            } else if (isBulkSale) {
                timeline.push({
                    stage: 'packaging',
                    user: currentRole ? currentRole.name : "Unknown",
                    date: new Date().toISOString(),
                    action: `Bulk sale - ${unitsPackaged} unit(s) - Proceeding to testing`
                });
            } else {
                timeline.push({
                    stage: 'packaging',
                    user: currentRole ? currentRole.name : "Unknown",
                    date: new Date().toISOString(),
                    action: `Packaged ${unitsPackaged} units - ${packagedProductType}`
                });
            }
            
            // Store 1g and 4g unit counts - labeling will track what was actually labeled
            const units1g = packagingDetails.units_1g || 0;
            const units4g = packagingDetails.units_4g || 0;

            const updateData = {
                packaging_date: document.getElementById('packagingDate').value,
                packaged_product_type: packagedProductType,
                units_packaged: unitsPackaged,
                units_1g: units1g,
                units_4g: units4g,
                total_grams_packaged: packagingDetails.total_grams,
                packaging_breakdown: packagingDetails.packaging_breakdown,
                wholesale_price: wholesalePrice,
                packaging_notes: document.getElementById('packagingNotes').value,
                packaging_user: currentRole ? currentRole.name : "Unknown",
                timeline: timeline
            };

            // If bulk sale, go to packaging status (testing queue) but will skip labeling after testing
            if (isBulkSale) {
                updateData.status = 'packaging'; // Goes to testing queue
                // Note: labels_applied will be set to true after testing is complete
            } else {
                // Normal packaging - goes to "complete" status waiting for labeling
                updateData.status = 'complete';
                updateData.completed_at = new Date().toISOString();
            }

            const { error } = await supabaseClient
                .from('wm_batches')
                .update(updateData)
                .eq('id', batchId);
            
            if (error) {
                console.error('Error updating batch:', error);
                alert('Error updating batch. Please try again.');
                return;
            }
            
            if (isBulkSale) {
                showCelebration({
                    emoji: '',
                    title: 'Bulk Sale Ready for Testing!',
                    message: `${batchId} is packaged and ready for testing!`,
                    stats: [
                        { value: `${totalGrams}g`, label: 'Total Weight' },
                        { value: packagedProductType, label: 'Product' }
                    ]
                });
            } else {
                // Build stats array based on what was packaged
                const celebrationStats = [];
                if (units1g > 0) celebrationStats.push({ value: `${units1g}x 1g`, label: '1g Units' });
                if (units4g > 0) celebrationStats.push({ value: `${units4g}x 4g`, label: '4g Units' });
                if (celebrationStats.length === 0) celebrationStats.push({ value: unitsPackaged, label: 'Units Packed' });
                celebrationStats.push({ value: packagedProductType, label: 'Product' });

                showCelebration({
                    emoji: '',
                    title: 'Packaging Complete!',
                    message: `${batchId} is packed and ready for labeling!`,
                    stats: celebrationStats
                });
            }

            document.getElementById('packagingForm').style.display = 'none';
            document.getElementById('packagingBatchSelect').value = '';
            document.getElementById('packagingNotes').value = '';
            document.getElementById('units1g').value = 0;
            document.getElementById('units4g').value = 0;
            document.getElementById('unitsPackaged').value = '';
            
            await loadBatches();
            populatePackagingSelect();
        }

        // Dashboard functions
        function updateDashboard() {
            document.getElementById('totalBatches').textContent = batches.length;
            document.getElementById('activeBatches').textContent = batches.filter(b => b.status !== 'complete').length;
            document.getElementById('completedBatches').textContent = batches.filter(b => b.status === 'complete').length;
            
            const totalGrams = batches.reduce((sum, b) => sum + (parseFloat(b.trim_weight) || 0), 0);
            document.getElementById('totalGramsIn').textContent = totalGrams.toFixed(0) + 'g';
            
            // Calculate total weight loss from bulk to labeled
            let totalWeightLoss = 0;
            let batchesWithDiscrepancy = 0;
            
            batches.forEach(batch => {
                if (batch.grams_labeled && batch.net_weight) {
                    const labeled = parseFloat(batch.grams_labeled);
                    const bulk = parseFloat(batch.net_weight);
                    const loss = bulk - labeled;
                    
                    if (loss > 0) {
                        totalWeightLoss += loss;
                        
                        // Count significant discrepancies (>5% or >5g)
                        const lossPercent = (loss / bulk) * 100;
                        if (lossPercent > 5 || loss > 5) {
                            batchesWithDiscrepancy++;
                        }
                    }
                }
            });
            
            // Update weight discrepancy card
            const discrepancyCard = document.getElementById('weightDiscrepancyCard');
            const weightLossElement = document.getElementById('totalWeightLoss');
            
            if (totalWeightLoss > 0) {
                discrepancyCard.style.display = 'block';
                weightLossElement.textContent = `${totalWeightLoss.toFixed(1)}g`;
                
                // Update label to show count if there are significant discrepancies
                const label = discrepancyCard.querySelector('.stat-label');
                if (batchesWithDiscrepancy > 0) {
                    label.innerHTML = ` Weight Loss (${batchesWithDiscrepancy} batches)`;
                    weightLossElement.style.color = 'var(--accent-orange)';
                } else {
                    label.innerHTML = ' Weight Loss (BulkLabel)';
                    weightLossElement.style.color = 'var(--accent-blue)';
                }
            } else {
                discrepancyCard.style.display = 'none';
            }
            
            // Update personal workload stats
            updatePersonalWorkloadStats();
            
            // Update badge counts on navigation tabs
            updateBadgeCounts();

            // Load needs data for dashboard display
            if (document.getElementById('dashboardNeedsGrid')) {
                loadNeedsData();
            }
        }

        // Update badge counts on navigation tabs
        function updateBadgeCounts() {
            // Count batches at each stage (excluding intake)
            const counts = {
                extraction: batches.filter(b => b.status === 'intake').length, // Waiting for extraction
                finishing: batches.filter(b => b.status === 'extraction').length, // Waiting for post-extraction
                packaging: batches.filter(b => b.status === 'finishing').length, // Waiting for packaging
                testing: batches.filter(b => b.status === 'packaging' || (b.status === 'complete' && !b.test_thc_percent)).length,
                labeling: batches.filter(b => b.status === 'complete' && b.test_thc_percent && !b.labels_applied).length
            };
            
            // Update each badge
            Object.entries(counts).forEach(([stage, count]) => {
                const badge = document.getElementById(`badge-${stage}`);
                if (badge) {
                    badge.textContent = count;
                    if (count > 0) {
                        badge.classList.add('has-count');
                    } else {
                        badge.classList.remove('has-count');
                    }
                }
            });
        }

        // Personal Performance Stats Dashboard
        let currentPersonalPeriod = 'today';
        
        function updatePersonalStats(period = 'today') {
            currentPersonalPeriod = period;
            
            // Update button states
            document.querySelectorAll('.personal-time-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            const periodBtn = document.querySelector(`[data-period="${period}"]`);
            if (periodBtn) periodBtn.classList.add('active');
            
            if (!currentRole) {
                document.getElementById('personalStatsContent').innerHTML = '<p style="grid-column: 1/-1; text-align: center; color: var(--text-secondary);">Please login to see your stats</p>';
                document.getElementById('personalRecordsContent').innerHTML = '';
                return;
            }
            
            // Calculate date range
            const now = new Date();
            let startDate;
            
            switch(period) {
                case 'today':
                    startDate = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                    break;
                case 'week':
                    startDate = new Date(now);
                    startDate.setDate(now.getDate() - 7);
                    break;
                case 'month':
                    startDate = new Date(now);
                    startDate.setDate(now.getDate() - 30);
                    break;
                case 'all':
                default:
                    startDate = new Date(0); // Beginning of time
            }
            
            // Calculate stats
            const stats = calculatePersonalStats(currentRole.name, startDate);
            
            // Display stats
            displayPersonalStats(stats, period);
            displayPersonalRecords(currentRole.name);
        }
        
        function calculatePersonalStats(userName, startDate) {
            const stats = {
                unitsPackaged: 0,
                unitsLabeled: 0,
                gramsExtracted: 0,
                batchesFinished: 0,
                avgPackagingRate: 0,
                avgLabelingRate: 0
            };
            
            batches.forEach(batch => {
                // PACKAGING: Check packaging_user field (same as Performance tab uses)
                if (batch.packaging_user === userName && batch.packaging_date && batch.units_packaged) {
                    const packagingDate = new Date(batch.packaging_date);
                    if (packagingDate >= startDate) {
                        stats.unitsPackaged += parseInt(batch.units_packaged) || 0;
                    }
                }
                
                // EXTRACTION: Check extraction_user field first (most reliable)
                if (batch.extraction_user === userName && batch.status !== 'intake' && batch.trim_weight) {
                    // Check if extraction was done in the date range
                    let extractionDate = null;
                    if (batch.timeline && batch.timeline.length > 0) {
                        const extractionEvent = batch.timeline.find(e => 
                            e.stage === 'extraction' && e.user === userName
                        );
                        if (extractionEvent) {
                            extractionDate = new Date(extractionEvent.timestamp || extractionEvent.date);
                        }
                    }
                    
                    // If we found an extraction event in the date range, count it
                    if (extractionDate && extractionDate >= startDate) {
                        const grams = parseFloat(batch.trim_weight) || 0;
                        stats.gramsExtracted += grams;
                    }
                }
                
                // FINISHING: Check finishing_user field
                if (batch.finishing_user === userName && batch.status !== 'intake' && batch.status !== 'extraction') {
                    // Check if finishing was done in the date range
                    let finishingDate = null;
                    if (batch.timeline && batch.timeline.length > 0) {
                        const finishingEvent = batch.timeline.find(e => 
                            e.stage === 'finishing' && e.user === userName
                        );
                        if (finishingEvent) {
                            finishingDate = new Date(finishingEvent.timestamp || finishingEvent.date);
                        }
                    }
                    
                    // If we found a finishing event in the date range, count it
                    if (finishingDate && finishingDate >= startDate) {
                        stats.batchesFinished++;
                    }
                }
                
                // LABELING: Check timeline (same as before)
                if (batch.timeline && batch.timeline.length > 0) {
                    batch.timeline.forEach(event => {
                        if (!event.date && !event.timestamp) return;
                        if (!event.user || event.user !== userName) return;
                        
                        const eventDate = new Date(event.timestamp || event.date);
                        if (eventDate < startDate) return;
                        
                        // Labeling
                        if (event.stage === 'labeling' && event.action && 
                            (event.action.toLowerCase().includes('completed') || event.action.toLowerCase().includes('labeled')) &&
                            batch.units_packaged) {
                            stats.unitsLabeled += parseInt(batch.units_packaged) || 0;
                        }
                    });
                }
            });

            return stats;
        }
        
        function displayPersonalStats(stats, period) {
            const periodLabel = {
                'today': 'Today',
                'week': 'This Week', 
                'month': 'This Month',
                'all': 'All Time'
            }[period];
            
            const statName = `${currentRole.name}'s Performance - ${periodLabel}`;
            const personalStatEl = document.getElementById('personalStatName');
            const modalStatEl = document.getElementById('modalPersonalStatName');
            if (personalStatEl) personalStatEl.textContent = statName;
            if (modalStatEl) modalStatEl.textContent = statName;
            
            // Convert grams to pounds if over 454g (1 lb)
            const extractedDisplay = stats.gramsExtracted >= 454 
                ? `${(stats.gramsExtracted / 453.592).toFixed(1)} lbs`
                : `${stats.gramsExtracted.toFixed(0)}g`;
            
            const content = `
                <div class="stat-box">
                    <div class="stat-number">${stats.unitsPackaged.toLocaleString()}</div>
                    <div class="stat-label"> Units Packaged</div>
                </div>
                
                <div class="stat-box">
                    <div class="stat-number">${stats.unitsLabeled.toLocaleString()}</div>
                    <div class="stat-label"> Units Labeled</div>
                </div>
                
                <div class="stat-box">
                    <div class="stat-number">${extractedDisplay}</div>
                    <div class="stat-label"> Trim Extracted</div>
                </div>
                
                <div class="stat-box">
                    <div class="stat-number">${stats.batchesFinished}</div>
                    <div class="stat-label"> Batches Finished</div>
                </div>
                
                ${stats.avgPackagingRate > 0 ? `
                <div class="stat-box">
                    <div class="stat-number">${stats.avgPackagingRate}</div>
                    <div class="stat-label"> Units/Hour (Packaging)</div>
                </div>
                ` : ''}
                
                ${stats.avgLabelingRate > 0 ? `
                <div class="stat-box">
                    <div class="stat-number">${stats.avgLabelingRate}</div>
                    <div class="stat-label"> Units/Hour (Labeling)</div>
                </div>
                ` : ''}
            `;
            
            document.getElementById('personalStatsContent').innerHTML = content;
        }
        
        // Open/close personal stats modal
        function openPersonalStatsModal() {
            if (!currentRole) {
                alert('Please login first to see your stats!');
                return;
            }

            document.getElementById('personalStatsModal').style.display = 'block';

            // Check if user is Drew (Sales) - show sales stats instead
            if (currentRole.name.includes('Drew') || currentRole.name.includes('Sales') || currentRole.name.includes('Ryan')) {
                showSalesWorkload();
            } else {
                populateWhatsNext();
                populateTodayProgress();
                updatePersonalStats('today');
            }
        }

        // Sales-specific workload view for Drew
        async function showSalesWorkload() {
            const modalName = document.getElementById('modalPersonalStatName');
            const whatsNextSection = document.getElementById('whatsNextSection');
            const todayProgressContent = document.getElementById('todayProgressContent');
            const personalStatsContent = document.getElementById('personalStatsContent');
            const myBatchesSection = document.getElementById('myBatchesSection');
            const personalRecords = document.getElementById('personalRecords');

            modalName.textContent = 'Sales Dashboard';

            // Show loading state
            whatsNextSection.innerHTML = `
                <h3 style="color: var(--accent-green); margin: 0 0 15px 0; font-size: 1.3rem;"> Sales Overview</h3>
                <div style="text-align: center; padding: 20px; color: var(--text-secondary);">Loading sales data...</div>
            `;

            // Load LeafLink data
            await ensureLeafLinkData();

            // Get stats for different periods
            const monthStats = calculateSalesStats('month');
            const weekStats = calculateSalesStats('week');

            // Update What's Next section with sales summary
            whatsNextSection.innerHTML = `
                <h3 style="color: var(--accent-green); margin: 0 0 15px 0; font-size: 1.3rem;"> This Month's Performance</h3>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px;">
                    <div style="background: linear-gradient(135deg, #1a1a2e, #16213e); padding: 20px; border-radius: 12px; text-align: center; border: 1px solid rgba(255,215,0,0.3);">
                        <div style="font-size: 2.5rem; font-weight: 700; color: #FFD700;">${monthStats.totalOrders}</div>
                        <div style="color: var(--text-secondary); font-size: 0.9rem;">Orders</div>
                        <div style="color: ${monthStats.ordersChange >= 0 ? 'var(--accent-green)' : 'var(--accent-red)'}; font-size: 0.8rem; margin-top: 5px;">
                            ${monthStats.ordersChange >= 0 ? '' : ''} ${Math.abs(monthStats.ordersChange)}% vs last month
                        </div>
                    </div>
                    <div style="background: linear-gradient(135deg, #1a1a2e, #16213e); padding: 20px; border-radius: 12px; text-align: center; border: 1px solid rgba(16,185,129,0.3);">
                        <div style="font-size: 2.5rem; font-weight: 700; color: #10B981;">$${monthStats.totalDollars.toLocaleString('en-US', {minimumFractionDigits: 0, maximumFractionDigits: 0})}</div>
                        <div style="color: var(--text-secondary); font-size: 0.9rem;">Revenue</div>
                        <div style="color: ${monthStats.dollarsChange >= 0 ? 'var(--accent-green)' : 'var(--accent-red)'}; font-size: 0.8rem; margin-top: 5px;">
                            ${monthStats.dollarsChange >= 0 ? '' : ''} ${Math.abs(monthStats.dollarsChange)}% vs last month
                        </div>
                    </div>
                    <div style="background: linear-gradient(135deg, #1a1a2e, #16213e); padding: 20px; border-radius: 12px; text-align: center; border: 1px solid rgba(191,0,255,0.3);">
                        <div style="font-size: 2.5rem; font-weight: 700; color: #BF00FF;">${monthStats.newShops.length}</div>
                        <div style="color: var(--text-secondary); font-size: 0.9rem;">New Shops</div>
                    </div>
                    <div style="background: linear-gradient(135deg, #1a1a2e, #16213e); padding: 20px; border-radius: 12px; text-align: center; border: 1px solid rgba(59,130,246,0.3);">
                        <div style="font-size: 2.5rem; font-weight: 700; color: #3B82F6;">${monthStats.uniqueCustomers}</div>
                        <div style="color: var(--text-secondary); font-size: 0.9rem;">Active Customers</div>
                    </div>
                </div>
            `;

            // Calculate payment stats
            const paymentStats = calculatePaymentStats(allLeafLinkOrders);

            // Today's Progress - Payment Status
            todayProgressContent.parentElement.querySelector('h3').innerHTML = ' Payment Status';
            todayProgressContent.innerHTML = `
                <div style="background: var(--bg-tertiary); padding: 15px; border-radius: 8px; text-align: center; border-left: 3px solid var(--accent-green);">
                    <div style="font-size: 2rem; font-weight: 700; color: var(--accent-green);">${paymentStats.paidCount}</div>
                    <div style="color: var(--text-secondary); font-size: 0.85rem;">Paid</div>
                    <div style="color: var(--accent-green); font-size: 0.8rem;">$${paymentStats.paidTotal.toLocaleString('en-US', {minimumFractionDigits: 0, maximumFractionDigits: 0})}</div>
                </div>
                <div style="background: var(--bg-tertiary); padding: 15px; border-radius: 8px; text-align: center; border-left: 3px solid var(--accent-orange);">
                    <div style="font-size: 2rem; font-weight: 700; color: var(--accent-orange);">${paymentStats.unpaidCount}</div>
                    <div style="color: var(--text-secondary); font-size: 0.85rem;">Unpaid</div>
                    <div style="color: var(--accent-orange); font-size: 0.8rem;">$${paymentStats.unpaidTotal.toLocaleString('en-US', {minimumFractionDigits: 0, maximumFractionDigits: 0})}</div>
                </div>
                <div style="background: var(--bg-tertiary); padding: 15px; border-radius: 8px; text-align: center; border-left: 3px solid ${paymentStats.overdueCount > 0 ? 'var(--accent-red)' : 'var(--text-secondary)'};">
                    <div style="font-size: 2rem; font-weight: 700; color: ${paymentStats.overdueCount > 0 ? 'var(--accent-red)' : 'var(--text-secondary)'};">${paymentStats.overdueCount}</div>
                    <div style="color: var(--text-secondary); font-size: 0.85rem;">Overdue</div>
                    <div style="color: ${paymentStats.overdueCount > 0 ? 'var(--accent-red)' : 'var(--text-secondary)'}; font-size: 0.8rem;">$${paymentStats.overdueTotal.toLocaleString('en-US', {minimumFractionDigits: 0, maximumFractionDigits: 0})}</div>
                </div>
            `;

            // Hide production-specific sections
            document.querySelectorAll('.personal-time-btn').forEach(btn => btn.style.display = 'none');
            personalStatsContent.style.display = 'none';

            // Show overdue orders in myBatchesSection with expandable dropdown
            if (paymentStats.overdueCount > 0) {
                // Store data globally for sorting
                overduePaymentData = paymentStats.overdueOrders;
                // Sort by days overdue by default
                overduePaymentData.sort((a, b) => b.daysOverdue - a.daysOverdue);

                // Count critical (60+ days) and severe (30+ days)
                const criticalCount = overduePaymentData.filter(o => o.daysOverdue > 60).length;
                const severeCount = overduePaymentData.filter(o => o.daysOverdue > 30 && o.daysOverdue <= 60).length;

                myBatchesSection.style.display = 'block';
                myBatchesSection.innerHTML = `
                    <div onclick="toggleOverduePayments()" style="cursor: pointer; display: flex; justify-content: space-between; align-items: center; padding: 15px; background: linear-gradient(135deg, rgba(239, 68, 68, 0.2), rgba(239, 68, 68, 0.1)); border-radius: 12px; border: 1px solid rgba(239, 68, 68, 0.4);">
                        <div style="display: flex; align-items: center; gap: 15px;">
                            <span id="overdueArrow" style="font-size: 1.2rem; color: var(--accent-red);"></span>
                            <h3 style="color: var(--accent-red); margin: 0; font-size: 1.3rem;"> Accounts Receivable (${paymentStats.overdueCount})</h3>
                        </div>
                        <div style="display: flex; gap: 10px; align-items: center;">
                            ${criticalCount > 0 ? `<span style="background: #ff0000; color: white; padding: 4px 10px; border-radius: 15px; font-size: 0.8rem; font-weight: 600;"> ${criticalCount} CRITICAL</span>` : ''}
                            ${severeCount > 0 ? `<span style="background: #ff6b00; color: white; padding: 4px 10px; border-radius: 15px; font-size: 0.8rem; font-weight: 600;"> ${severeCount} SEVERE</span>` : ''}
                            <span style="color: var(--accent-red); font-weight: 700; font-size: 1.2rem;">${paymentStats.overdueTotal.toLocaleString('en-US', {minimumFractionDigits: 0, maximumFractionDigits: 0})}</span>
                        </div>
                    </div>

                    <div id="overduePaymentsContent" style="display: none; margin-top: 15px;">
                        <div style="display: flex; gap: 10px; margin-bottom: 15px; flex-wrap: wrap;">
                            <span style="color: var(--text-secondary); padding: 8px 0;">Sort by:</span>
                            <button class="overdue-sort-btn active" data-sort="daysOverdue" onclick="sortOverduePayments('daysOverdue')" style="background: rgba(239, 68, 68, 0.2); border: 1px solid var(--accent-red); color: var(--accent-red); padding: 8px 15px; border-radius: 20px; cursor: pointer; font-size: 0.9rem;">Days Overdue</button>
                            <button class="overdue-sort-btn" data-sort="amount" onclick="sortOverduePayments('amount')" style="background: transparent; border: 1px solid var(--border); color: var(--text-secondary); padding: 8px 15px; border-radius: 20px; cursor: pointer; font-size: 0.9rem;">Amount</button>
                            <button class="overdue-sort-btn" data-sort="customer" onclick="sortOverduePayments('customer')" style="background: transparent; border: 1px solid var(--border); color: var(--text-secondary); padding: 8px 15px; border-radius: 20px; cursor: pointer; font-size: 0.9rem;">Customer</button>
                            <button class="overdue-sort-btn" data-sort="dueDate" onclick="sortOverduePayments('dueDate')" style="background: transparent; border: 1px solid var(--border); color: var(--text-secondary); padding: 8px 15px; border-radius: 20px; cursor: pointer; font-size: 0.9rem;">Due Date</button>
                        </div>
                        <div id="overduePaymentsList" style="display: flex; flex-direction: column; gap: 10px; max-height: 400px; overflow-y: auto;">
                        </div>
                    </div>
                `;

                // Render the initial sorted list
                renderOverduePayments(overduePaymentData);
            } else {
                myBatchesSection.style.display = 'none';
            }

            // Show new shops celebration instead of personal records
            if (monthStats.newShops.length > 0) {
                personalRecords.innerHTML = `
                    <h3 style="color: #BF00FF; margin-bottom: 20px; text-align: center; font-size: 1.5rem;"> Welcome New Partners!</h3>
                    <div style="display: flex; flex-wrap: wrap; gap: 10px; justify-content: center;">
                        ${monthStats.newShops.map(shop => `
                            <div style="background: linear-gradient(135deg, rgba(191,0,255,0.2), rgba(59,130,246,0.2)); border: 1px solid rgba(191,0,255,0.4); padding: 12px 20px; border-radius: 25px; display: flex; align-items: center; gap: 10px;">
                                <span style="font-size: 1.3rem;"></span>
                                <span style="font-weight: 600;">${shop.name}</span>
                            </div>
                        `).join('')}
                    </div>
                `;
            } else {
                personalRecords.innerHTML = `
                    <h3 style="color: var(--accent-purple); margin-bottom: 20px; text-align: center; font-size: 1.5rem;"> Goals</h3>
                    <div style="text-align: center; color: var(--text-secondary); padding: 20px;">
                        No new shops this month yet - keep pushing!
                    </div>
                `;
            }
        }
        
        function populateWhatsNext() {
            const userName = currentRole.name;
            const whatsNextEl = document.getElementById('whatsNextContent');

            // Get priority scores for each batch based on needs
            function getNeedsPriority(batch) {
                if (!needsData || typeof needsData !== 'object') return 0;
                const category = getProductCategory(batch.product_made);
                if (!category || !needsData[category]) return 0;
                const strainType = (batch.strain_type || 'Hybrid').trim();
                const need = (needsData[category].needs || []).find(n => n.strainType === strainType);
                if (!need) return 0;
                return (need.varietiesNeeded * 10) + (need.qtyNeeded > 0 ? 5 : 0);
            }

            // Find batches waiting for this user, sorted by needs priority
            let availableBatches = [];
            let taskType = '';

            if (currentRole.access.includes('packaging')) {
                availableBatches = batches.filter(b => b.status === 'finishing' && !b.packaging_user);
                taskType = ' Packaging';
            }
            if (availableBatches.length === 0 && currentRole.access.includes('labeling')) {
                availableBatches = batches.filter(b => b.status === 'packaging' && !b.labeling_user);
                taskType = ' Labeling';
            }
            if (availableBatches.length === 0 && currentRole.access.includes('extraction')) {
                availableBatches = batches.filter(b => b.status === 'intake');
                taskType = ' Extraction';
            }
            if (availableBatches.length === 0 && currentRole.access.includes('finishing')) {
                availableBatches = batches.filter(b => b.status === 'extraction');
                taskType = ' Finishing';
            }

            // Sort by needs priority (highest first)
            availableBatches.sort((a, b) => getNeedsPriority(b) - getNeedsPriority(a));

            const nextBatch = availableBatches[0];
            const priority = nextBatch ? getNeedsPriority(nextBatch) : 0;
            const isPriority = priority > 0;

            if (nextBatch) {
                const category = getProductCategory(nextBatch.product_made) || '';
                const strainType = nextBatch.strain_type || 'Hybrid';
                whatsNextEl.innerHTML = `
                    <div style="background: var(--bg-tertiary); padding: 20px; border-radius: 8px; border-left: 4px solid ${isPriority ? '#F59E0B' : 'var(--accent-green)'};">
                        <div style="font-size: 1.1rem; font-weight: 600; color: ${isPriority ? '#F59E0B' : 'var(--accent-green)'}; margin-bottom: 10px;">
                            ${taskType} ${isPriority ? ' PRIORITY' : ''}
                        </div>
                        <div style="font-size: 1.3rem; font-weight: 700; color: var(--text-primary); font-family: 'Space Mono', monospace;">${nextBatch.id}</div>
                        <div style="color: var(--text-secondary); margin-top: 5px;">${nextBatch.strain || 'Unknown strain'} (${strainType})</div>
                        ${category ? `<div style="color: var(--text-secondary); margin-top: 5px;">${category}</div>` : ''}
                        ${isPriority ? `<div style="color: #F59E0B; margin-top: 8px; font-size: 0.9rem;"> High demand - prioritize this batch!</div>` : ''}
                        ${nextBatch.trim_weight ? `<div style="color: var(--text-secondary); margin-top: 5px;">${parseFloat(nextBatch.trim_weight).toFixed(0)}g trim</div>` : ''}
                    </div>
                    ${availableBatches.length > 1 ? `<div style="color: var(--text-secondary); margin-top: 10px; font-size: 0.85rem;">+ ${availableBatches.length - 1} more batches in queue</div>` : ''}
                `;
            } else {
                whatsNextEl.innerHTML = `
                    <div style="background: var(--bg-tertiary); padding: 20px; border-radius: 8px; text-align: center; color: var(--text-secondary);">
                        <div style="font-size: 2rem; margin-bottom: 10px;"></div>
                        <div>All caught up! No batches waiting for you.</div>
                    </div>
                `;
            }
        }
        
        function populateTodayProgress() {
            const userName = currentRole.name;
            const today = new Date().toISOString().split('T')[0];
            const progressEl = document.getElementById('todayProgressContent');
            
            let packaged = 0;
            let labeled = 0;
            let extracted = 0;
            let finished = 0;
            
            batches.forEach(batch => {
                // Packaging
                if (batch.packaging_user === userName && batch.packaging_date) {
                    const date = new Date(batch.packaging_date).toISOString().split('T')[0];
                    if (date === today) packaged += parseInt(batch.units_packaged) || 0;
                }
                
                // Labeling
                if (batch.timeline) {
                    batch.timeline.forEach(event => {
                        if (event.user === userName && event.stage === 'labeling') {
                            const date = new Date(event.timestamp).toISOString().split('T')[0];
                            if (date === today) labeled += parseInt(batch.units_packaged) || 0;
                        }
                    });
                }
                
                // Extraction
                if (batch.timeline) {
                    const extractionEvent = batch.timeline.find(e => e.status === 'extraction' && e.user === userName);
                    if (extractionEvent) {
                        const date = new Date(extractionEvent.timestamp).toISOString().split('T')[0];
                        if (date === today) extracted++;
                    }
                }
                
                // Finishing
                if (batch.finishing_user === userName && batch.finishing_date) {
                    const date = new Date(batch.finishing_date).toISOString().split('T')[0];
                    if (date === today) finished++;
                }
            });
            
            let html = '';
            if (packaged > 0) {
                html += `<div style="background: var(--bg-tertiary); padding: 15px; border-radius: 8px; text-align: center;">
                    <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 5px;"> Packaged</div>
                    <div style="font-size: 2rem; font-weight: 700; color: var(--accent-purple);">${packaged}</div>
                </div>`;
            }
            if (labeled > 0) {
                html += `<div style="background: var(--bg-tertiary); padding: 15px; border-radius: 8px; text-align: center;">
                    <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 5px;"> Labeled</div>
                    <div style="font-size: 2rem; font-weight: 700; color: var(--accent-green);">${labeled}</div>
                </div>`;
            }
            if (extracted > 0) {
                html += `<div style="background: var(--bg-tertiary); padding: 15px; border-radius: 8px; text-align: center;">
                    <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 5px;"> Extracted</div>
                    <div style="font-size: 2rem; font-weight: 700; color: var(--accent-orange);">${extracted}</div>
                </div>`;
            }
            if (finished > 0) {
                html += `<div style="background: var(--bg-tertiary); padding: 15px; border-radius: 8px; text-align: center;">
                    <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 5px;"> Finished</div>
                    <div style="font-size: 2rem; font-weight: 700; color: var(--accent-blue);">${finished}</div>
                </div>`;
            }
            
            if (html === '') {
                html = `<div style="background: var(--bg-tertiary); padding: 20px; border-radius: 8px; text-align: center; color: var(--text-secondary); grid-column: 1 / -1;">
                    No production completed yet today
                </div>`;
            }
            
            progressEl.innerHTML = html;
        }
        
        function closePersonalStatsModal() {
            document.getElementById('personalStatsModal').style.display = 'none';
        }

        // ==================== MATERIAL TYPE / LIVE RESIN WORKFLOW ====================
        function updateMaterialTypeUI() {
            // Check if any Live Resin product is selected
            const selectedProducts = Array.from(document.querySelectorAll('input[name="products"]:checked')).map(cb => cb.value);
            const isLiveResin = selectedProducts.some(p => p.includes('Live Resin'));

            const weightLabel = document.getElementById('weightLabel');
            const socksLabel = document.getElementById('socksLabel');
            const socksHelp = document.getElementById('socksHelp');

            if (isLiveResin) {
                weightLabel.textContent = 'Fresh Frozen Weight (grams)';
                socksLabel.textContent = 'Number of Bowls';
                socksHelp.textContent = 'How many bowls will this fresh frozen fill?';
            } else {
                weightLabel.textContent = 'Trim Weight (grams)';
                socksLabel.textContent = 'Number of Socks';
                socksHelp.textContent = 'How many socks is this trim packed into?';
            }
        }

        // Get expected yield based on material type
        function getExpectedYield(materialType) {
            // Fresh Frozen (Live Resin) = 3.5%, Trim (Standard BHO) = 13%
            return materialType === 'Fresh Frozen' ? 3.5 : 13;
        }


        // Split Live Resin batch into Carts and AIOs sub-batches
        async function splitLiveResinBatch() {
            const finishBatchSelect = document.getElementById('finishBatchSelect');
            const batchId = finishBatchSelect.value;
            if (!batchId) {
                alert('Please select a batch first');
                return;
            }

            const cartsWeight = parseFloat(document.getElementById('splitCartsWeight').value) || 0;
            const aiosWeight = parseFloat(document.getElementById('splitAIOsWeight').value) || 0;

            if (cartsWeight === 0 && aiosWeight === 0) {
                alert('Please enter weights for at least one product type');
                return;
            }

            // Get the parent batch
            const { data: parentBatch, error: fetchError } = await supabaseClient
                .from('wm_batches')
                .select('*')
                .eq('id', batchId)
                .single();

            if (fetchError || !parentBatch) {
                alert('Error fetching batch');
                return;
            }

            const subBatches = [];
            const batchBase = batchId.split('-').slice(0, 2).join('-');

            // Create Carts sub-batch
            if (cartsWeight > 0) {
                const cartsSubId = batchBase + '-CARTS';
                subBatches.push({
                    id: cartsSubId,
                    business_id: parentBatch.business_id, // Inherit business from parent
                    strain: parentBatch.strain,
                    strain_type: parentBatch.strain_type,
                    material_type: parentBatch.material_type || 'Fresh Frozen',
                    expected_yield: parentBatch.expected_yield || 3.5,
                    trim_weight: parentBatch.trim_weight,
                    net_weight_grams: cartsWeight,
                    extraction_output: cartsWeight,
                    planned_products: [{ type: 'Live Resin Carts' }],
                    cultivation_license: parentBatch.cultivation_license,
                    grower_name: parentBatch.grower_name,
                    metrc_tags: parentBatch.metrc_tags,
                    parent_batch_id: batchId,
                    is_sub_batch: true,
                    status: 'post_extraction',
                    timeline: [{
                        stage: 'split',
                        user: currentRole ? currentRole.name : "Unknown",
                        date: new Date().toISOString(),
                        action: 'Split from ' + batchId + ' for Live Resin Carts - ' + cartsWeight + 'g'
                    }],
                    created_at: new Date().toISOString()
                });
            }

            // Create AIOs sub-batch
            if (aiosWeight > 0) {
                const aiosSubId = batchBase + '-AIOs';
                subBatches.push({
                    id: aiosSubId,
                    business_id: parentBatch.business_id, // Inherit business from parent
                    strain: parentBatch.strain,
                    strain_type: parentBatch.strain_type,
                    material_type: parentBatch.material_type || 'Fresh Frozen',
                    expected_yield: parentBatch.expected_yield || 3.5,
                    trim_weight: parentBatch.trim_weight,
                    net_weight_grams: aiosWeight,
                    extraction_output: aiosWeight,
                    planned_products: [{ type: 'Live Resin AIOs' }],
                    cultivation_license: parentBatch.cultivation_license,
                    grower_name: parentBatch.grower_name,
                    metrc_tags: parentBatch.metrc_tags,
                    parent_batch_id: batchId,
                    is_sub_batch: true,
                    status: 'post_extraction',
                    timeline: [{
                        stage: 'split',
                        user: currentRole ? currentRole.name : "Unknown",
                        date: new Date().toISOString(),
                        action: 'Split from ' + batchId + ' for Live Resin AIOs - ' + aiosWeight + 'g'
                    }],
                    created_at: new Date().toISOString()
                });
            }

            // Insert sub-batches
            const { error: insertError } = await supabaseClient
                .from('wm_batches')
                .insert(subBatches);

            if (insertError) {
                console.error('Error creating sub-batches:', insertError);
                alert('Error creating sub-batches');
                return;
            }

            // Update parent batch status
            await supabaseClient
                .from('wm_batches')
                .update({
                    status: 'split',
                    net_weight_grams: (cartsWeight + aiosWeight),
                    timeline: [...(parentBatch.timeline || []), {
                        stage: 'split',
                        user: currentRole ? currentRole.name : "Unknown",
                        date: new Date().toISOString(),
                        action: 'Batch split into: ' + subBatches.map(b => b.id).join(', ')
                    }]
                })
                .eq('id', batchId);

            // Register sub-batches for RTA qualification tracking
            subBatches.forEach(sb => {
                const rtaType = sb.planned_products[0]?.type || 'BHO';
                registerQualificationBatch(rtaType, sb.id);
            });

            alert(' Batch split successfully!\n\n' + subBatches.map(b => b.id + ' (' + b.net_weight_grams + 'g)').join('\n'));

            // Reset form
            document.getElementById('splitCartsWeight').value = '';
            document.getElementById('splitAIOsWeight').value = '';
            document.getElementById('splitBatchSection').style.display = 'none';

            // Refresh display
            loadBatches();
        }

        // Show/hide split section based on batch selection
        function checkShowSplitSection(batchId) {
            const splitSection = document.getElementById('splitBatchSection');
            if (!splitSection) return;

            const batch = batches.find(b => b.id === batchId);
            if (batch && (batch.material_type === 'Fresh Frozen' || isLiveResinBatch(batch))) {
                splitSection.style.display = 'block';
            } else {
                splitSection.style.display = 'none';
            }
        }

        // Check if batch is Live Resin
        function isLiveResinBatch(batch) {
            return batch.material_type === 'Fresh Frozen' ||
                   (batch.planned_products && batch.planned_products.includes('Live Resin'));
        }

        // ==================== COMPLIANCE ASSISTANT ====================
        // Full Colorado MED Rules Search (1 CCR 212-3) - Effective January 5, 2026

        let complianceData = null;
        let complianceLoading = false;

        async function loadComplianceData() {
            if (complianceData) return complianceData;
            if (complianceLoading) return null;

            complianceLoading = true;
            try {
                const response = await fetch('./compliance/compliance_rules.json');
                complianceData = await response.json();
                console.log('Loaded compliance data:', complianceData.ruleCount, 'rules');
                return complianceData;
            } catch (err) {
                console.error('Failed to load compliance data:', err);
                return null;
            } finally {
                complianceLoading = false;
            }
        }

        function openComplianceModal() {
            document.getElementById('complianceModal').style.display = 'block';
            document.getElementById('complianceSearchInput').value = '';
            document.getElementById('complianceResults').innerHTML = '<div style="text-align: center; color: var(--text-secondary); padding: 40px;"><div style="font-size: 3rem; margin-bottom: 15px;"></div><p>Loading compliance database...</p></div>';

            // Pre-load the data
            loadComplianceData().then(data => {
                if (data) {
                    document.getElementById('complianceResults').innerHTML = '<div style="text-align: center; color: var(--text-secondary); padding: 40px;"><div style="font-size: 3rem; margin-bottom: 15px;"></div><p>Search ' + data.ruleCount + ' Colorado MED rules or select a topic.</p><p style="font-size: 0.85rem; margin-top: 10px; color: var(--accent-green);">Full-text search across all 559 pages</p></div>';
                }
            });
        }

        function closeComplianceModal() {
            document.getElementById('complianceModal').style.display = 'none';
        }

        async function searchComplianceTopic(topic) {
            const topicMap = {
                'waste': ['3-900', '3-905', '3-910', '3-915', '3-920', '3-925', '3-930'],
                'metrc': ['3-800', '3-805', '3-810', '3-815', '3-820', '3-825'],
                'label': ['3-1000', '3-1005', '3-1010', '3-1015', '3-1020', '3-1025'],
                'security': ['3-305', '3-310', '3-315', '3-320', '3-325', '3-330'],
                'transport': ['3-1100', '3-1105', '3-1110', '3-1115'],
                'testing': ['3-600', '3-605', '3-610', '3-615', '3-620', '4-205', '4-210', '4-215', '4-220'],
                'reducedtesting': ['4-230']
            };

            const ruleNums = topicMap[topic];
            if (!ruleNums) return;

            const data = await loadComplianceData();
            if (!data) {
                document.getElementById('complianceResults').innerHTML = '<p style="color: var(--accent-red);">Failed to load compliance data.</p>';
                return;
            }

            let html = '<h3 style="color: var(--accent-green); margin: 0 0 20px 0;">' + topic.charAt(0).toUpperCase() + topic.slice(1) + ' Rules</h3>';

            ruleNums.forEach(num => {
                const ruleTexts = data.rules[num];
                if (ruleTexts && ruleTexts.length > 0) {
                    ruleTexts.forEach(text => {
                        const preview = text.length > 2000 ? text.substring(0, 2000) + '...' : text;
                        html += '<div class="compliance-result"><h4><span class="compliance-rule-num">' + num + '</span></h4><p>' + preview + '</p></div>';
                    });
                }
            });

            if (html.indexOf('compliance-result') === -1) {
                html += '<p style="color: var(--text-secondary);">No specific rules found for this topic in the database.</p>';
            }

            document.getElementById('complianceResults').innerHTML = html;
        }

        async function searchComplianceRules() {
            const query = document.getElementById('complianceSearchInput').value.toLowerCase().trim();
            if (!query) {
                alert('Please enter a search term');
                return;
            }

            document.getElementById('complianceResults').innerHTML = '<div style="text-align: center; padding: 40px;"><div class="spinner" style="border: 4px solid var(--border); border-top: 4px solid var(--accent-green); border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; margin: 0 auto;"></div><p style="color: var(--text-secondary); margin-top: 15px;">Searching ' + query + '...</p></div>';

            const data = await loadComplianceData();
            if (!data) {
                document.getElementById('complianceResults').innerHTML = '<p style="color: var(--accent-red);">Failed to load compliance data.</p>';
                return;
            }

            const results = [];
            const queryWords = query.split(/\s+/);

            // Search through chunks for context
            data.chunks.forEach((chunk, idx) => {
                const lowerText = chunk.text.toLowerCase();
                let matches = true;

                // Check if all query words are present
                for (const word of queryWords) {
                    if (!lowerText.includes(word)) {
                        matches = false;
                        break;
                    }
                }

                if (matches) {
                    // Find the best snippet around the match
                    const firstWordIdx = lowerText.indexOf(queryWords[0]);
                    const start = Math.max(0, firstWordIdx - 200);
                    const end = Math.min(chunk.text.length, firstWordIdx + 1500);
                    let snippet = chunk.text.substring(start, end);

                    if (start > 0) snippet = '...' + snippet;
                    if (end < chunk.text.length) snippet = snippet + '...';

                    // Highlight matches
                    queryWords.forEach(word => {
                        const regex = new RegExp('(' + word + ')', 'gi');
                        snippet = snippet.replace(regex, '<mark style="background: rgba(16, 185, 129, 0.3); padding: 2px 4px; border-radius: 3px;">$1</mark>');
                    });

                    results.push({
                        rules: chunk.rules,
                        snippet: snippet,
                        relevance: queryWords.filter(w => lowerText.includes(w)).length
                    });
                }
            });

            // Sort by relevance
            results.sort((a, b) => b.relevance - a.relevance);

            // Limit results
            const limitedResults = results.slice(0, 50);

            if (limitedResults.length === 0) {
                document.getElementById('complianceResults').innerHTML = '<div style="text-align: center; color: var(--text-secondary); padding: 40px;"><p>No results found for "<strong>' + query + '</strong>"</p><p style="font-size: 0.9rem; margin-top: 10px;">Try different keywords or check spelling</p></div>';
                return;
            }

            let html = '<p style="color: var(--text-secondary); margin-bottom: 20px;">Found <strong>' + results.length + '</strong> matches for "<strong>' + query + '</strong>"' + (results.length > 50 ? ' (showing first 50)' : '') + '</p>';

            limitedResults.forEach(result => {
                const ruleLabels = result.rules.length > 0 ? result.rules.map(r => '<span class="compliance-rule-num">' + r + '</span>').join(' ') : '<span style="color: var(--text-secondary);">General</span>';
                html += '<div class="compliance-result"><h4>' + ruleLabels + '</h4><p>' + result.snippet + '</p></div>';
            });

            document.getElementById('complianceResults').innerHTML = html;
        }
        
        // Inventory Management Functions
        // Pull Batch Functions
        
        function openPullBatchModal(machine) {
            currentPullMachine = machine;
            const machineName = machine === 'left' ? 'Left Machine' : 'Right Machine';
            document.getElementById('pullBatchModalTitle').textContent = ` Pull Batch from ${machineName}`;
            
            // Get machine status from Supabase
            supabaseClient
                .from('wm_machine_status')
                .select('*')
                .eq('machine', machine)
                .single()
                .then(({ data: machineStatus, error }) => {
                    if (error) {
                        console.error('Error loading machine status:', error);
                        machineStatus = {};
                    }
                    
                    if (!machineStatus.pot_batch) {
                        alert(' No batch in pot!\n\nPlease load a batch in the pot first using the machine status button.');
                        return;
                    }
                    
                    // Parse pot ledger
                    let potLedger = machineStatus.pot_ledger || [];
                    if (typeof potLedger === 'string') {
                        try { potLedger = JSON.parse(potLedger); } catch(e) { potLedger = []; }
                    }

                    // Get batch info
                    const batch = batches.find(b => b.id == machineStatus.pot_batch);
                    if (batch) {
                        document.getElementById('pullBatchNumber').textContent = batch.id;
                        document.getElementById('pullBatchStrain').textContent = batch.strain || 'Unknown Strain';

                        // Calculate total trim weight from pot ledger
                        let totalTrimWeight = 0;
                        if (potLedger.length > 0) {
                            totalTrimWeight = potLedger.reduce((sum, p) => sum + (p.trim_weight || 0), 0);
                        }

                        // Calculate projected yield based on material type
                        const expectedYield = getExpectedYieldFromConfig(batch.material_type) / 100;
                        const projectedYield = totalTrimWeight * expectedYield;

                        document.getElementById('pullBatchTrimWeight').textContent = `${Math.round(totalTrimWeight)}g`;
                        document.getElementById('pullBatchProjectedYield').textContent = `${projectedYield.toFixed(1)}g`;

                        // Show pot contents with source breakdown
                        let runsText = `${machineStatus.pot_runs || 0} runs collected`;
                        if (potLedger.length > 0) {
                            const totalSocks = potLedger.reduce((sum, p) => sum + p.socks, 0);
                            runsText += `  ${totalSocks} total socks`;
                            if (potLedger.length > 1) {
                                runsText += `\n Sources:\n`;
                                potLedger.forEach(p => {
                                    runsText += `   ${p.batch_id}: ${p.socks} socks (${Math.round(p.trim_weight)}g) - ${p.metrc_tag || 'No tag'}\n`;
                                });
                            }
                        }
                        document.getElementById('pullBatchRuns').innerHTML = runsText.replace(/\n/g, '<br>');
                    }

                    // Clear form
                    document.getElementById('pullProductType').value = '';
                    document.getElementById('pullSlabs').value = '';
                    document.getElementById('pullBowls').value = '';
                    document.getElementById('pullNotes').value = '';
                    updatePullFields();
                    
                    document.getElementById('pullBatchModal').style.display = 'block';
                });
        }
        
        function closePullBatchModal() {
            document.getElementById('pullBatchModal').style.display = 'none';
            currentPullMachine = null;
        }
        
        function updatePullFields() {
            const productType = document.getElementById('pullProductType').value;
            
            document.getElementById('shatterFields').style.display = productType === 'shatter' ? 'block' : 'none';
            document.getElementById('waxFields').style.display = (productType === 'wax' || productType === 'sugar_wax' || productType === 'live_resin') ? 'block' : 'none';
        }
        
        function submitPullBatch() {
            if (!currentPullMachine) return;
            
            // Get machine status from Supabase
            supabaseClient
                .from('wm_machine_status')
                .select('*')
                .eq('machine', currentPullMachine)
                .single()
                .then(({ data: machineStatus, error }) => {
                    if (error || !machineStatus || !machineStatus.pot_batch) {
                        alert('No batch in pot!');
                        return;
                    }
                    
                    const productType = document.getElementById('pullProductType').value;
                    const slabs = parseInt(document.getElementById('pullSlabs').value) || 0;
                    const bowls = parseInt(document.getElementById('pullBowls').value) || 0;
                    const notes = document.getElementById('pullNotes').value;
                    
                    if (!productType) {
                        alert('Please select a product type');
                        return;
                    }
                    
                    if (productType === 'shatter' && slabs === 0) {
                        alert('Please enter the number of slabs');
                        return;
                    }
                    
                    if ((productType === 'wax' || productType === 'sugar_wax' || productType === 'live_resin') && bowls === 0) {
                        alert('Please enter the number of bowls');
                        return;
                    }
                    
                    // Get batch info
                    const batch = batches.find(b => b.id == machineStatus.pot_batch);
                    
                    if (!batch) {
                        alert('Batch not found!');
                        return;
                    }
                    
                    // Continue with the rest of the pull batch logic...
                    completePullBatch(batch, machineStatus, productType, slabs, bowls, notes);
                });
        }
        
        function completePullBatch(batch, machineStatus, productType, slabs, bowls, notes) {
            // Parse pot ledger for source contributions
            let potLedger = machineStatus.pot_ledger || [];
            if (typeof potLedger === 'string') {
                try { potLedger = JSON.parse(potLedger); } catch(e) { potLedger = []; }
            }

            // Calculate common values
            const productTypeText = productType === 'shatter' ? 'Shatter' : productType === 'wax' ? 'Wax' : productType === 'sugar_wax' ? 'Sugar Wax' : productType === 'live_resin' ? 'Live Resin Oil' : 'Unknown';
            const amountText = productType === 'shatter' ? `${slabs} slab(s)` : `${bowls} bowl(s)`;
            const combinedTrimWeight = Math.round(potLedger.reduce((sum, p) => sum + (p.trim_weight || 0), 0) * 10) / 10;
            const totalSocksInPot = potLedger.reduce((sum, p) => sum + (p.socks || 0), 0);

            // Build source contributions summary for timeline
            let sourcesSummary = '';
            if (potLedger.length > 1) {
                sourcesSummary = ' | Sources: ' + potLedger.map(p => `${p.batch_id}(${p.socks}socks)`).join(', ');
            }

            // Create pull record for localStorage
            const pullRecord = {
                batchId: machineStatus.pot_batch,
                batchNumber: batch.id,
                machine: currentPullMachine,
                productType: productType,
                slabs: slabs,
                bowls: bowls,
                runs: machineStatus.pot_runs || 0,
                notes: notes,
                timestamp: new Date().toISOString(),
                pulledBy: currentRole ? currentRole.name : 'Unknown',
                source_contributions: potLedger
            };
            const pullHistory = JSON.parse(localStorage.getItem('wm_pull_history') || '[]');
            pullHistory.push(pullRecord);
            localStorage.setItem('wm_pull_history', JSON.stringify(pullHistory));

            // CHECK: Create a NEW sub-batch if:
            // 1. Multiple source batches in pot, OR
            // 2. Single source but batch already pulled from another pot (status is already 'extraction')
            const needsSubBatch = potLedger.length > 1 || batch.status === 'extraction';
            if (needsSubBatch) {
                // Determine sub-batch ID:
                // - Split extraction (single source, already extracted): use parent-A, parent-B, etc.
                // - Combined batch (multiple sources): use WM-{counter}
                let newBatchId;
                if (potLedger.length === 1 && batch.status === 'extraction') {
                    // Split extraction - find next available letter suffix
                    const parentId = batch.id;
                    const existingSuffixes = batches
                        .filter(b => b.id.startsWith(parentId + '-'))
                        .map(b => b.id.slice(parentId.length + 1))
                        .filter(s => /^[A-Z]$/.test(s));

                    // Find next letter (A, B, C, ...)
                    let nextLetter = 'A';
                    if (existingSuffixes.length > 0) {
                        const maxLetter = existingSuffixes.sort().pop();
                        nextLetter = String.fromCharCode(maxLetter.charCodeAt(0) + 1);
                    }
                    newBatchId = `${parentId}-${nextLetter}`;
                } else {
                    // Combined batch from multiple sources
                    newBatchId = `WM-${batchCounter}`;
                    batchCounter++;
                }

                // Capture filter media used for this extraction
                const filterMediaUsedCombined = {
                    silica_top: machineStatus.filter_silica_top || 0,
                    clay: machineStatus.filter_clay || 0,
                    silica_bottom: machineStatus.filter_silica_bottom || 0,
                    runs_through_filter: machineStatus.filter_runs || 0
                };

                const newSubBatch = {
                    id: newBatchId,
                    strain: batch.strain,
                    strain_type: batch.strain_type,
                    grower_name: potLedger.length > 1 ? 'Combined Sources' : batch.grower_name,
                    cultivation_license: potLedger.length > 1
                        ? potLedger.map(p => p.metrc_tag || p.batch_id).join(', ')
                        : batch.cultivation_license,
                    metrc_tags: potLedger.length > 1
                        ? potLedger.map(p => p.metrc_tag).filter(t => t).join(', ')
                        : batch.metrc_tags,
                    trim_weight: combinedTrimWeight,
                    socks_total: totalSocksInPot,
                    socks_remaining: 0,
                    material_agreement: batch.material_agreement,
                    material_cost: 0,
                    pre_sift: 'no',
                    planned_products: [productTypeText],
                    intake_date: new Date().toISOString().split('T')[0],
                    intake_user: currentRole ? currentRole.name : 'Unknown',
                    status: 'extraction',
                    extraction_method: 'BHO',
                    product_type: productTypeText,
                    product_made: productTypeText,
                    extraction_machine: currentPullMachine === 'left' ? 'Machine 1 (Left)' : 'Machine 2 (Right)',
                    extraction_runs: machineStatus.pot_runs || 0,
                    extraction_slabs: productType === 'shatter' ? slabs : null,
                    extraction_bowls: (productType === 'wax' || productType === 'sugar_wax' || productType === 'live_resin') ? bowls : null,
                    extraction_notes: notes,
                    extraction_user: currentRole ? currentRole.name : 'Unknown',
                    extraction_date: new Date().toISOString().split('T')[0],
                    source_contributions: potLedger,
                    combined_trim_weight: combinedTrimWeight,
                    total_socks_extracted: totalSocksInPot,
                    filter_media_used: filterMediaUsedCombined,
                    is_sub_batch: true,
                    parent_batch_id: batch.id,
                    labels_applied: false,
                    sift_sub_batch_created: false,
                    discrepancy_accepted: false,
                    extraction_paused: false,
                    packaging_paused: false,
                    labeling_paused: false,
                    timeline: [
                        {
                            timestamp: new Date().toISOString(),
                            stage: 'created',
                            user: currentRole ? currentRole.name : 'Unknown',
                            action: potLedger.length > 1
                                ? `Combined batch created from ${potLedger.length} sources: ${potLedger.map(p => p.batch_id).join(', ')}`
                                : `Sub-batch created from ${batch.id} (split extraction)`
                        },
                        {
                            timestamp: new Date().toISOString(),
                            stage: 'extraction',
                            user: currentRole ? currentRole.name : 'Unknown',
                            action: `Extraction completed - ${productTypeText} - ${amountText} - ${machineStatus.pot_runs || 0} runs - ${currentPullMachine === 'left' ? 'Machine 1 (Left)' : 'Machine 2 (Right)'}${sourcesSummary} | Filter: ${filterMediaUsedCombined.silica_top}c silica / ${filterMediaUsedCombined.clay}c clay / ${filterMediaUsedCombined.silica_bottom}c silica (${filterMediaUsedCombined.runs_through_filter} runs)`
                        }
                    ],
                    created_at: new Date().toISOString()
                };

                // Insert new sub-batch
                supabaseClient
                    .from('wm_batches')
                    .insert([newSubBatch])
                    .then(({ error }) => {
                        if (error) {
                            console.error('Error creating combined sub-batch:', error);
                            alert(`Error creating combined batch:\n\n${error.message || JSON.stringify(error)}`);
                            return;
                        }

                        // Update all contributing batches (mark as consumed or add contribution note)
                        const contributingBatchUpdates = potLedger.map(p => {
                            const contributingBatch = batches.find(b => b.id === p.batch_id);
                            if (!contributingBatch) return null;

                            const socksRemaining = contributingBatch.socks_remaining ?? contributingBatch.socks_total ?? 0;

                            if (socksRemaining === 0) {
                                return {
                                    batchId: p.batch_id,
                                    update: {
                                        status: 'consumed',
                                        consumed_by: newBatchId,
                                        timeline: [
                                            ...(contributingBatch.timeline || []),
                                            {
                                                timestamp: new Date().toISOString(),
                                                stage: 'consumed',
                                                user: currentRole ? currentRole.name : 'Unknown',
                                                action: `All ${p.socks} sock(s) contributed to combined batch ${newBatchId} - ${Math.round(p.trim_weight * 10) / 10}g trim`
                                            }
                                        ]
                                    }
                                };
                            } else {
                                return {
                                    batchId: p.batch_id,
                                    update: {
                                        timeline: [
                                            ...(contributingBatch.timeline || []),
                                            {
                                                timestamp: new Date().toISOString(),
                                                stage: 'contribution',
                                                user: currentRole ? currentRole.name : 'Unknown',
                                                action: `${p.socks} sock(s) contributed to combined batch ${newBatchId} - ${Math.round(p.trim_weight * 10) / 10}g trim (${socksRemaining} socks remaining)`
                                            }
                                        ]
                                    }
                                };
                            }
                        }).filter(u => u !== null);

                        Promise.all(contributingBatchUpdates.map(u =>
                            supabaseClient.from('wm_batches').update(u.update).eq('id', u.batchId)
                        )).then(() => {
                            console.log(`Created combined batch ${newBatchId} from ${potLedger.length} sources`);
                        });

                        // Clear pot in machine status
                        const clearedPotStatus = {
                            machine: currentPullMachine,
                            pot_batch: null,
                            pot_runs: 0,
                            pot_ledger: [],
                            column_batch: machineStatus.column_batch,
                            column_b_batch: machineStatus.column_b_batch,
                            filter_silica_top: machineStatus.filter_silica_top,
                            filter_clay: machineStatus.filter_clay,
                            filter_silica_bottom: machineStatus.filter_silica_bottom,
                            filter_runs: machineStatus.filter_runs,
                            last_updated: new Date().toISOString(),
                            updated_by: currentRole ? currentRole.name : 'Unknown'
                        };

                        supabaseClient
                            .from('wm_machine_status')
                            .upsert(clearedPotStatus, { onConflict: 'machine' })
                            .then(() => {
                                loadBatches();
                                updateMachineDisplays();
                                closePullBatchModal();
                                alert(` Combined Batch Created!\n\n${newBatchId}\n${productTypeText}: ${amountText}\n${machineStatus.pot_runs || 0} runs\n${combinedTrimWeight}g total trim from ${potLedger.length} sources\n\nPot has been emptied.`);
                            });
                    });

                return; // Exit early - combined batch flow handled above
            }

            // SINGLE SOURCE BATCH - Update existing batch (original behavior)
            const socksRemaining = batch.socks_remaining ?? 0;

            // Capture filter media used for this extraction
            const filterMediaUsed = {
                silica_top: machineStatus.filter_silica_top || 0,
                clay: machineStatus.filter_clay || 0,
                silica_bottom: machineStatus.filter_silica_bottom || 0,
                runs_through_filter: machineStatus.filter_runs || 0
            };

            const updatedBatch = {
                ...batch,
                status: 'extraction',
                extraction_method: 'BHO',
                product_type: productTypeText,
                product_made: productTypeText,
                extraction_machine: currentPullMachine === 'left' ? 'Machine 1 (Left)' : 'Machine 2 (Right)',
                extraction_runs: machineStatus.pot_runs || 0,
                extraction_slabs: productType === 'shatter' ? slabs : null,
                extraction_bowls: (productType === 'wax' || productType === 'sugar_wax' || productType === 'live_resin') ? bowls : null,
                extraction_notes: notes,
                extraction_user: currentRole ? currentRole.name : 'Unknown',
                extraction_date: new Date().toISOString().split('T')[0],
                source_contributions: potLedger,
                combined_trim_weight: combinedTrimWeight,
                total_socks_extracted: totalSocksInPot,
                filter_media_used: filterMediaUsed,
                timeline: [
                    ...(batch.timeline || []),
                    {
                        timestamp: new Date().toISOString(),
                        stage: 'extraction',
                        user: currentRole ? currentRole.name : 'Unknown',
                        action: `Extraction completed - ${productTypeText} - ${amountText} - ${machineStatus.pot_runs || 0} runs - ${currentPullMachine === 'left' ? 'Machine 1 (Left)' : 'Machine 2 (Right)'} | Filter: ${filterMediaUsed.silica_top}c silica / ${filterMediaUsed.clay}c clay / ${filterMediaUsed.silica_bottom}c silica (${filterMediaUsed.runs_through_filter} runs)`
                    }
                ]
            };

            supabaseClient
                .from('wm_batches')
                .update(updatedBatch)
                .eq('id', batch.id)
                .then(({ error, data }) => {
                    if (error) {
                        console.error('Error updating batch:', error);
                        alert(`Error completing extraction:\n\n${error.message || JSON.stringify(error)}`);
                        return;
                    }

                    // Clear pot in machine status in Supabase
                    const clearedPotStatus = {
                        machine: currentPullMachine,
                        pot_batch: null,
                        pot_runs: 0,
                        pot_ledger: [], // Clear the pot ledger
                        column_batch: machineStatus.column_batch, // Keep column A
                        column_b_batch: machineStatus.column_b_batch, // Keep column B
                        filter_silica_top: machineStatus.filter_silica_top, // Keep filter
                        filter_clay: machineStatus.filter_clay,
                        filter_silica_bottom: machineStatus.filter_silica_bottom,
                        filter_runs: machineStatus.filter_runs,
                        last_updated: new Date().toISOString(),
                        updated_by: currentRole ? currentRole.name : 'Unknown'
                    };
                    
                    supabaseClient
                        .from('wm_machine_status')
                        .upsert(clearedPotStatus, { onConflict: 'machine' })
                        .then(() => {
                            // Reload batches and update displays
                            loadBatches();
                            updateMachineDisplays();
                            closePullBatchModal();

                            const statusMsg = socksRemaining > 0
                                ? `Batch moved to Post-Extraction.\n ${socksRemaining} sock(s) remaining - still visible in extraction queue.`
                                : 'Batch moved to Post-Extraction.';
                            alert(` Extraction Complete!\n\n${batch.id}\n${productTypeText}: ${amountText}\n${machineStatus.pot_runs || 0} runs\n\n${statusMsg}\nPot has been emptied.`);
                        });
                });
        }

        // ==========================================
        // Extraction Queue & Column Loading Functions
        // ==========================================

        function populateExtractionQueue() {
            const queueEl = document.getElementById('extractionQueueList');
            if (!queueEl) return;

            // Get batches with socks remaining (intake status OR any status with socks left)
            const queueBatches = batches.filter(b => {
                // Never show consumed batches
                if (b.status === 'consumed') return false;
                // Always show intake batches with socks
                if (b.status === 'intake') {
                    if (b.socks_total != null && b.socks_remaining === 0) return false;
                    return true;
                }
                // Also show batches at other statuses if they still have socks remaining
                if (b.socks_total != null && b.socks_remaining > 0) return true;
                return false;
            });

            if (queueBatches.length === 0) {
                queueEl.innerHTML = `<div style="text-align: center; color: var(--text-secondary); padding: 20px;">
                    No batches waiting for extraction
                </div>`;
                return;
            }

            queueEl.innerHTML = queueBatches.map(batch => {
                const socksRemaining = batch.socks_remaining ?? batch.socks_total ?? null;
                const socksTotal = batch.socks_total ?? null;
                const hasSocks = socksTotal !== null;
                const sockDisplay = hasSocks ? `${socksRemaining}/${socksTotal}` : 'Not set';
                const sockColor = !hasSocks ? 'var(--accent-red)' :
                                  socksRemaining === 1 ? 'var(--accent-orange)' : 'var(--accent-green)';
                const rolloverWarning = socksRemaining === 1 ? ' ' : '';

                return `<div style="background: var(--bg-secondary); padding: 12px; border-radius: 8px; margin-bottom: 10px; border-left: 4px solid ${sockColor};">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <div style="font-weight: 700; font-family: 'Space Mono', monospace;">${batch.id}</div>
                            <div style="font-size: 0.85rem; color: var(--text-secondary);">${batch.strain}  ${batch.material_agreement}</div>
                            <div style="font-size: 0.8rem; color: var(--text-secondary);">${batch.cultivation_license || batch.grower_name || ''}</div>
                        </div>
                        <div style="text-align: right;">
                            <div style="font-size: 1.2rem; font-weight: 700; color: ${sockColor};">
                                 ${sockDisplay}${rolloverWarning}
                            </div>
                            <button class="btn" style="padding: 5px 10px; font-size: 0.75rem; background: var(--accent-blue);" onclick="editBatchSocks('${batch.id}', ${socksTotal || 0})">
                                Edit Socks
                            </button>
                        </div>
                    </div>
                </div>`;
            }).join('');
        }

        async function editBatchSocks(batchId, currentSocks) {
            const newSocks = prompt(`Enter number of socks for ${batchId}:`, currentSocks || '');
            if (newSocks === null) return;

            const socksNum = parseInt(newSocks);
            if (isNaN(socksNum) || socksNum < 1) {
                alert('Please enter a valid number of socks (1 or more)');
                return;
            }

            const batch = batches.find(b => b.id === batchId);
            if (!batch) return;

            const trimPerSock = Math.round((batch.trim_weight / socksNum) * 10) / 10; // Round to nearest tenth
            const socksUsed = (batch.socks_total || 0) - (batch.socks_remaining || 0);
            const socksRemaining = Math.max(0, socksNum - socksUsed);

            const { error } = await supabaseClient
                .from('wm_batches')
                .update({
                    socks_total: socksNum,
                    socks_remaining: socksRemaining,
                    trim_per_sock: trimPerSock
                })
                .eq('id', batchId);

            if (error) {
                console.error('Error updating socks:', error);
                alert('Error updating socks. Please try again.');
                return;
            }

            await loadBatches();
            populateExtractionQueue();
            alert(` ${batchId} updated to ${socksNum} socks`);
        }

        // ==========================================
        // Machine Status Tracking
        // ==========================================

        function generateMachineColumns(machineKey) {
            const container = document.getElementById('machineColumnsContainer');
            if (!container) return;

            // Find machine config
            const machineConfig = CONFIG.machines.find(m => {
                const key = (m.position?.toLowerCase() || m.name.toLowerCase()).replace(/[^a-z0-9]/g, '');
                return key === machineKey;
            }) || CONFIG.machines[0] || CONFIG_DEFAULTS.machines[0];

            const config = machineConfig.config || {};
            console.log("Machine config for", machineKey, ":", {
                machineType: machineConfig.machine_type,
                config: config,
                second_wash: config.second_wash,
                second_wash_type: typeof config.second_wash,
                second_sift: config.second_sift,
                second_sift_type: typeof config.second_sift
            });
            const numColumns = config.columns || 6;
            const machineType = machineConfig.machine_type || 'bho';

            // Generate columns HTML based on machine type
            let columnsHtml = '';

            if (machineType === 'bho') {
                // For BHO, show columns A-F based on config (2-6 columns)
                const columnLabels = ['A', 'B', 'C', 'D', 'E', 'F'];
                const colCount = Math.min(6, Math.max(2, numColumns));
                for (let i = 0; i < colCount; i++) {
                    const col = columnLabels[i];
                    columnsHtml += generateColumnHtml(col, 'machineColumn' + col + 'Batch');
                }
            } else if (machineType === 'rosin') {
                // Rosin washer - show wash stages
                columnsHtml += '<div style="background: rgba(59, 130, 246, 0.1); border-left: 4px solid var(--accent-blue); padding: 20px; border-radius: 8px; margin-bottom: 20px;">';
                columnsHtml += '<h3 style="color: var(--accent-blue); margin: 0 0 15px 0;"> Wash 1</h3>';
                columnsHtml += '<div class="form-group"><label>Batch</label><select id="rosinWash1Batch"><option value="">Empty</option></select></div>';
                columnsHtml += '</div>';
                if (config.second_wash === true) {
                    columnsHtml += '<div style="background: rgba(59, 130, 246, 0.1); border-left: 4px solid var(--accent-blue); padding: 20px; border-radius: 8px; margin-bottom: 20px;">';
                    columnsHtml += '<h3 style="color: var(--accent-blue); margin: 0 0 15px 0;"> Wash 2</h3>';
                    columnsHtml += '<div class="form-group"><label>Batch</label><select id="rosinWash2Batch"><option value="">Empty</option></select></div>';
                    columnsHtml += '</div>';
                }
            } else if (machineType === 'resinator') {
                // Resinator - process large batch in multiple barrel loads
                columnsHtml += '<div style="background: rgba(147, 51, 234, 0.1); border-left: 4px solid var(--accent-purple); padding: 20px; border-radius: 8px; margin-bottom: 20px;">';
                columnsHtml += '<h3 style="color: var(--accent-purple); margin: 0 0 15px 0;"> Batch Selection</h3>';
                columnsHtml += '<div class="form-group"><label>Batch to Process</label><select id="resinatorBatch" onchange="updateResinatorBatchInfo()"><option value="">Select Batch...</option></select></div>';
                columnsHtml += '<div id="batchRemainingDisplay" style="padding: 12px; background: var(--bg-tertiary); border-radius: 8px; margin-top: 10px; display: none;">';
                columnsHtml += '<div style="display: flex; justify-content: space-between; margin-bottom: 8px;"><span>Remaining to Run:</span><strong id="batchRemainingWeight">0g</strong></div>';
                columnsHtml += '<div style="display: flex; justify-content: space-between; color: var(--text-secondary); font-size: 0.9rem;"><span>Trim for Socks:</span><strong id="batchTrimForSocks">0g</strong></div>';
                columnsHtml += '</div>';
                columnsHtml += '</div>';

                // Current Barrel Load
                columnsHtml += '<div id="barrelLoadSection" style="background: rgba(59, 130, 246, 0.1); border-left: 4px solid var(--accent-blue); padding: 20px; border-radius: 8px; margin-bottom: 20px;">';
                columnsHtml += '<h3 style="color: var(--accent-blue); margin: 0 0 15px 0;"> Current Barrel Load</h3>';
                columnsHtml += '<div class="form-group"><label>Material in Barrel (g)</label><input type="number" id="resinatorInputWeight" step="0.1" placeholder="Weight loaded in barrel"></div>';
                columnsHtml += '<div class="form-grid" style="margin-top: 15px;">';
                columnsHtml += '<div class="form-group"><label>1st Sift Hash (g)</label><input type="number" id="resinatorSift1Output" step="0.1" placeholder="First pass yield"></div>';
                columnsHtml += '<div class="form-group"><label>2nd Sift Hash (g)</label><input type="number" id="resinatorSift2Output" step="0.1" placeholder="Second pass (optional)"></div>';
                columnsHtml += '</div>';
                columnsHtml += '<button type="button" class="btn" style="background: var(--accent-blue); width: 100%; padding: 12px; margin-top: 15px;" onclick="completeBarrelRun()"> Complete Barrel Run</button>';
                columnsHtml += '</div>';

                // Session totals - First sift vs Second sift
                columnsHtml += '<div id="siftTotalsDisplay" style="background: var(--bg-tertiary); padding: 15px; border-radius: 8px; margin-bottom: 20px;">';
                columnsHtml += '<h4 style="margin: 0 0 15px 0;"> Session Totals</h4>';
                columnsHtml += '<div id="siftTotalsContent">';
                columnsHtml += '<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; text-align: center;">';
                columnsHtml += '<div style="background: rgba(16, 185, 129, 0.2); padding: 15px; border-radius: 8px;"><div style="font-size: 0.85rem; color: var(--text-secondary);">1st Sift Total</div><div id="totalFirstSift" style="font-size: 1.5rem; font-weight: 700; color: var(--accent-green);">0g</div></div>';
                columnsHtml += '<div style="background: rgba(245, 158, 11, 0.2); padding: 15px; border-radius: 8px;"><div style="font-size: 0.85rem; color: var(--text-secondary);">2nd Sift Total</div><div id="totalSecondSift" style="font-size: 1.5rem; font-weight: 700; color: var(--accent-orange);">0g</div></div>';
                columnsHtml += '</div>';
                columnsHtml += '<div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--border);"><div style="display: flex; justify-content: space-between;"><span>Total Material Processed:</span><strong id="totalProcessed">0g</strong></div>';
                columnsHtml += '<div style="display: flex; justify-content: space-between; margin-top: 5px;"><span>Barrel Runs:</span><strong id="totalRuns">0</strong></div></div>';
                columnsHtml += '</div></div>';

                // Run history
                columnsHtml += '<div id="runHistorySection" style="background: var(--bg-secondary); padding: 15px; border-radius: 8px; margin-bottom: 20px; display: none;">';
                columnsHtml += '<h4 style="margin: 0 0 10px 0;"> Run History</h4>';
                columnsHtml += '<div id="runHistoryContent" style="max-height: 200px; overflow-y: auto;"></div>';
                columnsHtml += '</div>';

                // Complete batch button
                columnsHtml += '<button type="button" class="btn" style="background: var(--accent-green); width: 100%; padding: 12px;" onclick="completeResinatorBatch()"> Complete Batch & Start Next</button>';
            }

            // Add columns configured count display
            if (machineType === 'bho') {
                columnsHtml = '<div style="text-align: center; padding: 10px; background: var(--bg-tertiary); border-radius: 8px; margin-bottom: 15px; color: var(--text-secondary);">' +
                    '<strong>' + numColumns + ' Columns</strong> | ' + (config.socks_per_run || 6) + ' socks per run</div>' + columnsHtml;
            }

            container.innerHTML = columnsHtml;

            return machineConfig;
        }

        function generateColumnHtml(col, selectId) {
            return '<div style="background: rgba(59, 130, 246, 0.1); border-left: 4px solid var(--accent-blue); padding: 20px; border-radius: 8px; margin-bottom: 20px;">' +
                '<h3 style="color: var(--accent-blue); margin: 0 0 15px 0;"> Column ' + col + '</h3>' +
                '<div class="form-grid">' +
                    '<div class="form-group">' +
                        '<label>Primary Batch</label>' +
                        '<select id="' + selectId + '" onchange="updateColumnSockUI(\'' + col + '\')">' +
                            '<option value="">Empty / Not Loaded</option>' +
                        '</select>' +
                    '</div>' +
                    '<div class="form-group">' +
                        '<label>Socks</label>' +
                        '<select id="machineColumn' + col + 'Socks" onchange="updateColumnSockUI(\'' + col + '\')">' +
                            '<option value="0">0</option>' +
                            '<option value="1">1</option>' +
                            '<option value="2">2</option>' +
                        '</select>' +
                    '</div>' +
                '</div>' +
                '<div id="column' + col + 'SecondSock" style="display: none; margin-top: 15px; padding-top: 15px; border-top: 1px dashed var(--border);">' +
                    '<div class="form-grid">' +
                        '<div class="form-group">' +
                            '<label style="color: var(--accent-orange);">+ Second Sock From</label>' +
                            '<select id="machineColumn' + col + 'SecondBatch">' +
                                '<option value="">None</option>' +
                            '</select>' +
                        '</div>' +
                    '</div>' +
                '</div>' +
                '<button type="button" class="btn" style="background: var(--accent-orange); width: 100%; padding: 12px; margin-top: 15px;" onclick="runColumnToPot(\'' + col + '\')">' +
                    ' Run Column ' + col + ' to Pot' +
                '</button>' +
            '</div>';
        }

        // Open component selector - for now, opens the full machine modal
        function openComponentSelector(machineKey, component) {
            // Just open the machine modal for now - can be enhanced later for quick selection
            openMachineModal(machineKey);
        }

        // Open Pull Batch modal from within the machine modal
        function openPullBatchFromModal() {
            if (!currentMachine) return;
            // Close the machine modal first
            document.getElementById('machineModal').style.display = 'none';
            // Then open the pull batch modal
            openPullBatchModal(currentMachine);
        }

        function openMachineModal(machine) {
            currentMachine = machine;

            // Generate columns based on machine config
            const machineConfig = generateMachineColumns(machine);
            const machineName = machineConfig?.name || (machine === 'left' ? 'Left Machine' : 'Right Machine');
            const machineType = machineConfig?.machine_type || 'bho';
            const icon = machineType === 'bho' ? '' : machineType === 'rosin' ? '' : '';
            document.getElementById('machineModalTitle').textContent = icon + ' ' + machineName;

            // Show/hide sections based on machine type
            const potSection = document.getElementById('machinePotSection');
            const filterSection = document.getElementById('machineFilterSection');
            const formButtons = document.getElementById('machineFormButtons');
            if (potSection) potSection.style.display = (machineType === 'bho' || machineType === 'rosin') ? 'block' : 'none';
            if (filterSection) filterSection.style.display = machineType === 'bho' ? 'block' : 'none';
            if (formButtons) formButtons.style.display = machineType === 'resinator' ? 'none' : 'grid';

            // Load machine status - from localStorage in demo mode, Supabase otherwise
            const loadStatus = DEMO_MODE
                ? Promise.resolve({ data: demoGetMachineStatus(machine), error: null })
                : supabaseClient.from('wm_machine_status').select('*').eq('machine', machine).single();

            loadStatus.then(({ data: machineStatus, error }) => {
                    if (error && !DEMO_MODE) {
                        console.error('Error loading machine status:', error);
                        machineStatus = {};
                    }
                    machineStatus = machineStatus || {};

                    // Store current machine status for later use
                    window.currentMachineStatus = machineStatus;

                    // Populate batch dropdowns with sock counts (for BHO machines)
                    // Dynamically handle columns A-F
                    const columnLabels = ['A', 'B', 'C', 'D', 'E', 'F'];
                    columnLabels.forEach(col => {
                        const columnSelect = document.getElementById('machineColumn' + col + 'Batch');
                        const secondBatchSelect = document.getElementById('machineColumn' + col + 'SecondBatch');
                        const socksSelect = document.getElementById('machineColumn' + col + 'Socks');

                        if (columnSelect) {
                            // Clear and repopulate with sock counts
                            columnSelect.innerHTML = '<option value="">Empty / Not Loaded</option>';
                            if (secondBatchSelect) secondBatchSelect.innerHTML = '<option value="">None</option>';

                            batches.forEach(batch => {
                                // Show intake batches OR any batch with socks remaining
                                const hasSocksRemaining = batch.socks_total != null && batch.socks_remaining > 0;
                                if (batch.status === 'intake' || hasSocksRemaining) {
                                    // Skip batches with 0 socks remaining
                                    if (batch.socks_total != null && batch.socks_remaining === 0) return;
                                    const socksRemaining = batch.socks_remaining ?? batch.socks_total ?? '?';
                                    const socksTotal = batch.socks_total ?? '?';
                                    const statusLabel = batch.status !== 'intake' ? ` [${batch.status}]` : '';
                                    const sockDisplay = `(${socksRemaining}/${socksTotal} socks)${statusLabel}`;
                                    const option = `<option value="${batch.id}">${batch.id} - ${batch.strain} ${sockDisplay}</option>`;
                                    columnSelect.innerHTML += option;
                                    if (secondBatchSelect) secondBatchSelect.innerHTML += option;
                                }
                            });

                            // Set current values from machine status
                            const colKey = col.toLowerCase();
                            // Handle legacy format (column_batch for A, column_b_batch for B) and new format
                            const batchKey = col === 'A' ? 'column_batch' : `column_${colKey}_batch`;
                            const socksKey = `column_${colKey}_socks`;
                            const secondBatchKey = `column_${colKey}_second_batch`;

                            columnSelect.value = machineStatus[batchKey] || '';
                            if (socksSelect) socksSelect.value = machineStatus[socksKey] || 0;
                            if (secondBatchSelect) secondBatchSelect.value = machineStatus[secondBatchKey] || '';
                        }
                    });

                    // Set pot batch (hidden input and display)
                    const potBatchId = machineStatus.pot_batch || '';
                    document.getElementById('machinePotBatch').value = potBatchId;
                    if (potBatchId) {
                        const potBatch = batches.find(b => b.id === potBatchId);
                        document.getElementById('machinePotBatchDisplay').value = potBatch ?
                            `${potBatchId} - ${potBatch.strain}` : potBatchId;
                    } else {
                        document.getElementById('machinePotBatchDisplay').value = '';
                    }

                    document.getElementById('machinePotRuns').value = machineStatus.pot_runs || 0;

                    // Show/hide Pull Batch button based on pot status
                    const pullBatchBtn = document.getElementById('modalPullBatchBtn');
                    if (pullBatchBtn) {
                        pullBatchBtn.style.display = potBatchId ? 'block' : 'none';
                    }

                    document.getElementById('machineFilterSilicaTop').value = machineStatus.filter_silica_top || '';
                    document.getElementById('machineFilterClay').value = machineStatus.filter_clay || '';
                    document.getElementById('machineFilterSilicaBottom').value = machineStatus.filter_silica_bottom || '';
                    document.getElementById('machineFilterRuns').value = machineStatus.filter_runs || '';

                    // Handle secondary sock selectors visibility and trigger UI updates (for BHO machines)
                    columnLabels.forEach(col => {
                        const colKey = col.toLowerCase();
                        const secondSockDiv = document.getElementById('column' + col + 'SecondSock');
                        if (secondSockDiv) secondSockDiv.style.display = 'none';

                        // Trigger UI update for each column if batch is set
                        const batchKey = col === 'A' ? 'column_batch' : `column_${colKey}_batch`;
                        if (machineStatus[batchKey]) {
                            setTimeout(() => updateColumnSockUI(col), 100);
                        }
                    });

                    // Display pot ledger
                    displayPotLedger(machineStatus);

                    // Populate resinator batch dropdown - only show pre-sift batches
                    const resinatorBatchSelect = document.getElementById('resinatorBatch');
                    if (resinatorBatchSelect) {
                        resinatorBatchSelect.innerHTML = '<option value="">Select Batch...</option>';
                        batches.forEach(batch => {
                            // Only show intake batches with pre_sift: yes and remaining trim
                            if (batch.status === 'intake' && batch.pre_sift === 'yes' && (batch.trim_weight || 0) > 0) {
                                const option = `<option value="${batch.id}">${batch.id} - ${batch.strain} (${batch.trim_weight || 0}g)</option>`;
                                resinatorBatchSelect.innerHTML += option;
                            }
                        });

                        // Restore saved batch selection
                        if (machineStatus.current_batch) {
                            resinatorBatchSelect.value = machineStatus.current_batch;
                        }

                        // Update batch info display and totals
                        setTimeout(() => {
                            updateResinatorBatchInfo();
                            updateResinatorTotals();
                        }, 100);
                    }

                    document.getElementById('machineModal').style.display = 'block';
                });
        }

        function displayPotLedger(machineStatus) {
            const potLedgerDisplay = document.getElementById('potLedgerDisplay');
            let potLedger = machineStatus?.pot_ledger || [];
            if (typeof potLedger === 'string') {
                try { potLedger = JSON.parse(potLedger); } catch(e) { potLedger = []; }
            }

            if (potLedger.length === 0) {
                potLedgerDisplay.style.display = 'none';
                return;
            }

            const totalSocks = potLedger.reduce((sum, p) => sum + p.socks, 0);
            let html = `<div style="font-weight: 700; margin-bottom: 8px;"> Pot Contents (${totalSocks} socks total):</div>`;
            potLedger.forEach(p => {
                const percentage = ((p.socks / totalSocks) * 100).toFixed(0);
                const filter = p.filter_at_drop;
                let filterHtml = '';
                if (filter) {
                    filterHtml = `
                    <div style="font-size: 0.75rem; color: var(--text-secondary); margin-top: 4px; display: flex; align-items: center; gap: 8px;">
                        <span style="display: inline-flex; align-items: center; gap: 4px;">
                             Filter:
                            <span style="background: var(--bg-tertiary); padding: 2px 6px; border-radius: 4px; font-family: monospace;">
                                ${filter.silica_top || 0}g
                            </span>
                            <span style="color: var(--text-tertiary);">/</span>
                            <span style="background: var(--bg-tertiary); padding: 2px 6px; border-radius: 4px; font-family: monospace;">
                                ${filter.clay || 0}g
                            </span>
                            <span style="color: var(--text-tertiary);">/</span>
                            <span style="background: var(--bg-tertiary); padding: 2px 6px; border-radius: 4px; font-family: monospace;">
                                ${filter.silica_bottom || 0}g
                            </span>
                        </span>
                        <span style="color: var(--accent-purple);"> Run #${filter.filter_runs || 1}</span>
                    </div>`;
                }
                html += `<div style="padding: 8px 0; border-bottom: 1px solid var(--border);">
                    <strong>${p.batch_id}</strong> - ${p.strain || 'Unknown'}: ${p.socks} socks (${percentage}%)  ${Math.round(p.trim_weight)}g
                    <div style="font-size: 0.8rem; color: var(--text-secondary);">Tag: ${p.metrc_tag || 'Not set'}</div>
                    ${filterHtml}
                </div>`;
            });
            potLedgerDisplay.innerHTML = html;
            potLedgerDisplay.style.display = 'block';
        }

        function displaySiftTotals(machineStatus) {
            const display = document.getElementById('siftTotalsDisplay');
            const content = document.getElementById('siftTotalsContent');
            if (!display || !content) return;

            const siftLedger = machineStatus?.sift_ledger || [];
            if (siftLedger.length === 0) {
                display.style.display = 'none';
                return;
            }

            let totalInput = 0;
            let totalOutput = 0;
            let html = '';

            siftLedger.forEach(entry => {
                totalInput += entry.input_weight || 0;
                totalOutput += entry.output_weight || 0;
                const yieldPct = entry.input_weight > 0 ? ((entry.output_weight / entry.input_weight) * 100).toFixed(1) : 0;
                html += `<div style="padding: 8px 0; border-bottom: 1px solid var(--border);">
                    <strong>${entry.batch_id}</strong> - Sift ${entry.sift_number}: ${entry.input_weight}g  ${entry.output_weight}g hash (${yieldPct}% yield)
                </div>`;
            });

            const totalYield = totalInput > 0 ? ((totalOutput / totalInput) * 100).toFixed(1) : 0;
            html += `<div style="padding: 12px 0; font-weight: 700; color: var(--accent-green);">
                Total: ${totalInput.toFixed(1)}g input  ${totalOutput.toFixed(1)}g hash (${totalYield}% yield)
            </div>`;

            content.innerHTML = html;
            display.style.display = 'block';
        }

        function updateResinatorBatchInfo() {
            const batchSelect = document.getElementById('resinatorBatch');
            const remainingDisplay = document.getElementById('batchRemainingDisplay');
            const remainingWeight = document.getElementById('batchRemainingWeight');
            const trimForSocks = document.getElementById('batchTrimForSocks');

            if (!batchSelect) return;

            const batchId = batchSelect.value;
            if (!batchId) {
                if (remainingDisplay) remainingDisplay.style.display = 'none';
                return;
            }

            const batch = batches.find(b => b.id === batchId);
            if (batch && remainingDisplay && remainingWeight) {
                // Calculate remaining to run = original trim minus total input processed
                const status = window.currentMachineStatus || {};
                let siftLedger = status.sift_ledger || [];
                if (typeof siftLedger === 'string') {
                    try { siftLedger = JSON.parse(siftLedger); } catch(e) { siftLedger = []; }
                }

                // Sum up input weights for this batch from the ledger
                const totalInputProcessed = siftLedger
                    .filter(r => r.batch_id === batchId)
                    .reduce((sum, r) => sum + (r.input_weight || 0), 0);

                // Original trim = current trim_weight + total sift collected (since sift reduces trim_weight)
                const totalSiftCollected = siftLedger
                    .filter(r => r.batch_id === batchId)
                    .reduce((sum, r) => sum + (r.first_sift || 0) + (r.second_sift || 0), 0);

                const originalTrim = (batch.trim_weight || 0) + totalSiftCollected;
                const remainingToRun = Math.max(0, originalTrim - totalInputProcessed);
                const trimForSocksWeight = batch.trim_weight || 0;

                remainingWeight.textContent = `${remainingToRun.toFixed(0)}g`;
                if (trimForSocks) trimForSocks.textContent = `${trimForSocksWeight.toFixed(0)}g`;
                remainingDisplay.style.display = 'block';

                // Store current batch in status
                window.currentMachineStatus = window.currentMachineStatus || {};
                window.currentMachineStatus.current_batch = batchId;
            }
        }

        function completeBarrelRun() {
            const batchSelect = document.getElementById('resinatorBatch');
            const inputWeightEl = document.getElementById('resinatorInputWeight');
            const sift1OutputEl = document.getElementById('resinatorSift1Output');
            const sift2OutputEl = document.getElementById('resinatorSift2Output');

            if (!batchSelect || !inputWeightEl) {
                alert('Error: Form elements not found');
                return;
            }

            const batchId = batchSelect.value;
            const inputWeight = parseFloat(inputWeightEl.value) || 0;
            const sift1Output = parseFloat(sift1OutputEl?.value) || 0;
            const sift2Output = parseFloat(sift2OutputEl?.value) || 0;

            if (!batchId) {
                alert('Please select a batch to process');
                return;
            }
            if (inputWeight <= 0) {
                alert('Please enter the material weight loaded in the barrel');
                return;
            }
            if (sift1Output <= 0 && sift2Output <= 0) {
                alert('Please enter at least one sift yield');
                return;
            }

            const batch = batches.find(b => b.id === batchId);
            const totalOutput = sift1Output + sift2Output;
            const yieldPct = ((totalOutput / inputWeight) * 100).toFixed(1);

            let confirmMsg = `Complete Barrel Run?\n\nBatch: ${batchId} - ${batch?.strain || 'Unknown'}\nInput: ${inputWeight}g\n`;
            if (sift1Output > 0) confirmMsg += `1st Sift: ${sift1Output}g\n`;
            if (sift2Output > 0) confirmMsg += `2nd Sift: ${sift2Output}g\n`;
            confirmMsg += `Total Yield: ${totalOutput}g (${yieldPct}%)`;

            if (!confirm(confirmMsg)) {
                return;
            }

            // Get current sift ledger
            const currentStatus = window.currentMachineStatus || {};
            let siftLedger = currentStatus.sift_ledger || [];
            if (typeof siftLedger === 'string') {
                try { siftLedger = JSON.parse(siftLedger); } catch(e) { siftLedger = []; }
            }

            // Add run to ledger
            siftLedger.push({
                batch_id: batchId,
                strain: batch?.strain || '',
                input_weight: inputWeight,
                first_sift: sift1Output,
                second_sift: sift2Output,
                timestamp: new Date().toISOString()
            });

            // Update machine status
            window.currentMachineStatus = window.currentMachineStatus || {};
            window.currentMachineStatus.current_batch = batchId;
            window.currentMachineStatus.sift_ledger = siftLedger;

            // Update batch - subtract sift output from trim_weight (hash comes from the trim)
            const newTrimWeight = Math.max(0, (batch?.trim_weight || 0) - totalOutput);
            const newSiftWeight = (batch?.sift_weight || 0) + totalOutput;

            const batchUpdatePromise = DEMO_MODE
                ? demoUpdateBatch(batchId, { trim_weight: newTrimWeight, sift_weight: newSiftWeight })
                : supabaseClient.from('wm_batches').update({ trim_weight: newTrimWeight, sift_weight: newSiftWeight }).eq('id', batchId);

            batchUpdatePromise.then(() => {
                if (batch) {
                    batch.trim_weight = newTrimWeight;
                    batch.sift_weight = newSiftWeight;
                }
            });

            // Auto-save machine status
            const statusData = {
                machine: currentMachine,
                current_batch: batchId,
                sift_ledger: siftLedger,
                last_updated: new Date().toISOString(),
                updated_by: currentRole ? currentRole.name : 'Unknown'
            };

            const savePromise = DEMO_MODE
                ? demoSaveMachineStatus(currentMachine, { ...window.currentMachineStatus, ...statusData })
                : supabaseClient.from('wm_machine_status').upsert(statusData, { onConflict: 'machine' });

            savePromise.then(({ error }) => {
                if (error) {
                    console.error('Error saving run:', error);
                    alert('Error saving run data');
                    return;
                }

                // Clear input fields for next run
                if (inputWeightEl) inputWeightEl.value = '';
                if (sift1OutputEl) sift1OutputEl.value = '';
                if (sift2OutputEl) sift2OutputEl.value = '';

                // Update displays
                updateResinatorTotals(siftLedger);
                updateResinatorBatchInfo();

                // Calculate remaining to run through resinator
                let updatedLedger = window.currentMachineStatus?.sift_ledger || [];
                const totalInputProcessed = updatedLedger
                    .filter(r => r.batch_id === batchId)
                    .reduce((sum, r) => sum + (r.input_weight || 0), 0);
                const totalSiftCollected = updatedLedger
                    .filter(r => r.batch_id === batchId)
                    .reduce((sum, r) => sum + (r.first_sift || 0) + (r.second_sift || 0), 0);
                const originalTrim = newTrimWeight + totalSiftCollected;
                const remainingToRun = Math.max(0, originalTrim - totalInputProcessed);

                alert(` Barrel run complete!\n\n${totalOutput}g hash collected (${yieldPct}% yield)\n\nRemaining to run: ${remainingToRun.toFixed(0)}g\nTrim for socks: ${newTrimWeight.toFixed(0)}g`);
            });
        }

        function updateResinatorTotals(siftLedger) {
            if (!siftLedger) {
                const status = window.currentMachineStatus || {};
                siftLedger = status.sift_ledger || [];
                if (typeof siftLedger === 'string') {
                    try { siftLedger = JSON.parse(siftLedger); } catch(e) { siftLedger = []; }
                }
            }

            const totalFirstSift = siftLedger.reduce((sum, r) => sum + (r.first_sift || 0), 0);
            const totalSecondSift = siftLedger.reduce((sum, r) => sum + (r.second_sift || 0), 0);
            const totalProcessed = siftLedger.reduce((sum, r) => sum + (r.input_weight || 0), 0);
            const totalRuns = siftLedger.length;

            // Update display elements
            const el1 = document.getElementById('totalFirstSift');
            const el2 = document.getElementById('totalSecondSift');
            const elProcessed = document.getElementById('totalProcessed');
            const elRuns = document.getElementById('totalRuns');

            if (el1) el1.textContent = `${totalFirstSift.toFixed(1)}g`;
            if (el2) el2.textContent = `${totalSecondSift.toFixed(1)}g`;
            if (elProcessed) elProcessed.textContent = `${totalProcessed.toFixed(0)}g`;
            if (elRuns) elRuns.textContent = totalRuns;

            // Update run history
            const historySection = document.getElementById('runHistorySection');
            const historyContent = document.getElementById('runHistoryContent');
            if (historySection && historyContent && siftLedger.length > 0) {
                historySection.style.display = 'block';
                let html = '';
                siftLedger.forEach((run, i) => {
                    const yields = [];
                    if (run.first_sift > 0) yields.push(`1st: ${run.first_sift}g`);
                    if (run.second_sift > 0) yields.push(`2nd: ${run.second_sift}g`);
                    html += `<div style="padding: 8px 0; border-bottom: 1px solid var(--border); font-size: 0.9rem;">
                        <strong>Run ${i + 1}</strong> - ${run.batch_id}: ${run.input_weight}g  ${yields.join(', ')}
                    </div>`;
                });
                historyContent.innerHTML = html;
            }
        }

        function completeResinatorBatch() {
            const batchSelect = document.getElementById('resinatorBatch');
            const batchId = batchSelect?.value;

            if (!batchId) {
                alert('No batch selected.');
                return;
            }

            // Get session totals for this batch
            const status = window.currentMachineStatus || {};
            let siftLedger = status.sift_ledger || [];
            if (typeof siftLedger === 'string') {
                try { siftLedger = JSON.parse(siftLedger); } catch(e) { siftLedger = []; }
            }

            const batchRuns = siftLedger.filter(r => r.batch_id === batchId);
            if (batchRuns.length === 0) {
                alert('No runs recorded for this batch. Complete at least one barrel run first.');
                return;
            }

            const totalFirstSift = batchRuns.reduce((sum, r) => sum + (r.first_sift || 0), 0);
            const totalSecondSift = batchRuns.reduce((sum, r) => sum + (r.second_sift || 0), 0);
            const totalProcessed = batchRuns.reduce((sum, r) => sum + (r.input_weight || 0), 0);
            const batch = batches.find(b => b.id === batchId);

            const summary = `Complete batch ${batchId}?\n\n` +
                `Strain: ${batch?.strain || 'Unknown'}\n` +
                `Barrel Runs: ${batchRuns.length}\n` +
                `Material Processed: ${totalProcessed.toFixed(0)}g\n` +
                `1st Sift Total: ${totalFirstSift.toFixed(1)}g\n` +
                `2nd Sift Total: ${totalSecondSift.toFixed(1)}g\n` +
                `Total Hash: ${(totalFirstSift + totalSecondSift).toFixed(1)}g\n\n` +
                `Trim for Socks: ${batch?.trim_weight?.toFixed(0) || 0}g`;

            if (!confirm(summary)) {
                return;
            }

            // Create sub-batches for sift output
            const subBatchesCreated = [];
            const now = new Date().toISOString();

            // A-Sift sub-batch (1st sift / higher quality)
            if (totalFirstSift > 0) {
                const aSiftBatch = {
                    id: `${batchId}-A-Sift`,
                    strain: batch?.strain || 'Unknown',
                    partner: batch?.partner || 'Unknown',
                    status: 'sift_complete',
                    material_type: 'Dry Sift',
                    sift_weight: totalFirstSift,
                    trim_weight: 0,
                    socks_total: 0,
                    socks_remaining: 0,
                    parent_batch: batchId,
                    sift_grade: 'A',
                    metrc_tags: batch?.metrc_tags || batch?.metrc_source_tag || '',
                    pre_sift: 'no',
                    created_at: now,
                    notes: `A-grade sift from ${batchRuns.length} barrel run(s)`
                };
                subBatchesCreated.push(aSiftBatch);
            }

            // B-Sift sub-batch (2nd sift / higher yield)
            if (totalSecondSift > 0) {
                const bSiftBatch = {
                    id: `${batchId}-B-Sift`,
                    strain: batch?.strain || 'Unknown',
                    partner: batch?.partner || 'Unknown',
                    status: 'sift_complete',
                    material_type: 'Dry Sift',
                    sift_weight: totalSecondSift,
                    trim_weight: 0,
                    socks_total: 0,
                    socks_remaining: 0,
                    parent_batch: batchId,
                    sift_grade: 'B',
                    metrc_tags: batch?.metrc_tags || batch?.metrc_source_tag || '',
                    pre_sift: 'no',
                    created_at: now,
                    notes: `B-grade sift from ${batchRuns.length} barrel run(s)`
                };
                subBatchesCreated.push(bSiftBatch);
            }

            // Save sub-batches
            const createSubBatches = async () => {
                if (DEMO_MODE) {
                    // Add to local batches array for demo mode
                    subBatchesCreated.forEach(sb => batches.push(sb));
                    return { error: null };
                } else {
                    // Insert into Supabase
                    const { error } = await supabaseClient.from('wm_batches').insert(subBatchesCreated);
                    if (!error) {
                        // Also add to local batches array
                        subBatchesCreated.forEach(sb => batches.push(sb));
                    }
                    return { error };
                }
            };

            createSubBatches().then(({ error }) => {
                if (error) {
                    console.error('Error creating sub-batches:', error);
                    alert('Warning: Sub-batches could not be saved to database. Check console for details.');
                }

                // Clear session data but keep ledger history for records
                window.currentMachineStatus = window.currentMachineStatus || {};
                window.currentMachineStatus.sift_ledger = [];
                window.currentMachineStatus.current_batch = null;

                // Clear form
                const inputWeightEl = document.getElementById('resinatorInputWeight');
                const sift1OutputEl = document.getElementById('resinatorSift1Output');
                const sift2OutputEl = document.getElementById('resinatorSift2Output');
                const historySection = document.getElementById('runHistorySection');
                const remainingDisplay = document.getElementById('batchRemainingDisplay');

                if (batchSelect) batchSelect.value = '';
                if (inputWeightEl) inputWeightEl.value = '';
                if (sift1OutputEl) sift1OutputEl.value = '';
                if (sift2OutputEl) sift2OutputEl.value = '';
                if (historySection) historySection.style.display = 'none';
                if (remainingDisplay) remainingDisplay.style.display = 'none';

                // Reset totals display
                updateResinatorTotals([]);

                // Save cleared machine state
                const clearedStatus = {
                    machine: currentMachine,
                    current_batch: null,
                    sift_ledger: [],
                    last_updated: new Date().toISOString(),
                    updated_by: currentRole ? currentRole.name : 'Unknown'
                };

                const savePromise = DEMO_MODE
                    ? demoSaveMachineStatus(currentMachine, clearedStatus)
                    : supabaseClient.from('wm_machine_status').upsert(clearedStatus, { onConflict: 'machine' });

                savePromise.then(() => {
                    const subBatchList = subBatchesCreated.map(sb => `   ${sb.id}: ${sb.sift_weight.toFixed(1)}g`).join('\n');
                    alert(` Batch ${batchId} complete!\n\nSub-batches created:\n${subBatchList}\n\nReady for next batch.`);

                    // Refresh the extraction queue to show new sub-batches
                    populateExtractionQueue();
                });
            });
        }

        function updateColumnSockUI(column) {
            // Dynamic element IDs for any column A-F
            const batchSelect = document.getElementById('machineColumn' + column + 'Batch');
            const socksSelect = document.getElementById('machineColumn' + column + 'Socks');
            const secondSockDiv = document.getElementById('column' + column + 'SecondSock');
            const secondBatchSelect = document.getElementById('machineColumn' + column + 'SecondBatch');

            // Null safety check
            if (!batchSelect || !socksSelect) return;

            const batchId = batchSelect.value;
            const sockCount = parseInt(socksSelect.value) || 0;

            if (!batchId) {
                socksSelect.value = '0';
                if (secondSockDiv) secondSockDiv.style.display = 'none';
                return;
            }

            const batch = batches.find(b => b.id === batchId);

            // When batch is selected and socks not yet chosen, default to max available (up to 2)
            if (batch && sockCount === 0) {
                const remaining = batch.socks_remaining ?? batch.socks_total ?? 2;
                socksSelect.value = Math.min(2, remaining).toString();
            }

            // Re-read sock count after potential default setting
            const actualSockCount = parseInt(socksSelect.value) || 0;

            // Show second sock selector when exactly 1 sock is selected
            if (actualSockCount === 1 && batch && secondSockDiv && secondBatchSelect) {
                secondSockDiv.style.display = 'block';
                populateCompatibleBatches(secondBatchSelect, batch, batchId);
            } else {
                if (secondSockDiv) secondSockDiv.style.display = 'none';
                if (secondBatchSelect) secondBatchSelect.value = '';
            }
        }

        function populateCompatibleBatches(selectElement, primaryBatch, excludeBatchId) {
            // Mixing rules:
            // - Wholesale can mix with any Wholesale
            // - 50-50 Split can only mix with same partner (cultivation license)
            // - Custom Buyback can only mix with same partner

            selectElement.innerHTML = '<option value="">None (leave empty)</option>';

            batches.forEach(b => {
                if (b.id === excludeBatchId) return; // Skip primary batch
                if (b.status !== 'intake') return; // Only intake batches

                const hasSocksData = b.socks_remaining !== undefined || b.socks_total !== undefined;
                const socksRemaining = b.socks_remaining ?? b.socks_total ?? 2;
                if (socksRemaining < 1) return; // Need at least 1 sock

                let canMix = false;
                const primaryAgreement = primaryBatch.material_agreement || '';
                const batchAgreement = b.material_agreement || '';

                // Wholesale can mix with any Wholesale
                if (primaryAgreement === 'Wholesale' && batchAgreement === 'Wholesale') {
                    canMix = true;
                }
                // Percentage Split and Per Gram can only mix with same partner
                else if (primaryAgreement === batchAgreement &&
                         primaryBatch.partner === b.partner) {
                    canMix = true;
                }

                if (canMix) {
                    const sockDisplay = hasSocksData ? `(${socksRemaining} socks left)` : '';
                    selectElement.innerHTML += `<option value="${b.id}">${b.id} - ${b.strain} ${sockDisplay}</option>`;
                }
            });
        }

        function runColumnToPot(column) {
            // Get socks from the specified column (A-F) with dynamic element IDs
            const batchEl = document.getElementById('machineColumn' + column + 'Batch');
            const socksEl = document.getElementById('machineColumn' + column + 'Socks');
            const secondBatchEl = document.getElementById('machineColumn' + column + 'SecondBatch');

            // If elements don't exist, can't proceed
            if (!batchEl || !socksEl) {
                alert(`Error: Column ${column} form elements not found. Please refresh the page.`);
                return;
            }

            const columnBatch = batchEl.value;
            const columnSocks = parseInt(socksEl.value) || 0;
            const columnSecondBatch = secondBatchEl ? secondBatchEl.value : '';

            // Build list of contributions for this column
            let contributions = [];

            // Primary batch
            if (columnBatch && columnSocks > 0) {
                contributions.push({ batchId: columnBatch, socks: columnSocks === 1 && columnSecondBatch ? 1 : columnSocks });
            }

            // Second sock from different batch
            if (columnSocks === 1 && columnSecondBatch) {
                contributions.push({ batchId: columnSecondBatch, socks: 1 });
            }

            if (contributions.length === 0) {
                alert(`No socks loaded in Column ${column}! Load a batch first.`);
                return;
            }

            // Confirm run
            let confirmMsg = ` Run Column ${column} to Pot?\n\nThis will process:\n`;
            contributions.forEach(c => {
                const batch = batches.find(b => b.id === c.batchId);
                confirmMsg += ` ${c.socks} sock(s) from ${c.batchId} - ${batch?.strain || 'Unknown'}\n`;
            });

            if (!confirm(confirmMsg)) return;

            // Get current pot ledger
            const currentStatus = window.currentMachineStatus || {};
            let potLedger = currentStatus.pot_ledger || [];
            if (typeof potLedger === 'string') {
                try { potLedger = JSON.parse(potLedger); } catch(e) { potLedger = []; }
            }

            // Track socks to decrement from each batch
            let socksToDecrement = {};

            // Add contributions to pot ledger
            contributions.forEach(c => {
                const batch = batches.find(b => b.id === c.batchId);
                if (!batch) return;

                const trimPerSock = batch.trim_per_sock || Math.round((batch.trim_weight / (batch.socks_total || 1)) * 10) / 10;
                const trimWeight = Math.round(trimPerSock * c.socks * 10) / 10; // Round to nearest tenth

                // Check if this will be a partial use (not all socks from batch)
                const currentRemaining = batch.socks_remaining ?? batch.socks_total ?? 0;
                const willHaveRemaining = currentRemaining - c.socks > 0;

                // Check if batch already in ledger
                const existingEntry = potLedger.find(p => p.batch_id === c.batchId);
                if (existingEntry) {
                    existingEntry.socks += c.socks;
                    existingEntry.trim_weight = Math.round((existingEntry.trim_weight + trimWeight) * 10) / 10;
                    // Update is_partial - partial if batch will still have remaining socks
                    existingEntry.is_partial = willHaveRemaining;
                } else {
                    // Capture current filter state at time of drop
                    const currentFilterState = {
                        silica_top: parseFloat(document.getElementById('machineFilterSilicaTop')?.value) || 0,
                        clay: parseFloat(document.getElementById('machineFilterClay')?.value) || 0,
                        silica_bottom: parseFloat(document.getElementById('machineFilterSilicaBottom')?.value) || 0,
                        filter_runs: parseInt(document.getElementById('machineFilterRuns')?.value) || 0
                    };

                    potLedger.push({
                        batch_id: c.batchId,
                        metrc_tag: batch.metrc_tags || batch.metrc_source_tag || '',
                        socks: c.socks,
                        trim_weight: trimWeight,
                        cultivation_license: batch.partner || batch.cultivation_license || '',
                        material_agreement: batch.material_agreement || '',
                        strain: batch.strain || '',
                        is_partial: willHaveRemaining,
                        filter_at_drop: currentFilterState
                    });
                }

                // Track socks to decrement
                socksToDecrement[c.batchId] = (socksToDecrement[c.batchId] || 0) + c.socks;
            });

            // Determine majority batch for pot_batch
            let majorityBatchId = '';
            let maxSocks = 0;
            potLedger.forEach(p => {
                if (p.socks > maxSocks) {
                    maxSocks = p.socks;
                    majorityBatchId = p.batch_id;
                }
            });

            // Update UI
            document.getElementById('machinePotBatch').value = majorityBatchId;
            const majorityBatch = batches.find(b => b.id === majorityBatchId);
            document.getElementById('machinePotBatchDisplay').value = majorityBatch ?
                `${majorityBatchId} - ${majorityBatch.strain}` : majorityBatchId;

            // Increment pot runs
            const currentRuns = parseInt(document.getElementById('machinePotRuns').value) || 0;
            document.getElementById('machinePotRuns').value = currentRuns + 1;

            console.log('runColumnToPot - majorityBatchId:', majorityBatchId, 'newRuns:', currentRuns + 1, 'potLedger:', potLedger);

            // Update current machine status with new ledger
            window.currentMachineStatus = window.currentMachineStatus || {};
            window.currentMachineStatus.pot_ledger = potLedger;

            console.log('runColumnToPot - window.currentMachineStatus.pot_ledger set to:', window.currentMachineStatus.pot_ledger);

            // Update pot ledger display
            displayPotLedger({ pot_ledger: potLedger });

            // Clear the column that was run
            if (batchEl) batchEl.value = '';
            if (socksEl) socksEl.value = '0';
            if (secondBatchEl) secondBatchEl.value = '';
            const secondSockDiv = document.getElementById('column' + column + 'SecondSock');
            if (secondSockDiv) secondSockDiv.style.display = 'none';

            // Decrement socks from batches in database (skip in demo mode)
            const decrementPromises = Object.entries(socksToDecrement).map(([batchId, sockCount]) => {
                const batch = batches.find(b => b.id === batchId);
                if (!batch) return Promise.resolve();

                const currentRemaining = batch.socks_remaining ?? batch.socks_total ?? 0;
                const newRemaining = Math.max(0, currentRemaining - sockCount);

                // Update local cache
                batch.socks_remaining = newRemaining;

                // In demo mode, just update local cache, don't touch database
                if (DEMO_MODE) return Promise.resolve();

                return supabaseClient
                    .from('wm_batches')
                    .update({ socks_remaining: newRemaining })
                    .eq('id', batchId);
            });

            // Calculate total trim for this run (rounded to nearest tenth)
            const runTrimWeight = Math.round(contributions.reduce((sum, c) => {
                const batch = batches.find(b => b.id === c.batchId);
                if (!batch) return sum;
                const trimPerSock = batch.trim_per_sock || Math.round((batch.trim_weight / (batch.socks_total || 1)) * 10) / 10;
                return sum + (trimPerSock * c.socks);
            }, 0) * 10) / 10;

            // Log extraction run for cross-contamination tracking
            const strainList = [...new Set(contributions.map(c => {
                const batch = batches.find(b => b.id === c.batchId);
                return batch?.strain || 'Unknown';
            }))].join(', ');

            const currentFilterState = {
                silica_top: parseFloat(document.getElementById('machineFilterSilicaTop')?.value) || 0,
                clay: parseFloat(document.getElementById('machineFilterClay')?.value) || 0,
                silica_bottom: parseFloat(document.getElementById('machineFilterSilicaBottom')?.value) || 0,
                filter_runs: parseInt(document.getElementById('machineFilterRuns')?.value) || 0
            };

            const extractionRun = {
                timestamp: new Date().toISOString(),
                user: currentRole ? currentRole.name : 'Unknown',
                machine: currentMachine,
                column: column,
                trimWeight: runTrimWeight,
                socks: contributions.reduce((sum, c) => sum + c.socks, 0),
                batches: contributions.map(c => c.batchId),
                strain: strainList,
                filterState: currentFilterState
            };

            // Store in database for cross-contamination tracking
            if (!DEMO_MODE) {
                supabaseClient
                    .from('wm_machine_runs')
                    .insert({
                        timestamp: extractionRun.timestamp,
                        user_name: extractionRun.user,
                        machine: extractionRun.machine,
                        column_letter: extractionRun.column,
                        trim_weight: extractionRun.trimWeight,
                        socks: extractionRun.socks,
                        batches: extractionRun.batches,
                        strain: extractionRun.strain,
                        filter_state: extractionRun.filterState
                    })
                    .then(({ error }) => {
                        if (error) console.error('Error logging machine run:', error);
                        else console.log('Logged extraction run to database:', extractionRun);
                    });
            } else {
                // Demo mode - store in localStorage
                const extractionRuns = JSON.parse(localStorage.getItem('wm_extraction_runs') || '[]');
                extractionRuns.push(extractionRun);
                localStorage.setItem('wm_extraction_runs', JSON.stringify(extractionRuns));
                console.log('Logged extraction run (demo):', extractionRun);
            }

            Promise.all(decrementPromises).then(() => {
                // Auto-save pot status to database (so it persists if modal is closed)
                const potRuns = parseInt(document.getElementById('machinePotRuns').value) || 0;

                // In demo mode, save to localStorage instead of database
                if (DEMO_MODE) {
                    const demoStatus = demoGetMachineStatus(currentMachine);
                    demoStatus.pot_batch = majorityBatchId;
                    demoStatus.pot_runs = potRuns;
                    demoStatus.pot_ledger = potLedger;
                    return demoSaveMachineStatus(currentMachine, demoStatus);
                }

                return supabaseClient
                    .from('wm_machine_status')
                    .upsert({
                        machine: currentMachine,
                        pot_batch: majorityBatchId,
                        pot_runs: potRuns,
                        pot_ledger: potLedger,
                        last_updated: new Date().toISOString(),
                        updated_by: currentRole ? currentRole.name : 'Unknown'
                    }, { onConflict: 'machine' });
            }).then(() => {
                // Refresh extraction queue and column dropdowns
                populateExtractionQueue();
                refreshColumnDropdowns();

                // Auto-save machine status (skip in demo mode - already saved above)
                if (DEMO_MODE) {
                    updateMachineDisplays(); // Refresh the machine cards
                    alert(` Column ${column} run added to pot! (Demo Mode)`);
                    return;
                }

                autoSaveMachineStatus().then(() => {
                    updateMachineDisplays(); // Refresh the machine cards
                    alert(` Column ${column} run added to pot and saved!`);
                }).catch(err => {
                    console.error('Error auto-saving machine status:', err);
                    alert(` Column ${column} run added to pot!\n Auto-save failed - click "Save Status" manually.`);
                });
            }).catch(err => {
                console.error('Error updating machine status:', err);
                alert(' Run added to pot but error saving. Check console.');
            });
        }

        // Auto-save machine status without closing modal
        async function autoSaveMachineStatus() {
            if (!currentMachine) {
                console.error('autoSaveMachineStatus: No currentMachine set');
                return;
            }

            const potBatch = document.getElementById('machinePotBatch').value;
            const potRuns = parseInt(document.getElementById('machinePotRuns').value) || 0;
            const potLedger = window.currentMachineStatus?.pot_ledger || [];

            console.log('autoSaveMachineStatus - potBatch:', potBatch, 'potRuns:', potRuns, 'potLedger:', potLedger);

            // Dynamically get column values for A-F
            const columnLabels = ['A', 'B', 'C', 'D', 'E', 'F'];
            const columnData = {};
            columnLabels.forEach(col => {
                const colKey = col.toLowerCase();
                const batchEl = document.getElementById('machineColumn' + col + 'Batch');
                const socksEl = document.getElementById('machineColumn' + col + 'Socks');
                const secondEl = document.getElementById('machineColumn' + col + 'SecondBatch');

                if (batchEl) {
                    const batchKey = col === 'A' ? 'column_batch' : `column_${colKey}_batch`;
                    const socksKey = `column_${colKey}_socks`;
                    const secondKey = `column_${colKey}_second_batch`;

                    columnData[batchKey] = batchEl.value || '';
                    columnData[socksKey] = socksEl ? (parseInt(socksEl.value) || 0) : 0;
                    columnData[secondKey] = secondEl ? secondEl.value : '';
                }
            });

            const machineStatus = {
                machine: currentMachine,
                ...columnData,
                pot_batch: potBatch,
                pot_runs: potRuns,
                pot_ledger: potLedger,
                filter_silica_top: parseFloat(document.getElementById('machineFilterSilicaTop').value) || 0,
                filter_clay: parseFloat(document.getElementById('machineFilterClay').value) || 0,
                filter_silica_bottom: parseFloat(document.getElementById('machineFilterSilicaBottom').value) || 0,
                filter_runs: parseInt(document.getElementById('machineFilterRuns').value) || 0,
                last_updated: new Date().toISOString(),
                updated_by: currentRole ? currentRole.name : 'Unknown'
            };

            console.log('autoSaveMachineStatus - saving:', machineStatus);

            // In demo mode, save to localStorage instead
            if (DEMO_MODE) {
                demoSaveMachineStatus(currentMachine, machineStatus);
                console.log('autoSaveMachineStatus - saved to demo storage');
                updateMachineDisplays();
                return;
            }

            const { error } = await supabaseClient
                .from('wm_machine_status')
                .upsert(machineStatus, { onConflict: 'machine' });

            if (error) {
                console.error('autoSaveMachineStatus - error:', error);
                throw error;
            }

            console.log('autoSaveMachineStatus - saved successfully');

            // Update displays
            updateMachineDisplays();
        }

        function refreshColumnDropdowns() {
            // Dynamically refresh all columns A-F
            const columnLabels = ['A', 'B', 'C', 'D', 'E', 'F'];
            const savedSelections = {};

            // Save current selections for all columns
            columnLabels.forEach(col => {
                const select = document.getElementById('machineColumn' + col + 'Batch');
                if (select) savedSelections[col] = select.value;
            });

            // Build options HTML once
            let optionsHtml = '<option value="">Empty / Not Loaded</option>';
            batches.forEach(batch => {
                // Show intake batches OR any batch with socks remaining
                const hasSocksRemaining = batch.socks_total != null && batch.socks_remaining > 0;
                if (batch.status === 'intake' || hasSocksRemaining) {
                    // Skip batches with 0 socks remaining
                    if (batch.socks_total != null && batch.socks_remaining === 0) return;
                    const socksRemaining = batch.socks_remaining ?? batch.socks_total ?? '?';
                    const socksTotal = batch.socks_total ?? '?';
                    const statusLabel = batch.status !== 'intake' ? ` [${batch.status}]` : '';
                    const sockDisplay = `(${socksRemaining}/${socksTotal} socks)${statusLabel}`;
                    optionsHtml += `<option value="${batch.id}">${batch.id} - ${batch.strain} ${sockDisplay}</option>`;
                }
            });

            // Update all column dropdowns
            columnLabels.forEach(col => {
                const select = document.getElementById('machineColumn' + col + 'Batch');
                const secondSelect = document.getElementById('machineColumn' + col + 'SecondBatch');
                if (select) {
                    select.innerHTML = optionsHtml;
                    select.value = savedSelections[col] || '';
                    if (!select.value) select.selectedIndex = 0;
                }
                if (secondSelect) {
                    secondSelect.innerHTML = '<option value="">None</option>' + optionsHtml.replace('<option value="">Empty / Not Loaded</option>', '');
                }
            });
        }

        function closeMachineModal() {
            document.getElementById('machineModal').style.display = 'none';
            currentMachine = null;
        }
        
        function saveMachineStatus() {
            if (!currentMachine) return;

            // Dynamically get column values for A-F
            const columnLabels = ['A', 'B', 'C', 'D', 'E', 'F'];
            const columnData = {};
            columnLabels.forEach(col => {
                const colKey = col.toLowerCase();
                const batchEl = document.getElementById('machineColumn' + col + 'Batch');
                const socksEl = document.getElementById('machineColumn' + col + 'Socks');
                const secondEl = document.getElementById('machineColumn' + col + 'SecondBatch');

                if (batchEl) {
                    // Use legacy key names for A (column_batch) to maintain backwards compatibility
                    const batchKey = col === 'A' ? 'column_batch' : `column_${colKey}_batch`;
                    const socksKey = `column_${colKey}_socks`;
                    const secondKey = `column_${colKey}_second_batch`;

                    columnData[batchKey] = batchEl.value || '';
                    columnData[socksKey] = socksEl ? (parseInt(socksEl.value) || 0) : 0;
                    columnData[secondKey] = secondEl ? secondEl.value : '';
                }
            });

            const potBatch = document.getElementById('machinePotBatch').value;
            const potRuns = parseInt(document.getElementById('machinePotRuns').value) || 0;
            const filterSilicaTop = parseFloat(document.getElementById('machineFilterSilicaTop').value) || 0;
            const filterClay = parseFloat(document.getElementById('machineFilterClay').value) || 0;
            const filterSilicaBottom = parseFloat(document.getElementById('machineFilterSilicaBottom').value) || 0;
            const filterRuns = parseInt(document.getElementById('machineFilterRuns').value) || 0;

            // Preserve pot_ledger from current status
            const currentStatus = window.currentMachineStatus || {};
            let potLedger = currentStatus.pot_ledger || [];

            const machineStatus = {
                machine: currentMachine,
                ...columnData,
                pot_batch: potBatch,
                pot_runs: potRuns,
                pot_ledger: potLedger,
                filter_silica_top: filterSilicaTop,
                filter_clay: filterClay,
                filter_silica_bottom: filterSilicaBottom,
                filter_runs: filterRuns,
                last_updated: new Date().toISOString(),
                updated_by: currentRole ? currentRole.name : 'Unknown'
            };

            // In demo mode, save to localStorage instead
            if (DEMO_MODE) {
                demoSaveMachineStatus(currentMachine, machineStatus);
                updateMachineDisplays();
                closeMachineModal();
                alert(` Machine Status Saved! (Demo Mode)`);
                return;
            }

            // Save to Supabase
            supabaseClient
                .from('wm_machine_status')
                .upsert(machineStatus, { onConflict: 'machine' })
                .then(({ error }) => {
                    if (error) {
                        console.error('Error saving machine status:', error);
                        alert('Error saving machine status. Please try again.');
                        return;
                    }

                    updateMachineDisplays();
                    closeMachineModal();

                    // Find machine name from config for the alert
                    const machineInfo = CONFIG.machines.find(m => {
                        const key = (m.position?.toLowerCase() || m.name.toLowerCase()).replace(/[^a-z0-9]/g, '');
                        return key === currentMachine;
                    });
                    const machineName = machineInfo?.name || (currentMachine === 'left' ? 'Left' : currentMachine === 'right' ? 'Right' : currentMachine);
                    alert(` ${machineName} Status Saved!`);
                });
        }
        
        function clearMachineStatus() {
            if (!currentMachine) return;

            // Get current pot ledger to restore socks
            const currentStatus = window.currentMachineStatus || {};
            let potLedger = currentStatus.pot_ledger || [];
            if (typeof potLedger === 'string') {
                try { potLedger = JSON.parse(potLedger); } catch(e) { potLedger = []; }
            }

            // Check if there's anything in the pot to clear
            if (potLedger.length === 0) {
                alert('The pot is already empty.');
                return;
            }

            // Build confirmation message - only about pot contents
            let confirmMsg = `Clear the pot and return socks to their batches?\n\n The following socks will be returned:`;
            potLedger.forEach(entry => {
                const batch = batches.find(b => b.id === entry.batch_id);
                confirmMsg += `\n ${entry.socks} sock(s)  ${entry.batch_id} (${batch?.strain || 'Unknown'})`;
            });

            if (!confirm(confirmMsg)) {
                return;
            }

            // Restore socks to batches from pot_ledger
            const restorePromises = potLedger.map(entry => {
                // Skip demo batches when not in demo mode (and vice versa)
                const isDemoBatch = entry.batch_id?.startsWith('DEMO-');
                if (isDemoBatch && !DEMO_MODE) {
                    console.log('Skipping demo batch restore in regular mode:', entry.batch_id);
                    return Promise.resolve();
                }
                if (!isDemoBatch && DEMO_MODE) {
                    console.log('Skipping real batch restore in demo mode:', entry.batch_id);
                    return Promise.resolve();
                }

                const batch = batches.find(b => b.id === entry.batch_id);
                if (!batch) return Promise.resolve();

                const currentRemaining = batch.socks_remaining ?? 0;
                const newRemaining = currentRemaining + entry.socks;

                // Update local cache
                batch.socks_remaining = newRemaining;

                // In demo mode, just update local cache
                if (DEMO_MODE) return Promise.resolve();

                return supabaseClient
                    .from('wm_batches')
                    .update({ socks_remaining: newRemaining })
                    .eq('id', entry.batch_id);
            });

            // Only clear pot-related fields, preserve columns and filter
            const potClearStatus = {
                machine: currentMachine,
                pot_batch: null,
                pot_runs: 0,
                pot_ledger: [],
                last_updated: new Date().toISOString(),
                updated_by: currentRole ? currentRole.name : 'Unknown'
            };

            // Helper to clear pot form elements only
            const clearPotElements = () => {
                const clearEl = (id, val = '') => {
                    const el = document.getElementById(id);
                    if (el) el.value = val;
                };
                const hideEl = (id) => {
                    const el = document.getElementById(id);
                    if (el) el.style.display = 'none';
                };

                // Only clear pot-related elements
                clearEl('machinePotBatch');
                clearEl('machinePotBatchDisplay');
                clearEl('machinePotRuns');
                hideEl('potLedgerDisplay');

                // Update cached machine status - only clear pot fields
                if (window.currentMachineStatus) {
                    window.currentMachineStatus.pot_batch = null;
                    window.currentMachineStatus.pot_runs = 0;
                    window.currentMachineStatus.pot_ledger = [];
                }

                // Hide pull batch button since pot is now empty
                const pullBatchBtn = document.getElementById('modalPullBatchBtn');
                if (pullBatchBtn) pullBatchBtn.style.display = 'none';

                // Refresh displays and dropdowns
                updateMachineDisplays();
                refreshColumnDropdowns();
                populateExtractionQueue();

                // Get machine name for alert
                const machineInfo = CONFIG.machines.find(m => {
                    const key = (m.position?.toLowerCase() || m.name.toLowerCase()).replace(/[^a-z0-9]/g, '');
                    return key === currentMachine;
                });
                const machineName = machineInfo?.name || currentMachine;
                alert(` ${machineName} pot cleared! Socks returned to batches.${DEMO_MODE ? ' (Demo Mode)' : ''}`);
            };

            // Wait for sock restoration, then clear pot status only
            Promise.all(restorePromises).then(() => {
                // In demo mode, update localStorage (preserve other fields)
                if (DEMO_MODE) {
                    const existingStatus = demoGetMachineStatus(currentMachine) || {};
                    demoSaveMachineStatus(currentMachine, { ...existingStatus, ...potClearStatus });
                    clearPotElements();
                    return Promise.resolve();
                }

                // Use update instead of upsert to only modify pot fields
                return supabaseClient
                    .from('wm_machine_status')
                    .update(potClearStatus)
                    .eq('machine', currentMachine)
                    .then((result) => {
                        if (result?.error) {
                            console.error('Error clearing pot in DB:', result.error);
                            alert('Error clearing pot in database. Check console.');
                            return;
                        }
                        console.log('Pot cleared in database, updating UI...');
                        clearPotElements();
                    });
            }).catch(err => {
                console.error('Error during clear:', err);
                alert('Error clearing pot. Check console.');
            });
        }
        
        function updateMachineDisplays() {
            supabaseClient
                .from('wm_machine_status')
                .select('*')
                .then(({ data: machineStatuses, error }) => {
                    if (error) {
                        console.error('Error loading machine statuses:', error);
                        return;
                    }

                    // Get machine keys from CONFIG (or use defaults)
                    const machines = (CONFIG.machines.length > 0 ? CONFIG.machines : CONFIG_DEFAULTS.machines);
                    const machineKeys = machines.map(m => (m.position?.toLowerCase() || m.name.toLowerCase()).replace(/[^a-z0-9]/g, ''));

                    machineKeys.forEach(machineKey => {
                        // In demo mode, use demo data from localStorage instead
                        let machineStatus;
                        if (DEMO_MODE) {
                            machineStatus = demoGetMachineStatus(machineKey) || {};
                        } else {
                            machineStatus = machineStatuses.find(m => m.machine === machineKey) || {};
                        }

                        // Update all columns A-F dynamically
                        const columnLabels = ['A', 'B', 'C', 'D', 'E', 'F'];
                        columnLabels.forEach(col => {
                            const colEl = document.getElementById(`${machineKey}Col${col}Strain`);
                            const colBtn = document.getElementById(`${machineKey}Col${col}Btn`);
                            if (colEl) {
                                const colKey = col.toLowerCase();
                                // Handle legacy format (column_batch for A) and new format
                                const batchKey = col === 'A' ? 'column_batch' : `column_${colKey}_batch`;
                                const batchId = machineStatus[batchKey];
                                if (batchId) {
                                    const batch = batches.find(b => b.id == batchId);
                                    // Show strain name - truncate only if very long
                                    const strainName = batch?.strain || 'Loaded';
                                    colEl.textContent = strainName.length > 12 ? strainName.substring(0, 11) + '' : strainName;
                                    if (colBtn) colBtn.style.background = 'linear-gradient(145deg, rgba(59,130,246,0.5) 0%, rgba(59,130,246,0.25) 100%)';
                                } else {
                                    colEl.textContent = '-';
                                    if (colBtn) colBtn.style.background = 'linear-gradient(145deg, rgba(59,130,246,0.25) 0%, rgba(59,130,246,0.1) 100%)';
                                }
                            }
                        });

                        // Update Pot button
                        const potStrainEl = document.getElementById(`${machineKey}PotStrain`);
                        const potRunsEl = document.getElementById(`${machineKey}PotRuns`);
                        const potYieldEl = document.getElementById(`${machineKey}PotYield`);
                        const potBtn = document.getElementById(`${machineKey}PotBtn`);
                        if (potStrainEl) {
                            if (machineStatus.pot_batch) {
                                const batch = batches.find(b => b.id == machineStatus.pot_batch);
                                potStrainEl.textContent = batch?.strain || machineStatus.pot_batch;
                                if (potRunsEl) potRunsEl.textContent = machineStatus.pot_runs ? `${machineStatus.pot_runs} runs` : '';

                                // Calculate predicted yield from pot_ledger
                                if (potYieldEl) {
                                    let potLedger = machineStatus.pot_ledger || [];
                                    if (typeof potLedger === 'string') {
                                        try { potLedger = JSON.parse(potLedger); } catch(e) { potLedger = []; }
                                    }
                                    if (potLedger.length > 0) {
                                        let totalPredictedYield = 0;
                                        potLedger.forEach(entry => {
                                            const entryBatch = batches.find(b => b.id === entry.batch_id);
                                            const trimWeight = entry.trim_weight || 0;
                                            const yieldPct = (entryBatch?.expected_yield || 13) / 100;
                                            totalPredictedYield += trimWeight * yieldPct;
                                        });
                                        potYieldEl.textContent = `~${totalPredictedYield.toFixed(0)}g`;
                                    } else {
                                        potYieldEl.textContent = '';
                                    }
                                }
                                if (potBtn) potBtn.style.background = 'linear-gradient(145deg, rgba(147,51,234,0.45) 0%, rgba(147,51,234,0.2) 100%)';
                            } else {
                                potStrainEl.textContent = 'Empty';
                                if (potRunsEl) potRunsEl.textContent = '';
                                if (potYieldEl) potYieldEl.textContent = '';
                                if (potBtn) potBtn.style.background = 'linear-gradient(145deg, rgba(147,51,234,0.3) 0%, rgba(147,51,234,0.1) 100%)';
                            }
                        }

                        // Update Filter button
                        const filterRunsEl = document.getElementById(`${machineKey}FilterRuns`);
                        const filterBtn = document.getElementById(`${machineKey}FilterBtn`);
                        if (filterRunsEl) {
                            const runs = machineStatus.filter_runs || 0;
                            filterRunsEl.textContent = runs;
                            if (filterBtn) {
                                if (runs > 0) {
                                    filterBtn.style.background = 'linear-gradient(145deg, rgba(16,185,129,0.4) 0%, rgba(16,185,129,0.2) 100%)';
                                } else {
                                    filterBtn.style.background = 'linear-gradient(145deg, rgba(16,185,129,0.25) 0%, rgba(16,185,129,0.1) 100%)';
                                }
                            }
                        }

                        // Update resinator sift displays
                        const sift1El = document.getElementById(`${machineKey}Sift1`);
                        const sift2El = document.getElementById(`${machineKey}Sift2`);
                        if (sift1El || sift2El) {
                            // This is a resinator - show sift totals
                            let siftLedger = machineStatus.sift_ledger || [];
                            if (typeof siftLedger === 'string') {
                                try { siftLedger = JSON.parse(siftLedger); } catch(e) { siftLedger = []; }
                            }

                            if (siftLedger.length > 0) {
                                const totalOutput = siftLedger.reduce((sum, s) => sum + (s.output_weight || 0), 0);
                                const siftCount = siftLedger.length;
                                if (sift1El) sift1El.textContent = `${totalOutput.toFixed(1)}g (${siftCount} runs)`;
                            } else {
                                if (sift1El) sift1El.textContent = 'Empty';
                            }
                            if (sift2El && !machineStatus.sift_ledger) sift2El.textContent = 'Empty';
                        }
                    });
                });
        }
        
        // Supplies Modal
        function openSuppliesModal() {
            supabaseClient
                .from('wm_inventory')
                .select('*')
                .then(({ data: inventory, error }) => {
                    if (error) {
                        console.error('Error loading inventory:', error);
                        return;
                    }
                    
                    const butane = inventory.find(i => i.supply_type === 'butane');
                    const nitrogen = inventory.find(i => i.supply_type === 'nitrogen');
                    
                    // Update displays in modal
                    document.getElementById('modalButaneDisplay').textContent = butane ? `${parseFloat(butane.current_level).toFixed(1)} lbs` : '0.0 lbs';
                    document.getElementById('modalNitrogenDisplay').textContent = nitrogen ? `${parseFloat(nitrogen.current_level).toFixed(1)}` : '0.0';
                    
                    // Clear input fields
                    document.getElementById('modalWithdrawButane').value = '';
                    document.getElementById('modalWithdrawNitrogen').value = '';
                    
                    document.getElementById('suppliesModal').style.display = 'block';
                });
        }
        
        function closeSuppliesModal() {
            document.getElementById('suppliesModal').style.display = 'none';
        }
        
        function withdrawButaneFromModal() {
            const withdrawAmount = parseFloat(document.getElementById('modalWithdrawButane').value);
            
            if (!withdrawAmount || withdrawAmount <= 0) {
                alert('Please enter an amount to withdraw');
                return;
            }
            
            supabaseClient
                .from('wm_inventory')
                .select('*')
                .eq('supply_type', 'butane')
                .single()
                .then(({ data: butaneRecord, error }) => {
                    if (error) {
                        console.error('Error loading butane inventory:', error);
                        return;
                    }
                    
                    const currentButane = parseFloat(butaneRecord.current_level) || 0;
                    
                    if (withdrawAmount > currentButane) {
                        if (!confirm(` Warning: You're withdrawing ${withdrawAmount.toFixed(1)} lbs but only ${currentButane.toFixed(1)} lbs are in the bulk tank.\n\nContinue anyway?`)) {
                            return;
                        }
                    }
                    
                    const newButane = currentButane - withdrawAmount;
                    
                    // Update inventory in Supabase
                    supabaseClient
                        .from('wm_inventory')
                        .update({
                            current_level: newButane,
                            last_updated: new Date().toISOString(),
                            updated_by: currentRole ? currentRole.name : 'Unknown'
                        })
                        .eq('supply_type', 'butane')
                        .then(({ error: updateError }) => {
                            if (updateError) {
                                console.error('Error updating butane:', updateError);
                                return;
                            }
                            
                            // Save transaction
                            supabaseClient
                                .from('wm_inventory_transactions')
                                .insert({
                                    supply_type: 'butane',
                                    transaction_type: 'withdraw',
                                    amount: withdrawAmount,
                                    previous_level: currentButane,
                                    new_level: newButane,
                                    notes: `Withdrew ${withdrawAmount.toFixed(1)} lbs`,
                                    timestamp: new Date().toISOString(),
                                    user_name: currentRole ? currentRole.name : 'Unknown'
                                })
                                .then(() => {
                                    document.getElementById('modalWithdrawButane').value = '';
                                    document.getElementById('modalButaneDisplay').textContent = `${newButane.toFixed(1)} lbs`;
                                    updateSuppliesButton();
                                    
                                    alert(` Withdrawn!\n\n${withdrawAmount.toFixed(1)} lbs butane removed\nRemaining: ${newButane.toFixed(1)} lbs`);
                                });
                        });
                });
        }
        
        function withdrawNitrogenFromModal() {
            const withdrawAmount = parseFloat(document.getElementById('modalWithdrawNitrogen').value);
            
            if (!withdrawAmount || withdrawAmount <= 0) {
                alert('Please enter an amount to withdraw');
                return;
            }
            
            supabaseClient
                .from('wm_inventory')
                .select('*')
                .eq('supply_type', 'nitrogen')
                .single()
                .then(({ data: nitrogenRecord, error }) => {
                    if (error) {
                        console.error('Error loading nitrogen inventory:', error);
                        return;
                    }
                    
                    const currentNitrogen = parseFloat(nitrogenRecord.current_level) || 0;
                    
                    if (withdrawAmount > currentNitrogen) {
                        if (!confirm(` Warning: You're withdrawing ${withdrawAmount.toFixed(1)} tank(s) but only ${currentNitrogen.toFixed(1)} remain.\n\nContinue anyway?`)) {
                            return;
                        }
                    }
                    
                    const newNitrogen = currentNitrogen - withdrawAmount;
                    
                    // Update inventory in Supabase
                    supabaseClient
                        .from('wm_inventory')
                        .update({
                            current_level: newNitrogen,
                            last_updated: new Date().toISOString(),
                            updated_by: currentRole ? currentRole.name : 'Unknown'
                        })
                        .eq('supply_type', 'nitrogen')
                        .then(({ error: updateError }) => {
                            if (updateError) {
                                console.error('Error updating nitrogen:', updateError);
                                return;
                            }
                            
                            // Save transaction
                            supabaseClient
                                .from('wm_inventory_transactions')
                                .insert({
                                    supply_type: 'nitrogen',
                                    transaction_type: 'withdraw',
                                    amount: withdrawAmount,
                                    previous_level: currentNitrogen,
                                    new_level: newNitrogen,
                                    notes: `Withdrew ${withdrawAmount.toFixed(1)} tank(s)`,
                                    timestamp: new Date().toISOString(),
                                    user_name: currentRole ? currentRole.name : 'Unknown'
                                })
                                .then(() => {
                                    document.getElementById('modalWithdrawNitrogen').value = '';
                                    document.getElementById('modalNitrogenDisplay').textContent = `${newNitrogen.toFixed(1)}`;
                                    updateSuppliesButton();
                                    
                                    alert(` Withdrawn!\n\n${withdrawAmount.toFixed(1)} nitrogen tank(s) removed\nRemaining: ${newNitrogen.toFixed(1)} tanks`);
                                });
                        });
                });
        }
        
        // Butane Modals
        function openAddButaneModal() {
            document.getElementById('butaneShipmentAmount').value = '';
            document.getElementById('butaneShipmentNotes').value = '';
            document.getElementById('addShipmentModal').style.display = 'block';
        }
        
        function closeAddButaneModal() {
            document.getElementById('addShipmentModal').style.display = 'none';
        }
        
        function addButaneShipment() {
            const addAmount = parseFloat(document.getElementById('butaneShipmentAmount').value);
            const notes = document.getElementById('butaneShipmentNotes').value;
            
            if (!addAmount || addAmount <= 0) {
                alert('Please enter a valid amount');
                return;
            }
            
            supabaseClient
                .from('wm_inventory')
                .select('*')
                .eq('supply_type', 'butane')
                .single()
                .then(({ data: butaneRecord, error }) => {
                    if (error) {
                        console.error('Error loading butane inventory:', error);
                        return;
                    }
                    
                    const currentButane = parseFloat(butaneRecord.current_level) || 0;
                    const newButane = currentButane + addAmount;
                    
                    // Update inventory in Supabase
                    supabaseClient
                        .from('wm_inventory')
                        .update({
                            current_level: newButane,
                            last_updated: new Date().toISOString(),
                            updated_by: currentRole ? currentRole.name : 'Unknown'
                        })
                        .eq('supply_type', 'butane')
                        .then(({ error: updateError }) => {
                            if (updateError) {
                                console.error('Error updating butane:', updateError);
                                return;
                            }
                            
                            // Save transaction
                            supabaseClient
                                .from('wm_inventory_transactions')
                                .insert({
                                    supply_type: 'butane',
                                    transaction_type: 'add',
                                    amount: addAmount,
                                    previous_level: currentButane,
                                    new_level: newButane,
                                    notes: notes || `Added ${addAmount.toFixed(1)} lbs shipment`,
                                    timestamp: new Date().toISOString(),
                                    user_name: currentRole ? currentRole.name : 'Unknown'
                                })
                                .then(() => {
                                    // Update all displays
                                    if (document.getElementById('modalButaneDisplay')) {
                                        document.getElementById('modalButaneDisplay').textContent = `${newButane.toFixed(1)} lbs`;
                                    }
                                    updateSuppliesButton();
                                    closeAddButaneModal();
                                    
                                    alert(` Shipment Added!\n\n${addAmount.toFixed(1)} lbs butane added\nNew Total: ${newButane.toFixed(1)} lbs`);
                                });
                        });
                });
        }
        
        function openEditButaneModal() {
            supabaseClient
                .from('wm_inventory')
                .select('*')
                .eq('supply_type', 'butane')
                .single()
                .then(({ data: butaneRecord, error }) => {
                    if (error) {
                        console.error('Error loading butane inventory:', error);
                        return;
                    }
                    
                    const currentButane = parseFloat(butaneRecord.current_level) || 0;
                    document.getElementById('editButaneCurrentDisplay').textContent = `${currentButane.toFixed(1)} lbs`;
                    document.getElementById('butaneSetAmount').value = '';
                    document.getElementById('butaneSetNotes').value = '';
                    document.getElementById('editBulkModal').style.display = 'block';
                });
        }
        
        function closeEditButaneModal() {
            document.getElementById('editBulkModal').style.display = 'none';
        }
        
        function setButaneWeight() {
            const setAmount = parseFloat(document.getElementById('butaneSetAmount').value);
            const notes = document.getElementById('butaneSetNotes').value;
            
            if (!setAmount && setAmount !== 0) {
                alert('Please enter a valid amount');
                return;
            }
            
            if (!notes.trim()) {
                alert('Please provide a reason for this manual change');
                return;
            }
            
            supabaseClient
                .from('wm_inventory')
                .select('*')
                .eq('supply_type', 'butane')
                .single()
                .then(({ data: butaneRecord, error }) => {
                    if (error) {
                        console.error('Error loading butane inventory:', error);
                        return;
                    }
                    
                    const currentButane = parseFloat(butaneRecord.current_level) || 0;
                    
                    // Update inventory in Supabase
                    supabaseClient
                        .from('wm_inventory')
                        .update({
                            current_level: setAmount,
                            last_updated: new Date().toISOString(),
                            updated_by: currentRole ? currentRole.name : 'Unknown'
                        })
                        .eq('supply_type', 'butane')
                        .then(({ error: updateError }) => {
                            if (updateError) {
                                console.error('Error updating butane:', updateError);
                                return;
                            }
                            
                            // Save transaction
                            supabaseClient
                                .from('wm_inventory_transactions')
                                .insert({
                                    supply_type: 'butane',
                                    transaction_type: 'edit',
                                    amount: setAmount - currentButane,
                                    previous_level: currentButane,
                                    new_level: setAmount,
                                    notes: `Manual adjustment: ${notes}`,
                                    timestamp: new Date().toISOString(),
                                    user_name: currentRole ? currentRole.name : 'Unknown'
                                })
                                .then(() => {
                                    // Update all displays
                                    if (document.getElementById('modalButaneDisplay')) {
                                        document.getElementById('modalButaneDisplay').textContent = `${setAmount.toFixed(1)} lbs`;
                                    }
                                    updateSuppliesButton();
                                    closeEditButaneModal();
                                    
                                    alert(` Butane Updated!\n\nManually set to ${setAmount.toFixed(1)} lbs (was ${currentButane.toFixed(1)} lbs)\n\nReason: ${notes}`);
                                });
                        });
                });
        }
        
        // Nitrogen Modals
        function openAddNitrogenModal() {
            document.getElementById('nitrogenShipmentAmount').value = '';
            document.getElementById('nitrogenShipmentNotes').value = '';
            document.getElementById('addNitrogenModal').style.display = 'block';
        }
        
        function closeAddNitrogenModal() {
            document.getElementById('addNitrogenModal').style.display = 'none';
        }
        
        function addNitrogenShipment() {
            const addAmount = parseFloat(document.getElementById('nitrogenShipmentAmount').value);
            const notes = document.getElementById('nitrogenShipmentNotes').value;
            
            if (!addAmount || addAmount <= 0) {
                alert('Please enter a valid amount');
                return;
            }
            
            supabaseClient
                .from('wm_inventory')
                .select('*')
                .eq('supply_type', 'nitrogen')
                .single()
                .then(({ data: nitrogenRecord, error }) => {
                    if (error) {
                        console.error('Error loading nitrogen inventory:', error);
                        return;
                    }
                    
                    const currentNitrogen = parseFloat(nitrogenRecord.current_level) || 0;
                    const newNitrogen = currentNitrogen + addAmount;
                    
                    // Update inventory in Supabase
                    supabaseClient
                        .from('wm_inventory')
                        .update({
                            current_level: newNitrogen,
                            last_updated: new Date().toISOString(),
                            updated_by: currentRole ? currentRole.name : 'Unknown'
                        })
                        .eq('supply_type', 'nitrogen')
                        .then(({ error: updateError }) => {
                            if (updateError) {
                                console.error('Error updating nitrogen:', updateError);
                                return;
                            }
                            
                            // Save transaction
                            supabaseClient
                                .from('wm_inventory_transactions')
                                .insert({
                                    supply_type: 'nitrogen',
                                    transaction_type: 'add',
                                    amount: addAmount,
                                    previous_level: currentNitrogen,
                                    new_level: newNitrogen,
                                    notes: notes || `Added ${addAmount.toFixed(1)} tank(s)`,
                                    timestamp: new Date().toISOString(),
                                    user_name: currentRole ? currentRole.name : 'Unknown'
                                })
                                .then(() => {
                                    // Update all displays
                                    if (document.getElementById('modalNitrogenDisplay')) {
                                        document.getElementById('modalNitrogenDisplay').textContent = `${newNitrogen.toFixed(1)}`;
                                    }
                                    updateSuppliesButton();
                                    closeAddNitrogenModal();
                                    
                                    alert(` Tanks Added!\n\n${addAmount.toFixed(1)} nitrogen tank(s) added\nNew Total: ${newNitrogen.toFixed(1)} tanks`);
                                });
                        });
                });
        }
        
        function openEditNitrogenModal() {
            supabaseClient
                .from('wm_inventory')
                .select('*')
                .eq('supply_type', 'nitrogen')
                .single()
                .then(({ data: nitrogenRecord, error }) => {
                    if (error) {
                        console.error('Error loading nitrogen inventory:', error);
                        return;
                    }
                    
                    const currentNitrogen = parseFloat(nitrogenRecord.current_level) || 0;
                    document.getElementById('editNitrogenCurrentDisplay').textContent = `${currentNitrogen.toFixed(1)} tanks`;
                    document.getElementById('nitrogenSetAmount').value = '';
                    document.getElementById('nitrogenSetNotes').value = '';
                    document.getElementById('editNitrogenModal').style.display = 'block';
                });
        }
        
        function closeEditNitrogenModal() {
            document.getElementById('editNitrogenModal').style.display = 'none';
        }
        
        function setNitrogenAmount() {
            const setAmount = parseFloat(document.getElementById('nitrogenSetAmount').value);
            const notes = document.getElementById('nitrogenSetNotes').value;
            
            if (!setAmount && setAmount !== 0) {
                alert('Please enter a valid amount');
                return;
            }
            
            if (!notes.trim()) {
                alert('Please provide a reason for this manual change');
                return;
            }
            
            supabaseClient
                .from('wm_inventory')
                .select('*')
                .eq('supply_type', 'nitrogen')
                .single()
                .then(({ data: nitrogenRecord, error }) => {
                    if (error) {
                        console.error('Error loading nitrogen inventory:', error);
                        return;
                    }
                    
                    const currentNitrogen = parseFloat(nitrogenRecord.current_level) || 0;
                    
                    // Update inventory in Supabase
                    supabaseClient
                        .from('wm_inventory')
                        .update({
                            current_level: setAmount,
                            last_updated: new Date().toISOString(),
                            updated_by: currentRole ? currentRole.name : 'Unknown'
                        })
                        .eq('supply_type', 'nitrogen')
                        .then(({ error: updateError }) => {
                            if (updateError) {
                                console.error('Error updating nitrogen:', updateError);
                                return;
                            }
                            
                            // Save transaction
                            supabaseClient
                                .from('wm_inventory_transactions')
                                .insert({
                                    supply_type: 'nitrogen',
                                    transaction_type: 'edit',
                                    amount: setAmount - currentNitrogen,
                                    previous_level: currentNitrogen,
                                    new_level: setAmount,
                                    notes: `Manual adjustment: ${notes}`,
                                    timestamp: new Date().toISOString(),
                                    user_name: currentRole ? currentRole.name : 'Unknown'
                                })
                                .then(() => {
                                    // Update all displays
                                    if (document.getElementById('modalNitrogenDisplay')) {
                                        document.getElementById('modalNitrogenDisplay').textContent = `${setAmount.toFixed(1)}`;
                                    }
                                    updateSuppliesButton();
                                    closeEditNitrogenModal();
                                    
                                    alert(` Nitrogen Updated!\n\nManually set to ${setAmount.toFixed(1)} tanks (was ${currentNitrogen.toFixed(1)})\n\nReason: ${notes}`);
                                });
                        });
                });
        }
        
        // Company Production Summary (respects time range)
        function updateCompanyProductionSummary(timeRange = 30) {
            const now = new Date();
            const rangeStart = getPerformanceRangeStart(timeRange);
            
            // Display time range
            const periodEl = document.getElementById('companyPeriodRange');
            if (periodEl) {
                const startStr = rangeStart.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                const endStr = now.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
                periodEl.textContent = `${startStr} - ${endStr}`;
            }
            
            let trimExtracted = 0;
            let trimBatches = 0;
            let finishedWeight = 0;
            let finishedBatches = 0;
            let packaged = 0;
            let packagedWeight = 0;
            let labeled = 0;
            let labeledWeight = 0;
            
            batches.forEach(batch => {
                // Check extraction completed in range (from timeline)
                if (batch.timeline && batch.timeline.length > 0) {
                    const extractionEvent = batch.timeline.find(event => {
                        if (event.status === 'extraction' && event.timestamp) {
                            const eventDate = new Date(event.timestamp);
                            return eventDate >= rangeStart && eventDate <= now;
                        }
                        return false;
                    });
                    
                    if (extractionEvent) {
                        trimExtracted += parseFloat(batch.trim_weight) || 0;
                        trimBatches++;
                    }
                }
                
                // Check finishing completed in range
                if (batch.finishing_date) {
                    const finishingDate = new Date(batch.finishing_date);
                    if (finishingDate >= rangeStart && finishingDate <= now) {
                        finishedWeight += parseFloat(batch.final_weight) || parseFloat(batch.net_weight) || 0;
                        finishedBatches++;
                    }
                }
                
                // Check packaging done in range
                if (batch.packaging_date) {
                    const packagingDate = new Date(batch.packaging_date);
                    if (packagingDate >= rangeStart && packagingDate <= now && batch.units_packaged) {
                        packaged += parseInt(batch.units_packaged) || 0;
                        packagedWeight += parseFloat(batch.net_weight) || 0;
                    }
                }
                
                // Check labeling done in range (from timeline)
                if (batch.timeline && batch.timeline.length > 0) {
                    const labelingEvent = batch.timeline.find(event => {
                        if ((event.stage === 'labeling' || event.status === 'complete') && event.timestamp) {
                            const eventDate = new Date(event.timestamp);
                            if (eventDate >= rangeStart && eventDate <= now) {
                                const action = (event.action || event.note || '').toLowerCase();
                                return action.includes('label') || action.includes('complet');
                            }
                        }
                        return false;
                    });
                    
                    if (labelingEvent && batch.units_packaged) {
                        labeled += parseInt(batch.units_packaged) || 0;
                        labeledWeight += parseFloat(batch.grams_labeled) || 0;
                    }
                }
            });
            
            // Update displays
            document.getElementById('companyTrimExtracted').textContent = `${trimExtracted.toLocaleString()}g`;
            document.getElementById('companyTrimBatches').textContent = `${trimBatches} batch${trimBatches !== 1 ? 'es' : ''}`;
            
            document.getElementById('companyFinished').textContent = `${finishedWeight.toLocaleString()}g`;
            document.getElementById('companyFinishedBatches').textContent = `${finishedBatches} batch${finishedBatches !== 1 ? 'es' : ''}`;
            
            document.getElementById('companyPackaged').textContent = packaged.toLocaleString();
            document.getElementById('companyPackagedWeight').textContent = `${packagedWeight.toLocaleString()}g total`;
            
            document.getElementById('companyLabeled').textContent = labeled.toLocaleString();
            document.getElementById('companyLabeledWeight').textContent = `${labeledWeight.toLocaleString()}g total`;
        }
        
        // Today's Production Summary
        function updateTodayProduction() {
            // Use local Colorado time instead of UTC
            const now = new Date();
            const localDate = new Date(now.getTime() - (now.getTimezoneOffset() * 60000));
            const today = localDate.toISOString().split('T')[0]; // YYYY-MM-DD format in local time
            
            // Display today's date
            const dateEl = document.getElementById('todayDate');
            if (dateEl) {
                dateEl.textContent = new Date().toLocaleDateString('en-US', { 
                    weekday: 'long', 
                    month: 'long', 
                    day: 'numeric' 
                });
            }
            
            let trimExtracted = 0;
            let trimBatches = 0;
            let finishedWeight = 0;
            let finishedBatches = 0;
            let packaged = 0;
            let packagedWeight = 0;
            let labeled = 0;
            let labeledWeight = 0;
            
            batches.forEach(batch => {
                // Check extraction completed today (from timeline)
                if (batch.timeline && batch.timeline.length > 0) {
                    const extractionEvent = batch.timeline.find(event => {
                        if (event.status === 'extraction' && event.timestamp) {
                            const eventTime = new Date(event.timestamp);
                            const localEventDate = new Date(eventTime.getTime() - (eventTime.getTimezoneOffset() * 60000));
                            const eventDate = localEventDate.toISOString().split('T')[0];
                            return eventDate === today;
                        }
                        return false;
                    });
                    
                    if (extractionEvent) {
                        trimExtracted += parseFloat(batch.trim_weight) || 0;
                        trimBatches++;
                    }
                }
                
                // Check finishing completed today
                if (batch.finishing_date) {
                    const finishTime = new Date(batch.finishing_date);
                    const localFinishDate = new Date(finishTime.getTime() - (finishTime.getTimezoneOffset() * 60000));
                    const finishingDate = localFinishDate.toISOString().split('T')[0];
                    if (finishingDate === today) {
                        finishedWeight += parseFloat(batch.final_weight) || parseFloat(batch.net_weight) || 0;
                        finishedBatches++;
                    }
                }
                
                // Check packaging done today
                if (batch.packaging_date) {
                    const packTime = new Date(batch.packaging_date);
                    const localPackDate = new Date(packTime.getTime() - (packTime.getTimezoneOffset() * 60000));
                    const packagingDate = localPackDate.toISOString().split('T')[0];
                    if (packagingDate === today && batch.units_packaged) {
                        packaged += parseInt(batch.units_packaged) || 0;
                        packagedWeight += parseFloat(batch.net_weight) || 0;
                    }
                }
                
                // Check labeling done today (from timeline)
                if (batch.timeline && batch.timeline.length > 0) {
                    const labelingEvent = batch.timeline.find(event => {
                        if ((event.stage === 'labeling' || event.status === 'complete') && event.timestamp) {
                            const eventTime = new Date(event.timestamp);
                            const localEventDate = new Date(eventTime.getTime() - (eventTime.getTimezoneOffset() * 60000));
                            const eventDate = localEventDate.toISOString().split('T')[0];
                            if (eventDate === today) {
                                const action = (event.action || event.note || '').toLowerCase();
                                return action.includes('label') || action.includes('complet');
                            }
                        }
                        return false;
                    });
                    
                    if (labelingEvent && batch.units_packaged) {
                        labeled += parseInt(batch.units_packaged) || 0;
                        labeledWeight += parseFloat(batch.grams_labeled) || 0;
                    }
                }
            });
            
            // Update displays
            document.getElementById('todayTrimExtracted').textContent = `${trimExtracted.toFixed(0)}g`;
            document.getElementById('todayTrimBatches').textContent = `${trimBatches} batch${trimBatches !== 1 ? 'es' : ''}`;
            
            document.getElementById('todayFinished').textContent = `${finishedWeight.toFixed(0)}g`;
            document.getElementById('todayFinishedBatches').textContent = `${finishedBatches} batch${finishedBatches !== 1 ? 'es' : ''}`;
            
            document.getElementById('todayPackaged').textContent = packaged.toLocaleString();
            document.getElementById('todayPackagedWeight').textContent = `${packagedWeight.toFixed(0)}g total`;
            
            document.getElementById('todayLabeled').textContent = labeled.toLocaleString();
            document.getElementById('todayLabeledWeight').textContent = `${labeledWeight.toFixed(0)}g total`;
        }
        
        // Login Activity Tracker
        function updateLoginTracker() {
            const now = new Date();
            const twentyFourHoursAgo = new Date(now.getTime() - (24 * 60 * 60 * 1000));
            const thirtyMinutesAgo = new Date(now.getTime() - (30 * 60 * 1000));
            
            // Get recent logins (last 24 hours)
            supabaseClient
                .from('wm_login_history')
                .select('*')
                .gte('login_time', twentyFourHoursAgo.toISOString())
                .order('login_time', { ascending: false })
                .limit(10)
                .then(({ data: logins, error }) => {
                    if (error) {
                        console.error('Error loading login history:', error);
                        return;
                    }
                    
                    // Find currently active users (logged in within 30 min and no logout)
                    const activeUsers = logins.filter(login => {
                        const loginTime = new Date(login.login_time);
                        return loginTime >= thirtyMinutesAgo && !login.logout_time;
                    });
                    
                    // Display active users
                    const activeUsersEl = document.getElementById('activeUsers');
                    if (activeUsers.length === 0) {
                        activeUsersEl.innerHTML = '<div style="color: var(--text-secondary); font-style: italic;">No active users</div>';
                    } else {
                        const uniqueUsers = [...new Set(activeUsers.map(u => u.user_name))];
                        activeUsersEl.innerHTML = uniqueUsers.map(name => {
                            const userLogin = activeUsers.find(u => u.user_name === name);
                            const loginTime = new Date(userLogin.login_time);
                            const minutesAgo = Math.floor((now - loginTime) / 1000 / 60);
                            const timeText = minutesAgo < 1 ? 'just now' : `${minutesAgo}m ago`;
                            return `<div style="padding: 5px 0; border-bottom: 1px solid var(--border);">
                                <strong>${name}</strong> <span style="color: var(--text-secondary); font-size: 0.85rem;">(${timeText})</span>
                            </div>`;
                        }).join('');
                    }
                    
                    // Display recent logins
                    const recentLoginsEl = document.getElementById('recentLogins');
                    if (logins.length === 0) {
                        recentLoginsEl.innerHTML = '<div style="color: var(--text-secondary); font-style: italic;">No recent logins</div>';
                    } else {
                        recentLoginsEl.innerHTML = logins.map(login => {
                            const loginTime = new Date(login.login_time);
                            const timeStr = loginTime.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });
                            const dateStr = loginTime.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                            
                            let sessionInfo = '';
                            if (login.logout_time) {
                                const duration = login.session_duration;
                                const hours = Math.floor(duration / 60);
                                const mins = duration % 60;
                                const durationStr = hours > 0 ? `${hours}h ${mins}m` : `${mins}m`;
                                sessionInfo = `<span style="color: var(--text-secondary);">(${durationStr})</span>`;
                            } else {
                                sessionInfo = '<span style="color: var(--accent-green);"></span>';
                            }
                            
                            return `<div style="padding: 5px 0; border-bottom: 1px solid var(--border); display: flex; justify-content: space-between;">
                                <div><strong>${login.user_name}</strong></div>
                                <div style="color: var(--text-secondary); font-size: 0.85rem;">${dateStr} ${timeStr} ${sessionInfo}</div>
                                <div style="color: var(--text-tertiary); font-size: 0.75rem;">${login.ip_address || ''}</div>
                            </div>`;
                        }).join('');
                    }
                });
        }
        
        // Login History Modal functions
        function openLoginHistoryModal() {
            document.getElementById('loginHistoryModal').style.display = 'block';
            loadLoginHistory();
        }

        function closeLoginHistoryModal() {
            document.getElementById('loginHistoryModal').style.display = 'none';
        }

        // LeafLink Approvals Modal functions
        function openLeafLinkApprovalsModal() {
            document.getElementById('leaflinkApprovalsModal').style.display = 'block';
            renderLeafLinkApprovalQueue();
        }

        function closeLeafLinkApprovalsModal() {
            document.getElementById('leaflinkApprovalsModal').style.display = 'none';
        }

        // Print Labels Modal functions
        function openPrintLabelsModal() {
            document.getElementById('printLabelsModal').style.display = 'block';
            populatePrintLabelsBatchSelect();
        }

        function closePrintLabelsModal() {
            document.getElementById('printLabelsModal').style.display = 'none';
        }

        function populatePrintLabelsBatchSelect() {
            const select = document.getElementById('printLabelsBatchSelect');
            select.innerHTML = '<option value="">Select a batch...</option>';

            // Filter out labeled batches (finished through labeling) and sort by intake_date descending
            const activeBatches = batches.filter(b => !b.labels_applied);
            const sortedBatches = [...activeBatches].sort((a, b) => {
                const dateA = new Date(a.intake_date || 0);
                const dateB = new Date(b.intake_date || 0);
                return dateB - dateA;
            });

            sortedBatches.forEach(batch => {
                const option = document.createElement('option');
                option.value = batch.id;
                option.textContent = `${batch.id} - ${batch.strain || 'Unknown'} (${batch.status})`;
                select.appendChild(option);
            });

            // Add change listener to show batch info
            select.onchange = function() {
                const batchId = this.value;
                const infoDiv = document.getElementById('printLabelsBatchInfo');
                if (batchId) {
                    const batch = batches.find(b => b.id === batchId);
                    if (batch) {
                        infoDiv.style.display = 'block';
                        infoDiv.innerHTML = `
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                                <div><strong style="color: var(--text-secondary);">Strain:</strong> ${batch.strain || 'N/A'}</div>
                                <div><strong style="color: var(--text-secondary);">Type:</strong> ${batch.strain_type || 'N/A'}</div>
                                <div><strong style="color: var(--text-secondary);">Trim:</strong> ${batch.trim_weight || 0}g</div>
                                <div><strong style="color: var(--text-secondary);">Final:</strong> ${batch.final_weight || batch.net_weight || 'N/A'}g</div>
                            </div>
                        `;
                    }
                } else {
                    infoDiv.style.display = 'none';
                }
            };
        }

        async function printFromActionsModal() {
            const batchId = document.getElementById('printLabelsBatchSelect').value;
            if (!batchId) {
                alert('Please select a batch first!');
                return;
            }

            const batch = batches.find(b => b.id === batchId);
            if (!batch) {
                alert('Batch not found!');
                return;
            }

            const labelType = document.getElementById('printLabelsLabelType').value;

            if (labelType === 'intake') {
                const zpl = generateIntakeBatchLabelZPL(batch);
                const result = await sendZPLToPrinter(zpl, `intake-${batch.id}.zpl`);
                if (result.success) alert(` Intake label sent to printer!`);
            } else if (labelType === 'postprod') {
                const finalWeight = parseFloat(batch.final_weight) || parseFloat(batch.net_weight) || 0;
                const sampleWeight = parseFloat(batch.sample_weight) || 0;
                const totalBowls = batch.extraction_bowls || 1;
                let successCount = 0;

                for (let bowlNum = 1; bowlNum <= totalBowls; bowlNum++) {
                    const zpl = generatePostProductionLabelZPL(batch, finalWeight, sampleWeight, bowlNum, totalBowls);
                    const result = await sendZPLToPrinter(zpl, `postprod-${batch.id}-bowl${bowlNum}.zpl`);
                    if (result.success) successCount++;
                }
                if (successCount > 0) alert(` ${successCount} post-production label(s) sent to printer!`);
            } else if (labelType === 'labeling') {
                const labeledBy = currentRole ? currentRole.name : 'Unknown';
                const units1g = batch.units_1g || 0;
                const units4g = batch.units_4g || 0;
                let labelsPrinted = 0;

                if (units1g > 0) {
                    const zpl1g = generateLabelingCompletionZPL(batch, labeledBy, 1);
                    const result = await sendZPLToPrinter(zpl1g, `labeling-${batch.id}-1g.zpl`);
                    if (result.success) labelsPrinted++;
                }

                if (units4g > 0) {
                    const zpl4g = generateLabelingCompletionZPL(batch, labeledBy, 4);
                    const result = await sendZPLToPrinter(zpl4g, `labeling-${batch.id}-4g.zpl`);
                    if (result.success) labelsPrinted++;
                }
                if (labelsPrinted > 0) alert(` ${labelsPrinted} labeling label(s) sent to printer!`);
            }
        }

        async function loadLoginHistory() {
            const contentEl = document.getElementById('loginHistoryContent');
            contentEl.innerHTML = 'Loading...';

            try {
                const sevenDaysAgo = new Date();
                sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);

                const { data: logins, error } = await supabaseClient
                    .from('wm_login_history')
                    .select('*')
                    .gte('login_time', sevenDaysAgo.toISOString())
                    .order('login_time', { ascending: false })
                    .limit(50);

                if (error) throw error;

                if (!logins || logins.length === 0) {
                    contentEl.innerHTML = '<div style="text-align: center; color: var(--text-secondary); padding: 40px;">No login records found</div>';
                    return;
                }

                contentEl.innerHTML = `
                    <table style="width: 100%; border-collapse: collapse;">
                        <thead>
                            <tr style="background: var(--bg-tertiary);">
                                <th style="padding: 12px; text-align: left; border-bottom: 2px solid var(--border);">User</th>
                                <th style="padding: 12px; text-align: left; border-bottom: 2px solid var(--border);">Login Time</th>
                                <th style="padding: 12px; text-align: left; border-bottom: 2px solid var(--border);">IP Address</th>
                                <th style="padding: 12px; text-align: left; border-bottom: 2px solid var(--border);">Session</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${logins.map(login => {
                                const loginTime = new Date(login.login_time);
                                const dateStr = loginTime.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                                const timeStr = loginTime.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });

                                let sessionInfo = '';
                                if (login.logout_time) {
                                    // Logged out - show session duration
                                    const duration = login.session_duration || 0;
                                    const hours = Math.floor(duration / 60);
                                    const mins = duration % 60;
                                    sessionInfo = hours > 0 ? `${hours}h ${mins}m` : `${mins}m`;
                                } else if (login.last_activity) {
                                    // Check how recent the activity was
                                    const lastActive = new Date(login.last_activity);
                                    const minutesAgo = Math.floor((Date.now() - lastActive.getTime()) / 60000);

                                    if (minutesAgo < 2) {
                                        sessionInfo = '<span style="color: var(--accent-green);"> Active Now</span>';
                                    } else if (minutesAgo < 60) {
                                        sessionInfo = `<span style="color: var(--accent-orange);"> Idle ${minutesAgo}m</span>`;
                                    } else {
                                        const hoursAgo = Math.floor(minutesAgo / 60);
                                        sessionInfo = `<span style="color: var(--text-secondary);"> Idle ${hoursAgo}h</span>`;
                                    }
                                } else {
                                    // No activity data yet - show as potentially idle
                                    const loginTime = new Date(login.login_time);
                                    const minutesSinceLogin = Math.floor((Date.now() - loginTime.getTime()) / 60000);
                                    if (minutesSinceLogin < 5) {
                                        sessionInfo = '<span style="color: var(--accent-green);"> Just logged in</span>';
                                    } else {
                                        sessionInfo = '<span style="color: var(--text-secondary);"> Unknown</span>';
                                    }
                                }

                                return `
                                    <tr style="border-bottom: 1px solid var(--border);">
                                        <td style="padding: 12px;"><strong>${login.user_name}</strong></td>
                                        <td style="padding: 12px;">${dateStr} ${timeStr}</td>
                                        <td style="padding: 12px; font-family: monospace; font-size: 0.9rem;">${login.ip_address || '-'}</td>
                                        <td style="padding: 12px;">${sessionInfo}</td>
                                    </tr>
                                `;
                            }).join('')}
                        </tbody>
                    </table>
                `;
            } catch (err) {
                console.error('Error loading login history:', err);
                contentEl.innerHTML = '<div style="color: var(--accent-red); text-align: center; padding: 40px;">Error loading login history</div>';
            }
        }

        // Update button display on extraction page
        function updateSuppliesButton() {
            supabaseClient
                .from('wm_inventory')
                .select('*')
                .then(({ data: inventory, error }) => {
                    if (error) {
                        console.error('Error loading inventory:', error);
                        return;
                    }
                    
                    const butane = inventory.find(i => i.supply_type === 'butane');
                    const nitrogen = inventory.find(i => i.supply_type === 'nitrogen');
                    
                    const btnButane = document.getElementById('btnButaneDisplay');
                    const btnNitrogen = document.getElementById('btnNitrogenDisplay');
                    
                    if (btnButane && butane) {
                        btnButane.textContent = `${parseFloat(butane.current_level).toFixed(1)} lbs`;
                    }
                    
                    if (btnNitrogen && nitrogen) {
                        btnNitrogen.textContent = `${parseFloat(nitrogen.current_level).toFixed(1)} tanks`;
                    }
                });
        }
        
        // Helper function to save transactions
        function saveTransaction(type, action, previousAmount, newAmount, withdraw, add, notes) {
            const transactionKey = type === 'butane' ? 'wm_gas_transactions' : 'wm_nitrogen_transactions';
            const transactions = JSON.parse(localStorage.getItem(transactionKey) || '[]');
            
            transactions.push({
                timestamp: new Date().toISOString(),
                user: currentRole ? currentRole.name : 'Unknown',
                action: action,
                previousAmount: previousAmount,
                newAmount: newAmount,
                withdraw: withdraw,
                add: add,
                notes: notes
            });
            
            localStorage.setItem(transactionKey, JSON.stringify(transactions));
        }
        
        
        // Old functions - redirect to new ones
        function openGasModal() {
            // No longer used - interface is now inline
        }
        
        function closeGasModal() {
            // No longer used
        }
        
        // Inventory Management Functions (Redirect to gas modal)
        function openInventoryModal() {
            openGasModal();
        }
        
        function closeInventoryModal() {
            document.getElementById('inventoryModal').style.display = 'none';
        }
        
        function displayPersonalRecords(userName) {
            // Find best days
            const dailyStats = {};
            
            batches.forEach(batch => {
                // PACKAGING: Use packaging_user and packaging_date
                if (batch.packaging_user === userName && batch.packaging_date && batch.units_packaged) {
                    const date = batch.packaging_date;
                    if (!dailyStats[date]) {
                        dailyStats[date] = { packaged: 0, labeled: 0, extracted: 0 };
                    }
                    dailyStats[date].packaged += parseInt(batch.units_packaged) || 0;
                }
                
                // EXTRACTION: Use extraction_user and look for extraction timeline entry
                if (batch.extraction_user === userName && batch.trim_weight && batch.timeline) {
                    const extractionEvent = batch.timeline.find(e => 
                        e.stage === 'extraction' && e.user === userName
                    );
                    if (extractionEvent) {
                        const eventDate = new Date(extractionEvent.timestamp || extractionEvent.date);
                        const date = eventDate.toISOString().split('T')[0];
                        if (!dailyStats[date]) {
                            dailyStats[date] = { packaged: 0, labeled: 0, extracted: 0 };
                        }
                        dailyStats[date].extracted += parseFloat(batch.trim_weight) || 0;
                    }
                }
                
                // LABELING: Check timeline
                (batch.timeline || []).forEach(entry => {
                    if (!entry.date && !entry.timestamp) return;
                    if (!entry.user || entry.user !== userName) return;
                    if (!entry.action) return;
                    
                    const eventDate = new Date(entry.timestamp || entry.date);
                    const date = eventDate.toISOString().split('T')[0];
                    
                    if (!dailyStats[date]) {
                        dailyStats[date] = { packaged: 0, labeled: 0, extracted: 0 };
                    }
                    
                    const actionLower = entry.action.toLowerCase();
                    
                    if (entry.stage === 'labeling' && (actionLower.includes('labeled') || actionLower.includes('completed'))) {
                        dailyStats[date].labeled += parseInt(batch.units_packaged) || 0;
                    }
                });
            });
            
            // Find best records
            let bestPackaging = { date: '', units: 0 };
            let bestLabeling = { date: '', units: 0 };
            let bestExtraction = { date: '', grams: 0 };
            
            Object.entries(dailyStats).forEach(([date, stats]) => {
                if (stats.packaged > bestPackaging.units) {
                    bestPackaging = { date, units: stats.packaged };
                }
                if (stats.labeled > bestLabeling.units) {
                    bestLabeling = { date, units: stats.labeled };
                }
                if (stats.extracted > bestExtraction.grams) {
                    bestExtraction = { date, grams: stats.extracted };
                }
            });
            
            // Convert extraction grams to pounds if appropriate
            const extractedDisplay = bestExtraction.grams >= 454 
                ? `${(bestExtraction.grams / 453.592).toFixed(1)} lbs`
                : `${bestExtraction.grams.toFixed(0)}g`;
            
            const content = `
                ${bestPackaging.units > 0 ? `
                <div class="record-box">
                    <div style="font-size: 1.8rem; font-weight: 700; color: var(--accent-green); margin-bottom: 5px;">
                        ${bestPackaging.units} units
                    </div>
                    <div style="color: var(--text-secondary); font-size: 0.9rem;">
                         Best Packaging Day
                    </div>
                    <div style="color: var(--text-secondary); font-size: 0.85rem; margin-top: 5px;">
                        ${new Date(bestPackaging.date).toLocaleDateString()}
                    </div>
                </div>
                ` : ''}
                
                ${bestLabeling.units > 0 ? `
                <div class="record-box" style="border-left-color: var(--accent-blue);">
                    <div style="font-size: 1.8rem; font-weight: 700; color: var(--accent-blue); margin-bottom: 5px;">
                        ${bestLabeling.units} units
                    </div>
                    <div style="color: var(--text-secondary); font-size: 0.9rem;">
                         Best Labeling Day
                    </div>
                    <div style="color: var(--text-secondary); font-size: 0.85rem; margin-top: 5px;">
                        ${new Date(bestLabeling.date).toLocaleDateString()}
                    </div>
                </div>
                ` : ''}
                
                ${bestExtraction.grams > 0 ? `
                <div class="record-box" style="border-left-color: var(--accent-purple);">
                    <div style="font-size: 1.8rem; font-weight: 700; color: var(--accent-purple); margin-bottom: 5px;">
                        ${extractedDisplay}
                    </div>
                    <div style="color: var(--text-secondary); font-size: 0.9rem;">
                         Best Extraction Day
                    </div>
                    <div style="color: var(--text-secondary); font-size: 0.85rem; margin-top: 5px;">
                        ${new Date(bestExtraction.date).toLocaleDateString()}
                    </div>
                </div>
                ` : ''}
            `;
            
            document.getElementById('personalRecordsContent').innerHTML = content || '<p style="text-align: center; color: var(--text-secondary);">No records yet - start tracking your work!</p>';
        }

        // Feature #2: Personal Dashboard Quick Stats
        // Feature #2: Personal Dashboard Quick Stats (Workload Summary)
        function updatePersonalWorkloadStats() {
            const statsGrid = document.getElementById('personalStatsGrid');
            const statsTitle = document.getElementById('personalStatsTitle');
            
            if (!currentRole) {
                statsGrid.innerHTML = '<p style="color: var(--text-secondary); grid-column: 1/-1;">Login to see your personal workload</p>';
                statsTitle.textContent = 'Your Workload';
                return;
            }
            
            statsTitle.textContent = `${currentRole.name}'s Workload`;
            
            // Count batches at each stage
            const waitingExtraction = batches.filter(b => b.status === 'intake' && !(b.socks_total != null && b.socks_remaining === 0)).length;
            const waitingFinishing = batches.filter(b => b.status === 'extraction').length;
            const waitingPackaging = batches.filter(b => b.status === 'finishing').length;
            const waitingTesting = batches.filter(b => b.status === 'packaging' || (b.status === 'complete' && !b.test_thc_percent)).length;
            const waitingLabeling = batches.filter(b => b.status === 'complete' && b.test_thc_percent && !b.labels_applied).length;
            const paused = batches.filter(b => b.extraction_paused || b.packaging_paused || b.labeling_paused).length;
            
            const stats = [
                { label: 'Waiting Extraction', count: waitingExtraction, icon: '', color: 'var(--accent-orange)' },
                { label: 'Waiting Post-Extraction', count: waitingFinishing, icon: '', color: 'var(--accent-purple)' },
                { label: 'Waiting Packaging', count: waitingPackaging, icon: '', color: 'var(--accent-blue)' },
                { label: 'Waiting Testing', count: waitingTesting, icon: '', color: 'var(--accent-green)' },
                { label: 'Ready to Label', count: waitingLabeling, icon: '', color: 'var(--accent-purple)' },
                { label: 'Paused (Need Attention)', count: paused, icon: '', color: '#ff9800' }
            ];
            
            statsGrid.innerHTML = stats.map(s => `
                <div style="background: var(--bg-tertiary); padding: 15px; border-radius: 8px; border-left: 4px solid ${s.color};">
                    <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 5px;">${s.icon} ${s.label}</div>
                    <div style="font-size: 2rem; font-weight: 700; color: ${s.count > 0 ? s.color : 'var(--text-secondary)'};">${s.count}</div>
                </div>
            `).join('');
        }

        // Feature #1: Enhanced Batch Search with Filtering
        function addDropdownSearchFilters() {
            // Add search to extraction dropdown
            addSearchToDropdown('extractionBatchSelect', 'extraction');
            // Add search to packaging dropdown
            addSearchToDropdown('packagingBatchSelect', 'packaging');
            // Add search to finishing dropdown
            addSearchToDropdown('finishingBatchSelect', 'finishing');
            // Add search to labeling dropdown
            addSearchToDropdown('labelingBatchSelect', 'labeling');
            // Add search to testing dropdown
            addSearchToDropdown('testingBatchSelect', 'testing');
            // Add search to print labels dropdown
            addSearchToDropdown('printLabelsBatchSelect', 'print');
        }

        function addSearchToDropdown(selectId, stage) {
            const select = document.getElementById(selectId);
            if (!select) return;
            
            // Create search input
            const searchWrapper = document.createElement('div');
            searchWrapper.style.cssText = 'position: relative; margin-bottom: 10px;';
            
            const searchInput = document.createElement('input');
            searchInput.type = 'text';
            searchInput.placeholder = ' Search batch ID or strain...';
            searchInput.style.cssText = 'width: 100%; padding: 10px; background: var(--bg-secondary); border: 2px solid var(--border); border-radius: 8px; color: var(--text-primary); font-size: 0.95rem;';
            
            // Insert before dropdown
            select.parentNode.insertBefore(searchWrapper, select);
            searchWrapper.appendChild(searchInput);
            
            // Filter dropdown on search
            searchInput.addEventListener('input', function() {
                const searchTerm = this.value.toLowerCase();
                const options = select.querySelectorAll('option');
                
                options.forEach(opt => {
                    if (opt.value === '') {
                        opt.style.display = '';
                        return;
                    }
                    
                    const text = opt.textContent.toLowerCase();
                    opt.style.display = text.includes(searchTerm) ? '' : 'none';
                });
            });
        }

        // Feature #3: Batch Timeline Visual Progress Viewer
        function showBatchTimeline(batchId) {
            const batch = batches.find(b => b.id === batchId);
            if (!batch) return;
            
            const stages = [
                { name: 'Intake', status: 'intake', icon: '', completed: batch.intake_date },
                { name: 'Extraction', status: 'extraction', icon: '', completed: batch.extraction_user, paused: batch.extraction_paused },
                { name: 'Post-Extraction', status: 'finishing', icon: '', completed: batch.finishing_user },
                { name: 'Packaging', status: 'packaging', icon: '', completed: batch.packaging_user, paused: batch.packaging_paused },
                { name: 'Testing', status: 'testing', icon: '', completed: batch.test_thc_percent },
                { name: 'Labeling', status: 'complete', icon: '', completed: batch.labels_applied, paused: batch.labeling_paused }
            ];
            
            let currentStageIndex = stages.findIndex(s => s.status === batch.status);
            if (currentStageIndex === -1) currentStageIndex = stages.length - 1;
            
            return stages.map((stage, index) => {
                let statusIcon, statusColor, statusText;
                
                if (index < currentStageIndex) {
                    statusIcon = '';
                    statusColor = 'var(--accent-green)';
                    statusText = 'Complete';
                } else if (index === currentStageIndex) {
                    if (stage.paused) {
                        statusIcon = '';
                        statusColor = '#ff9800';
                        statusText = 'Paused';
                    } else {
                        statusIcon = '';
                        statusColor = 'var(--accent-blue)';
                        statusText = 'In Progress';
                    }
                } else {
                    statusIcon = '';
                    statusColor = 'var(--text-secondary)';
                    statusText = 'Waiting';
                }
                
                return `
                    <div style="display: flex; align-items: center; gap: 10px; padding: 8px; background: ${index === currentStageIndex ? 'rgba(59, 130, 246, 0.1)' : 'transparent'}; border-radius: 6px;">
                        <div style="font-size: 1.5rem;">${stage.icon}</div>
                        <div style="flex: 1;">
                            <div style="font-weight: 600;">${stage.name}</div>
                            <div style="font-size: 0.85rem; color: ${statusColor};">${statusIcon} ${statusText}</div>
                        </div>
                    </div>
                `;
            }).join('<div style="width: 2px; height: 15px; background: var(--border); margin-left: 23px;"></div>');
        }

        // Feature #4: Auto-Calculate Yield Percentage with Alerts
        function calculateYield(batch) {
            if (!batch.trim_weight) return null;
            
            // Prioritize grams_labeled (actual sellable weight after labeling) over final_weight (post-extraction)
            const finalWeight = batch.grams_labeled ? parseFloat(batch.grams_labeled) : 
                                batch.final_weight ? parseFloat(batch.final_weight) : null;
            
            if (!finalWeight) return null;
            
            const trimWeight = parseFloat(batch.trim_weight);
            
            if (trimWeight === 0) return null;
            
            const yieldPercent = (finalWeight / trimWeight) * 100;
            const expectedYield = batch.expected_yield || getExpectedYield(batch.material_type) || 13;
            const variance = yieldPercent - expectedYield;
            
            return {
                actual: yieldPercent,
                expected: expectedYield,
                variance: variance,
                status: variance < -3 ? 'low' : (variance > 3 ? 'high' : 'normal')
            };
        }

        function displayYieldAlert(batch, yieldData) {
            if (!yieldData) return '';
            
            let alertHTML = '';
            let statusIcon, statusColor, statusText;
            
            if (yieldData.status === 'low') {
                statusIcon = '';
                statusColor = '#f44336';
                statusText = 'Low Yield Alert';
            } else if (yieldData.status === 'high') {
                statusIcon = '';
                statusColor = 'var(--accent-green)';
                statusText = 'Excellent Yield';
            } else {
                statusIcon = '';
                statusColor = 'var(--accent-blue)';
                statusText = 'Normal Yield';
            }
            
            return `
                <div style="background: rgba(${statusColor === '#f44336' ? '244, 67, 54' : '59, 130, 246'}, 0.1); padding: 12px; border-radius: 8px; border-left: 4px solid ${statusColor}; margin-top: 10px;">
                    <div style="font-weight: 600; color: ${statusColor}; margin-bottom: 5px;">${statusIcon} ${statusText}</div>
                    <div style="font-size: 1.6rem; font-weight: 700; color: ${statusColor};">
                        ${yieldData.actual.toFixed(1)}% Yield
                    </div>
                </div>
            `;
        }

        // Feature #8: End-of-Day Report Generator
        function generateDailyReport() {
            const today = new Date().toISOString().split('T')[0];

            // Helper to get date from timeline entry (handles both 'date' and 'timestamp' fields)
            const getEntryDate = (t) => t.date || t.timestamp || '';

            // Filter batches with activity today
            const todaysBatches = batches.filter(b => {
                const timeline = b.timeline || [];
                return timeline.some(t => getEntryDate(t).startsWith(today));
            });

            // Count by stage
            const extracted = todaysBatches.filter(b =>
                (b.timeline || []).some(t => t.stage === 'extraction' && getEntryDate(t).startsWith(today))
            ).length;

            const packaged = todaysBatches.filter(b =>
                (b.timeline || []).some(t => t.stage === 'packaging' && getEntryDate(t).startsWith(today) && (t.action || '').toLowerCase().includes('packaged'))
            ).length;

            const labeled = todaysBatches.filter(b =>
                (b.timeline || []).some(t => t.stage === 'labeling' && getEntryDate(t).startsWith(today))
            ).length;

            // Employee performance
            const employeeActivity = {};
            todaysBatches.forEach(b => {
                (b.timeline || []).forEach(t => {
                    const entryDate = getEntryDate(t);
                    if (!entryDate || !entryDate.startsWith(today)) return;
                    if (!t.user) return;
                    if (!employeeActivity[t.user]) {
                        employeeActivity[t.user] = { extracted: 0, packaged: 0, labeled: 0 };
                    }
                    if (t.stage === 'extraction') employeeActivity[t.user].extracted++;
                    if (t.stage === 'packaging' && (t.action || '').toLowerCase().includes('packaged')) employeeActivity[t.user].packaged++;
                    if (t.stage === 'labeling') employeeActivity[t.user].labeled++;
                });
            });

            return {
                date: today,
                batches: todaysBatches.length,
                extracted,
                packaged,
                labeled,
                employees: employeeActivity
            };
        }

        // Recalculate trim weight allocations for all existing sub-batches
        async function recalculateAllSubBatchYields() {
            if (!confirm('This will recalculate trim weight allocations for all sub-batches based on actual yields.\n\nThis affects yield calculations in the dashboard and analytics.\n\nContinue?')) {
                return;
            }
            
            // Find all parent batches that have been split
            const parentBatches = batches.filter(b => b.status === 'split');
            
            if (parentBatches.length === 0) {
                alert('No split batches found. Nothing to recalculate.');
                return;
            }
            
            let updatedCount = 0;
            let errorCount = 0;
            const updates = [];
            
            for (const parent of parentBatches) {
                // Find all sub-batches for this parent
                const subBatches = batches.filter(b => b.parent_batch_id === parent.id && b.is_sub_batch);
                
                if (subBatches.length === 0) continue;
                
                // Calculate total final weight across all sub-batches
                // Prioritize grams_labeled (actual sellable) over final_weight (post-extraction)
                const totalFinalWeight = subBatches.reduce((sum, sub) => {
                    const weight = sub.grams_labeled ? parseFloat(sub.grams_labeled) : parseFloat(sub.final_weight) || 0;
                    return sum + weight;
                }, 0);
                
                if (totalFinalWeight === 0) continue;
                
                // Calculate overall yield from parent trim to total sub-batch output
                const parentTrimWeight = parseFloat(parent.trim_weight) || 0;
                if (parentTrimWeight === 0) continue;
                
                const overallYieldPercent = (totalFinalWeight / parentTrimWeight) * 100;
                
                // Update each sub-batch with proportional trim weight
                for (const subBatch of subBatches) {
                    // Use grams_labeled if available, otherwise final_weight
                    const subFinalWeight = subBatch.grams_labeled ? parseFloat(subBatch.grams_labeled) : parseFloat(subBatch.final_weight) || 0;
                    if (subFinalWeight === 0) continue;
                    
                    // Back-calculate trim weight: if yield is 18% and final is 50g, trim = 50/0.18 = 277.8g
                    const newTrimWeight = overallYieldPercent > 0 
                        ? (subFinalWeight / overallYieldPercent) * 100
                        : 0;
                    
                    // Only update if different
                    if (Math.abs(newTrimWeight - (parseFloat(subBatch.trim_weight) || 0)) > 0.1) {
                        updates.push({
                            id: subBatch.id,
                            oldTrim: parseFloat(subBatch.trim_weight) || 0,
                            newTrim: newTrimWeight,
                            finalWeight: subFinalWeight,
                            yieldPercent: overallYieldPercent,
                            usedLabeledWeight: !!subBatch.grams_labeled
                        });
                        
                        // Update in database
                        const { error } = await supabaseClient
                            .from('wm_batches')
                            .update({
                                trim_weight: newTrimWeight,
                                intake_notes: (subBatch.intake_notes || '') + `\n[Yield recalculated: ${newTrimWeight.toFixed(1)}g trim for ${subFinalWeight.toFixed(1)}g ${subBatch.grams_labeled ? 'labeled' : 'bulk'} weight at ${overallYieldPercent.toFixed(2)}%]`
                            })
                            .eq('id', subBatch.id);
                        
                        if (error) {
                            console.error(`Error updating ${subBatch.id}:`, error);
                            errorCount++;
                        } else {
                            updatedCount++;
                        }
                    }
                }
            }
            
            if (updates.length === 0) {
                alert('All sub-batches already have correct trim allocations. Nothing to update.');
                return;
            }
            
            // Reload batches to reflect changes
            await loadBatches();
            
            // Show detailed report
            const reportDetails = updates.map(u => 
                `${u.id}: ${u.oldTrim.toFixed(1)}g  ${u.newTrim.toFixed(1)}g trim (${u.finalWeight.toFixed(1)}g @ ${u.yieldPercent.toFixed(2)}%)`
            ).join('\n');
            
            alert(` Sub-Batch Yield Recalculation Complete!\n\nUpdated: ${updatedCount} batches\nErrors: ${errorCount}\n\nDetails:\n${reportDetails.substring(0, 500)}${reportDetails.length > 500 ? '\n...(truncated)' : ''}`);
        }

        function showDailyReportPopup() {
            const report = generateDailyReport();
            
            let employeeReport = Object.entries(report.employees).map(([name, stats]) => 
                `${name}: ${stats.extracted} extracted, ${stats.packaged} packaged, ${stats.labeled} labeled`
            ).join('\n');
            
            alert(` Daily Production Report
            
Date: ${report.date}

Summary:
 ${report.batches} batches with activity today
 ${report.extracted} batches extracted
 ${report.packaged} batches packaged  
 ${report.labeled} batches labeled

Employee Activity:
${employeeReport || 'No activity recorded today'}
            `);
        }


        function renderBatches(filter = 'all', searchTerm = '') {
            const container = document.getElementById('batchesList');
            let filteredBatches = batches;
            
            if (filter !== 'all') {
                if (filter === 'extraction') {
                    // Show batches waiting for extraction (at intake status)
                    filteredBatches = batches.filter(b => b.status === 'intake');
                } else if (filter === 'finishing') {
                    // Show batches waiting for post-extraction (at extraction status)
                    filteredBatches = batches.filter(b => b.status === 'extraction');
                } else if (filter === 'packaging') {
                    // Show batches waiting for packaging (at finishing status)
                    filteredBatches = batches.filter(b => b.status === 'finishing');
                } else if (filter === 'testing') {
                    // Show batches waiting for testing (at packaging status or complete without test results)
                    filteredBatches = batches.filter(b => 
                        b.status === 'packaging' || 
                        (b.status === 'complete' && !b.test_thc_percent)
                    );
                } else if (filter === 'labeling') {
                    // Show batches waiting for labeling (complete with test results but not labeled)
                    filteredBatches = batches.filter(b => 
                        b.status === 'complete' && 
                        b.test_thc_percent && 
                        !b.labels_applied
                    );
                } else if (filter === 'complete') {
                    // Show fully completed batches
                    filteredBatches = batches.filter(b => 
                        b.status === 'complete' && 
                        b.labels_applied
                    );
                } else if (filter === 'intake') {
                    // Show just intake (newly created batches)
                    filteredBatches = batches.filter(b => b.status === 'intake');
                } else {
                    // Fallback to status filter
                    filteredBatches = batches.filter(b => b.status === filter);
                }
            }
            
            if (searchTerm) {
                filteredBatches = filteredBatches.filter(b => 
                    b.id.toLowerCase().includes(searchTerm.toLowerCase()) ||
                    b.strain.toLowerCase().includes(searchTerm.toLowerCase())
                );
            }
            
            container.innerHTML = filteredBatches.map(batch => `
                <div class="batch-item">
                    <div style="display: flex; align-items: center; gap: 12px; flex-wrap: wrap; padding: 5px 0;">
                        <div class="batch-id" style="font-weight: 700; min-width: 90px;">${batch.id}</div>
                        ${currentBusinessId === 'all' ? getBusinessBadge(batch.business_id) : ''}
                        <div class="batch-status status-${batch.status}" style="font-size: 0.7rem; padding: 2px 8px;">${batch.status.toUpperCase()}</div>
                        <div style="font-size: 1.2rem; font-weight: 700;">${batch.strain}</div>
                        <span style="color: var(--text-secondary); font-size: 0.85rem;">(${batch.strain_type})</span>
                        ${batch.final_weight ? `<div><strong>${batch.net_weight || batch.final_weight}g</strong></div>` : ''}
                        ${batch.final_weight && batch.trim_weight ? `<div style="font-weight: 700; color: ${((parseFloat(batch.final_weight) / parseFloat(batch.trim_weight)) * 100) < 15 ? '#f44336' : (((parseFloat(batch.final_weight) / parseFloat(batch.trim_weight)) * 100) > 21 ? 'var(--accent-green)' : 'var(--accent-blue)')};">${((parseFloat(batch.final_weight) / parseFloat(batch.trim_weight)) * 100).toFixed(1)}%</div>` : ''}
                        <div style="color: var(--text-secondary);">Trim: ${batch.trim_weight}g</div>
                        ${batch.grams_labeled ? `<div style="color: var(--text-secondary);">Lab: ${batch.grams_labeled}g</div>` : ''}
                        ${batch.is_sub_batch ? `<div style="color: var(--accent-purple); font-size: 0.8rem;">${batch.parent_batch_id}</div>` : ''}

                        <div style="margin-left: auto; display: flex; align-items: center; gap: 6px;">
                            <button class="btn" style="background: var(--accent-purple); padding: 8px 14px; font-size: 1rem;" onclick="event.stopPropagation(); openBatchPrintMenu('${batch.id}', event)"></button>
                            ${currentRole && currentRole.canEditBatches ? `
                                <button class="btn" style="background: var(--accent-orange); padding: 8px 14px; font-size: 1rem;" onclick="event.stopPropagation(); openEditBatch('${batch.id}')"></button>
                                ${batch.is_sub_batch ? `
                                    <button class="btn" style="background: var(--accent-red); padding: 8px 14px; font-size: 1rem;" onclick="event.stopPropagation(); deleteSubBatch('${batch.id}')"></button>
                                ` : `
                                    <button class="btn" style="background: var(--accent-green); padding: 8px 14px; font-size: 1rem;" onclick="event.stopPropagation(); openCreateSubBatch('${batch.id}')"></button>
                                    <button class="btn" style="background: #ef4444; padding: 8px 14px; font-size: 1rem;" onclick="event.stopPropagation(); openDeleteBatchModal('${batch.id}')"></button>
                                `}
                            ` : ''}
                            <span onclick="toggleBatchTimeline('${batch.id}')" style="cursor: pointer; color: var(--accent-blue); padding: 3px 6px;" id="timeline-toggle-${batch.id}"></span>
                        </div>
                    </div>

                    <div class="batch-details" style="display: none;">
                        ${batch.is_sub_batch ? `
                            <div class="batch-detail" style="background: rgba(147, 51, 234, 0.1); border-left: 3px solid var(--accent-purple); padding: 8px; border-radius: 4px; grid-column: 1/-1;">
                                <div class="batch-detail-label"> Sub-Batch Of</div>
                                <div class="batch-detail-value">${batch.parent_batch_id}</div>
                            </div>
                        ` : ''}
                        <div class="batch-detail" style="grid-column: 1/-1;">
                            <div class="batch-detail-value" style="font-size: 1.4rem; font-weight: 700;">${batch.strain} <span style="font-weight: 400; font-size: 0.9rem; color: var(--text-secondary);">(${batch.strain_type})</span></div>
                        </div>
                        ${batch.final_weight ? `
                            <div class="batch-detail">
                                <div class="batch-detail-label">Net Wt</div>
                                <div class="batch-detail-value" style="font-weight: 600;">${batch.net_weight || batch.final_weight}g</div>
                            </div>
                            <div class="batch-detail">
                                <div class="batch-detail-label">Yield</div>
                                <div class="batch-detail-value" style="font-weight: 700; font-size: 1.1rem; color: ${((parseFloat(batch.final_weight) / parseFloat(batch.trim_weight)) * 100) < 15 ? '#f44336' : (((parseFloat(batch.final_weight) / parseFloat(batch.trim_weight)) * 100) > 21 ? 'var(--accent-green)' : 'var(--accent-blue)')};">${((parseFloat(batch.final_weight) / parseFloat(batch.trim_weight)) * 100).toFixed(1)}%</div>
                            </div>
                        ` : ''}
                        <div class="batch-detail">
                            <div class="batch-detail-label">Trim</div>
                            <div class="batch-detail-value">${batch.trim_weight}g</div>
                        </div>
                        ${batch.grams_labeled ? `
                            <div class="batch-detail">
                                <div class="batch-detail-label">Labeled</div>
                                <div class="batch-detail-value">${batch.grams_labeled}g</div>
                            </div>
                        ` : ''}
                        ${(() => {
                            // Calculate weight discrepancy between bulk and labeled weight
                            if (batch.grams_labeled && batch.net_weight) {
                                const labeled = parseFloat(batch.grams_labeled);
                                const bulk = parseFloat(batch.net_weight);
                                const discrepancy = bulk - labeled;
                                const discrepancyPercent = (discrepancy / bulk) * 100;
                                
                                // Show alert if discrepancy is > 5% or > 5g
                                if (Math.abs(discrepancyPercent) > 5 || Math.abs(discrepancy) > 5) {
                                    const isHigh = discrepancyPercent > 0;
                                    const icon = isHigh ? '' : '';
                                    const color = isHigh ? 'var(--accent-orange)' : 'var(--accent-green)';
                                    const bgColor = isHigh ? 'rgba(245, 158, 11, 0.1)' : 'rgba(16, 185, 129, 0.1)';
                                    
                                    return `
                                        <div style="grid-column: 1/-1; background: ${bgColor}; padding: 10px; border-radius: 8px; border-left: 4px solid ${color}; margin-top: 5px;">
                                            <div style="font-weight: 600; color: ${color}; font-size: 0.9rem; margin-bottom: 3px;">
                                                ${icon} Weight Discrepancy
                                            </div>
                                            <div style="font-size: 0.85rem; color: var(--text-secondary);">
                                                Lost: ${discrepancy.toFixed(1)}g (${discrepancyPercent.toFixed(1)}%) between bulk and labeled
                                            </div>
                                            ${batch.weight_discrepancy !== undefined ? `
                                                <div style="font-size: 0.8rem; color: var(--text-secondary); margin-top: 3px; font-style: italic;">
                                                    Note: ${batch.discrepancy_accepted ? 'Discrepancy noted and accepted' : 'Discrepancy recorded'}
                                                </div>
                                            ` : ''}
                                        </div>
                                    `;
                                }
                            }
                            return '';
                        })()}
                        ${batch.units_packaged ? `
                            <div class="batch-detail">
                                <div class="batch-detail-label">Units Packaged</div>
                                <div class="batch-detail-value">${batch.units_packaged} units${batch.packaging_breakdown ? ` (${batch.packaging_breakdown})` : ''}</div>
                            </div>
                        ` : ''}
                        <!-- Comprehensive Batch Tracking Section -->
                        <div style="grid-column: 1/-1; margin-top: 15px;">
                            <!-- Current Stage Badge -->
                            <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 15px; padding-bottom: 15px; border-bottom: 2px solid var(--accent-purple);">
                                <span style="font-size: 1.1rem; color: var(--text-secondary);">Current Stage:</span>
                                <span style="font-size: 1.2rem; font-weight: 700; padding: 8px 20px; border-radius: 25px; text-transform: uppercase; background: ${batch.status === 'complete' ? 'var(--accent-green)' : batch.status === 'intake' ? 'var(--accent-blue)' : batch.status === 'extraction' ? 'var(--accent-purple)' : batch.status === 'finishing' ? 'var(--accent-orange)' : 'var(--accent-yellow)'}; color: white;">
                                    ${batch.status === 'intake' ? ' Intake' : batch.status === 'extraction' ? ' Extraction' : batch.status === 'finishing' ? ' Finishing' : batch.status === 'packaging' ? ' Packaging' : batch.status === 'testing' ? ' Testing' : batch.status === 'labeling' ? ' Labeling' : batch.status === 'complete' ? ' Complete' : batch.status}
                                </span>
                            </div>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">

                                <!-- INTAKE LABEL CARD -->
                                <div style="background: var(--bg-secondary); border-radius: 16px; padding: 20px; box-shadow: 0 4px 6px rgba(0,0,0,0.3); border-left: 4px solid var(--accent-blue);">
                                    <div style="font-weight: 700; color: var(--accent-blue); font-size: 1.3rem; margin-bottom: 15px; display: flex; align-items: center; gap: 10px;"><span style="font-size: 1.5rem;"></span> INTAKE DATA</div>
                                    <div style="font-size: 1.1rem; line-height: 2;">
                                        <div style="margin-bottom: 6px;"><strong>Batch ID:</strong> <span style="font-family: monospace; background: var(--bg-tertiary); padding: 2px 6px; border-radius: 4px;">${batch.id}</span></div>
                                        <div style="margin-bottom: 6px;"><strong>Strain:</strong> ${batch.strain} <span style="color: var(--text-secondary);">(${batch.strain_type})</span></div>
                                        <div style="margin-bottom: 6px;"><strong>Trim Weight:</strong> ${batch.trim_weight || 0}g</div>
                                        <div style="margin-bottom: 6px;"><strong>Socks:</strong> ${batch.socks_total || 'N/A'} total${batch.socks_remaining != null ? ' (' + batch.socks_remaining + ' remaining)' : ''}</div>
                                        <div style="margin-bottom: 6px;"><strong>Intake Date:</strong> ${batch.intake_date ? new Date(batch.intake_date).toLocaleDateString() : 'N/A'}</div>
                                        <div style="margin-bottom: 6px;"><strong>Grower:</strong> ${batch.grower_name || 'N/A'}</div>
                                        <div style="margin-bottom: 6px;"><strong>License (403):</strong> <span style="font-family: monospace;">${batch.cultivation_license || 'N/A'}</span></div>
                                        <div style="margin-bottom: 6px;"><strong>Agreement:</strong> ${batch.material_agreement || 'N/A'}</div>
                                        <div style="margin-bottom: 6px;"><strong>Planned Products:</strong> ${batch.planned_products && batch.planned_products.length > 0 ? batch.planned_products.join(', ') : 'N/A'}</div>
                                        <div style="margin-bottom: 6px;"><strong>METRC Source Tags:</strong></div>
                                        <div style="font-family: monospace; font-size: 0.8rem; background: var(--bg-tertiary); padding: 8px; border-radius: 6px; word-break: break-all;">${batch.metrc_tags || 'None assigned'}</div>
                                        ${batch.intake_notes ? '<div style="margin-top: 8px;"><strong>Intake Notes:</strong> <span style="color: var(--text-secondary);">' + batch.intake_notes + '</span></div>' : ''}
                                    </div>
                                </div>

                                <!-- POST-PRODUCTION LABEL CARD -->
                                <div style="background: var(--bg-secondary); border-radius: 16px; padding: 20px; box-shadow: 0 4px 6px rgba(0,0,0,0.3); border-left: 4px solid var(--accent-green);">
                                    <div style="font-weight: 700; color: var(--accent-green); font-size: 1.3rem; margin-bottom: 15px; display: flex; align-items: center; gap: 10px;"><span style="font-size: 1.5rem;"></span> POST-PRODUCTION DATA</div>
                                    <div style="font-size: 1.1rem; line-height: 2;">
                                        <div style="margin-bottom: 6px;"><strong>Status:</strong> <span style="text-transform: uppercase; font-weight: 600; color: ${batch.status === 'complete' ? 'var(--accent-green)' : batch.status === 'extraction' ? 'var(--accent-blue)' : 'var(--accent-yellow)'};">${batch.status}</span></div>
                                        <div style="margin-bottom: 6px;"><strong>Final Weight:</strong> ${batch.final_weight || 'Not yet'}${batch.final_weight ? 'g' : ''}</div>
                                        <div style="margin-bottom: 6px;"><strong>Sample Weight:</strong> ${batch.sample_weight || 0}g</div>
                                        <div style="margin-bottom: 6px;"><strong>Net Weight:</strong> ${batch.net_weight || 'N/A'}${batch.net_weight ? 'g' : ''}</div>
                                        <div style="margin-bottom: 6px;"><strong>Product Type:</strong> ${batch.product_type || 'N/A'}</div>
                                        <div style="margin-bottom: 6px;"><strong>Extraction Date:</strong> ${batch.extraction_date ? new Date(batch.extraction_date).toLocaleDateString() : 'Not yet'}</div>
                                        <div style="margin-bottom: 6px;"><strong>Units Packaged:</strong> ${batch.units_packaged || 'N/A'}${batch.packaging_breakdown ? ' (' + batch.packaging_breakdown + ')' : ''}</div>
                                        ${batch.parent_batch_id ? '<div style="margin-bottom: 6px;"><strong>Parent Batch:</strong> <span style="font-family: monospace; background: rgba(147, 51, 234, 0.2); padding: 2px 6px; border-radius: 4px;">' + batch.parent_batch_id + '</span></div>' : ''}
                                        ${batch.extraction_notes ? '<div style="margin-top: 8px;"><strong>Extraction Notes:</strong> <span style="color: var(--text-secondary);">' + batch.extraction_notes + '</span></div>' : ''}
                                        ${batch.finishing_notes ? '<div style="margin-top: 4px;"><strong>Finishing Notes:</strong> <span style="color: var(--text-secondary);">' + batch.finishing_notes + '</span></div>' : ''}
                                    </div>
                                </div>
                            </div>

                            <!-- SOURCE CONTRIBUTIONS - Full Width -->
                            ${(() => {
                                let sourceContributions = batch.source_contributions || [];
                                if (typeof sourceContributions === 'string') {
                                    try { sourceContributions = JSON.parse(sourceContributions); } catch(e) { sourceContributions = []; }
                                }
                                if (sourceContributions.length > 0) {
                                    let rows = sourceContributions.map(s => {
                                        const trimDisplay = s.trim_weight ? (Math.round(s.trim_weight * 10) / 10) + 'g' : s.socks + ' socks';
                                        const sourceBatch = batches.find(b => b.id === s.batch_id);
                                        const metrcTag = s.metrc_tag || sourceBatch?.metrc_tags || 'N/A';
                                        return '<tr style="border-bottom: 1px solid var(--border-color);">' +
                                        '<td style="padding: 6px; font-family: monospace;">' + s.batch_id + '</td>' +
                                        '<td style="padding: 6px;">' + trimDisplay + '</td>' +
                                        '<td style="padding: 6px; font-family: monospace; font-size: 0.8rem;">' + metrcTag + '</td>' +
                                        '</tr>';
                                    }).join('');
                                    return '<div style="margin-top: 15px; background: rgba(147, 51, 234, 0.1); border: 2px solid var(--accent-purple); border-radius: 12px; padding: 15px;">' +
                                        '<div style="font-weight: 700; color: var(--accent-purple); margin-bottom: 10px;"> SOURCE CONTRIBUTIONS (Combined From)</div>' +
                                        '<table style="width: 100%; font-size: 0.85rem; border-collapse: collapse;">' +
                                        '<thead><tr style="background: var(--bg-tertiary);"><th style="padding: 8px; text-align: left;">Source Batch</th><th style="padding: 8px; text-align: left;">Amount Used</th><th style="padding: 8px; text-align: left;">METRC Tag</th></tr></thead>' +
                                        '<tbody>' + rows + '</tbody></table></div>';
                                }
                                return '';
                            })()}
                        </div>
                    </div>

                                        <div class="timeline" id="timeline-${batch.id}" style="display: none;">
                        <!-- Activity History Dropdown -->
                        <div style="margin-top: 10px;">
                            <div onclick="this.nextElementSibling.style.display = this.nextElementSibling.style.display === 'none' ? 'block' : 'none'; this.querySelector('.arrow').textContent = this.nextElementSibling.style.display === 'none' ? '' : '';"
                                 style="background: var(--bg-secondary); padding: 15px 20px; border-radius: 12px; cursor: pointer; display: flex; align-items: center; gap: 12px; font-size: 1.2rem; font-weight: 600; color: var(--accent-blue); box-shadow: 0 2px 4px rgba(0,0,0,0.2);">
                                <span class="arrow"></span>  Activity History (${(batch.timeline || []).length} entries)
                            </div>
                            <div style="display: none; background: var(--bg-tertiary); border-radius: 0 0 12px 12px; padding: 15px; margin-top: 2px;">
                                ${(batch.timeline || []).length > 0 ? (batch.timeline || []).map(t =>
                                    '<div style="padding: 12px; border-bottom: 1px solid var(--border-color); font-size: 1rem;">' +
                                    '<div><strong style="color: var(--accent-purple);">' + t.user + '</strong> - ' + t.action + '</div>' +
                                    '<div style="color: var(--text-secondary); font-size: 0.95rem; margin-top: 4px;">' + new Date(t.date || t.timestamp).toLocaleString() + '</div>' +
                                    '</div>'
                                ).join('') : '<div style="padding: 12px; color: var(--text-secondary);">No activity recorded yet</div>'}
                            </div>
                        </div>
                    </div>
                    
                </div>
            `).join('');
        }

        // Filter buttons
        document.querySelectorAll('.filter-btn').forEach(btn => {
            btn.addEventListener('click', function() {
                document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                
                const filter = this.dataset.filter;
                const searchTerm = document.getElementById('searchBatches').value;
                renderBatches(filter, searchTerm);
            });
        });

        // Search
        document.getElementById('searchBatches').addEventListener('input', function() {
            const activeFilter = document.querySelector('.filter-btn.active').dataset.filter;
            renderBatches(activeFilter, this.value);
        });

        // Toggle batch timeline visibility
        function toggleBatchTimeline(batchId) {
            const timeline = document.getElementById(`timeline-${batchId}`);
            const toggle = document.getElementById(`timeline-toggle-${batchId}`);
            const batchItem = toggle.closest('.batch-item');
            const batchDetails = batchItem ? batchItem.querySelector('.batch-details') : null;

            if (timeline.style.display === 'none') {
                timeline.style.display = 'block';
                if (batchDetails) batchDetails.style.display = 'grid';
                toggle.textContent = 'Hide Details ';
            } else {
                timeline.style.display = 'none';
                if (batchDetails) batchDetails.style.display = 'none';
                toggle.textContent = '';
            }
        }

        function initializeApp() {
            document.querySelectorAll('input[type="date"]').forEach(input => {
                if (!input.value) {
                    input.value = new Date().toISOString().split('T')[0];
                }
            });
            
            document.getElementById('batchId').value = `WM-${batchCounter}`;
            
            // Add pre-sift change handler to highlight hash products
            const preSiftSelect = document.getElementById('preSift');
            if (preSiftSelect) {
                preSiftSelect.addEventListener('change', function() {
                    const brickHashLabel = document.getElementById('brickHash')?.parentElement;
                    const hashHitsLabel = document.getElementById('hashHits')?.parentElement;
                    
                    if (this.value === 'yes') {
                        // Highlight hash products as required
                        if (brickHashLabel) {
                            brickHashLabel.style.background = 'rgba(245, 158, 11, 0.2)';
                            brickHashLabel.style.border = '2px solid var(--accent-orange)';
                            brickHashLabel.style.borderRadius = '8px';
                            brickHashLabel.style.padding = '8px';
                        }
                        if (hashHitsLabel) {
                            hashHitsLabel.style.background = 'rgba(245, 158, 11, 0.2)';
                            hashHitsLabel.style.border = '2px solid var(--accent-orange)';
                            hashHitsLabel.style.borderRadius = '8px';
                            hashHitsLabel.style.padding = '8px';
                        }
                    } else {
                        // Remove highlighting
                        if (brickHashLabel) {
                            brickHashLabel.style.background = '';
                            brickHashLabel.style.border = '';
                            brickHashLabel.style.padding = '';
                        }
                        if (hashHitsLabel) {
                            hashHitsLabel.style.background = '';
                            hashHitsLabel.style.border = '';
                            hashHitsLabel.style.padding = '';
                        }
                    }
                });
            }
        }

        // Testing functions
        function populateTestingSelect() {
            const select = document.getElementById('testingBatchSelect');
            // Show batches that are finishing or complete, but NOT yet labeled
            const testableBatches = batches.filter(b =>
                (b.status === 'finishing' || b.status === 'complete') && !b.labeling_date
            );

            select.innerHTML = '<option value="">Select a batch...</option>';
            testableBatches.forEach(batch => {
                let statusIcon = '';
                let statusText = '';
                if (batch.test_thc_percent !== null && batch.test_thc_percent !== undefined) {
                    statusIcon = ' '; // Has results - ready for labeling
                    statusText = ` [${batch.test_thc_percent}% THC - Ready]`;
                } else if (batch.test_submitted_date) {
                    statusIcon = ' '; // Submitted to lab - awaiting results
                    statusText = ' [Awaiting Results]';
                } else {
                    statusIcon = ' '; // Not yet submitted
                    statusText = '';
                }
                select.innerHTML += `<option value="${batch.id}">${statusIcon}${batch.id} - ${batch.strain}${statusText}</option>`;
            });
        }

        document.getElementById('testingBatchSelect').addEventListener('change', function() {
            const form = document.getElementById('testingForm');
            form.style.display = this.value ? 'block' : 'none';
            
            if (this.value) {
                const batch = batches.find(b => b.id === this.value);
                
                // Display current batch ID
                document.getElementById('currentBatchIdDisplay').textContent = batch.id;
                
                // Calculate trim used for this batch
                let trimUsedInfo = '';
                if (batch.is_sub_batch && batch.parent_batch_id) {
                    // Sub-batch: calculate proportional trim used
                    const parentBatch = batches.find(b => b.id === batch.parent_batch_id);
                    if (parentBatch) {
                        const parentTrimWeight = parseFloat(parentBatch.adjusted_trim_weight || parentBatch.trim_weight || 0);
                        const thisBatchWeight = parseFloat(batch.final_weight || batch.net_weight || 0);

                        // Calculate total output from ALL batches sharing this parent's trim
                        // This includes the parent (if it has output) and all sub-batches
                        const allSiblings = batches.filter(b => b.parent_batch_id === batch.parent_batch_id);
                        let totalFamilyOutput = allSiblings.reduce((sum, b) =>
                            sum + parseFloat(b.final_weight || b.net_weight || 0), 0);

                        // Also add parent's own output if it has one (some parents keep output)
                        const parentOutput = parseFloat(parentBatch.final_weight || parentBatch.net_weight || 0);
                        // Only add parent if it's not also a sub-batch (to avoid double counting)
                        if (parentOutput > 0 && !parentBatch.is_sub_batch) {
                            // Check if parent still has its own separate output
                            const parentHasOwnProduct = parentBatch.product_made && allSiblings.length > 0;
                            if (parentHasOwnProduct) {
                                totalFamilyOutput += parentOutput;
                            } else if (allSiblings.length === 0) {
                                // No sub-batches, use parent output
                                totalFamilyOutput = parentOutput;
                            }
                        }

                        // If no family output calculated, fall back to parent output
                        if (totalFamilyOutput === 0) {
                            totalFamilyOutput = parentOutput;
                        }

                        if (totalFamilyOutput > 0) {
                            const trimUsed = (thisBatchWeight / totalFamilyOutput) * parentTrimWeight;
                            const yieldPercent = trimUsed > 0 ? (thisBatchWeight / trimUsed) * 100 : 0;
                            trimUsedInfo = `
                                <div style="background: rgba(59, 130, 246, 0.15); padding: 15px; border-radius: 8px; margin: 10px 0; border-left: 4px solid var(--accent-blue);">
                                    <p style="margin: 0 0 8px 0;"><strong style="color: var(--accent-blue);"> Calculated Trim (Sub-Batch)</strong></p>
                                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                                        <div>
                                            <span style="color: var(--text-secondary); font-size: 0.85rem;">Trim Used:</span><br>
                                            <strong style="font-size: 1.3rem; color: var(--accent-green);">${trimUsed.toFixed(1)}g</strong>
                                        </div>
                                        <div>
                                            <span style="color: var(--text-secondary); font-size: 0.85rem;">Yield:</span><br>
                                            <strong style="font-size: 1.3rem; color: var(--accent-purple);">${yieldPercent.toFixed(2)}%</strong>
                                        </div>
                                    </div>
                                    <p style="margin: 10px 0 0 0; font-size: 0.85rem; color: var(--text-secondary);">
                                        Sub-batch of <strong>${parentBatch.id}</strong>  ${parentTrimWeight.toFixed(1)}g total trim  ${totalFamilyOutput.toFixed(1)}g total output
                                    </p>
                                </div>
                            `;
                        }
                    }
                } else if (batch.extraction_method === 'Dry Sift') {
                    // Sift batch: the sift weight IS the trim used
                    trimUsedInfo = `
                        <div style="background: rgba(16, 185, 129, 0.15); padding: 12px; border-radius: 8px; margin: 10px 0; border-left: 4px solid var(--accent-green);">
                            <strong>Trim Used:</strong> <span style="font-size: 1.2rem; font-weight: 700; color: var(--accent-green);">${batch.trim_weight}g</span> (dry sift)
                        </div>
                    `;
                } else {
                    // Check if this batch has sub-batches (parent batch)
                    const subBatches = batches.filter(b => b.parent_batch_id === batch.id);
                    const trimWeight = parseFloat(batch.adjusted_trim_weight || batch.trim_weight || 0);
                    const finalWeight = parseFloat(batch.final_weight || batch.net_weight || 0);

                    if (subBatches.length > 0 && finalWeight > 0) {
                        // Parent batch with sub-batches - calculate proportional trim
                        const totalSubBatchOutput = subBatches.reduce((sum, b) =>
                            sum + parseFloat(b.final_weight || b.net_weight || 0), 0);
                        const totalFamilyOutput = finalWeight + totalSubBatchOutput;
                        const trimUsed = totalFamilyOutput > 0 ? (finalWeight / totalFamilyOutput) * trimWeight : trimWeight;
                        const yieldPercent = trimUsed > 0 ? (finalWeight / trimUsed) * 100 : 0;

                        trimUsedInfo = `
                            <div style="background: rgba(245, 158, 11, 0.15); padding: 15px; border-radius: 8px; margin: 10px 0; border-left: 4px solid var(--accent-orange);">
                                <p style="margin: 0 0 8px 0;"><strong style="color: var(--accent-orange);"> Calculated Trim (Has ${subBatches.length} Sub-Batch${subBatches.length > 1 ? 'es' : ''})</strong></p>
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                                    <div>
                                        <span style="color: var(--text-secondary); font-size: 0.85rem;">Trim Used (this batch):</span><br>
                                        <strong style="font-size: 1.3rem; color: var(--accent-green);">${trimUsed.toFixed(1)}g</strong>
                                    </div>
                                    <div>
                                        <span style="color: var(--text-secondary); font-size: 0.85rem;">Yield:</span><br>
                                        <strong style="font-size: 1.3rem; color: var(--accent-purple);">${yieldPercent.toFixed(2)}%</strong>
                                    </div>
                                </div>
                                <p style="margin: 10px 0 0 0; font-size: 0.85rem; color: var(--text-secondary);">
                                    Total trim: ${trimWeight.toFixed(1)}g  Total output (all batches): ${totalFamilyOutput.toFixed(1)}g
                                </p>
                            </div>
                        `;
                    } else {
                        // Regular batch without sub-batches
                        const yieldPercent = trimWeight > 0 ? (finalWeight / trimWeight) * 100 : 0;

                        trimUsedInfo = `
                            <div style="background: rgba(16, 185, 129, 0.15); padding: 12px; border-radius: 8px; margin: 10px 0; border-left: 4px solid var(--accent-green);">
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <div>
                                        <strong>Trim Used:</strong> <span style="font-size: 1.2rem; font-weight: 700; color: var(--accent-green);">${trimWeight.toFixed(1)}g</span>${batch.adjusted_trim_weight ? ' <span style="color: var(--text-secondary);">(after sift)</span>' : ''}
                                    </div>
                                    <div>
                                        <strong>Yield:</strong> <span style="font-size: 1.2rem; font-weight: 700; color: var(--accent-purple);">${yieldPercent.toFixed(2)}%</span>
                                    </div>
                                </div>
                            </div>
                        `;
                    }
                }
                
                // Parse source contributions if they exist
                let sourceContributions = batch.source_contributions || [];
                if (typeof sourceContributions === 'string') {
                    try { sourceContributions = JSON.parse(sourceContributions); } catch(e) { sourceContributions = []; }
                }

                // Build source contributions HTML for METRC
                let sourceContributionsHtml = '';
                if (sourceContributions.length > 1) {
                    const totalSocks = sourceContributions.reduce((sum, p) => sum + p.socks, 0);
                    const totalTrimFromSources = sourceContributions.reduce((sum, p) => sum + (parseFloat(p.trim_weight) || 0), 0);
                    sourceContributionsHtml = `
                        <div style="background: rgba(239, 68, 68, 0.15); padding: 15px; border-radius: 8px; margin: 15px 0; border: 2px solid var(--accent-red);">
                            <p style="margin: 0 0 10px 0;"><strong style="color: var(--accent-red);"> MIXED SOURCE BATCH - PARTIAL TAGS</strong></p>
                            <p style="margin: 0 0 15px 0; font-size: 0.9rem; color: var(--text-secondary);">
                                This batch used trim from multiple source tags. Only a portion of each tag's trim was used.
                            </p>
                            <div style="background: var(--bg-secondary); padding: 12px; border-radius: 8px; margin-bottom: 12px;">
                                <strong>Total Trim Used:</strong> <span style="font-size: 1.2rem; font-weight: 700; color: var(--accent-orange);">${totalTrimFromSources.toFixed(1)}g</span> from ${sourceContributions.length} sources
                            </div>
                            ${sourceContributions.map(p => {
                                const percentage = ((p.socks / totalSocks) * 100).toFixed(1);
                                const trimUsed = parseFloat(p.trim_weight) || 0;
                                return `<div style="background: var(--bg-tertiary); padding: 12px; border-radius: 6px; margin: 8px 0;">
                                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                        <div>
                                            <span style="background: var(--accent-orange); color: white; padding: 2px 8px; border-radius: 4px; font-size: 0.75rem; font-weight: 700;">PARTIAL</span>
                                            <strong style="margin-left: 8px;">${p.batch_id}</strong>  ${p.strain || 'Unknown'}
                                        </div>
                                        <div style="text-align: right;">
                                            <span style="color: var(--accent-purple); font-weight: 700;">${percentage}%</span>
                                        </div>
                                    </div>
                                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; font-size: 0.9rem;">
                                        <div>
                                            <span style="color: var(--text-secondary);">METRC Tag:</span><br>
                                            <strong style="font-family: 'Space Mono', monospace; color: var(--accent-blue);">${p.metrc_tag || 'Not set'}</strong>
                                        </div>
                                        <div>
                                            <span style="color: var(--text-secondary);">Trim Used:</span><br>
                                            <strong style="color: var(--accent-green);">${trimUsed.toFixed(1)}g</strong> <span style="color: var(--text-secondary);">(${p.socks} socks)</span>
                                        </div>
                                    </div>
                                </div>`;
                            }).join('')}
                            <p style="margin: 12px 0 0 0; padding: 10px; background: rgba(59, 130, 246, 0.15); border-radius: 6px; font-size: 0.85rem; color: var(--text-secondary);">
                                <strong style="color: var(--accent-blue);"> METRC Instructions:</strong> Pull the exact trim weight shown above from each source tag when creating this batch.
                            </p>
                        </div>
                    `;
                } else if (sourceContributions.length === 1) {
                    // Single source but from pot ledger - show trim used
                    const p = sourceContributions[0];
                    const trimUsed = parseFloat(p.trim_weight) || 0;
                    sourceContributionsHtml = `
                        <div style="background: rgba(16, 185, 129, 0.15); padding: 15px; border-radius: 8px; margin: 15px 0; border-left: 4px solid var(--accent-green);">
                            <p style="margin: 0 0 10px 0;"><strong style="color: var(--accent-green);"> Source Tag (Calculated Trim):</strong></p>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                                <div>
                                    <span style="color: var(--text-secondary); font-size: 0.85rem;">METRC Tag:</span><br>
                                    <strong style="font-family: 'Space Mono', monospace; font-size: 1.1rem; color: var(--accent-blue);">${p.metrc_tag || 'Not set'}</strong>
                                </div>
                                <div>
                                    <span style="color: var(--text-secondary); font-size: 0.85rem;">Trim Used:</span><br>
                                    <strong style="font-size: 1.1rem; color: var(--accent-green);">${trimUsed.toFixed(1)}g</strong>
                                </div>
                            </div>
                        </div>
                    `;
                }

                // Show current batch info
                const details = `
                    <p><strong>Strain:</strong> ${batch.strain} (${batch.strain_type})</p>
                    <p><strong>Product:</strong> ${batch.product_made}</p>
                    <p><strong>Net Weight:</strong> ${batch.net_weight || batch.final_weight || 'N/A'}g</p>
                    ${trimUsedInfo}
                    <div style="background: rgba(245, 158, 11, 0.2); padding: 12px; border-radius: 8px; margin: 10px 0; border-left: 4px solid var(--accent-orange);">
                        <p style="margin: 0;"><strong style="color: var(--accent-orange);"> METRC Tags:</strong> <span style="font-family: 'Space Mono', monospace; font-size: 1.1rem; font-weight: 700;">${batch.metrc_tags && batch.metrc_tags.trim() !== '' ? batch.metrc_tags : 'Not entered at intake'}</span></p>
                    </div>
                    ${sourceContributionsHtml}
                    <p><strong>Cultivation License:</strong> ${batch.cultivation_license}</p>
                    <p><strong>Grower:</strong> ${batch.grower_name || 'N/A'}</p>
                    <p><strong>Status:</strong> ${batch.status}</p>
                    ${batch.test_submitted_date ? `<p><strong>Previously Submitted:</strong> ${batch.test_submitted_date}</p>` : ''}
                    ${batch.is_rta === 'yes' ? `<p style="color: var(--accent-green);"><strong> RTA Full Panel</strong></p>` : ''}
                `;
                document.getElementById('testBatchDetails').innerHTML = details;
                
                // Auto-populate product name with current strain + product type
                // User can modify if they want to rename for wholesale variety
                const defaultProductName = batch.final_product_name || `${batch.strain} ${batch.product_made}`;
                document.getElementById('finalProductName').value = defaultProductName;
                
                // Auto-populate strain type from batch, but allow redesignation
                const strainType = batch.final_strain_type || batch.strain_type;
                
                // Handle Dealer's Choice - default to Hybrid
                if (batch.strain_type === "Dealer's Choice") {
                    document.getElementById('finalStrainType').value = 'Hybrid';
                } else {
                    document.getElementById('finalStrainType').value = strainType;
                }
                
                // Pre-fill if test results already exist
                if (batch.test_submitted_date) {
                    document.getElementById('testSubmittedDate').value = batch.test_submitted_date || '';
                    document.getElementById('testExpirationDate').value = batch.test_expiration_date || '';
                    document.getElementById('metrcLast4').value = ''; // Clear - batch ID already set
                    document.getElementById('newBatchId').value = batch.id || ''; // Show current batch ID
                    document.getElementById('isRTA').value = batch.is_rta || 'no';
                    // Load saved product name and strain type
                    document.getElementById('finalProductName').value = batch.strain || '';
                    document.getElementById('finalConsistency').value = batch.product_made || '';
                    document.getElementById('finalStrainType').value = batch.strain_type || 'Hybrid';
                    // Parse current batch ID to show parsed info
                    parseBatchId(batch.id);
                } else {
                    // Clear form for new submission
                    document.getElementById('testSubmittedDate').value = new Date().toISOString().split('T')[0]; // Default to today
                    document.getElementById('testExpirationDate').value = '';
                    document.getElementById('metrcLast4').value = '';
                    document.getElementById('newBatchId').value = '';
                    document.getElementById('isRTA').value = 'no';
                    // Pre-populate from batch data
                    document.getElementById('finalProductName').value = batch.strain || '';
                    document.getElementById('finalConsistency').value = batch.product_made || '';
                    document.getElementById('finalStrainType').value = batch.strain_type || 'Hybrid';
                    // Hide parsed info
                    document.getElementById('parsedBatchInfo').style.display = 'none';
                }

                // Update ready for testing status UI
                updateReadyForTestingUI(batch);

                // Check if RTA full panel is required for this product type
                if (batch.product_made) {
                    checkRTAAlert(batch.product_made);
                }

                // Update test results display section
                updateTestResultsDisplay(batch);

                // Show batch status in header
                const statusDiv = document.getElementById('testingBatchStatus');
                if (statusDiv) {
                    if (batch.test_thc_percent) {
                        statusDiv.innerHTML = `<span style="background: var(--accent-green); color: black; padding: 4px 12px; border-radius: 20px; font-size: 0.85rem; font-weight: 600;">Results Ready</span>`;
                    } else if (batch.test_submitted_date) {
                        statusDiv.innerHTML = `<span style="background: var(--accent-orange); color: black; padding: 4px 12px; border-radius: 20px; font-size: 0.85rem; font-weight: 600;">Awaiting Results</span>`;
                    } else {
                        statusDiv.innerHTML = `<span style="background: var(--accent-blue); color: white; padding: 4px 12px; border-radius: 20px; font-size: 0.85rem; font-weight: 600;">Ready to Submit</span>`;
                    }
                }
            }

            // Check RTA status after loading
            checkRTAStatus();
        });

        // Auto-generate batch ID from expiration date and METRC tag last 4
        function generateBatchId() {
            const expirationDate = document.getElementById('testExpirationDate').value;
            const metrcLast4 = document.getElementById('metrcLast4').value.trim();
            
            if (expirationDate && metrcLast4 && metrcLast4.length === 4) {
                // Parse date string directly to avoid timezone issues
                // Date format from input is YYYY-MM-DD
                const dateParts = expirationDate.split('-');
                const month = parseInt(dateParts[1], 10); // Remove leading zero
                const day = parseInt(dateParts[2], 10);   // Remove leading zero
                
                const batchId = `${month}.${day}.${metrcLast4}`;
                document.getElementById('newBatchId').value = batchId;
            } else {
                document.getElementById('newBatchId').value = '';
            }
        }

        // Add event listeners for auto-generation
        document.getElementById('testExpirationDate').addEventListener('change', generateBatchId);
        document.getElementById('metrcLast4').addEventListener('input', generateBatchId);


        // ==================== RTA QUALIFICATION SYSTEM ====================
        // Colorado MED Rule 4-230: Reduced Testing Allowance

        // RTA status per product type - cached locally, synced with Supabase
        let rtaStatusCache = null;

        function getRTAStatus() {
            if (rtaStatusCache) return rtaStatusCache;
            const stored = localStorage.getItem('wm_rta_status');
            if (stored) {
                rtaStatusCache = JSON.parse(stored);
                return rtaStatusCache;
            }
            return {
                'BHO': { status: 'none', consecutivePasses: 0, qualificationStart: null, qualificationDeadline: null, rtaStart: null, rtaExpires: null, lastTestDate: null, nextTestDue: null, history: [], pendingBatches: [] },
                'Live Resin Carts': { status: 'none', consecutivePasses: 0, qualificationStart: null, qualificationDeadline: null, rtaStart: null, rtaExpires: null, lastTestDate: null, nextTestDue: null, history: [], pendingBatches: [] },
                'Live Resin AIOs': { status: 'none', consecutivePasses: 0, qualificationStart: null, qualificationDeadline: null, rtaStart: null, rtaExpires: null, lastTestDate: null, nextTestDue: null, history: [], pendingBatches: [] },
                'Brick Hash': { status: 'none', consecutivePasses: 0, qualificationStart: null, qualificationDeadline: null, rtaStart: null, rtaExpires: null, lastTestDate: null, nextTestDue: null, history: [], pendingBatches: [] }
            };
        }

        function saveRTAStatus(status) {
            rtaStatusCache = status;
            localStorage.setItem('wm_rta_status', JSON.stringify(status));
            saveRTAToSupabase(status);
        }

        async function loadRTAFromSupabase() {
            try {
                const { data, error } = await supabaseClient
                    .from('wm_rta_status')
                    .select('*');
                if (error) throw error;
                if (data && data.length > 0) {
                    const status = {};
                    data.forEach(row => {
                        status[row.product_type] = {
                            status: row.status || 'none',
                            consecutivePasses: row.consecutive_passes || 0,
                            qualificationStart: row.qualification_start,
                            qualificationDeadline: row.qualification_deadline,
                            rtaStart: row.rta_start,
                            rtaExpires: row.rta_expires,
                            lastTestDate: row.last_test_date,
                            nextTestDue: row.next_test_due,
                            pendingBatches: row.pending_batches || [],
                            history: row.history || []
                        };
                    });
                    rtaStatusCache = status;
                    localStorage.setItem('wm_rta_status', JSON.stringify(status));
                    console.log('RTA status loaded from Supabase');
                    renderRTAQuickStatus();
                }
            } catch (err) {
                console.error('Error loading RTA from Supabase:', err);
            }
        }

        async function saveRTAToSupabase(status) {
            try {
                for (const [productType, data] of Object.entries(status)) {
                    await supabaseClient
                        .from('wm_rta_status')
                        .upsert({
                            product_type: productType,
                            status: data.status,
                            consecutive_passes: data.consecutivePasses,
                            qualification_start: data.qualificationStart,
                            qualification_deadline: data.qualificationDeadline,
                            rta_start: data.rtaStart,
                            rta_expires: data.rtaExpires,
                            last_test_date: data.lastTestDate,
                            next_test_due: data.nextTestDue,
                            pending_batches: data.pendingBatches || [],
                            history: data.history || [],
                            updated_at: new Date().toISOString()
                        }, { onConflict: 'product_type' });
                }
            } catch (err) {
                console.error('Error saving RTA to Supabase:', err);
            }
        }

        // Determine RTA product type from batch data
        function getRTAProductType(batch) {
            const productMade = batch.product_made || '';
            const plannedProducts = batch.planned_products || [];
            const firstPlanned = plannedProducts[0]?.type || '';

            // Check for Live Resin products first
            if (productMade.includes('Live Resin Carts') || firstPlanned.includes('Live Resin Carts')) {
                return 'Live Resin Carts';
            }
            if (productMade.includes('Live Resin AIOs') || firstPlanned.includes('Live Resin AIOs')) {
                return 'Live Resin AIOs';
            }
            if (productMade.includes('Brick Hash') || firstPlanned.includes('Brick Hash')) {
                return 'Brick Hash';
            }
            // Default to BHO for standard products (Wax, Shatter, Sugar Wax)
            return 'BHO';
        }

        // Register a batch created during qualification period
        function registerQualificationBatch(productType, batchId) {
            const rtaStatus = getRTAStatus();
            const typeStatus = rtaStatus[productType];
            if (!typeStatus) return;

            // Only track if in qualifying or reauthorizing
            if (typeStatus.status === 'qualifying' || typeStatus.status === 'reauthorizing') {
                if (!typeStatus.pendingBatches) typeStatus.pendingBatches = [];
                if (!typeStatus.pendingBatches.includes(batchId)) {
                    typeStatus.pendingBatches.push(batchId);
                    saveRTAStatus(rtaStatus);
                    console.log('Registered batch ' + batchId + ' for RTA qualification');
                }
            }
        }

        // Get count of untested batches during qualification
        function getUntestedBatchCount(productType) {
            const rtaStatus = getRTAStatus();
            const typeStatus = rtaStatus[productType];
            if (!typeStatus || !typeStatus.pendingBatches) return 0;
            return typeStatus.pendingBatches.length;
        }



        // Show/hide test result dropdown based on RTA selection
        function updateTestResultVisibility() {
            const isRTA = document.getElementById('isRTA').value;
            const resultGroup = document.getElementById('testResultGroup');
            if (resultGroup) {
                resultGroup.style.display = isRTA === 'yes' ? 'block' : 'none';
            }
        }

        // Parse batch ID format M.D.XXXX to extract expiration and METRC
        function parseBatchId(value) {
            const parsedInfo = document.getElementById('parsedBatchInfo');
            const parsedExpiration = document.getElementById('parsedExpiration');
            const parsedMetrc = document.getElementById('parsedMetrc');
            const expirationInput = document.getElementById('testExpirationDate');
            const metrcInput = document.getElementById('metrcLast4');

            if (!value || !value.includes('.')) {
                parsedInfo.style.display = 'none';
                return null;
            }

            // Parse M.D.XXXX format (e.g., 10.3.1212)
            const parts = value.split('.');
            if (parts.length < 3) {
                parsedInfo.style.display = 'none';
                return null;
            }

            const month = parseInt(parts[0]);
            const day = parseInt(parts[1]);
            const metrcLast4 = parts.slice(2).join(''); // Handle cases like 10.3.12.12 -> 1212

            if (isNaN(month) || isNaN(day) || month < 1 || month > 12 || day < 1 || day > 31) {
                parsedInfo.style.display = 'none';
                return null;
            }

            // Determine year - if month is before current month, assume next year
            const now = new Date();
            const currentMonth = now.getMonth() + 1;
            const currentYear = now.getFullYear();
            let year = currentYear;
            if (month < currentMonth || (month === currentMonth && day < now.getDate())) {
                year = currentYear + 1;
            }

            // Format expiration date
            const expirationDate = new Date(year, month - 1, day);
            const formattedDate = expirationDate.toLocaleDateString('en-US', {
                month: 'long',
                day: 'numeric',
                year: 'numeric'
            });
            const isoDate = `${year}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}`;

            // Update display
            parsedExpiration.textContent = formattedDate;
            parsedMetrc.textContent = metrcLast4 || '--';
            parsedInfo.style.display = 'block';

            // Update hidden inputs
            expirationInput.value = isoDate;
            metrcInput.value = metrcLast4;

            return { month, day, year, metrcLast4, expirationDate: isoDate };
        }

        // Simplified submit to testing function
        async function submitToTesting() {
            if (blockDemoWrite('Submitting to testing')) return;

            if (!currentRole) {
                alert('Please select a user first!');
                return;
            }

            const batchId = document.getElementById('testingBatchSelect').value;
            const batch = batches.find(b => b.id === batchId);

            if (!batch) {
                alert('Please select a batch first!');
                return;
            }

            const finalProductName = document.getElementById('finalProductName').value.trim();
            const newBatchId = document.getElementById('newBatchId').value.trim();
            const isRTA = document.getElementById('isRTA').value;
            const submittedDate = new Date().toISOString().split('T')[0]; // Auto-set to today

            // Validate
            if (!finalProductName) {
                alert('Please enter a product name.');
                return;
            }
            if (!newBatchId) {
                alert('Please enter the batch ID (M.D.XXXX format).');
                return;
            }

            // Parse batch ID for expiration and METRC
            const parsed = parseBatchId(newBatchId);
            if (!parsed) {
                alert('Invalid batch ID format. Please use M.D.XXXX (e.g., 10.3.1212)');
                return;
            }

            // Check for duplicate batch ID
            if (newBatchId !== batchId) {
                const existingBatch = batches.find(b => b.id === newBatchId);
                if (existingBatch) {
                    alert(`Batch ID "${newBatchId}" already exists. Please use a different ID.`);
                    return;
                }
            }

            // Confirm submission
            let confirmMsg = `Submit batch to testing?\n\n`;
            confirmMsg += `Product: ${finalProductName}\n`;
            confirmMsg += `Batch ID: ${newBatchId}\n`;
            confirmMsg += `Expiration: ${parsed.expirationDate}\n`;
            confirmMsg += `METRC (last 4): ${parsed.metrcLast4}\n`;
            confirmMsg += `RTA Full Panel: ${isRTA === 'yes' ? 'Yes' : 'No'}`;

            if (!confirm(confirmMsg)) return;

            const now = new Date().toISOString();
            const timeline = batch.timeline || [];

            timeline.push({
                stage: 'testing',
                user: currentRole.name,
                date: now,
                action: `Submitted to lab - ${finalProductName} | Batch ID: ${newBatchId}${isRTA === 'yes' ? ' | RTA Full Panel' : ''}`
            });

            // Build update object
            const updates = {
                strain: finalProductName,
                test_submitted_date: submittedDate,
                test_expiration_date: parsed.expirationDate,
                is_rta: isRTA,
                timeline: timeline
            };

            // Store METRC last 4 in notes for now (could add column later)
            if (parsed.metrcLast4) {
                updates.test_results_notes = `METRC Last 4: ${parsed.metrcLast4}`;
            }

            try {
                // Handle batch ID change
                if (newBatchId !== batchId) {
                    // Delete old record
                    const { error: deleteError } = await supabaseClient
                        .from('wm_batches')
                        .delete()
                        .eq('id', batchId);

                    if (deleteError) throw deleteError;

                    // Insert with new ID
                    const newBatchData = { ...batch, ...updates, id: newBatchId };
                    delete newBatchData.created_at;

                    const { error: insertError } = await supabaseClient
                        .from('wm_batches')
                        .insert(newBatchData);

                    if (insertError) throw insertError;

                    // Update local array
                    const idx = batches.findIndex(b => b.id === batchId);
                    if (idx !== -1) {
                        batches[idx] = { ...batch, ...updates, id: newBatchId };
                    }
                } else {
                    // Simple update
                    const { error } = await supabaseClient
                        .from('wm_batches')
                        .update(updates)
                        .eq('id', batchId);

                    if (error) throw error;

                    Object.assign(batch, updates);
                }

                // Refresh UI
                populateTestingSelect();
                document.getElementById('testingBatchSelect').value = '';
                document.getElementById('testingForm').style.display = 'none';

                alert(`Batch ${newBatchId} submitted to testing!\n\nProduct: ${finalProductName}\nExpiration: ${parsed.expirationDate}\n\nTest results will auto-import when COA sync runs.`);

            } catch (err) {
                console.error('Error submitting to testing:', err);
                alert('Error: ' + err.message);
            }
        }

        // Check if product type needs RTA full panel and show alert
        function checkRTAAlert(productType) {
            const rtaAlert = document.getElementById('rtaAlertBanner');
            const isRTASelect = document.getElementById('isRTA');

            if (!rtaAlert) return;

            // Check if this product type requires full panel (qualifying or reauthorizing)
            const needsFullPanel = requiresFullPanel(productType);

            if (needsFullPanel) {
                rtaAlert.style.display = 'block';
                // Auto-select RTA full panel
                if (isRTASelect) {
                    isRTASelect.value = 'yes';
                    updateTestResultVisibility();
                }
            } else {
                rtaAlert.style.display = 'none';
            }
        }

        // Update test results display section
        function updateTestResultsDisplay(batch) {
            const resultsSection = document.getElementById('testResultsSection');
            const displayThc = document.getElementById('displayThc');
            const displayCbd = document.getElementById('displayCbd');
            const displayStatus = document.getElementById('displayStatus');
            const notesDiv = document.getElementById('testResultsNotes');

            if (!resultsSection) return;

            // Show results section if we have THC data
            if (batch.test_thc_percent !== null && batch.test_thc_percent !== undefined) {
                resultsSection.style.display = 'block';
                displayThc.textContent = batch.test_thc_percent + '%';
                displayCbd.textContent = (batch.test_cbd_percent || 0) + '%';
                displayStatus.textContent = 'Ready for Labeling';
                displayStatus.style.color = 'var(--accent-green)';

                if (batch.test_results_notes) {
                    notesDiv.textContent = batch.test_results_notes;
                    notesDiv.style.display = 'block';
                } else {
                    notesDiv.style.display = 'none';
                }
            } else if (batch.test_submitted_date) {
                resultsSection.style.display = 'block';
                displayThc.textContent = '--';
                displayCbd.textContent = '--';
                displayStatus.textContent = 'Awaiting Results';
                displayStatus.style.color = 'var(--accent-orange)';
                notesDiv.style.display = 'none';
            } else {
                resultsSection.style.display = 'none';
            }
        }

        // Record a full panel test result
        function recordRTAResult(productType, batchId, result, testDate) {
            const rtaStatus = getRTAStatus();
            const typeStatus = rtaStatus[productType];
            if (!typeStatus) return;

            // Remove from pending batches if present
            if (typeStatus.pendingBatches && batchId !== 'manual') {
                typeStatus.pendingBatches = typeStatus.pendingBatches.filter(b => b !== batchId);
            }

            // Add to history
            typeStatus.history.push({
                batchId: batchId,
                result: result,
                date: testDate || new Date().toISOString()
            });

            if (result === 'pass') {
                typeStatus.consecutivePasses++;

                // Check if just started qualifying
                if (typeStatus.status === 'none' && typeStatus.consecutivePasses === 1) {
                    typeStatus.status = 'qualifying';
                    typeStatus.qualificationStart = new Date().toISOString();
                }

                                // Show progress - user must manually complete qualification after 4-week period
                const requiredPasses = typeStatus.status === 'reauthorizing' ? 5 : 4;
                const pendingCount = (typeStatus.pendingBatches || []).length;

                if (typeStatus.status === 'qualifying' || typeStatus.status === 'reauthorizing') {
                    let msg = ' Test PASSED!\n\n' + productType + ': ' + typeStatus.consecutivePasses + '/' + requiredPasses + ' passes';
                    if (pendingCount > 0) {
                        msg += '\n ' + pendingCount + ' batches still need testing';
                    } else if (typeStatus.consecutivePasses >= requiredPasses) {
                        msg += '\n\n Ready to complete!\nClick Manage  Complete button';
                    }
                    alert(msg);
                } else if (typeStatus.status === 'reauthorizing') {
                    // Failed during reauthorization - lose RTA completely
                    typeStatus.status = 'none';
                    typeStatus.consecutivePasses = 0;
                    typeStatus.rtaStart = null;
                    typeStatus.rtaExpires = null;
                    alert(' RTA LOST\n\n' + productType + ' failed during reauthorization.\nYou must start over with 4 consecutive passing batches.');
                } else {
                    // Failed during initial qualification
                    typeStatus.status = 'none';
                    typeStatus.consecutivePasses = 0;
                    typeStatus.qualificationStart = null;
                }
            }

            saveRTAStatus(rtaStatus);
            renderRTAQualificationStatus();
        }

                // Complete RTA qualification (call after 4-week period)
        function completeRTAQualification(productType) {
            const rtaStatus = getRTAStatus();
            const typeStatus = rtaStatus[productType];
            if (!typeStatus) return;

            const requiredPasses = typeStatus.status === 'reauthorizing' ? 5 : 4;
            const pendingCount = (typeStatus.pendingBatches || []).length;

            if (typeStatus.consecutivePasses < requiredPasses) {
                alert(' Cannot complete qualification\n\n' + productType + ' needs ' + requiredPasses + ' passes.\nCurrent: ' + typeStatus.consecutivePasses);
                return;
            }

            if (pendingCount > 0) {
                alert(' Cannot complete qualification\n\n' + productType + ' has ' + pendingCount + ' untested batches.');
                return;
            }

            const now = new Date();
            typeStatus.status = 'active';
            typeStatus.rtaStart = now.toISOString();
            const expires = new Date(now);
            expires.setFullYear(expires.getFullYear() + 1);
            typeStatus.rtaExpires = expires.toISOString();

            typeStatus.lastTestDate = now.toISOString();
            const nextDue = new Date(now);
            nextDue.setDate(nextDue.getDate() + 30);
            typeStatus.nextTestDue = nextDue.toISOString();
            typeStatus.qualificationDeadline = null;
            typeStatus.consecutivePasses = 0;

            saveRTAStatus(rtaStatus);
            renderRTAQualificationStatus();
            renderRTAManagerContent();
            renderRTAQuickStatus();
            closeRTAManager();

            alert(' RTA QUALIFIED!\n\n' + productType + ' certified for 1 year!\n\nExpires: ' + expires.toLocaleDateString() + '\nNext 30-day test: ' + nextDue.toLocaleDateString());
        }

// Start qualification period for a product type
        function startRTAQualification(productType) {
            const rtaStatus = getRTAStatus();
            if (rtaStatus[productType]) {
                const now = new Date();
                const deadline = new Date(now);
                deadline.setDate(deadline.getDate() + 28); // 4 weeks

                rtaStatus[productType].status = 'qualifying';
                rtaStatus[productType].consecutivePasses = 0;
                rtaStatus[productType].qualificationStart = now.toISOString();
                rtaStatus[productType].qualificationDeadline = deadline.toISOString();
                saveRTAStatus(rtaStatus);
                renderRTAQualificationStatus();
                closeRTAManager();
                alert('Started RTA qualification for ' + productType + '\n\n 4-week window started\n All batches must be FULL PANEL tested\n Need 4 consecutive passes to qualify\n\nDeadline: ' + deadline.toLocaleDateString());
            }
        }

        // Check if product type is in qualification period (requires full panel)
        function requiresFullPanel(productType) {
            const rtaStatus = getRTAStatus();
            const typeStatus = rtaStatus[productType];
            if (!typeStatus) return false;
            return typeStatus.status === 'qualifying' || typeStatus.status === 'reauthorizing';
        }

        // Render RTA qualification status in testing tab
        function renderRTAQualificationStatus() {
            const container = document.getElementById('rtaStatusCards');
            if (!container) return;

            const rtaStatus = getRTAStatus();
            const today = new Date();

            let html = '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 15px;">';

            Object.entries(rtaStatus).forEach(([productType, status]) => {
                let statusColor, statusText, statusIcon, details;

                switch (status.status) {
                    case 'active':
                        const expires = new Date(status.rtaExpires);
                        const daysLeft = Math.floor((expires - today) / (1000 * 60 * 60 * 24));
                        statusColor = daysLeft < 30 ? 'var(--accent-orange)' : 'var(--accent-green)';
                        statusIcon = '';
                        statusText = 'RTA Active';
                        details = daysLeft < 0 ? 'EXPIRED!' : 'Expires: ' + expires.toLocaleDateString() + ' (' + daysLeft + ' days)';
                        break;
                    case 'qualifying':
                        statusColor = 'var(--accent-blue)';
                        statusIcon = '';
                        statusText = 'Qualifying';
                        details = status.consecutivePasses + '/4 passes' + (status.pendingBatches && status.pendingBatches.length > 0 ? '  ' + status.pendingBatches.length + ' untested' : '');
                        break;
                    case 'reauthorizing':
                        statusColor = 'var(--accent-orange)';
                        statusIcon = '';
                        statusText = 'Reauthorizing';
                        details = status.consecutivePasses + '/5 passes' + (status.pendingBatches && status.pendingBatches.length > 0 ? '  ' + status.pendingBatches.length + ' untested' : '');
                        break;
                    default:
                        statusColor = 'var(--text-secondary)';
                        statusIcon = '';
                        statusText = 'No RTA';
                        details = 'Not started';
                }

                html += `
                    <div style="background: var(--bg-secondary); padding: 15px; border-radius: 10px; border-left: 4px solid ${statusColor};">
                        <div style="font-size: 0.8rem; color: var(--text-secondary); margin-bottom: 5px;">${productType}</div>
                        <div style="font-size: 1.1rem; font-weight: 700; color: ${statusColor}; margin-bottom: 5px;">${statusIcon} ${statusText}</div>
                        <div style="font-size: 0.85rem; color: var(--text-secondary);">${details}</div>
                    </div>
                `;
            });

            html += '</div>';
            container.innerHTML = html;
        }

        // Open RTA Manager modal
        
        // Render quick status boxes in Testing tab
        function renderRTAQuickStatus() {
            const container = document.getElementById('rtaQuickStatus');
            if (!container) return;

            const rtaStatus = getRTAStatus();
            const today = new Date();

            let html = '';
            Object.entries(rtaStatus).forEach(([productType, status]) => {
                let color, icon, label, sublabel = '';

                switch (status.status) {
                    case 'active':
                        const expires = new Date(status.rtaExpires);
                        const daysLeft = Math.floor((expires - today) / (1000 * 60 * 60 * 24));
                        const nextTest = status.nextTestDue ? new Date(status.nextTestDue) : null;
                        const testDaysLeft = nextTest ? Math.floor((nextTest - today) / (1000 * 60 * 60 * 24)) : null;

                        if (daysLeft < 30) {
                            color = 'var(--accent-orange)';
                            icon = '';
                            label = 'Recert Soon';
                            sublabel = daysLeft + 'd left';
                        } else if (testDaysLeft !== null && testDaysLeft <= 7) {
                            color = 'var(--accent-orange)';
                            icon = '';
                            label = 'Test Due';
                            sublabel = testDaysLeft <= 0 ? 'OVERDUE' : testDaysLeft + 'd';
                        } else {
                            color = 'var(--accent-green)';
                            icon = '';
                            label = 'Active';
                            sublabel = daysLeft + 'd left';
                        }
                        break;
                    case 'qualifying':
                        const deadline = status.qualificationDeadline ? new Date(status.qualificationDeadline) : null;
                        const qualDays = deadline ? Math.floor((deadline - today) / (1000 * 60 * 60 * 24)) : null;
                        const qPending = (status.pendingBatches || []).length;
                        const readyToComplete = status.consecutivePasses >= 4 && qPending === 0;

                        if (readyToComplete) {
                            color = 'var(--accent-green)';
                            icon = '';
                            label = 'Ready!';
                            sublabel = 'Click Manage';
                        } else {
                            color = 'var(--accent-blue)';
                            icon = '';
                            label = status.consecutivePasses + '/4';
                            sublabel = qPending > 0 ? qPending + ' pending' : (qualDays ? qualDays + 'd left' : 'Testing');
                        }
                        break;
                    case 'reauthorizing':
                        color = 'var(--accent-orange)';
                        icon = '';
                        label = status.consecutivePasses + '/5';
                        sublabel = 'Reauth';
                        break;
                    default:
                        color = 'var(--text-secondary)';
                        icon = '';
                        label = 'None';
                        sublabel = 'Not Started';
                }

                html += `
                    <div style="background: var(--bg-secondary); padding: 10px; border-radius: 8px; border-left: 3px solid ${color}; text-align: center;">
                        <div style="font-size: 0.7rem; color: var(--text-secondary); margin-bottom: 3px;">${productType}</div>
                        <div style="font-size: 1rem; font-weight: 700; color: ${color};">${icon} ${label}</div>
                        <div style="font-size: 0.7rem; color: var(--text-secondary);">${sublabel}</div>
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        function openRTAManager() {
            renderRTAQualificationStatus();
            renderRTAManagerContent();
            checkRTAStatus();
            renderRTAQuickStatus();
            document.getElementById('rtaManagerModal').style.display = 'block';
        }

        function closeRTAManager() {
            document.getElementById('rtaManagerModal').style.display = 'none';
        }

        // Render RTA Manager content
        function renderRTAManagerContent() {
            const container = document.getElementById('rtaManagerContent');
            if (!container) return;

            const rtaStatus = getRTAStatus();
            const today = new Date();

            let html = '';

            Object.entries(rtaStatus).forEach(([productType, status]) => {
                let statusBadge, actionButtons;

                switch (status.status) {
                    case 'active':
                        const expires = new Date(status.rtaExpires);
                        const daysLeft = Math.floor((expires - today) / (1000 * 60 * 60 * 24));
                        statusBadge = `<span style="background: var(--accent-green); color: white; padding: 3px 10px; border-radius: 12px; font-size: 0.8rem;"> Active - ${daysLeft} days left</span>`;
                        actionButtons = `<button class="btn" style="padding: 5px 10px; font-size: 0.85rem; background: var(--accent-red);" onclick="simulateFailure('${productType}')">Record Failed Test</button>`;
                        break;
                    case 'qualifying':
                        const pendingCount = status.pendingBatches ? status.pendingBatches.length : 0;
                        statusBadge = `<span style="background: var(--accent-blue); color: white; padding: 3px 10px; border-radius: 12px; font-size: 0.8rem;"> Qualifying: ${status.consecutivePasses}/4</span>${pendingCount > 0 ? ` <span style="background: var(--accent-orange); color: white; padding: 3px 10px; border-radius: 12px; font-size: 0.8rem;"> ${pendingCount} untested batches</span>` : ''}`;
                        const pendingList = status.pendingBatches && status.pendingBatches.length > 0
                            ? '<div style="margin-top: 10px; padding: 10px; background: rgba(255,165,0,0.1); border-radius: 8px; border-left: 3px solid var(--accent-orange);"><strong> Untested batches:</strong><br>' + status.pendingBatches.join(', ') + '</div>'
                            : '';
                        actionButtons = `
                            <button class="btn" style="padding: 5px 10px; font-size: 0.85rem; background: var(--accent-green);" onclick="recordRTAResult('${productType}', 'manual', 'pass')">+ Record Pass</button>
                            <button class="btn" style="padding: 5px 10px; font-size: 0.85rem; background: var(--accent-red);" onclick="recordRTAResult('${productType}', 'manual', 'fail')">Record Fail</button>
                            ${pendingList}
                        `;
                        break;
                    case 'reauthorizing':
                        statusBadge = `<span style="background: var(--accent-orange); color: white; padding: 3px 10px; border-radius: 12px; font-size: 0.8rem;"> Reauth: ${status.consecutivePasses}/5</span>`;
                        actionButtons = `
                            <button class="btn" style="padding: 5px 10px; font-size: 0.85rem; background: var(--accent-green);" onclick="recordRTAResult('${productType}', 'manual', 'pass')">+ Record Pass</button>
                            <button class="btn" style="padding: 5px 10px; font-size: 0.85rem; background: var(--accent-red);" onclick="recordRTAResult('${productType}', 'manual', 'fail')">Record Fail</button>
                        `;
                        break;
                    default:
                        statusBadge = `<span style="background: var(--bg-tertiary); color: var(--text-secondary); padding: 3px 10px; border-radius: 12px; font-size: 0.8rem;"> Not Started</span>`;
                        actionButtons = `<button class="btn" style="padding: 5px 10px; font-size: 0.85rem; background: var(--accent-purple);" onclick="startRTAQualification('${productType}')">Start Qualification</button>`;
                }

                html += `
                    <div style="background: var(--bg-tertiary); padding: 15px; border-radius: 10px; margin-bottom: 15px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <h4 style="margin: 0; color: var(--text-primary);">${productType}</h4>
                            ${statusBadge}
                        </div>
                        <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                            ${actionButtons}
                        </div>
                        ${status.history && status.history.length > 0 ? `
                            <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid var(--bg-secondary);">
                                <div style="font-size: 0.8rem; color: var(--text-secondary);">Recent: ${status.history.slice(-3).map(h =>
                                    '<span style="color: ' + (h.result === 'pass' ? 'var(--accent-green)' : 'var(--accent-red)') + ';">' + (h.result === 'pass' ? '' : '') + '</span>'
                                ).join(' ')}</div>
                            </div>
                        ` : ''}
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        // Simulate a failure for active RTA (for manual tracking)
        function simulateFailure(productType) {
            if (confirm('Record a FAILED full panel test for ' + productType + '?\n\nThis will require 5 consecutive passing batches to reauthorize.')) {
                recordRTAResult(productType, 'manual-fail', 'fail');
                renderRTAManagerContent();
            }
        }

        // Reset all RTA status
        function resetAllRTA() {
            if (confirm(' Reset ALL RTA status?\n\nThis will clear all qualification progress and history.')) {
                localStorage.removeItem('wm_rta_status');
                renderRTAQualificationStatus();
                renderRTAManagerContent();
                alert('All RTA status has been reset.');
            }
        }

        // Initialize RTA status display on page load
        document.addEventListener('DOMContentLoaded', function() {
            setTimeout(async () => {
                await loadRTAFromSupabase();
                renderRTAQuickStatus();
            }, 1000);
        });

        // Check RTA status and show reminder if needed - BY EXTRACTION METHOD
        function checkRTAStatus() {
            const rtaBatches = batches.filter(b => b.is_rta === 'yes' && b.test_submitted_date);
            
            const today = new Date();
            
            // Track BHO and Brick Hash/Dry Sift separately
            const bhoRTAs = rtaBatches.filter(b => b.extraction_method === 'BHO' && !isLiveResinBatch(b));
            const hashRTAs = rtaBatches.filter(b => b.extraction_method === 'Dry Sift' || b.extraction_method === 'Brick Hash');

            // Live Resin Carts and AIOs tracked separately
            const cartsRTAs = rtaBatches.filter(b => {
                const products = b.planned_products || [];
                const productMade = (b.product_made || '').toLowerCase();
                return isLiveResinBatch(b) && (
                    products.some(p => (p.type || p).toLowerCase().includes('cart')) ||
                    productMade.includes('cart') ||
                    productMade === 'live resin oil'
                );
            });

            const aiosRTAs = rtaBatches.filter(b => {
                const products = b.planned_products || [];
                const productMade = (b.product_made || '').toLowerCase();
                return isLiveResinBatch(b) && (
                    products.some(p => (p.type || p).toLowerCase().includes('aio') || (p.type || p).toLowerCase().includes('all-in-one')) ||
                    productMade.includes('aio') ||
                    productMade.includes('all-in-one') ||
                    productMade.includes('all in one')
                );
            });
            
            let reminderHTML = '<div style="display: grid; gap: 15px;">';
            
            // Check BHO RTA Status
            reminderHTML += checkMethodRTA(bhoRTAs, 'BHO (Wax/Shatter/Sugar)', today);
            
            // Check Hash RTA Status
            reminderHTML += checkMethodRTA(hashRTAs, 'Brick Hash / Dry Sift', today);

            // Check Live Resin Carts RTA Status
            reminderHTML += checkMethodRTA(cartsRTAs, 'Live Resin Carts', today);

            // Check Live Resin AIOs RTA Status
            reminderHTML += checkMethodRTA(aiosRTAs, 'Live Resin AIOs', today);
            
            reminderHTML += '</div>';
            
            document.getElementById('rtaReminder').innerHTML = reminderHTML;
        }
        
        function checkMethodRTA(rtaBatches, methodName, today) {
            if (rtaBatches.length === 0) {
                return `
                    <div style="background: rgba(239, 68, 68, 0.2); border: 2px solid var(--accent-red); padding: 20px; border-radius: 10px;">
                        <h3 style="color: var(--accent-red); margin-bottom: 10px;"> ${methodName} - No RTA Submitted</h3>
                        <p style="color: var(--text-primary);">You must submit at least one RTA full panel per month for ${methodName}.</p>
                    </div>
                `;
            }
            
            // Get most recent RTA for this method
            rtaBatches.sort((a, b) => new Date(b.test_submitted_date) - new Date(a.test_submitted_date));
            const lastRTA = rtaBatches[0];
            const lastRTADate = new Date(lastRTA.test_submitted_date);
            
            // Check if next RTA is due (30 days)
            const nextRTADue = new Date(lastRTADate);
            nextRTADue.setDate(nextRTADue.getDate() + 30);
            
            const daysUntilDue = Math.floor((nextRTADue - today) / (1000 * 60 * 60 * 24));
            
            if (daysUntilDue < 0) {
                // Overdue
                return `
                    <div style="background: rgba(239, 68, 68, 0.2); border: 2px solid var(--accent-red); padding: 20px; border-radius: 10px;">
                        <h3 style="color: var(--accent-red); margin-bottom: 10px;"> ${methodName} RTA OVERDUE!</h3>
                        <p style="color: var(--text-primary); margin-bottom: 10px;">Last RTA: ${lastRTA.id} (${lastRTADate.toLocaleDateString()}) - ${Math.abs(daysUntilDue)} days overdue</p>
                        <p style="color: var(--text-primary); font-weight: 700;">Submit new ${methodName} RTA immediately!</p>
                    </div>
                `;
            } else if (daysUntilDue <= 7) {
                // Due soon
                return `
                    <div style="background: rgba(245, 158, 11, 0.2); border: 2px solid var(--accent-orange); padding: 20px; border-radius: 10px;">
                        <h3 style="color: var(--accent-orange); margin-bottom: 10px;"> ${methodName} RTA Due Soon</h3>
                        <p style="color: var(--text-primary); margin-bottom: 10px;">Last RTA: ${lastRTA.id} (${lastRTADate.toLocaleDateString()})</p>
                        <p style="color: var(--text-primary); font-weight: 700;">Next ${methodName} RTA due in ${daysUntilDue} days (${nextRTADue.toLocaleDateString()})</p>
                    </div>
                `;
            } else {
                // All good
                return `
                    <div style="background: rgba(16, 185, 129, 0.2); border: 2px solid var(--accent-green); padding: 20px; border-radius: 10px;">
                        <h3 style="color: var(--accent-green); margin-bottom: 10px;"> ${methodName} RTA: Current</h3>
                        <p style="color: var(--text-primary); margin-bottom: 10px;">Last RTA: ${lastRTA.id} (${lastRTADate.toLocaleDateString()})</p>
                        <p style="color: var(--text-primary);">Next due: ${nextRTADue.toLocaleDateString()} (${daysUntilDue} days)</p>
                    </div>
                `;
            }
        }

        // Mark batch as extraction complete / ready for testing
        async function markReadyForTesting() {
            try {
            if (!currentRole) {
                alert('Please select a user first!');
                return;
            }

            const batchId = document.getElementById('testingBatchSelect').value;
            const batch = batches.find(b => b.id === batchId);

            if (!batch) {
                alert('Please select a batch first!');
                return;
            }

            // Get form values
            const finalProductName = document.getElementById('finalProductName').value.trim();
            const finalConsistency = document.getElementById('finalConsistency').value;
            const finalStrainType = document.getElementById('finalStrainType').value;
            const newBatchId = document.getElementById('newBatchId').value.trim();

            // Check if already marked by looking at timeline
            const hasExtractionComplete = batch.timeline?.some(t => t.stage === 'ready_for_testing' || t.stage === 'product_update');
            const isUpdate = hasExtractionComplete || batch.test_submitted_date;

            // Validate required fields
            if (!finalProductName) {
                alert('Please enter a product name.');
                return;
            }
            if (!finalConsistency) {
                alert('Please select a product type.');
                return;
            }

            // Check if batch ID is changing
            let batchIdChanged = false;
            let oldBatchId = batchId;
            if (newBatchId && newBatchId !== batchId) {
                const existingBatch = batches.find(b => b.id === newBatchId);
                if (existingBatch) {
                    alert(`Error: Batch ID "${newBatchId}" already exists. Please use a different ID.`);
                    return;
                }
                batchIdChanged = true;
            }

            // Build confirmation message
            let confirmMsg = isUpdate
                ? `Update product info for batch ${batchId}?\n\n`
                : `Finalize batch ${batchId} as Extraction Complete?\n\n`;
            confirmMsg += `Product Name: ${finalProductName}\n`;
            confirmMsg += `Consistency: ${finalConsistency}\n`;
            confirmMsg += `Strain Type: ${finalStrainType}\n`;
            if (batchIdChanged) {
                confirmMsg += `\nNEW BATCH ID: ${newBatchId}\n`;
            }
            if (!isUpdate) {
                confirmMsg += `\nThis marks the batch as ready for lab submission.`;
            }

            if (!confirm(confirmMsg)) return;

            const now = new Date().toISOString();

            // Build timeline notes
            const strainTypeNote = batch.strain_type !== finalStrainType ? ` | Redesignated: ${batch.strain_type}  ${finalStrainType}` : '';
            const batchIdNote = batchIdChanged ? ` | Batch ID: ${oldBatchId}  ${newBatchId}` : '';

            // Add timeline entry
            const timeline = batch.timeline || [];
            const timelineAction = isUpdate
                ? `Updated product info - ${finalProductName} (${finalConsistency})${strainTypeNote}${batchIdNote}`
                : `Extraction Complete - ${finalProductName} (${finalConsistency})${strainTypeNote}${batchIdNote}`;
            timeline.push({
                stage: isUpdate ? 'product_update' : 'ready_for_testing',
                user: currentRole.name,
                date: now,
                action: timelineAction
            });

            // Build update object - use existing columns that we know exist
            const updates = {
                strain: finalProductName,        // Save product name to strain column
                product_made: finalConsistency,  // Use existing product_made column
                strain_type: finalStrainType,    // Use existing strain_type column
                timeline: timeline
                // Don't change status - batch stays in its current workflow stage
            };


            // Handle batch ID change
            if (batchIdChanged) {
                // Delete old record and insert new one with new ID
                const { error: deleteError } = await supabaseClient
                    .from('wm_batches')
                    .delete()
                    .eq('id', oldBatchId);

                if (deleteError) {
                    console.error('Error deleting old batch:', deleteError);
                    alert('Error updating batch ID. Please try again.');
                    return;
                }

                // Create new record with new ID
                const newBatchData = { ...batch, ...updates, id: newBatchId };
                delete newBatchData.created_at; // Let Supabase handle this

                const { error: insertError } = await supabaseClient
                    .from('wm_batches')
                    .insert(newBatchData);

                if (insertError) {
                    console.error('Error creating new batch:', insertError);
                    alert('Error creating batch with new ID. Please try again.');
                    return;
                }

                // Update local array
                const batchIndex = batches.findIndex(b => b.id === oldBatchId);
                if (batchIndex !== -1) {
                    batches[batchIndex] = { ...batch, ...updates, id: newBatchId };
                }

                // Update dropdown
                populateTestingSelect();
                document.getElementById('testingBatchSelect').value = newBatchId;
                document.getElementById('currentBatchIdDisplay').textContent = newBatchId;

            } else {
                // Simple update
                const { error } = await supabaseClient
                    .from('wm_batches')
                    .update(updates)
                    .eq('id', batchId);

                if (error) {
                    console.error('Error marking ready for testing:', error);
                    alert(`Error updating batch: ${error.message}`);
                    return;
                }

                // Update local batch
                Object.assign(batch, updates);
            }

            // Update UI
            const updatedBatch = batches.find(b => b.id === (batchIdChanged ? newBatchId : batchId));
            updateReadyForTestingUI(updatedBatch);

            // Refresh the batch details display
            refreshBatchDetails(updatedBatch);

            const successMsg = isUpdate
                ? `Product info updated for ${batchIdChanged ? newBatchId : batchId}!\n\n${finalProductName} (${finalConsistency})`
                : `Batch ${batchIdChanged ? newBatchId : batchId} finalized!\n\n${finalProductName} (${finalConsistency})\nReady for lab submission.`;
            alert(successMsg);

            } catch (err) {
                console.error('Exception in markReadyForTesting:', err);
                alert('Error: ' + err.message);
            }
        }

        // Update the ready for testing UI based on batch status (simplified version)
        function updateReadyForTestingUI(batch) {
            // This function is now simplified - status is shown in the batch info header
            // No longer need the old complex status div
        }

        // Allow editing finalize info even after marked (legacy function - now simplified)
        function editFinalizeInfo() {
            // No longer needed in simplified UI
        }

        // Refresh the batch details display after update
        function refreshBatchDetails(batch) {
            // Calculate trim info
            let trimUsedInfo = '';
            if (batch.is_sub_batch && batch.parent_batch_id) {
                const parentBatch = batches.find(b => b.id === batch.parent_batch_id);
                if (parentBatch) {
                    const parentTrimWeight = parseFloat(parentBatch.adjusted_trim_weight || parentBatch.trim_weight || 0);
                    const parentTotalOutput = parseFloat(parentBatch.final_weight || parentBatch.net_weight || 0);
                    const thisBatchWeight = parseFloat(batch.final_weight || batch.net_weight || 0);
                    if (parentTotalOutput > 0) {
                        const trimUsed = (thisBatchWeight / parentTotalOutput) * parentTrimWeight;
                        const yieldPercent = (thisBatchWeight / trimUsed) * 100;
                        trimUsedInfo = `<p><strong>Trim Used:</strong> ${trimUsed.toFixed(1)}g</p><p><strong>Yield %:</strong> ${yieldPercent.toFixed(2)}%</p>`;
                    }
                }
            } else {
                const trimWeight = parseFloat(batch.adjusted_trim_weight || batch.trim_weight || 0);
                const finalWeight = parseFloat(batch.final_weight || batch.net_weight || 0);
                const yieldPercent = trimWeight > 0 ? (finalWeight / trimWeight) * 100 : 0;
                trimUsedInfo = `<p><strong>Trim Used:</strong> ${trimWeight.toFixed(1)}g</p><p><strong>Yield %:</strong> ${yieldPercent.toFixed(2)}%</p>`;
            }

            const details = `
                <p><strong>Strain:</strong> ${batch.strain} (${batch.strain_type})</p>
                <p><strong>Product:</strong> ${batch.product_made || 'N/A'}</p>
                <p><strong>Net Weight:</strong> ${batch.net_weight || batch.final_weight || 'N/A'}g</p>
                ${trimUsedInfo}
                <div style="background: rgba(245, 158, 11, 0.2); padding: 12px; border-radius: 8px; margin: 10px 0; border-left: 4px solid var(--accent-orange);">
                    <p style="margin: 0;"><strong style="color: var(--accent-orange);"> METRC Tags:</strong> <span style="font-family: 'Space Mono', monospace; font-size: 1.1rem; font-weight: 700;">${batch.metrc_tags && batch.metrc_tags.trim() !== '' ? batch.metrc_tags : 'Not entered at intake'}</span></p>
                </div>
                <p><strong>Cultivation License:</strong> ${batch.cultivation_license}</p>
                <p><strong>Grower:</strong> ${batch.grower_name || 'N/A'}</p>
                <p><strong>Status:</strong> ${batch.status}</p>
                ${batch.test_submitted_date ? `<p><strong>Previously Submitted:</strong> ${batch.test_submitted_date}</p>` : ''}
            `;
            document.getElementById('testBatchDetails').innerHTML = details;
        }

        async function submitTestResults() {
            if (blockDemoWrite('Submitting test results')) return;

            if (!currentRole) {
                alert('Please select a user first!');
                return;
            }

            const batchId = document.getElementById('testingBatchSelect').value;
            const batch = batches.find(b => b.id === batchId);
            
            if (!batch) return;
            
            const thcPercent = parseFloat(document.getElementById('testThcPercent').value) || null;
            const cbdPercent = parseFloat(document.getElementById('testCbdPercent').value) || null;
            const isRTA = document.getElementById('isRTA').value;
            const submittedDate = document.getElementById('testSubmittedDate').value;
            const expirationDate = document.getElementById('testExpirationDate').value;
            const newBatchId = document.getElementById('newBatchId').value.trim();
            const finalProductName = document.getElementById('finalProductName').value.trim();
            const finalStrainType = document.getElementById('finalStrainType').value;
            
            if (!finalProductName) {
                alert('Please enter a product name for this batch.');
                return;
            }
            
            // Check if new batch ID is being assigned
            let batchIdChanged = false;
            let oldBatchId = batchId;
            if (newBatchId && newBatchId !== batchId) {
                // Verify new batch ID doesn't already exist
                const existingBatch = batches.find(b => b.id === newBatchId);
                if (existingBatch) {
                    alert(`Error: Batch ID "${newBatchId}" already exists in the system. Please choose a different ID.`);
                    return;
                }
                
                const confirmChange = confirm(
                    ` BATCH ID REASSIGNMENT\n\n` +
                    `Current ID: ${oldBatchId}\n` +
                    `New ID: ${newBatchId}\n\n` +
                    `This will permanently change the batch ID in the system.\n\n` +
                    `Continue?`
                );
                
                if (!confirmChange) return;
                
                batchIdChanged = true;
            }
            
            // Show redesignation note in timeline if strain type changed
            const strainTypeNote = batch.strain_type !== finalStrainType ? ` | Redesignated: ${batch.strain_type}  ${finalStrainType}` : '';
            const batchIdNote = batchIdChanged ? ` | Batch ID reassigned: ${oldBatchId}  ${newBatchId}` : '';
            
            const timeline = batch.timeline || [];
            const resultsText = thcPercent !== null ? `THC ${thcPercent}%, CBD ${cbdPercent || 0}%` : 'Test submitted - results pending';
            timeline.push({
                stage: 'testing',
                user: currentRole ? currentRole.name : "Unknown",
                date: new Date().toISOString(),
                action: `${resultsText}${isRTA === 'yes' ? ' - RTA FULL PANEL' : ''} | Named: ${finalProductName}${strainTypeNote}${batchIdNote}`
            });
            
            // Build update object - only include fields that exist in database
            const updates = {
                test_submitted_date: submittedDate,
                test_expiration_date: expirationDate,
                test_thc_percent: thcPercent,
                test_cbd_percent: cbdPercent,
                is_rta: isRTA,
                test_results_notes: document.getElementById('testResultsNotes').value || null,
                timeline: timeline
            };
            
            // Update the batch strain name and strain_type to reflect the final product
            // This makes batch IDs display the actual wholesale product name
            updates.strain = finalProductName;
            updates.strain_type = finalStrainType;
            
            // Store product info in notes for now until we add columns
            const productInfo = `\n\n[PRODUCT INFO]\nOriginal Strain: ${batch.strain}\nOriginal Type: ${batch.strain_type}\nFinal Name: ${finalProductName}\nFinal Type: ${finalStrainType}`;
            updates.test_results_notes = (updates.test_results_notes || '') + productInfo;
            
            // If this is a bulk sale, mark as complete and skip labeling
            if (batch.packaged_product_type === 'Bulk Sale') {
                updates.status = 'complete';
                updates.labels_applied = true;
                updates.labeling_date = new Date().toISOString().split('T')[0];
                updates.labeling_user = currentRole ? currentRole.name : "Unknown";
                updates.labeling_notes = 'Bulk sale - labeling not required';
                updates.completed_at = new Date().toISOString();
                timeline.push({
                    stage: 'complete',
                    user: currentRole ? currentRole.name : "Unknown",
                    date: new Date().toISOString(),
                    action: 'Bulk sale completed after testing - labeling skipped'
                });
                updates.timeline = timeline;
            }
            
            // If batch ID is being changed, we need to handle it specially
            if (batchIdChanged) {
                // Add new batch ID to updates
                updates.id = newBatchId;
                
                // First, insert a new record with the new ID
                const { error: insertError } = await supabaseClient
                    .from('wm_batches')
                    .insert({
                        ...batch,
                        ...updates,
                        id: newBatchId
                    });
                
                if (insertError) {
                    console.error('Error creating new batch with new ID:', insertError);
                    alert('Error reassigning batch ID. Please try again.');
                    return;
                }
                
                // Then delete the old record
                const { error: deleteError } = await supabaseClient
                    .from('wm_batches')
                    .delete()
                    .eq('id', oldBatchId);
                
                if (deleteError) {
                    console.error('Error deleting old batch record:', deleteError);
                    alert('Warning: New batch created but old batch could not be removed. You may need to manually delete batch ' + oldBatchId);
                }
            } else {
                // Normal update without ID change
                const { error } = await supabaseClient
                    .from('wm_batches')
                    .update(updates)
                    .eq('id', batchId);

                if (error) {
                    console.error('Error updating test results:', error);
                    alert('Error saving test results. Please try again.');
                    return;
                }
            }

            // Update 50/50 split tracking for bulk sales that are now complete (non-blocking)
            if (batch.packaged_product_type === 'Bulk Sale' &&
                (batch.material_agreement === '50/50 Split' || batch.material_agreement === '50-50 Split')) {
                try {
                    const updatedBatch = { ...batch, ...updates, id: batchIdChanged ? newBatchId : batchId };
                    await update5050SplitFinished(updatedBatch);
                } catch (splitErr) {
                    console.warn('50/50 split tracking failed (non-critical):', splitErr);
                }
            }

            // Apply test results to any 4g sub-batches (they share the same test)
            const finalBatchIdForSubBatch = batchIdChanged ? newBatchId : batchId;
            const subBatches = batches.filter(b => b.parent_batch_id === batchId || b.parent_batch_id === finalBatchIdForSubBatch);

            if (subBatches.length > 0) {
                for (const subBatch of subBatches) {
                    const subBatchTimeline = subBatch.timeline || [];
                    subBatchTimeline.push({
                        stage: 'testing',
                        user: currentRole ? currentRole.name : "Unknown",
                        date: new Date().toISOString(),
                        action: `Test results applied from parent batch ${finalBatchIdForSubBatch}: THC ${thcPercent}%, CBD ${cbdPercent || 0}%`
                    });

                    const subBatchUpdates = {
                        test_submitted_date: submittedDate,
                        test_expiration_date: expirationDate,
                        test_thc_percent: thcPercent,
                        test_cbd_percent: cbdPercent,
                        is_rta: isRTA,
                        strain: finalProductName,
                        strain_type: finalStrainType,
                        timeline: subBatchTimeline
                    };

                    // Update parent_batch_id if the parent's ID changed
                    if (batchIdChanged) {
                        subBatchUpdates.parent_batch_id = newBatchId;
                    }

                    const { error: subBatchError } = await supabaseClient
                        .from('wm_batches')
                        .update(subBatchUpdates)
                        .eq('id', subBatch.id);

                    if (subBatchError) {
                        console.error(`Error updating sub-batch ${subBatch.id}:`, subBatchError);
                    }
                }
            }

            const lidColor = finalStrainType === 'Indica' ? 'Blue' : finalStrainType === 'Sativa' ? 'Red' : 'Green';
            const resultsInfo = thcPercent !== null ? `\nTHC: ${thcPercent}% | CBD: ${cbdPercent || 0}%` : '\nTest submitted - awaiting results';
            const finalBatchId = batchIdChanged ? newBatchId : batchId;
            const batchChangeMsg = batchIdChanged ? `\n Batch ID changed: ${oldBatchId}  ${newBatchId}` : '';
            const subBatchMsg = subBatches.length > 0 ? `\n Test results also applied to: ${subBatches.map(s => s.id).join(', ')}` : '';
            alert(`Test results saved for ${finalBatchId}!${batchChangeMsg}${subBatchMsg}\n\nProduct Name: ${finalProductName}\nStrain Type: ${finalStrainType} (${lidColor} Lid)${strainTypeNote ? '\n Strain type redesignated' : ''}${resultsInfo}\n${isRTA === 'yes' ? ' RTA Full Panel' : 'Standard Potency'}\nExpires: ${expirationDate}`);
            
            document.getElementById('testingForm').style.display = 'none';
            document.getElementById('testingBatchSelect').value = '';
            
            await loadBatches();
            populateTestingSelect();
            checkRTAStatus();
        }

        // Toggle connection type UI
        function toggleConnectionType() {
            const type = document.getElementById('connectionType').value;
            document.getElementById('networkIPGroup').style.display = type === 'network' ? 'block' : 'none';
            document.getElementById('networkPortGroup').style.display = type === 'network' ? 'block' : 'none';
        }

        function savePrintSettings() {
            const printServerURL = document.getElementById('printServerURL').value;
            if (printServerURL) {
                localStorage.setItem('printServerURL', printServerURL);
                alert('Print server settings saved!\n\nMake sure the print server is running on that computer.');
            } else {
                localStorage.setItem('printServerURL', 'http://localhost:3000/print');
                alert('Using default localhost print server.');
            }
        }

        function populateLabelingSelect() {
            const select = document.getElementById('labelingBatchSelect');
            // Show batches that are complete and have test results, but haven't been labeled yet
            const labelableBatches = batches.filter(b =>
                b.status === 'complete' &&
                b.test_thc_percent &&
                !b.labels_applied
            );

            select.innerHTML = '<option value="">Select a batch...</option>';
            labelableBatches.forEach(batch => {
                const pauseIndicator = batch.labeling_paused ? '  PAUSED' : '';
                const workerIndicator = batch.labeling_user ? `  ${batch.labeling_user.split(' ')[0]}` : '';
                select.innerHTML += `<option value="${batch.id}">${batch.id} - ${batch.strain} - ${batch.packaged_product_type} (${batch.units_packaged} units)${workerIndicator}${pauseIndicator}</option>`;
            });
            
            // Load saved settings
            const savedURL = localStorage.getItem('printServerURL');
            if (savedURL) {
                document.getElementById('printServerURL').value = savedURL;
            }
        }

        document.getElementById('labelingBatchSelect').addEventListener('change', function() {
            const form = document.getElementById('labelingForm');
            form.style.display = this.value ? 'block' : 'none';

            if (this.value) {
                const batch = batches.find(b => b.id === this.value);
                displayLabelPreview(batch);

                // Determine which unit input sections to show
                const units1g = parseInt(batch.units_1g) || 0;
                const units4g = parseInt(batch.units_4g) || 0;
                const hasBreakdown = units1g > 0 || units4g > 0;

                // Show/hide appropriate sections
                document.getElementById('units1gSection').style.display = units1g > 0 ? 'block' : 'none';
                document.getElementById('units4gSection').style.display = units4g > 0 ? 'block' : 'none';
                document.getElementById('unitsGenericSection').style.display = hasBreakdown ? 'none' : 'block';

                // Show/hide print sections and set default quantities
                document.getElementById('print1gSection').style.display = units1g > 0 ? 'block' : 'none';
                document.getElementById('print4gSection').style.display = units4g > 0 ? 'block' : 'none';
                document.getElementById('print1gQty').value = units1g || '';
                document.getElementById('print4gQty').value = units4g || '';
                document.getElementById('labelPrintStatus').style.display = 'none';

                // Populate expected values
                document.getElementById('expected1gUnits').textContent = units1g;
                document.getElementById('expected4gUnits').textContent = units4g;
                document.getElementById('expectedUnits').textContent = parseInt(batch.units_packaged) || 0;

                // Set total expected
                const totalExpected = hasBreakdown ? (units1g + units4g) : (parseInt(batch.units_packaged) || 0);
                document.getElementById('totalExpectedUnits').textContent = totalExpected;
                document.getElementById('totalLabeledUnits').textContent = '-';

                // Clear inputs
                document.getElementById('units1gLabeled').value = '';
                document.getElementById('units4gLabeled').value = '';
                document.getElementById('unitsLabeled').value = '';
                document.getElementById('acceptDiscrepancy').checked = false;
                document.getElementById('discrepancyAlert').style.display = 'none';

                // Update pause button visibility
                updatePauseButtons();
            }
        });

        // Helper function to update labeling totals and discrepancy
        function updateLabelingTotals() {
            const batchId = document.getElementById('labelingBatchSelect').value;
            const batch = batches.find(b => b.id === batchId);
            if (!batch) return;

            const units1g = parseInt(batch.units_1g) || 0;
            const units4g = parseInt(batch.units_4g) || 0;
            const hasBreakdown = units1g > 0 || units4g > 0;

            let totalLabeled = 0;
            let totalExpected = 0;

            if (hasBreakdown) {
                const labeled1g = parseInt(document.getElementById('units1gLabeled').value) || 0;
                const labeled4g = parseInt(document.getElementById('units4gLabeled').value) || 0;
                totalLabeled = labeled1g + labeled4g;
                totalExpected = units1g + units4g;
            } else {
                totalLabeled = parseInt(document.getElementById('unitsLabeled').value) || 0;
                totalExpected = parseInt(batch.units_packaged) || 0;
            }

            document.getElementById('totalLabeledUnits').textContent = totalLabeled || '-';

            // Check for discrepancy
            const discrepancy = Math.abs(totalLabeled - totalExpected);
            const discrepancyAlert = document.getElementById('discrepancyAlert');

            if (discrepancy > 0 && totalLabeled > 0) {
                discrepancyAlert.style.display = 'block';
                let detailsHtml = '';
                if (hasBreakdown) {
                    const labeled1g = parseInt(document.getElementById('units1gLabeled').value) || 0;
                    const labeled4g = parseInt(document.getElementById('units4gLabeled').value) || 0;
                    if (units1g > 0) detailsHtml += `<div>1g: Expected ${units1g}, Labeled ${labeled1g}</div>`;
                    if (units4g > 0) detailsHtml += `<div>4g: Expected ${units4g}, Labeled ${labeled4g}</div>`;
                } else {
                    detailsHtml = `<div>Expected: <strong>${totalExpected} units</strong></div>
                                   <div>Labeled: <strong>${totalLabeled} units</strong></div>`;
                }
                detailsHtml += `<div style="color: var(--accent-orange); font-weight: 700; margin-top: 8px;">Total Difference: ${discrepancy} unit${discrepancy !== 1 ? 's' : ''}</div>`;
                document.getElementById('discrepancyDetails').innerHTML = detailsHtml;
            } else {
                discrepancyAlert.style.display = 'none';
                document.getElementById('acceptDiscrepancy').checked = false;
            }
        }

        // Real-time units comparison for labeling - attach to all input fields
        ['units1gLabeled', 'units4gLabeled', 'unitsLabeled'].forEach(id => {
            const input = document.getElementById(id);
            if (input) {
                input.addEventListener('input', updateLabelingTotals);
            }
        });


        function displayLabelPreview(batch) {
            const preview = document.getElementById('labelPreview');
            preview.innerHTML = `
                <div>
                    <div style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 5px;">PRODUCT</div>
                    <div style="font-weight: 700;">${batch.packaged_product_type}</div>
                </div>
                <div>
                    <div style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 5px;">STRAIN</div>
                    <div style="font-weight: 700;">${batch.strain}</div>
                </div>
                <div>
                    <div style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 5px;">BATCH ID</div>
                    <div style="font-weight: 700; color: var(--accent-purple);">${batch.id}</div>
                </div>
                <div>
                    <div style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 5px;">THC</div>
                    <div style="font-weight: 700; color: var(--accent-green);">${batch.test_thc_percent}%</div>
                </div>
                <div>
                    <div style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 5px;">CBD</div>
                    <div style="font-weight: 700;">${batch.test_cbd_percent || 0}%</div>
                </div>
                <div>
                    <div style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 5px;">EXPIRES</div>
                    <div style="font-weight: 700;">${batch.test_expiration_date ? new Date(batch.test_expiration_date).toLocaleDateString() : 'N/A'}</div>
                </div>
                <div>
                    <div style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 5px;">UNITS</div>
                    <div style="font-weight: 700;">${batch.units_packaged}</div>
                </div>
                ${batch.packaging_breakdown ? `
                <div>
                    <div style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 5px;">SIZES</div>
                    <div style="font-weight: 700;">${batch.packaging_breakdown}</div>
                </div>
                ` : ''}
            `;
        }

        // Open printable label popup
        function openPrintableLabels() {
            const batchId = document.getElementById('labelingBatchSelect').value;
            const batch = batches.find(b => b.id === batchId);
            
            if (!batch) {
                alert('Please select a batch first');
                return;
            }
            
            const quantity = batch.units_packaged || 1;
            
            // Format expiration date
            let expDate = 'N/A';
            if (batch.test_expiration_date) {
                const d = new Date(batch.test_expiration_date);
                expDate = `${d.getMonth() + 1}/${d.getDate()}/${d.getFullYear().toString().slice(-2)}`;
            }
            
            // Determine net weight
            let netWeight = '1 GRAM';
            if (batch.packaged_product_type.includes('4g')) {
                netWeight = '4 GRAM';
            } else if (batch.packaged_product_type.includes('0.5')) {
                netWeight = '0.5 GRAM';
            }
            
            const thc = parseFloat(batch.test_thc_percent) || 0;
            const cbd = parseFloat(batch.test_cbd_percent) || 0;
            const cultivationLicense = batch.cultivation_license || '403R-01007';
            const extractionLicense = '404R-00016';
            
            // Create labels array
            let labelsHTML = '';
            for (let i = 0; i < quantity; i++) {
                labelsHTML += `
                    <div class="label">
                        <div class="product-type">${batch.packaged_product_type.toUpperCase()}</div>
                        <div class="strain">${batch.strain.toUpperCase()}</div>
                        <div class="cannabinoids">
                            <div class="cannabinoid-box">
                                <div>TOTAL THC: ${thc.toFixed(1)}%</div>
                                <div>TOTAL CBD: ${cbd.toFixed(1)}%</div>
                            </div>
                        </div>
                        <div class="licenses">
                            <div>CULTIVATED BY ${cultivationLicense}</div>
                            <div>EXTRACTED BY ${extractionLicense}</div>
                        </div>
                        <div class="warnings">
                            <div>INTENDED USE: INHALED PRODUCT.</div>
                            <div>NOT APPROVED BY THE FDA.</div>
                        </div>
                        <div class="net-weight">NET WEIGHT: ${netWeight}</div>
                        <div class="serving">SERVING SIZE: </div>
                        <div class="batch-id">BATCH ${batch.id}</div>
                        <div class="expiration">USE BY ${expDate}</div>
                    </div>
                `;
            }
            
            // Create popup window
            const popup = window.open('', 'PrintLabels', 'width=800,height=600');
            popup.document.write(`
<!DOCTYPE html>
<html>
<head>
    <title>Print Labels - ${batch.id}</title>
    <style>
        @media print {
            @page {
                size: 1.77in 1.77in;
                margin: 0;
            }
            body {
                margin: 0;
                padding: 0;
            }
            .no-print {
                display: none;
            }
            .label {
                page-break-after: always;
                page-break-inside: avoid;
            }
        }
        
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f0f0f0;
        }
        
        .no-print {
            background: white;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .no-print h1 {
            margin: 0 0 10px 0;
            color: #333;
        }
        
        .no-print button {
            background: #9333ea;
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 16px;
            border-radius: 6px;
            cursor: pointer;
            margin-right: 10px;
        }
        
        .no-print button:hover {
            background: #7c2db8;
        }
        
        .labels-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, 1.77in);
            gap: 20px;
            justify-content: center;
        }
        
        .label {
            width: 1.77in;
            height: 1.77in;
            border: 2px solid #333;
            border-radius: 50%;
            background: white;
            padding: 8px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            position: relative;
        }
        
        .product-type {
            font-size: 9pt;
            font-weight: bold;
            margin-bottom: 2px;
        }
        
        .strain {
            font-size: 14pt;
            font-weight: bold;
            margin-bottom: 4px;
            line-height: 1.1;
        }
        
        .cannabinoid-box {
            border: 2px solid #000;
            padding: 4px 8px;
            margin: 4px 0;
            font-size: 6pt;
            font-weight: bold;
        }
        
        .licenses {
            font-size: 5pt;
            margin: 4px 0;
            line-height: 1.3;
        }
        
        .warnings {
            font-size: 4.5pt;
            margin: 3px 0;
            line-height: 1.2;
        }
        
        .net-weight {
            font-size: 6pt;
            font-weight: bold;
            margin: 3px 0;
        }
        
        .serving {
            font-size: 6pt;
            margin: 2px 0;
        }
        
        .batch-id {
            font-size: 7pt;
            font-weight: bold;
            margin: 3px 0;
        }
        
        .expiration {
            font-size: 6pt;
            margin-top: 2px;
        }
    </style>
</head>
<body>
    <div class="no-print">
        <h1>Print Labels for ${batch.id}</h1>
        <p>Quantity: ${quantity} labels</p>
        <button onclick="window.print()"> Print Labels</button>
        <button onclick="window.close()">Close</button>
    </div>
    
    <div class="labels-container">
        ${labelsHTML}
    </div>
</body>
</html>
            `);
            popup.document.close();
        }

        function generateZPL(batch) {
            // Generate ZPL (Zebra Programming Language) code for CIRCULAR label
            const labelSize = document.getElementById('labelSize').value;
            
            // Circular label dimensions (in dots at 203dpi)
            const sizes = {
                '1.0': { diameter: 203 },   // 1.0" circle
                '1.5': { diameter: 305 },   // 1.5" circle
                '2.0': { diameter: 406 }    // 2.0" circle
            };
            
            const size = sizes[labelSize] || sizes['1.5'];
            const centerX = Math.floor(size.diameter / 2);
            
            // Format product type for label
            const productType = batch.packaged_product_type.toUpperCase().replace('WAX/SUGAR', 'WAX');
            
            // Format expiration date as M.D.YY (like 3.6.26)
            let expDate = 'N/A';
            if (batch.test_expiration_date) {
                const d = new Date(batch.test_expiration_date);
                expDate = `${d.getMonth() + 1}.${d.getDate()}.${d.getFullYear().toString().slice(-2)}`;
            }
            
            // Get THC and CBD percentages
            const thc = parseFloat(batch.test_thc_percent) || 0;
            const cbd = parseFloat(batch.test_cbd_percent) || 0;
            
            // Determine net weight based on product type
            let netWeight = '1 GRAM';
            if (batch.packaged_product_type.includes('4g')) {
                netWeight = '4 GRAM';
            } else if (batch.packaged_product_type.includes('0.5')) {
                netWeight = '0.5 GRAM';
            }
            
            // Get cultivation license from batch (403R)
            const cultivationLicense = batch.cultivation_license || '403R-01007';
            
            // White Mousse extraction license (404R)
            const extractionLicense = '404R-00016';
            
            // ZPL for 45mm circular label matching Canva design
            const diameter = 360;  // 45mm at 203dpi
            const center = 180;
            const zpl = `^XA
^MMT
^PW${diameter}
^LL${diameter}
^LS0

~SD20

^CF0,22
^FO${center},35^FB${diameter},1,0,C^FD${productType}^FS

^CF0,40
^FO${center},60^FB${diameter},2,0,C^FD${batch.strain.toUpperCase()}^FS

^FO${center - 100},110^GB200,40,3^FS
^CF0,14
^FO${center},118^FB${diameter},1,0,C^FDTOTAL THC: ${thc.toFixed(1)}%^FS
^FO${center},133^FB${diameter},1,0,C^FDTOTAL CBD: ${cbd.toFixed(1)}%^FS

^CF0,11
^FO${center},165^FB${diameter},1,0,C^FDCULTIVATED BY ${cultivationLicense}^FS
^FO${center},180^FB${diameter},1,0,C^FDEXTRACTED BY ${extractionLicense}^FS

^CF0,10
^FO${center},198^FB${diameter},1,0,C^FDINTENDED USE: INHALED PRODUCT.^FS
^FO${center},210^FB${diameter},1,0,C^FDNOT APPROVED BY THE FDA.^FS

^CF0,12
^FO${center},228^FB${diameter},1,0,C^FDNET WEIGHT: ${netWeight}^FS

^CF0,12
^FO${center},245^FB${diameter},1,0,C^FDSERVING SIZE: ^FS
^FO${center + 40},243^GC6,6,B^FS

^CF0,16
^FO${center},265^FB${diameter},1,0,C^FDBATCH ${batch.id}^FS

^CF0,12
^FO${center},285^FB${diameter},1,0,C^FDUSE BY ${expDate}^FS

^XZ`;
            
            document.getElementById('zplPreview').textContent = zpl;
            return zpl;
        }

        async function testPrinterConnection() {
            const connectionType = document.getElementById('connectionType').value;
            const statusDiv = document.getElementById('printerStatus');
            
            if (connectionType === 'network') {
                const ip = document.getElementById('printerIP').value;
                const port = document.getElementById('printerPort').value;
                
                if (!ip) {
                    alert('Please enter printer IP address');
                    return;
                }
                
                // Save settings
                localStorage.setItem('zebraPrinterIP', ip);
                localStorage.setItem('zebraPrinterPort', port);
                
                statusDiv.innerHTML = `
                    <div style="background: rgba(59, 130, 246, 0.2); border: 2px solid var(--accent-blue); padding: 20px; border-radius: 10px;">
                        <h3 style="color: var(--accent-blue); margin-bottom: 10px;"> Network Printer Setup</h3>
                        <p style="color: var(--text-primary); margin-bottom: 10px;">To print directly to network printer at ${ip}:${port}, you need:</p>
                        <ol style="color: var(--text-primary); margin-left: 20px;">
                            <li><strong>Zebra Browser Print</strong> - Free software from Zebra
                                <br><a href="https://www.zebra.com/us/en/support-downloads/software/printer-software/browser-print.html" target="_blank" style="color: var(--accent-blue);">Download here</a>
                            </li>
                            <li><strong>Or download ZPL</strong> and send file to printer manually</li>
                        </ol>
                        <p style="color: var(--text-primary); margin-top: 15px;">IP saved: <strong>${ip}:${port}</strong></p>
                    </div>
                `;
            } else {
                // USB mode
                localStorage.setItem('zebraConnectionType', 'usb');
                
                statusDiv.innerHTML = `
                    <div style="background: rgba(16, 185, 129, 0.2); border: 2px solid var(--accent-green); padding: 20px; border-radius: 10px;">
                        <h3 style="color: var(--accent-green); margin-bottom: 10px;"> USB Connection Mode</h3>
                        <p style="color: var(--text-primary); margin-bottom: 10px;"><strong>Setup Steps:</strong></p>
                        <ol style="color: var(--text-primary); margin-left: 20px;">
                            <li>Connect ZT230 to computer via USB</li>
                            <li>Install <strong>Zebra Browser Print</strong> - <a href="https://www.zebra.com/us/en/support-downloads/software/printer-software/browser-print.html" target="_blank" style="color: var(--accent-blue);">Download here</a></li>
                            <li>Browser Print will auto-detect your USB printer</li>
                            <li>Click "Print Labels" and they'll go straight to your ZT230!</li>
                        </ol>
                        <p style="color: var(--text-primary); margin-top: 15px;"><strong>Mode saved:</strong> USB Direct Connection</p>
                    </div>
                `;
            }
        }

        async function printLabels() {
            const batchId = document.getElementById('labelingBatchSelect').value;
            const batch = batches.find(b => b.id === batchId);

            if (!batch) {
                alert('Please select a batch first');
                return;
            }

            const quantity = parseInt(document.getElementById('labelQuantity').value) || 1;
            const labelsPerUnit = parseInt(document.getElementById('labelsPerUnit').value) || 1;
            const totalLabels = quantity * labelsPerUnit;

            const zpl = generateZPL(batch);
            
            // Generate ZPL with multiple copies
            let fullZPL = '';
            for (let i = 0; i < totalLabels; i++) {
                fullZPL += zpl + '\n';
            }
            
            // Try print server first (works from mobile!)
            const printServerURL = localStorage.getItem('printServerURL') || 'http://localhost:3000/print';

            try {
                const response = await fetch(printServerURL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ zpl: fullZPL })
                });

                if (response.ok) {
                    alert(` Sent ${totalLabels} labels to printer!`);
                    return;
                }
            } catch (error) {
                // Print server not available, try Browser Print
            }

            // Fallback to Browser Print
            if (window.BrowserPrint) {
                try {
                    const printer = await window.BrowserPrint.getDefaultDevice('printer');

                    printer.send(fullZPL, undefined, (error) => {
                        if (error) {
                            console.error('Print error:', error);
                            alert('Print failed. Use "Download ZPL" button instead.');
                        } else {
                            alert(` Sent ${totalLabels} labels to printer!`);
                        }
                    });
                } catch (error) {
                    console.error('Browser Print error:', error);
                    alert('Printing not available.\n\nOptions:\n1. Start print server (see setup docs)\n2. Use "Download ZPL" button');
                }
            } else {
                alert('Print server not running and Browser Print not installed.\n\nUse "Download ZPL" button to print manually.');
            }
        }

        function downloadZPL() {
            const batchId = document.getElementById('labelingBatchSelect').value;
            const batch = batches.find(b => b.id === batchId);

            if (!batch) {
                alert('Please select a batch first');
                return;
            }

            const quantity = parseInt(document.getElementById('labelQuantity').value) || 1;
            const labelsPerUnit = parseInt(document.getElementById('labelsPerUnit').value) || 1;
            const totalLabels = quantity * labelsPerUnit;

            const zpl = generateZPL(batch);

            // Generate ZPL file with multiple copies
            let fullZPL = '';
            for (let i = 0; i < totalLabels; i++) {
                fullZPL += zpl + '\n';
            }

            try {
                // Create download
                const blob = new Blob([fullZPL], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `${batch.id}_labels_${totalLabels}x.zpl`;
                link.click();

                alert(`Downloaded ZPL file for ${totalLabels} labels!\n\nSend this file to your Zebra printer using:\n- Zebra Setup Utilities  Send File\n- Or drag file to printer in Setup Utilities`);
            } catch (error) {
                console.error('Download error:', error);
                alert('Error creating download.');
            }
        }

        // Start labeling (marks batch as in-progress)
        async function startLabeling() {
            if (!currentRole) {
                alert('Please login first!');
                return;
            }
            
            const batchId = document.getElementById('labelingBatchSelect').value;
            const batch = batches.find(b => b.id === batchId);
            
            if (!batch) return;
            
            const confirmation = confirm(
                `Mark batch ${batchId} as STARTED labeling?\n\n` +
                `This will:\n` +
                ` Add "Labeling Started" to timeline\n` +
                ` Keep status as "complete" (not yet labeled)\n` +
                ` Allow you to finish later\n\n` +
                `You can skip this and go straight to "Complete Labeling" for single sessions.`
            );
            
            if (!confirmation) return;
            
            const timeline = batch.timeline || [];
            timeline.push({
                stage: 'labeling',
                user: currentRole ? currentRole.name : "Unknown",
                date: new Date().toISOString(),
                action: 'Labeling started'
            });
            
            const { error } = await supabaseClient
                .from('wm_batches')
                .update({
                    labeling_notes: document.getElementById('labelingNotes').value || null,
                    timeline: timeline
                })
                .eq('id', batchId);
            
            if (error) {
                console.error('Error marking batch as started:', error);
                alert('Error updating batch. Please try again.');
                return;
            }
            
            alert(` Batch ${batchId} marked as labeling in progress!\n\n` +
                  `Started by: ${currentRole.name}\n\n` +
                  `This batch will remain in the dropdown until you click "Complete Labeling".`);
            
            // Refresh batch data but keep form open and batch selected
            await loadBatches();
            populateLabelingSelect();
            
            // Re-select the batch
            document.getElementById('labelingBatchSelect').value = batchId;
            document.getElementById('labelingForm').style.display = 'block';
            
            // Re-populate the label preview since batch was reselected
            const updatedBatch = batches.find(b => b.id === batchId);
            if (updatedBatch) {
                displayLabelPreview(updatedBatch);
                
                // Reinitialize units verification
                const unitsLabeledInput = document.getElementById('unitsLabeled');
                const expectedUnitsEl = document.getElementById('expectedUnits');
                if (unitsLabeledInput && expectedUnitsEl) {
                    const expectedUnits = parseInt(updatedBatch.units_packaged) || 0;
                    expectedUnitsEl.textContent = expectedUnits;
                }
            }
        }

        // Toggle pause/resume for labeling
        async function togglePauseLabeling() {
            if (!currentRole) {
                alert('Please select a user first!');
                return;
            }

            const batchId = document.getElementById('labelingBatchSelect').value;
            const batch = batches.find(b => b.id === batchId);
            
            if (!batch) {
                alert('Please select a batch first!');
                return;
            }
            
            const isPaused = batch.labeling_paused || false;
            const action = isPaused ? 'RESUME' : 'PAUSE';
            const actionVerb = isPaused ? 'Resumed' : 'Paused';
            
            const confirmation = confirm(
                `${action} labeling for batch ${batchId}?\n\n` +
                `This will:\n` +
                ` Add "${actionVerb}" to timeline\n` +
                ` ${isPaused ? 'Allow work to continue' : 'Temporarily stop work'}\n` +
                ` Keep batch in labeling stage`
            );
            
            if (!confirmation) return;
            
            const timeline = batch.timeline || [];
            timeline.push({
                stage: 'labeling',
                user: currentRole ? currentRole.name : "Unknown",
                date: new Date().toISOString(),
                action: `Labeling ${actionVerb.toLowerCase()}`
            });
            
            const { error } = await supabaseClient
                .from('wm_batches')
                .update({
                    labeling_paused: !isPaused,
                    timeline: timeline
                })
                .eq('id', batchId);
            
            if (error) {
                console.error('Error toggling pause:', error);
                alert('Error updating batch. Please try again.');
                return;
            }
            
            alert(` Labeling ${actionVerb.toLowerCase()} for batch ${batchId}!\n\n` +
                  `${isPaused ? 'Work can continue.' : 'Work temporarily stopped.'}\n` +
                  `${actionVerb} by: ${currentRole.name}`);
            
            await loadBatches();
            populateLabelingSelect();
            // Keep the batch selected
            document.getElementById('labelingBatchSelect').value = batchId;
            document.getElementById('labelingBatchSelect').dispatchEvent(new Event('change'));
        }

        async function markAsLabeled() {
            if (blockDemoWrite('Marking as labeled')) return;

            if (!currentRole) {
                alert('Please login first!');
                return;
            }

            const batchId = document.getElementById('labelingBatchSelect').value;
            const batch = batches.find(b => b.id === batchId);

            if (!batch) {
                alert('Please select a batch first');
                return;
            }

            // Determine if this batch has 1g/4g breakdown
            const expected1g = parseInt(batch.units_1g) || 0;
            const expected4g = parseInt(batch.units_4g) || 0;
            const hasBreakdown = expected1g > 0 || expected4g > 0;

            let labeled1g = 0;
            let labeled4g = 0;
            let unitsLabeled = 0;
            let totalExpected = 0;
            let discrepancyData = null;

            if (hasBreakdown) {
                // Get 1g and 4g labeled counts
                labeled1g = parseInt(document.getElementById('units1gLabeled').value) || 0;
                labeled4g = parseInt(document.getElementById('units4gLabeled').value) || 0;
                unitsLabeled = labeled1g + labeled4g;
                totalExpected = expected1g + expected4g;

                // Validate at least one field is filled
                if (unitsLabeled <= 0) {
                    alert('Please enter the number of units labeled');
                    return;
                }
            } else {
                // Get generic units labeled
                unitsLabeled = parseInt(document.getElementById('unitsLabeled').value) || 0;
                totalExpected = parseInt(batch.units_packaged) || 0;

                if (unitsLabeled <= 0) {
                    alert('Please enter the number of units labeled');
                    return;
                }
            }

            // Check for discrepancy
            const discrepancy = Math.abs(unitsLabeled - totalExpected);
            if (discrepancy > 0) {
                const acceptCheckbox = document.getElementById('acceptDiscrepancy');
                if (!acceptCheckbox || !acceptCheckbox.checked) {
                    alert(' Unit count discrepancy detected!\n\nYou must check the box to verify and accept the discrepancy before proceeding.');
                    return;
                }
                discrepancyData = { discrepancy, expected: totalExpected, actual: unitsLabeled };
            }

            // Build confirmation message
            let confirmMsg = `Mark ${batchId} as labeled?\n\n`;
            if (hasBreakdown) {
                if (expected1g > 0) confirmMsg += `1g Units: ${labeled1g} labeled (expected ${expected1g})\n`;
                if (expected4g > 0) confirmMsg += `4g Units: ${labeled4g} labeled (expected ${expected4g})\n`;
                confirmMsg += `\nTotal: ${unitsLabeled} units`;
            } else {
                confirmMsg += `Units Labeled: ${unitsLabeled}\nExpected: ${totalExpected}`;
            }

            if (!confirm(confirmMsg)) {
                return;
            }

            // Build timeline action text
            let actionText = '';
            if (hasBreakdown) {
                const parts = [];
                if (labeled1g > 0) parts.push(`${labeled1g}x 1g`);
                if (labeled4g > 0) parts.push(`${labeled4g}x 4g`);
                actionText = `Labeled ${parts.join(' + ')} (${unitsLabeled} total)`;
            } else {
                actionText = `Labeled ${unitsLabeled} units`;
            }
            if (discrepancyData) actionText += ` (expected ${totalExpected})`;

            const timeline = batch.timeline || [];
            timeline.push({
                stage: 'labeling',
                timestamp: new Date().toISOString(),
                user: currentRole ? currentRole.name : "Unknown",
                action: actionText
            });

            const updateData = {
                labels_applied: true,
                labeling_date: new Date().toISOString().split('T')[0],
                labeling_user: currentRole ? currentRole.name : "Unknown",
                labels_applied_quantity: unitsLabeled,
                units_1g_labeled: hasBreakdown ? labeled1g : null,
                units_4g_labeled: hasBreakdown ? labeled4g : null,
                labeling_notes: document.getElementById('labelingNotes').value || null,
                timeline: timeline
            };

            // Add discrepancy data if any
            if (discrepancyData) {
                updateData.unit_discrepancy = discrepancyData.discrepancy;
                updateData.discrepancy_accepted = true;
            }

            const { error } = await supabaseClient
                .from('wm_batches')
                .update(updateData)
                .eq('id', batchId);

            if (error) {
                console.error('Error marking as labeled:', error);
                alert('Error saving labeling status. Please try again.');
                return;
            }

            // Update 50/50 split tracking if applicable (non-blocking)
            if (batch.material_agreement === '50/50 Split' || batch.material_agreement === '50-50 Split') {
                try {
                    await update5050SplitFinished(batch);
                } catch (splitErr) {
                    console.warn('50/50 split tracking failed (non-critical):', splitErr);
                }
            }

            // Print labeling completion label
            printLabelingCompletionLabel(batch, currentRole ? currentRole.name : 'Unknown');

            // Queue for LeafLink approval (skip buyback batches)
            let leafLinkMsg = '';
            if (batch.material_agreement !== 'Custom Buyback') {
                await queueForLeafLinkApproval({
                    ...batch,
                    labels_applied_quantity: unitsLabeled,
                    units_1g_labeled: labeled1g,
                    units_4g_labeled: labeled4g
                });
                leafLinkMsg = ' Queued for LeafLink approval';
            } else {
                leafLinkMsg = '(Buyback - not listed)';
            }

            // Build celebration stats
            const celebrationStats = [];
            if (hasBreakdown) {
                if (labeled1g > 0) celebrationStats.push({ value: `${labeled1g}x 1g`, label: '1g Units' });
                if (labeled4g > 0) celebrationStats.push({ value: `${labeled4g}x 4g`, label: '4g Units' });
            } else {
                celebrationStats.push({ value: unitsLabeled, label: 'Units Labeled' });
            }
            celebrationStats.push({ value: batch.packaged_product_type || 'N/A', label: 'Product' });

            showCelebration({
                emoji: '',
                title: 'Batch Complete!',
                message: `${batchId} is fully labeled and ready for sale! ${leafLinkMsg}`,
                stats: celebrationStats,
                confettiCount: 80
            });

            document.getElementById('labelingForm').style.display = 'none';
            document.getElementById('labelingBatchSelect').value = '';
            document.getElementById('labelingNotes').value = '';
            document.getElementById('unitsLabeled').value = '';
            document.getElementById('units1gLabeled').value = '';
            document.getElementById('units4gLabeled').value = '';

            await loadBatches();
            populateLabelingSelect();
        }

        // Analytics functions
        let currentAnalyticsFilter = 'all';

        // Waste Log Functions
        function getNextTuesday(fromDate) {
            const date = new Date(fromDate);
            const dayOfWeek = date.getDay();
            const daysUntilTuesday = (2 - dayOfWeek + 7) % 7 || 7;
            date.setDate(date.getDate() + daysUntilTuesday);
            return date;
        }
        
        function calculateWasteWeight(batch) {
            const trimWeight = parseFloat(batch.trim_weight) || 0;
            
            // If we have actual yield data, calculate real waste
            if (batch.crude_weight || batch.final_weight || batch.grams_labeled) {
                const actualYield = parseFloat(batch.grams_labeled) || parseFloat(batch.final_weight) || parseFloat(batch.crude_weight) || 0;
                return Math.max(0, trimWeight - actualYield);
            }
            
            // Otherwise use 90% estimate
            return trimWeight * 0.90;
        }
        
        function isWasteEstimated(batch) {
            return !(batch.crude_weight || batch.final_weight || batch.grams_labeled);
        }
        
        function renderWasteLog() {
            const tbody = document.getElementById('wasteLogTableBody');
            if (!tbody) return;
            
            // Get batches that have been extracted (have extraction_date)
            const extractedStatuses = ['extraction', 'finishing', 'packaging', 'completed'];
            const wasteBatches = batches.filter(b => (b.extraction_date || extractedStatuses.includes(b.status)) && !b.is_sub_batch);
            
            if (wasteBatches.length === 0) {
                tbody.innerHTML = '<tr><td colspan="9" style="padding: 40px; text-align: center; color: var(--text-secondary);">No waste records found</td></tr>';
                updateWasteStats([]);
                return;
            }
            
            // Sort by extraction date descending
            wasteBatches.sort((a, b) => new Date(b.extraction_date) - new Date(a.extraction_date));
            
            let html = '';
            wasteBatches.forEach(batch => {
                const wasteWeight = calculateWasteWeight(batch);
                const isEstimate = isWasteEstimated(batch);
                const disposalDate = getNextTuesday(batch.extraction_date);
                const isPastDue = disposalDate < new Date();
                
                html += '<tr style="border-bottom: 1px solid var(--border);">';
                html += '<td style="padding: 12px; color: var(--accent-purple); font-weight: 600;">' + batch.id + '</td>';
                html += '<td style="padding: 12px; color: var(--text-primary);">' + batch.strain + '</td>';
                html += '<td style="padding: 12px; text-align: right; color: var(--text-secondary);">' + parseFloat(batch.trim_weight).toFixed(1) + 'g</td>';
                html += '<td style="padding: 12px; text-align: right; font-weight: 600; color: ' + (isEstimate ? 'var(--accent-orange)' : 'var(--accent-green)') + ';">' + wasteWeight.toFixed(1) + 'g' + '</td>';
                html += '<td style="padding: 12px; text-align: center; color: var(--text-secondary);">' + new Date(batch.extraction_date).toLocaleDateString() + '</td>';
                html += '<td style="padding: 12px; text-align: center; font-weight: 600; color: ' + (isPastDue ? 'var(--accent-red)' : 'var(--accent-blue)') + ';">' + disposalDate.toLocaleDateString() + '</td>';
                html += '<td style="padding: 12px; text-align: center; color: var(--accent-purple);">' + (batch.metrc_tags || '--') + '</td>';
                html += '<td style="padding: 12px; text-align: center; color: var(--text-secondary);">Filter Media</td>';
                html += '<td style="padding: 12px; text-align: center; color: var(--text-secondary);">Waste Management</td>';
                html += '</tr>';
            });
            
            tbody.innerHTML = html;
            updateWasteStats(wasteBatches);
        }
        
        function updateWasteStats(wasteBatches) {
            let totalWaste = 0;
            let pendingCount = 0;
            let nextDisposal = null;
            const today = new Date();
            
            wasteBatches.forEach(batch => {
                const wasteWeight = calculateWasteWeight(batch);
                totalWaste += wasteWeight;
                
                const disposalDate = getNextTuesday(batch.extraction_date);
                if (disposalDate >= today) {
                    pendingCount++;
                    if (!nextDisposal || disposalDate < nextDisposal) {
                        nextDisposal = disposalDate;
                    }
                }
            });
            
            document.getElementById('wastePendingCount').textContent = pendingCount;
            document.getElementById('wasteTotalWeight').textContent = totalWaste.toFixed(1) + 'g';
            document.getElementById('wasteNextDisposal').textContent = nextDisposal ? nextDisposal.toLocaleDateString() : '--';
        }
        
        function exportWasteLog() {
            const extractedStatuses = ['extraction', 'finishing', 'packaging', 'completed'];
            const wasteBatches = batches.filter(b => (b.extraction_date || extractedStatuses.includes(b.status)) && !b.is_sub_batch);
            if (wasteBatches.length === 0) { alert('No waste records to export'); return; }
            wasteBatches.sort((a, b) => new Date(b.extraction_date) - new Date(a.extraction_date));
            let csv = 'Batch ID,Strain,Trim Weight (g),Waste Weight (g),Extraction Date,Disposal Date,METRC Tag,Mixed With,Disposal Facility\n';
            wasteBatches.forEach(batch => {
                const wasteWeight = calculateWasteWeight(batch);
                const disposalDate = getNextTuesday(batch.extraction_date);
                csv += '"' + batch.id + '","' + batch.strain + '",' + parseFloat(batch.trim_weight).toFixed(1) + ',' + wasteWeight.toFixed(1) + ',"' + new Date(batch.extraction_date).toLocaleDateString() + '","' + disposalDate.toLocaleDateString() + '","' + (batch.metrc_tags || '') + '","Filter Media","Waste Management"\n';
            });
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'waste_log_' + new Date().toISOString().split('T')[0] + '.csv';
            a.click();
            URL.revokeObjectURL(url);
        }



        function updateAnalytics() {
            const completedBatches = batches.filter(b => b.status === 'complete');
            
            if (completedBatches.length === 0) {
                document.getElementById('avgYield').textContent = '0%';
                document.getElementById('avgThc').textContent = '0%';
                document.getElementById('avgProcessingTime').textContent = '0d';
                document.getElementById('avgCostPerGram').textContent = '$0';
                document.getElementById('completedBatchesGrid').innerHTML = '<p style="padding: 40px; text-align: center; color: var(--text-secondary); grid-column: 1 / -1;">No completed batches yet</p>';
                return;
            }
            
            // Calculate summary stats
            let totalYield = 0, yieldCount = 0;
            let totalThc = 0, thcCount = 0;
            let totalProcessingDays = 0, timeCount = 0;
            let totalCostPerGram = 0, costCount = 0;
            
            completedBatches.forEach(b => {
                // Yield - use grams_labeled (actual sellable weight) instead of net_weight
                if (b.trim_weight && b.grams_labeled) {
                    totalYield += (parseFloat(b.grams_labeled) / parseFloat(b.trim_weight)) * 100;
                    yieldCount++;
                }
                // THC
                if (b.test_thc_percent) {
                    totalThc += parseFloat(b.test_thc_percent);
                    thcCount++;
                }
                // Processing time
                if (b.intake_date && b.finishing_date) {
                    const days = (new Date(b.finishing_date) - new Date(b.intake_date)) / (1000 * 60 * 60 * 24);
                    totalProcessingDays += days;
                    timeCount++;
                }
                // Cost per gram - use grams_labeled (actual sellable weight) instead of net_weight
                if (b.material_cost && b.grams_labeled) {
                    totalCostPerGram += parseFloat(b.material_cost) / parseFloat(b.grams_labeled);
                    costCount++;
                }
            });
            
            document.getElementById('avgYield').textContent = yieldCount > 0 ? (totalYield / yieldCount).toFixed(2) + '%' : '0%';
            document.getElementById('avgThc').textContent = thcCount > 0 ? (totalThc / thcCount).toFixed(2) + '%' : '0%';
            document.getElementById('avgProcessingTime').textContent = timeCount > 0 ? (totalProcessingDays / timeCount).toFixed(1) + 'd' : '0d';
            document.getElementById('avgCostPerGram').textContent = costCount > 0 ? '$' + (totalCostPerGram / costCount).toFixed(2) : '$0';
            
            filterAnalytics(currentAnalyticsFilter);
        }
        
        function filterAnalytics(filter) {
            currentAnalyticsFilter = filter;
            
            // Update active button
            document.querySelectorAll('[data-filter-analytics]').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.filterAnalytics === filter);
            });
            
            let filteredBatches = batches.filter(b => b.status === 'complete');
            
            const now = new Date();
            const thisMonthStart = new Date(now.getFullYear(), now.getMonth(), 1);
            const lastMonthStart = new Date(now.getFullYear(), now.getMonth() - 1, 1);
            const lastMonthEnd = new Date(now.getFullYear(), now.getMonth(), 0);
            
            if (filter === 'thisMonth') {
                filteredBatches = filteredBatches.filter(b => new Date(b.finishing_date) >= thisMonthStart);
            } else if (filter === 'lastMonth') {
                filteredBatches = filteredBatches.filter(b => {
                    const finishDate = new Date(b.finishing_date);
                    return finishDate >= lastMonthStart && finishDate <= lastMonthEnd;
                });
            }
            
            renderBatchCards(filteredBatches);
        }
        
        function renderBatchCards(completedBatches) {
            const container = document.getElementById('completedBatchesGrid');
            
            if (completedBatches.length === 0) {
                container.innerHTML = '<p style="padding: 40px; text-align: center; color: var(--text-secondary); grid-column: 1 / -1;">No batches for this period</p>';
                return;
            }
            
            container.innerHTML = completedBatches.map(batch => {
                return `
                    <div class="batch-card" onclick="showBatchDetails('${batch.id}')" style="cursor: pointer; transition: all 0.2s; background: var(--bg-secondary); padding: 20px; border-radius: 12px; border: 2px solid var(--border);">
                        <div style="text-align: center;">
                            <div style="font-family: 'Space Mono', monospace; font-size: 1.3rem; font-weight: 700; color: var(--accent-green); margin-bottom: 8px;">${batch.id}</div>
                            <div style="color: var(--text-primary); font-size: 1rem; font-weight: 600;">${batch.strain}</div>
                            <div style="margin-top: 8px; padding: 4px 12px; background: rgba(147, 51, 234, 0.2); border-radius: 12px; font-size: 0.85rem; color: var(--accent-purple); display: inline-block;">
                                ${batch.strain_type}
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
            
            // Add hover effect via CSS
            document.querySelectorAll('.batch-card').forEach(card => {
                card.addEventListener('mouseenter', function() {
                    this.style.transform = 'translateY(-4px)';
                    this.style.boxShadow = '0 8px 24px rgba(147, 51, 234, 0.3)';
                    this.style.borderColor = 'var(--accent-purple)';
                });
                card.addEventListener('mouseleave', function() {
                    this.style.transform = 'translateY(0)';
                    this.style.boxShadow = 'none';
                    this.style.borderColor = 'var(--border)';
                });
            });
        }

        function showBatchDetails(batchId) {
            const batch = batches.find(b => b.id === batchId);
            if (!batch) return;
            
            // Update modal title
            document.getElementById('modalBatchId').textContent = batch.id;
            
            // Batch Overview Cards
            const overview = `
                <div style="background: var(--bg-secondary); padding: 15px; border-radius: 10px; border-left: 4px solid var(--accent-green);">
                    <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 5px;">Strain</div>
                    <div style="font-size: 1.1rem; font-weight: 700;">${batch.strain}</div>
                    <div style="font-size: 0.9rem; color: var(--accent-purple);">${batch.strain_type}</div>
                </div>
                <div style="background: var(--bg-secondary); padding: 15px; border-radius: 10px; border-left: 4px solid var(--accent-blue);">
                    <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 5px;">Product Made</div>
                    <div style="font-size: 1.1rem; font-weight: 700;">${batch.product_made || 'N/A'}</div>
                </div>
                <div style="background: var(--bg-secondary); padding: 15px; border-radius: 10px; border-left: 4px solid var(--accent-orange);">
                    <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 5px;">Grower</div>
                    <div style="font-size: 1.1rem; font-weight: 700;">${batch.grower_name || 'N/A'}</div>
                    <div style="font-size: 0.9rem; color: var(--accent-orange);">${batch.cultivation_license}</div>
                </div>
            `;
            document.getElementById('modalBatchOverview').innerHTML = overview;

            // Batch Tracking Details
            let sourceContributionsHtml = '';
            if (batch.source_contributions && batch.source_contributions.length > 0) {
                const sources = typeof batch.source_contributions === 'string' ? JSON.parse(batch.source_contributions) : batch.source_contributions;
                const totalTrim = sources.reduce((sum, s) => sum + (parseFloat(s.trim_weight) || 0), 0);
                const totalSocks = sources.reduce((sum, s) => sum + (s.socks || 0), 0);

                if (sources.length > 1) {
                    sourceContributionsHtml = `
                        <div style="background: rgba(239, 68, 68, 0.15); padding: 15px; border-radius: 8px; margin-top: 15px; border: 2px solid var(--accent-red);">
                            <p style="margin: 0 0 10px 0;"><strong style="color: var(--accent-red);"> MIXED SOURCE - ${sources.length} TAGS</strong></p>
                            <p style="margin: 0 0 10px 0; font-size: 0.9rem;">Total: <strong>${totalTrim.toFixed(1)}g</strong> from ${totalSocks} socks</p>
                            ${sources.map(s => {
                                const trimUsed = parseFloat(s.trim_weight) || 0;
                                const sourceBatch = batches.find(b => b.id === s.batch_id);
                                const metrcTag = s.metrc_tag || sourceBatch?.metrc_tags || 'No tag';
                                return `<div style="background: var(--bg-tertiary); padding: 10px; border-radius: 6px; margin: 6px 0; display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                                    <div>
                                        <strong>${s.batch_id}</strong><br>
                                        <span style="font-family: 'Space Mono', monospace; font-size: 0.85rem; color: var(--accent-blue);">${metrcTag}</span>
                                    </div>
                                    <div style="text-align: right;">
                                        <strong style="color: var(--accent-green);">${trimUsed.toFixed(1)}g</strong><br>
                                        <span style="font-size: 0.85rem; color: var(--text-secondary);">${s.socks} socks</span>
                                    </div>
                                </div>`;
                            }).join('')}
                        </div>
                    `;
                } else {
                    const s = sources[0];
                    const trimUsed = parseFloat(s.trim_weight) || 0;
                    const sourceBatch = batches.find(b => b.id === s.batch_id);
                    const metrcTag = s.metrc_tag || sourceBatch?.metrc_tags || 'No tag';
                    sourceContributionsHtml = `
                        <div style="background: rgba(16, 185, 129, 0.15); padding: 12px; border-radius: 8px; margin-top: 15px; border-left: 4px solid var(--accent-green);">
                            <p style="margin: 0;"><strong style="color: var(--accent-green);"> Source:</strong> ${s.batch_id}</p>
                            <p style="margin: 5px 0 0 0; font-family: 'Space Mono', monospace; color: var(--accent-blue);">${metrcTag}</p>
                            <p style="margin: 5px 0 0 0;"><strong>${trimUsed.toFixed(1)}g</strong> (${s.socks} socks)</p>
                        </div>
                    `;
                }
            }
            const allNotes = [batch.intake_notes, batch.extraction_notes, batch.finishing_notes, batch.packaging_notes, batch.labeling_notes].filter(n => n).join(' | ');
            const tracking = `
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                    <div><strong>Status:</strong> <span style="color: var(--accent-green); text-transform: uppercase;">${batch.status}</span></div>
                    <div><strong>Socks:</strong> ${batch.socks_remaining != null ? batch.socks_remaining + '/' + batch.socks_total + ' remaining' : 'N/A'}</div>
                    <div><strong>METRC Tags:</strong> <span style="font-family: monospace;">${batch.metrc_tags || 'None'}</span></div>
                    <div><strong>Grow License:</strong> ${batch.cultivation_license || 'N/A'}</div>
                </div>
                ${batch.parent_batch_id ? '<p style="margin-top: 15px;"><strong>Parent Batch:</strong> ' + batch.parent_batch_id + '</p>' : ''}
                ${sourceContributionsHtml}
                ${allNotes ? '<div style="margin-top: 15px; padding: 10px; background: var(--bg-secondary); border-radius: 8px;"><strong>Notes:</strong> ' + allNotes + '</div>' : ''}
            `;
            document.getElementById('modalTracking').innerHTML = tracking;
            
            // Processing Timeline
            const intakeDate = new Date(batch.intake_date);
            
            // Derive extraction date from timeline completion
            let extractionDate = null;
            if (batch.timeline && batch.timeline.length > 0) {
                const extractionComplete = batch.timeline.find(t => 
                    t.stage === 'extraction' && t.timestamp
                );
                if (extractionComplete) {
                    extractionDate = new Date(extractionComplete.timestamp);
                }
            }
            
            const finishingDate = batch.finishing_date ? new Date(batch.finishing_date) : null;
            const packagingDate = batch.packaging_date ? new Date(batch.packaging_date) : null;
            const testingDate = batch.test_results_received_date ? new Date(batch.test_results_received_date) : null;
            const labelingDate = batch.labeling_date ? new Date(batch.labeling_date) : null;
            
            const totalDays = finishingDate ? ((finishingDate - intakeDate) / (1000 * 60 * 60 * 24)).toFixed(1) : 'N/A';
            const extractionDays = extractionDate && intakeDate ? ((extractionDate - intakeDate) / (1000 * 60 * 60 * 24)).toFixed(1) : 'N/A';
            const finishingDays = finishingDate && extractionDate ? ((finishingDate - extractionDate) / (1000 * 60 * 60 * 24)).toFixed(1) : 'N/A';
            
            // Helper function to format time in hours/minutes
            function formatDuration(minutes) {
                if (!minutes || minutes < 0) return 'N/A';
                const hours = Math.floor(minutes / 60);
                const mins = Math.round(minutes % 60);
                if (hours > 0) {
                    return mins > 0 ? `${hours}h ${mins}m` : `${hours}h`;
                }
                return `${mins}m`;
            }
            
            // Calculate stage durations from timeline
            let extractionTime = null;
            let finishingTime = null;
            let packagingTime = null;
            let testingTime = null;
            let labelingTime = null;
            
            if (batch.timeline && batch.timeline.length > 0) {
                // Find extraction start and complete
                const extractionStart = batch.timeline.find(t => 
                    t.action && (t.action.toLowerCase().includes('processing started') || t.action.toLowerCase().includes('extraction started'))
                );
                const extractionComplete = batch.timeline.find(t => 
                    (t.stage === 'extraction' || t.stage === 'finishing') && 
                    t.action && 
                    (t.action.toLowerCase().includes('completed') || t.action.toLowerCase().includes('extracted'))
                );
                
                if (extractionStart && extractionComplete) {
                    const startTime = new Date(extractionStart.date || extractionStart.timestamp);
                    const endTime = new Date(extractionComplete.date || extractionComplete.timestamp);
                    extractionTime = (endTime - startTime) / (1000 * 60); // minutes
                }
                
                // Find finishing/post-extraction start and complete (if exists)
                const finishingStart = batch.timeline.find(t => 
                    t.action && (t.action.toLowerCase().includes('post-processing started') || t.action.toLowerCase().includes('finishing started'))
                );
                const finishingComplete = batch.timeline.find(t => 
                    t.stage === 'finishing' && 
                    t.action && 
                    (t.action.toLowerCase().includes('finishing completed') || t.action.toLowerCase().includes('post-extraction completed'))
                );
                
                if (finishingStart && finishingComplete) {
                    const startTime = new Date(finishingStart.date || finishingStart.timestamp);
                    const endTime = new Date(finishingComplete.date || finishingComplete.timestamp);
                    finishingTime = (endTime - startTime) / (1000 * 60); // minutes
                }
                
                // Find packaging start and complete
                const packagingStart = batch.timeline.find(t =>
                    t.action && t.action.toLowerCase().includes('packaging started')
                );
                const packagingComplete = batch.timeline.find(t =>
                    t.stage === 'packaging' &&
                    t.action &&
                    (t.action.toLowerCase().includes('packaged') || t.action.includes('Packaging completed'))
                );

                if (packagingStart && packagingComplete) {
                    const startTime = new Date(packagingStart.date || packagingStart.timestamp);
                    const endTime = new Date(packagingComplete.date || packagingComplete.timestamp);
                    let totalTime = (endTime - startTime) / (1000 * 60); // minutes

                    // Subtract paused time
                    const packagingPauses = batch.timeline.filter(t => t.action && t.action.toLowerCase().includes('packaging paused'));
                    const packagingResumes = batch.timeline.filter(t => t.action && t.action.toLowerCase().includes('packaging resumed'));
                    for (let i = 0; i < Math.min(packagingPauses.length, packagingResumes.length); i++) {
                        const pauseTime = new Date(packagingPauses[i].date || packagingPauses[i].timestamp);
                        const resumeTime = new Date(packagingResumes[i].date || packagingResumes[i].timestamp);
                        if (resumeTime > pauseTime) {
                            totalTime -= (resumeTime - pauseTime) / (1000 * 60);
                        }
                    }
                    packagingTime = Math.max(0, totalTime);
                }
                
                // Find testing start and complete (test submitted to results received)
                const testSubmitted = batch.timeline.find(t => 
                    t.action && (t.action.toLowerCase().includes('test submitted') || t.action.toLowerCase().includes('submitted for testing'))
                );
                const testComplete = batch.timeline.find(t => 
                    t.action && (t.action.toLowerCase().includes('test results') || t.action.toLowerCase().includes('results received'))
                );
                
                if (testSubmitted && testComplete) {
                    const startTime = new Date(testSubmitted.date || testSubmitted.timestamp);
                    const endTime = new Date(testComplete.date || testComplete.timestamp);
                    testingTime = (endTime - startTime) / (1000 * 60); // minutes
                }
                
                // Find labeling start and complete
                const labelingStart = batch.timeline.find(t =>
                    t.action && t.action.toLowerCase().includes('labeling started')
                );
                const labelingComplete = batch.timeline.find(t =>
                    t.stage === 'labeling' &&
                    (t.action && t.action.toLowerCase().includes('labeled') || t.timestamp)
                );

                if (labelingStart && labelingComplete) {
                    const startTime = new Date(labelingStart.date || labelingStart.timestamp);
                    const endTime = new Date(labelingComplete.date || labelingComplete.timestamp);
                    let totalTime = (endTime - startTime) / (1000 * 60); // minutes

                    // Subtract paused time
                    const labelingPauses = batch.timeline.filter(t => t.action && t.action.toLowerCase().includes('labeling paused'));
                    const labelingResumes = batch.timeline.filter(t => t.action && t.action.toLowerCase().includes('labeling resumed'));
                    for (let i = 0; i < Math.min(labelingPauses.length, labelingResumes.length); i++) {
                        const pauseTime = new Date(labelingPauses[i].date || labelingPauses[i].timestamp);
                        const resumeTime = new Date(labelingResumes[i].date || labelingResumes[i].timestamp);
                        if (resumeTime > pauseTime) {
                            totalTime -= (resumeTime - pauseTime) / (1000 * 60);
                        }
                    }
                    labelingTime = Math.max(0, totalTime);
                }
            }
            
            const timeline = `
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px;">
                    <div style="text-align: center; padding: 15px; background: var(--bg-secondary); border-radius: 10px;">
                        <div style="font-size: 2rem; margin-bottom: 5px;"></div>
                        <div style="font-size: 0.85rem; color: var(--text-secondary);">Intake</div>
                        <div style="font-weight: 700;">${intakeDate.toLocaleDateString()}</div>
                    </div>
                    ${extractionDate ? `
                    <div style="text-align: center; padding: 15px; background: var(--bg-secondary); border-radius: 10px;">
                        <div style="font-size: 2rem; margin-bottom: 5px;"></div>
                        <div style="font-size: 0.85rem; color: var(--text-secondary);">Extraction</div>
                        <div style="font-weight: 700;">${extractionDate.toLocaleDateString()}</div>
                        ${extractionTime ? `<div style="font-size: 0.9rem; color: var(--accent-green); font-weight: 700; margin-top: 5px;"> ${formatDuration(extractionTime)}</div>` : ''}
                    </div>` : ''}
                    ${finishingDate ? `
                    <div style="text-align: center; padding: 15px; background: var(--bg-secondary); border-radius: 10px;">
                        <div style="font-size: 2rem; margin-bottom: 5px;"></div>
                        <div style="font-size: 0.85rem; color: var(--text-secondary);">Finishing</div>
                        <div style="font-weight: 700;">${finishingDate.toLocaleDateString()}</div>
                        ${finishingTime ? `<div style="font-size: 0.9rem; color: var(--accent-green); font-weight: 700; margin-top: 5px;"> ${formatDuration(finishingTime)}</div>` : ''}
                    </div>` : ''}
                    ${packagingDate ? `
                    <div style="text-align: center; padding: 15px; background: var(--bg-secondary); border-radius: 10px;">
                        <div style="font-size: 2rem; margin-bottom: 5px;"></div>
                        <div style="font-size: 0.85rem; color: var(--text-secondary);">Packaged</div>
                        <div style="font-weight: 700;">${packagingDate.toLocaleDateString()}</div>
                        ${packagingTime ? `<div style="font-size: 0.9rem; color: var(--accent-green); font-weight: 700; margin-top: 5px;"> ${formatDuration(packagingTime)}</div>` : ''}
                    </div>` : ''}
                    ${testingDate ? `
                    <div style="text-align: center; padding: 15px; background: var(--bg-secondary); border-radius: 10px;">
                        <div style="font-size: 2rem; margin-bottom: 5px;"></div>
                        <div style="font-size: 0.85rem; color: var(--text-secondary);">Testing</div>
                        <div style="font-weight: 700;">${testingDate.toLocaleDateString()}</div>
                        ${testingTime ? `<div style="font-size: 0.9rem; color: var(--accent-green); font-weight: 700; margin-top: 5px;"> ${formatDuration(testingTime)}</div>` : ''}
                    </div>` : ''}
                    ${labelingDate ? `
                    <div style="text-align: center; padding: 15px; background: var(--bg-secondary); border-radius: 10px;">
                        <div style="font-size: 2rem; margin-bottom: 5px;"></div>
                        <div style="font-size: 0.85rem; color: var(--text-secondary);">Labeled</div>
                        <div style="font-weight: 700;">${labelingDate.toLocaleDateString()}</div>
                        ${labelingTime ? `<div style="font-size: 0.9rem; color: var(--accent-green); font-weight: 700; margin-top: 5px;"> ${formatDuration(labelingTime)}</div>` : ''}
                    </div>` : ''}
                </div>
                <div style="text-align: center; margin-top: 20px; padding: 15px; background: rgba(16, 185, 129, 0.2); border-radius: 10px;">
                    <div style="font-size: 1.6rem; font-weight: 700; color: var(--accent-green);">Total Processing Time</div>
                    <div style="font-size: 1.8rem; font-weight: 700; color: var(--accent-green);">${totalDays} days</div>
                </div>
            `;
            document.getElementById('modalTimeline').innerHTML = timeline;
            
            // Economics
            const trimWeight = parseFloat(batch.trim_weight || 0);
            const netWeight = parseFloat(batch.net_weight || 0);
            const gramsLabeled = parseFloat(batch.grams_labeled || 0);
            
            // Use grams_labeled for yield if available, otherwise fall back to net_weight
            const finalWeight = gramsLabeled > 0 ? gramsLabeled : netWeight;
            const yield_percent = trimWeight > 0 ? ((finalWeight / trimWeight) * 100).toFixed(2) : 0;
            
            const materialCost = parseFloat(batch.material_cost || 0);
            const costPerGram = finalWeight > 0 ? (materialCost / finalWeight).toFixed(2) : 0;
            const costPerUnit = batch.units_packaged > 0 ? (materialCost / batch.units_packaged).toFixed(2) : 0;
            
            const economics = `
                <p><strong>Trim Used:</strong> ${trimWeight}g</p>
                <p><strong>Final Net Weight:</strong> ${netWeight}g</p>
                ${gramsLabeled > 0 ? `<p><strong>Labeled Weight:</strong> ${gramsLabeled}g</p>` : ''}
                <p style="color: var(--accent-green); font-size: 1.2rem; font-weight: 700; margin: 10px 0;"><strong>Yield:</strong> ${yield_percent}%</p>
                <p><strong>Material Cost:</strong> $${materialCost.toFixed(2)}</p>
                <p><strong>Cost Per Gram:</strong> $${costPerGram}</p>
                ${batch.units_packaged ? `<p><strong>Cost Per Unit:</strong> $${costPerUnit}</p>` : ''}
            `;
            document.getElementById('modalEconomics').innerHTML = economics;
            
            // Testing Results
            const testing = `
                <p><strong>THC:</strong> <span style="color: var(--accent-green); font-size: 1.3rem; font-weight: 700;">${batch.test_thc_percent || 'N/A'}${batch.test_thc_percent ? '%' : ''}</span></p>
                <p><strong>CBD:</strong> ${batch.test_cbd_percent || 0}%</p>
                ${batch.is_rta === 'yes' ? '<p style="color: var(--accent-green);"><strong> RTA Full Panel</strong></p>' : '<p style="color: var(--text-secondary);">Standard Potency Test</p>'}
                ${batch.test_expiration_date ? `<p><strong>Expires:</strong> ${new Date(batch.test_expiration_date).toLocaleDateString()}</p>` : ''}
            `;
            document.getElementById('modalTesting').innerHTML = testing;
            
            // Production
            const production = `
                <p><strong>Units Packaged:</strong> ${batch.units_packaged || 'N/A'}</p>
                ${batch.packaging_breakdown ? `<p><strong>Breakdown:</strong> ${batch.packaging_breakdown}</p>` : ''}
                <p><strong>Extraction Method:</strong> ${batch.extraction_method || 'N/A'}</p>
                <p><strong>Material Agreement:</strong> ${batch.material_agreement || 'N/A'}</p>
                ${batch.metrc_tags ? `<p style="margin-top: 10px;"><strong>METRC Tags:</strong><br><span style="font-family: 'Space Mono', monospace; font-size: 0.9rem;">${batch.metrc_tags}</span></p>` : ''}
            `;
            document.getElementById('modalProduction').innerHTML = production;
            
            // Team Members
            const teamMembers = {};
            if (batch.timeline) {
                batch.timeline.forEach(entry => {
                    if (entry.user && entry.user !== 'Unknown') {
                        if (!teamMembers[entry.user]) {
                            teamMembers[entry.user] = [];
                        }
                        teamMembers[entry.user].push(entry.stage);
                    }
                });
            }
            
            const team = Object.keys(teamMembers).length > 0 ? Object.keys(teamMembers).map(user => `
                <div style="display: inline-block; margin: 5px 10px 5px 0; padding: 10px 15px; background: var(--bg-secondary); border-radius: 8px; border-left: 4px solid var(--accent-blue);">
                    <div style="font-weight: 700;">${user}</div>
                    <div style="font-size: 0.85rem; color: var(--text-secondary);">${[...new Set(teamMembers[user])].join(', ')}</div>
                </div>
            `).join('') : '<p style="color: var(--text-secondary);">No team members recorded</p>';
            
            document.getElementById('modalTeam').innerHTML = team;
            
            // Show modal
            document.getElementById('batchDetailsModal').style.display = 'block';
        }

        function closeBatchDetails() {
            document.getElementById('batchDetailsModal').style.display = 'none';
        }

        // Close modal when clicking outside
        document.getElementById('batchDetailsModal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeBatchDetails();
            }
        });

        // Performance Analytics
        document.getElementById('performanceFilter')?.addEventListener('change', function() {
            renderPerformanceAnalytics();
        });

        // Save and load targets
        function saveTargets() {
            const targets = {
                packaging: parseFloat(document.getElementById('targetPackagingUnits')?.value) || 200,
                labeling: parseFloat(document.getElementById('targetLabelingUnits')?.value) || 300,
                extractionTrim: parseFloat(document.getElementById('targetExtractionTrim')?.value) || 11200
            };
            localStorage.setItem('productionTargets', JSON.stringify(targets));
        }

        function loadTargets() {
            const saved = localStorage.getItem('productionTargets');
            if (saved) {
                const targets = JSON.parse(saved);
                if (document.getElementById('targetUnitsPerDay')) {
                    document.getElementById('targetUnitsPerDay').value = targets.unitsPerDay || 800;
                    document.getElementById('targetExtractionTrim').value = targets.extractionTrim || 11200;
                }
            }
            // Combined units target (packaging + labeling = 800/day total)
            const defaults = { unitsPerDay: 800, extractionTrim: 11200 };
            const result = saved ? JSON.parse(saved) : defaults;
            // Ensure unitsPerDay exists (migration from old format)
            if (!result.unitsPerDay) {
                result.unitsPerDay = 800;
            }
            return result;
        }


        // Denver timezone helper - converts to Mountain Time
        function getDenverDate(date = new Date()) {
            return new Date(date.toLocaleString('en-US', { timeZone: 'America/Denver' }));
        }

        function getDenverMidnight(date = new Date()) {
            const denver = getDenverDate(date);
            denver.setHours(0, 0, 0, 0);
            return denver;
        }

        // Helper to calculate date range start (handles 'Today' correctly with Denver midnight)
        function getPerformanceRangeStart(timeRange) {
            const now = getDenverDate();
            if (timeRange === 1) {
                // Today: start at midnight Denver time
                return getDenverMidnight();
            }
            // Other ranges: subtract days from Denver time
            return new Date(now.getTime() - (timeRange * 24 * 60 * 60 * 1000));
        }

        function renderPerformanceAnalytics() {
            const filter = document.getElementById('performanceFilter')?.value || 'all';
            const viewMode = document.getElementById('performanceViewMode')?.value || 'overview';
            const timeRange = parseInt(document.getElementById('performanceTimeRange')?.value) || 30;
            const statsContainer = document.getElementById('performanceStats');
            const companySummary = document.getElementById('companySummary');
            const staffingContainer = document.getElementById('staffingRecommendations');
            const capacityContainer = document.getElementById('capacityPlanning');
            const logContainer = document.getElementById('activityLog');
            
            if (!statsContainer) return;
            
            // Update today's production summary
            updateTodayProduction();
            
            // Update company production summary based on time range
            updateCompanyProductionSummary(timeRange);
            
            // Update login tracker
            updateLoginTracker();

            const targets = loadTargets();
            
            // Calculate date range
            const now = new Date();
            const rangeStart = getPerformanceRangeStart(timeRange);
            
            // Build employee production data from batches
            const employeeData = {};
            const dailyProduction = {}; // For trend analysis
            
            batches.forEach(batch => {
                // Track packaging production
                if (batch.packaging_user && batch.packaging_date && batch.units_packaged) {
                    const packagingDate = new Date(batch.packaging_date);
                    if (packagingDate >= rangeStart) {
                        const user = batch.packaging_user;
                        if (!employeeData[user]) {
                            employeeData[user] = {
                                name: user,
                                packaging: { units: 0, batches: 0, byProduct: {}, dates: [] },
                                labeling: { units: 0, batches: 0, dates: [] },
                                extraction: { batches: 0, runs: 0, trimWeight: 0, dates: [] },
                                daysActive: new Set()
                            };
                        }
                        
                        employeeData[user].packaging.units += batch.units_packaged;
                        employeeData[user].packaging.batches += 1;
                        employeeData[user].packaging.dates.push(packagingDate);
                        employeeData[user].daysActive.add(packagingDate.toDateString());
                        
                        // Track by product type
                        const productType = batch.packaged_product_type || 'Unknown';
                        if (!employeeData[user].packaging.byProduct[productType]) {
                            employeeData[user].packaging.byProduct[productType] = 0;
                        }
                        employeeData[user].packaging.byProduct[productType] += batch.units_packaged;
                        
                        // Daily production tracking
                        const dateKey = packagingDate.toDateString();
                        if (!dailyProduction[dateKey]) dailyProduction[dateKey] = { packaging: 0, labeling: 0 };
                        dailyProduction[dateKey].packaging += batch.units_packaged;
                    }
                }
                
                // Track labeling production (from timeline)
                if (batch.timeline && batch.timeline.length > 0) {
                    batch.timeline.forEach(event => {
                        const eventDate = new Date(event.timestamp || event.date);
                        
                        // Labeling completion
                        if (event.stage === 'labeling' && 
                            event.action && 
                            (event.action.toLowerCase().includes('completed') || event.action.toLowerCase().includes('labeled')) &&
                            eventDate >= rangeStart &&
                            batch.units_packaged) {
                            
                            const user = event.user;
                            if (!employeeData[user]) {
                                employeeData[user] = {
                                    name: user,
                                    packaging: { units: 0, batches: 0, byProduct: {}, dates: [] },
                                    labeling: { units: 0, batches: 0, dates: [] },
                                    extraction: { batches: 0, runs: 0, trimWeight: 0, dates: [] },
                                    daysActive: new Set()
                                };
                            }
                            
                            employeeData[user].labeling.units += batch.units_packaged;
                            employeeData[user].labeling.batches += 1;
                            employeeData[user].labeling.dates.push(eventDate);
                            employeeData[user].daysActive.add(eventDate.toDateString());
                            
                            const dateKey = eventDate.toDateString();
                            if (!dailyProduction[dateKey]) dailyProduction[dateKey] = { packaging: 0, labeling: 0 };
                            dailyProduction[dateKey].labeling += batch.units_packaged;
                        }
                        
                        // Extraction completion - check multiple formats
                        const isExtractionComplete1 = (
                            (event.stage === 'extraction' && event.action && event.action.toLowerCase().includes('completed')) ||
                            (event.stage === 'ready_for_testing' && event.action && event.action.includes('Extraction Complete'))
                        );
                        if (isExtractionComplete1 && eventDate >= rangeStart) {
                            
                            const user = event.user;
                            if (!employeeData[user]) {
                                employeeData[user] = {
                                    name: user,
                                    packaging: { units: 0, batches: 0, byProduct: {}, dates: [] },
                                    labeling: { units: 0, batches: 0, dates: [] },
                                    extraction: { batches: 0, runs: 0, trimWeight: 0, dates: [] },
                                    daysActive: new Set()
                                };
                            }
                            
                            employeeData[user].extraction.batches += 1;
                            // Track runs from extraction_runs field
                            if (batch.extraction_runs) {
                                employeeData[user].extraction.runs += parseInt(batch.extraction_runs);
                            }
                            // Track trim weight processed
                            if (batch.trim_weight) {
                                employeeData[user].extraction.trimWeight += parseFloat(batch.trim_weight);
                            }
                            employeeData[user].extraction.dates.push(eventDate);
                            employeeData[user].daysActive.add(eventDate.toDateString());
                        }
                        
                        // Finishing completion - count as active day
                        if (event.stage === 'finishing' && 
                            event.action && 
                            event.action.toLowerCase().includes('completed') &&
                            eventDate >= rangeStart) {
                            
                            const user = event.user;
                            if (!employeeData[user]) {
                                employeeData[user] = {
                                    name: user,
                                    packaging: { units: 0, batches: 0, byProduct: {}, dates: [] },
                                    labeling: { units: 0, batches: 0, dates: [] },
                                    extraction: { batches: 0, runs: 0, trimWeight: 0, dates: [] },
                                    daysActive: new Set()
                                };
                            }
                            employeeData[user].daysActive.add(eventDate.toDateString());
                        }
                    });
                }
            });
            
            // Add extraction runs from localStorage (actual column runs)
            const extractionRuns = JSON.parse(localStorage.getItem('wm_extraction_runs') || '[]');
            extractionRuns.forEach(run => {
                const runDate = new Date(run.timestamp);
                if (runDate < rangeStart) return;

                const user = run.user;
                if (!employeeData[user]) {
                    employeeData[user] = {
                        name: user,
                        packaging: { units: 0, batches: 0, byProduct: {}, dates: [] },
                        labeling: { units: 0, batches: 0, dates: [] },
                        extraction: { batches: 0, runs: 0, trimWeight: 0, dates: [] },
                        daysActive: new Set()
                    };
                }

                employeeData[user].extraction.runs += 1;
                employeeData[user].extraction.trimWeight += run.trimWeight || 0;
                employeeData[user].extraction.dates.push(runDate);
                employeeData[user].daysActive.add(runDate.toDateString());
            });

            // Calculate per-day averages for each employee
            Object.values(employeeData).forEach(emp => {
                const daysActive = emp.daysActive.size;
                emp.daysActiveCount = daysActive;
                // Combined units (packaging + labeling)
                emp.totalUnits = emp.packaging.units + emp.labeling.units;
                emp.unitsPerDay = daysActive > 0 ? (emp.totalUnits / daysActive).toFixed(0) : 0;
                emp.packaging.perDay = daysActive > 0 ? (emp.packaging.units / daysActive).toFixed(1) : 0;
                emp.labeling.perDay = daysActive > 0 ? (emp.labeling.units / daysActive).toFixed(1) : 0;
                emp.extraction.perDay = daysActive > 0 ? (emp.extraction.trimWeight / daysActive).toFixed(0) : 0;
            });
            
            // Filter data if needed
            const displayData = filter === 'all' 
                ? Object.values(employeeData) 
                : Object.values(employeeData).filter(e => e.name === filter);
            
            // Render company-wide summary (removed - now using separate function)
            
            // Render employee cards
            renderEmployeeCards(employeeData, timeRange);
            
            // Render individual employee cards based on view mode (legacy)
            if (displayData.length === 0) {
                statsContainer.innerHTML = '<p style="text-align: center; color: var(--text-secondary); padding: 40px;">No production data found for this period</p>';
            } else {
                const sortedEmployees = displayData.sort((a, b) => {
                    if (viewMode === 'packaging') return b.packaging.units - a.packaging.units;
                    if (viewMode === 'labeling') return b.labeling.units - a.labeling.units;
                    if (viewMode === 'extraction') return b.extraction.batches - a.extraction.batches;
                    return (b.packaging.units + b.labeling.units) - (a.packaging.units + a.labeling.units);
                });
                
                statsContainer.innerHTML = sortedEmployees.map(emp => {
                    // Determine current task status for this employee
                    let currentTask = null;
                    batches.forEach(batch => {
                        // Check packaging in progress - status stays as 'finishing' while packaging
                        if (batch.status === 'finishing') {
                            const hasStarted = batch.timeline && batch.timeline.some(t =>
                                t.action && t.action.toLowerCase().includes('packaging started') &&
                                t.user === emp.name);
                            const hasCompleted = batch.timeline && batch.timeline.some(t =>
                                t.stage === 'packaging' && t.action &&
                                (t.action.toLowerCase().includes('packaged') || t.action.includes('Packaging completed')));

                            if (hasStarted && !hasCompleted) {
                                currentTask = {
                                    type: 'packaging',
                                    batchId: batch.id,
                                    strain: batch.strain || batch.strain_name || 'Unknown',
                                    paused: batch.packaging_paused || false
                                };
                            }
                        }
                        // Check labeling in progress - status is 'complete' while labeling
                        if (batch.status === 'complete') {
                            const hasStarted = batch.timeline && batch.timeline.some(t =>
                                t.action && t.action.toLowerCase().includes('labeling started') &&
                                t.user === emp.name);
                            const hasCompleted = batch.timeline && batch.timeline.some(t =>
                                t.stage === 'labeling' && t.action && t.action.toLowerCase().includes('labeled'));

                            if (hasStarted && !hasCompleted) {
                                currentTask = {
                                    type: 'labeling',
                                    batchId: batch.id,
                                    strain: batch.strain || batch.strain_name || 'Unknown',
                                    paused: batch.labeling_paused || false
                                };
                            }
                        }
                    });

                    // Combined units target (packaging + labeling = 800/day total)
                    const unitsTarget = (targets.unitsPerDay || 800) * emp.daysActiveCount;
                    const totalUnits = emp.packaging.units + emp.labeling.units;
                    const unitsPct = unitsTarget > 0 ? ((totalUnits / unitsTarget) * 100).toFixed(0) : 0;
                    const extractionTrimTarget = (targets.extractionTrim || 11200) * emp.daysActiveCount;
                    const extractionPct = extractionTrimTarget > 0 ? ((emp.extraction.trimWeight / extractionTrimTarget) * 100).toFixed(0) : 0;
                    
                    // Determine performance color
                    const getPerformanceColor = (pct) => {
                        if (pct >= 90) return 'var(--accent-green)';
                        if (pct >= 70) return 'var(--accent-blue)';
                        if (pct >= 50) return 'var(--accent-orange)';
                        return 'var(--accent-red)';
                    };
                    
                    let detailSection = '';
                    
                    if (viewMode === 'overview' || viewMode === 'packaging') {
                        const productBreakdown = Object.entries(emp.packaging.byProduct)
                            .sort((a, b) => b[1] - a[1])
                            .map(([product, units]) => `
                                <div style="display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid var(--border);">
                                    <span>${product}</span>
                                    <span style="font-weight: 700; font-family: 'Space Mono', monospace;">${units} units</span>
                                </div>
                            `).join('');
                        
                        detailSection += `
                            <div style="background: var(--bg-primary); padding: 20px; border-radius: 12px; margin-top: 15px;">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                                    <h4 style="color: var(--accent-blue); font-size: 1.1rem;"> Packaging Performance</h4>
                                    <span style="font-size: 1.5rem; font-weight: 700; color: ${getPerformanceColor(unitsPct)};">${unitsPct}%</span>
                                </div>
                                
                                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px; margin-bottom: 15px;">
                                    <div style="text-align: center; padding: 15px; background: var(--bg-secondary); border-radius: 8px;">
                                        <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 5px;">Total Units</div>
                                        <div style="font-size: 2rem; font-weight: 700; color: var(--accent-blue);">${emp.packaging.units.toLocaleString()}</div>
                                    </div>
                                    <div style="text-align: center; padding: 15px; background: var(--bg-secondary); border-radius: 8px;">
                                        <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 5px;">Per Day</div>
                                        <div style="font-size: 2rem; font-weight: 700; color: var(--accent-green);">${emp.packaging.perDay}</div>
                                    </div>
                                    <div style="text-align: center; padding: 15px; background: var(--bg-secondary); border-radius: 8px;">
                                        <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 5px;">Batches</div>
                                        <div style="font-size: 2rem; font-weight: 700; color: var(--accent-purple);">${emp.packaging.batches}</div>
                                    </div>
                                </div>
                                
                                ${Object.keys(emp.packaging.byProduct).length > 0 ? `
                                    <div style="border-top: 2px solid var(--border); padding-top: 15px;">
                                        <h5 style="margin-bottom: 10px; color: var(--text-secondary); font-size: 0.9rem;">By Product Type:</h5>
                                        ${productBreakdown}
                                    </div>
                                ` : ''}
                                
                                <div style="margin-top: 15px; padding: 12px; background: var(--bg-secondary); border-radius: 8px; border-left: 4px solid ${getPerformanceColor(unitsPct)};">
                                    <div style="display: flex; justify-content: space-between; align-items: center;">
                                        <span style="color: var(--text-secondary);">Target: ${targets.unitsPerDay || 800}/day  ${emp.daysActiveCount} days</span>
                                        <span style="font-weight: 700;">${emp.packaging.units} / ${unitsTarget}</span>
                                    </div>
                                </div>
                            </div>
                        `;
                    }
                    
                    if (viewMode === 'overview' || viewMode === 'labeling') {
                        detailSection += `
                            <div style="background: var(--bg-primary); padding: 20px; border-radius: 12px; margin-top: 15px;">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                                    <h4 style="color: var(--accent-green); font-size: 1.1rem;"> Labeling Performance</h4>
                                    <span style="font-size: 1.5rem; font-weight: 700; color: ${getPerformanceColor(unitsPct)};">${unitsPct}%</span>
                                </div>
                                
                                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px; margin-bottom: 15px;">
                                    <div style="text-align: center; padding: 15px; background: var(--bg-secondary); border-radius: 8px;">
                                        <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 5px;">Total Units</div>
                                        <div style="font-size: 2rem; font-weight: 700; color: var(--accent-green);">${emp.labeling.units.toLocaleString()}</div>
                                    </div>
                                    <div style="text-align: center; padding: 15px; background: var(--bg-secondary); border-radius: 8px;">
                                        <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 5px;">Per Day</div>
                                        <div style="font-size: 2rem; font-weight: 700; color: var(--accent-blue);">${emp.labeling.perDay}</div>
                                    </div>
                                    <div style="text-align: center; padding: 15px; background: var(--bg-secondary); border-radius: 8px;">
                                        <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 5px;">Batches</div>
                                        <div style="font-size: 2rem; font-weight: 700; color: var(--accent-purple);">${emp.labeling.batches}</div>
                                    </div>
                                </div>
                                
                                <div style="margin-top: 15px; padding: 12px; background: var(--bg-secondary); border-radius: 8px; border-left: 4px solid ${getPerformanceColor(unitsPct)};">
                                    <div style="display: flex; justify-content: space-between; align-items: center;">
                                        <span style="color: var(--text-secondary);">Target: ${targets.unitsPerDay || 800}/day  ${emp.daysActiveCount} days</span>
                                        <span style="font-weight: 700;">${emp.labeling.units} / ${unitsTarget}</span>
                                    </div>
                                </div>
                            </div>
                        `;
                    }
                    
                    if (viewMode === 'overview' || viewMode === 'extraction') {
                        detailSection += `
                            <div style="background: var(--bg-primary); padding: 20px; border-radius: 12px; margin-top: 15px;">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                                    <h4 style="color: var(--accent-orange); font-size: 1.1rem;"> Extraction Performance</h4>
                                    <span style="font-size: 1.5rem; font-weight: 700; color: ${getPerformanceColor(extractionPct)};">${extractionPct}%</span>
                                </div>
                                
                                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px; margin-bottom: 15px;">
                                    <div style="text-align: center; padding: 15px; background: var(--bg-secondary); border-radius: 8px;">
                                        <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 5px;">Batches</div>
                                        <div style="font-size: 2rem; font-weight: 700; color: var(--accent-orange);">${emp.extraction.batches}</div>
                                    </div>
                                    <div style="text-align: center; padding: 15px; background: var(--bg-secondary); border-radius: 8px;">
                                        <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 5px;">Total Runs</div>
                                        <div style="font-size: 2rem; font-weight: 700; color: var(--accent-blue);">${emp.extraction.runs}</div>
                                    </div>
                                    <div style="text-align: center; padding: 15px; background: var(--bg-secondary); border-radius: 8px;">
                                        <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 5px;">Trim (g)</div>
                                        <div style="font-size: 2rem; font-weight: 700; color: var(--accent-green);">${emp.extraction.trimWeight.toFixed(0)}</div>
                                    </div>
                                </div>
                                
                                <div style="margin-top: 15px; padding: 12px; background: var(--bg-secondary); border-radius: 8px; border-left: 4px solid ${getPerformanceColor(extractionPct)};">
                                    <div style="display: flex; justify-content: space-between; align-items: center;">
                                        <span style="color: var(--text-secondary);">Trim Target: ${targets.extractionTrim || 11200}g/day  ${emp.daysActiveCount} days</span>
                                        <span style="font-weight: 700;">${emp.extraction.trimWeight.toFixed(0)}g / ${extractionTrimTarget.toFixed(0)}g</span>
                                    </div>
                                </div>
                            </div>
                        `;
                    }
                    
                    return `
                        <div style="background: var(--bg-tertiary); padding: 25px; border-radius: 15px; border: 2px solid var(--border); margin-bottom: 25px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                                <div>
                                    <h3 style="font-size: 1.8rem; margin-bottom: 5px; color: var(--accent-purple);">
                                        ${emp.name}
                                        ${(() => {
                                            // Find PIN for this employee
                                            const roleEntry = Object.entries(ROLES).find(([key, role]) => role.name === emp.name);
                                            return roleEntry ? ` - PIN: ${roleEntry[1].pin}` : '';
                                        })()}
                                    </h3>
                                    <p style="color: var(--text-secondary); font-size: 0.95rem;">Active ${emp.daysActiveCount} of ${timeRange} days</p>
                                    ${currentTask ? `
                                    <div style="margin-top: 8px; display: inline-flex; align-items: center; gap: 8px; padding: 6px 12px; border-radius: 20px; font-size: 0.85rem; font-weight: 600;
                                        background: ${currentTask.paused ? 'rgba(255, 107, 0, 0.2)' : 'rgba(57, 255, 20, 0.2)'};
                                        border: 1px solid ${currentTask.paused ? 'var(--accent-orange)' : 'var(--accent-green)'};
                                        color: ${currentTask.paused ? 'var(--accent-orange)' : 'var(--accent-green)'};">
                                        <span style="font-size: 1rem;">${currentTask.paused ? '' : currentTask.type === 'packaging' ? '' : ''}</span>
                                        <span>${currentTask.paused ? 'PAUSED' : 'WORKING'}: ${currentTask.type === 'packaging' ? 'Packaging' : 'Labeling'} ${currentTask.strain}</span>
                                    </div>
                                    ` : ''}
                                </div>
                                <div style="text-align: right;">
                                    <div style="font-family: 'Space Mono', monospace; font-size: 2.5rem; font-weight: 700; color: var(--accent-green);">${(emp.packaging.units + emp.labeling.units).toLocaleString()}</div>
                                    <div style="color: var(--text-secondary); font-size: 0.9rem;">Total Units</div>
                                </div>
                            </div>
                            
                            ${detailSection}
                        </div>
                    `;
                }).join('');
            }
            
            // Staffing recommendations (only show when viewing all employees)
            if (staffingContainer && filter === 'all') {
                const totalPackaging = Object.values(employeeData).reduce((sum, e) => sum + e.packaging.units, 0);
                const totalLabeling = Object.values(employeeData).reduce((sum, e) => sum + e.labeling.units, 0);
                const avgDailyPackaging = totalPackaging / timeRange;
                const avgDailyLabeling = totalLabeling / timeRange;
                const activeEmployees = Object.keys(employeeData).length;
                
                const packagingCapacity = activeEmployees * targets.packaging;
                const labelingCapacity = activeEmployees * targets.labeling;
                
                const packagingUtilization = packagingCapacity > 0 ? ((avgDailyPackaging / packagingCapacity) * 100).toFixed(0) : 0;
                const labelingUtilization = labelingCapacity > 0 ? ((avgDailyLabeling / labelingCapacity) * 100).toFixed(0) : 0;
                
                // Calculate needed employees to meet different inventory targets
                const inventoryTargets = [500, 1000, 1500, 2000];
                
                staffingContainer.innerHTML = `
                    <div style="background: var(--bg-tertiary); padding: 25px; border-radius: 15px; border: 2px solid var(--accent-green);">
                        <h3 style="color: var(--accent-green); margin-bottom: 20px; font-size: 1.4rem;"> Capacity & Staffing Analysis</h3>
                        
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; margin-bottom: 25px;">
                            <div style="background: var(--bg-primary); padding: 20px; border-radius: 12px;">
                                <div style="font-size: 0.9rem; color: var(--text-secondary); margin-bottom: 10px;">Packaging Capacity Utilization</div>
                                <div style="font-size: 2.5rem; font-weight: 700; color: ${packagingUtilization >= 80 ? 'var(--accent-red)' : packagingUtilization >= 60 ? 'var(--accent-orange)' : 'var(--accent-green)'};">${packagingUtilization}%</div>
                                <div style="font-size: 0.85rem; color: var(--text-secondary); margin-top: 8px;">${avgDailyPackaging.toFixed(0)} / ${packagingCapacity} units per day</div>
                            </div>
                            
                            <div style="background: var(--bg-primary); padding: 20px; border-radius: 12px;">
                                <div style="font-size: 0.9rem; color: var(--text-secondary); margin-bottom: 10px;">Labeling Capacity Utilization</div>
                                <div style="font-size: 2.5rem; font-weight: 700; color: ${labelingUtilization >= 80 ? 'var(--accent-red)' : labelingUtilization >= 60 ? 'var(--accent-orange)' : 'var(--accent-green)'};">${labelingUtilization}%</div>
                                <div style="font-size: 0.85rem; color: var(--text-secondary); margin-top: 8px;">${avgDailyLabeling.toFixed(0)} / ${labelingCapacity} units per day</div>
                            </div>
                        </div>
                        
                        <div style="background: var(--bg-primary); padding: 20px; border-radius: 12px;">
                            <h4 style="margin-bottom: 15px; color: var(--accent-blue);">Staffing to Meet Daily Production Targets:</h4>
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                                ${inventoryTargets.map(target => {
                                    const packagingNeeded = Math.ceil(target / targets.packaging);
                                    const labelingNeeded = Math.ceil(target / targets.labeling);
                                    const maxNeeded = Math.max(packagingNeeded, labelingNeeded);
                                    const diff = maxNeeded - activeEmployees;
                                    
                                    return `
                                        <div style="background: var(--bg-secondary); padding: 15px; border-radius: 8px; border-left: 4px solid ${diff > 0 ? 'var(--accent-orange)' : 'var(--accent-green)'};">
                                            <div style="font-weight: 700; font-size: 1.3rem; margin-bottom: 8px; color: var(--accent-purple);">${target} units/day</div>
                                            <div style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 5px;">Packaging: ${packagingNeeded} employees</div>
                                            <div style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 10px;">Labeling: ${labelingNeeded} employees</div>
                                            <div style="font-weight: 600; color: ${diff > 0 ? 'var(--accent-orange)' : 'var(--accent-green)'};">
                                                ${diff > 0 ? `Need +${diff} more` : diff < 0 ? `${Math.abs(diff)} extra capacity` : ' Fully staffed'}
                                            </div>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        </div>
                    </div>
                `;
            } else if (staffingContainer) {
                staffingContainer.innerHTML = '';
            }
            
            // Render activity log
            if (logContainer) {
                const activities = [];
                batches.forEach(batch => {
                    if (batch.timeline && Array.isArray(batch.timeline)) {
                        batch.timeline.forEach(event => {
                            const eventDate = new Date(event.timestamp || event.date);
                            if (eventDate >= rangeStart) {
                                activities.push({
                                    ...event,
                                    batchId: batch.id,
                                    strain: batch.strain,
                                    date: eventDate,
                                    units: batch.units_packaged || 0
                                });
                            }
                        });
                    }
                });
                
                const filteredActivities = filter === 'all' 
                    ? activities 
                    : activities.filter(a => a.user === filter);
                
                const sortedActivities = filteredActivities.sort((a, b) => b.date - a.date);
                
                if (sortedActivities.length === 0) {
                    logContainer.innerHTML = '<p style="text-align: center; color: var(--text-secondary); padding: 40px;">No activities to display</p>';
                } else {
                    logContainer.innerHTML = `
                        <div style="overflow-x: auto;">
                            <table style="width: 100%; border-collapse: collapse;">
                                <thead>
                                    <tr style="background: var(--bg-tertiary); border-bottom: 2px solid var(--border);">
                                        <th style="padding: 15px; text-align: left; color: var(--text-secondary); font-size: 0.9rem; text-transform: uppercase;">Date</th>
                                        <th style="padding: 15px; text-align: left; color: var(--text-secondary); font-size: 0.9rem; text-transform: uppercase;">Employee</th>
                                        <th style="padding: 15px; text-align: left; color: var(--text-secondary); font-size: 0.9rem; text-transform: uppercase;">Action</th>
                                        <th style="padding: 15px; text-align: left; color: var(--text-secondary); font-size: 0.9rem; text-transform: uppercase;">Batch</th>
                                        <th style="padding: 15px; text-align: left; color: var(--text-secondary); font-size: 0.9rem; text-transform: uppercase;">Strain</th>
                                        <th style="padding: 15px; text-align: right; color: var(--text-secondary); font-size: 0.9rem; text-transform: uppercase;">Units</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${sortedActivities.slice(0, 100).map(activity => {
                                        const isCompletion = activity.action && (
                                            activity.action.toLowerCase().includes('completed') ||
                                            activity.action.toLowerCase().includes('labeled')
                                        );
                                        
                                        return `
                                            <tr style="border-bottom: 1px solid var(--border);">
                                                <td style="padding: 12px; color: var(--text-secondary); font-size: 0.95rem;">${activity.date.toLocaleDateString()} ${activity.date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</td>
                                                <td style="padding: 12px; font-weight: 600; font-size: 0.95rem;">${activity.user}</td>
                                                <td style="padding: 12px;">
                                                    <span style="background: rgba(147, 51, 234, 0.2); color: var(--accent-purple); padding: 6px 12px; border-radius: 12px; font-size: 0.85rem; text-transform: capitalize;">
                                                        ${activity.stage || 'unknown'}
                                                    </span>
                                                    ${isCompletion ? '<span style="margin-left: 8px; color: var(--accent-green);"></span>' : ''}
                                                </td>
                                                <td style="padding: 12px; font-family: 'Space Mono', monospace; font-size: 0.95rem;">${activity.batchId}</td>
                                                <td style="padding: 12px; color: var(--text-secondary); font-size: 0.95rem;">${activity.strain}</td>
                                                <td style="padding: 12px; text-align: right; font-weight: 700; font-family: 'Space Mono', monospace; font-size: 0.95rem;">${isCompletion && activity.units > 0 ? activity.units : '-'}</td>
                                            </tr>
                                        `;
                                    }).join('')}
                                </tbody>
                            </table>
                        </div>
                        ${sortedActivities.length > 100 ? '<p style="text-align: center; color: var(--text-secondary); margin-top: 20px;">Showing most recent 100 activities</p>' : ''}
                    `;
                }
            }
        }

        

        // Get employee role info from ROLES object
        function getEmployeeRole(employeeName) {
            const roleKey = Object.keys(ROLES).find(key => ROLES[key].name === employeeName);
            return roleKey ? ROLES[roleKey] : null;
        }

        // Render clickable employee cards
        function renderEmployeeCards(employeeData, timeRange) {
            const grid = document.getElementById('employeeCardsGrid');
            if (!grid) return;

            const targets = loadTargets();
            const now = new Date();
            const rangeStart = getPerformanceRangeStart(timeRange);

            // Update date range display
            const dateRangeEl = document.getElementById('performanceDateRange');
            if (dateRangeEl) {
                dateRangeEl.textContent = timeRange === 1 ? 'Today (' + getDenverDate().toLocaleDateString() + ')' : rangeStart.toLocaleDateString() + ' - ' + getDenverDate().toLocaleDateString();
            }

            // Get all employees from ROLES (excluding demo)
            const allEmployees = Object.values(ROLES)
                .filter(r => !r.isDemo && r.name !== 'Drew (Sales)')
                .map(r => {
                    const data = employeeData[r.name] || {
                        name: r.name,
                        packaging: { units: 0, batches: 0, byProduct: {}, dates: [], perDay: 0 },
                        labeling: { units: 0, batches: 0, dates: [], perDay: 0 },
                        extraction: { batches: 0, runs: 0, trimWeight: 0, dates: [], perDay: 0 },
                        daysActive: new Set(),
                        daysActiveCount: 0
                    };
                    return { ...data, role: r };
                });

            if (allEmployees.length === 0) {
                grid.innerHTML = '<p style="text-align: center; color: var(--text-secondary); padding: 40px;">No employees found</p>';
                return;
            }

            grid.innerHTML = allEmployees.map(emp => {
                const role = emp.role;
                const access = role.access || [];

                // Calculate overall performance %
                // Combined units target
                const unitsTarget = (targets.unitsPerDay || 800) * (emp.daysActiveCount || 1);
                const totalUnits = (emp.packaging?.units || 0) + (emp.labeling?.units || 0);
                const extractionTarget = (targets.extractionTrim || 11200) * (emp.daysActiveCount || 1);

                let scores = [];
                // Combined units score for packaging/labeling
                if ((access.includes('packaging') || access.includes('labeling')) && unitsTarget > 0) {
                    scores.push((totalUnits / unitsTarget) * 100);
                }
                // Extraction score
                if (access.includes('extraction') && extractionTarget > 0) {
                    scores.push((emp.extraction.trimWeight / extractionTarget) * 100);
                }

                const avgScore = scores.length > 0 ? scores.reduce((a, b) => a + b, 0) / scores.length : 0;
                const scoreColor = avgScore >= 90 ? 'var(--accent-green)' : avgScore >= 70 ? 'var(--accent-blue)' : avgScore >= 50 ? 'var(--accent-orange)' : 'var(--accent-red)';

                // Build skill badges based on access
                const skillBadges = [];
                if (access.includes('extraction')) skillBadges.push('<span style="background: rgba(245, 158, 11, 0.3); color: var(--accent-orange); padding: 3px 8px; border-radius: 10px; font-size: 0.75rem;">Extraction</span>');
                if (access.includes('finishing')) skillBadges.push('<span style="background: rgba(59, 130, 246, 0.3); color: var(--accent-blue); padding: 3px 8px; border-radius: 10px; font-size: 0.75rem;">Finishing</span>');
                if (access.includes('packaging')) skillBadges.push('<span style="background: rgba(147, 51, 234, 0.3); color: var(--accent-purple); padding: 3px 8px; border-radius: 10px; font-size: 0.75rem;">Packaging</span>');
                if (access.includes('labeling')) skillBadges.push('<span style="background: rgba(16, 185, 129, 0.3); color: var(--accent-green); padding: 3px 8px; border-radius: 10px; font-size: 0.75rem;">Labeling</span>');

                // Build quick stats based on access
                let quickStats = '';
                if (access.includes('packaging')) {
                    quickStats += '<div style="display: flex; justify-content: space-between; padding: 6px 0; border-bottom: 1px solid var(--border);"><span style="color: var(--text-secondary);">Packaged</span><span style="font-weight: 600; font-family: monospace;">' + emp.packaging.units.toLocaleString() + ' units</span></div>';
                }
                if (access.includes('labeling')) {
                    quickStats += '<div style="display: flex; justify-content: space-between; padding: 6px 0; border-bottom: 1px solid var(--border);"><span style="color: var(--text-secondary);">Labeled</span><span style="font-weight: 600; font-family: monospace;">' + emp.labeling.units.toLocaleString() + ' units</span></div>';
                }
                if (access.includes('extraction')) {
                    quickStats += '<div style="display: flex; justify-content: space-between; padding: 6px 0; border-bottom: 1px solid var(--border);"><span style="color: var(--text-secondary);">Extracted</span><span style="font-weight: 600; font-family: monospace;">' + emp.extraction.trimWeight.toFixed(0) + 'g trim</span></div>';
                }
                if (access.includes('finishing')) {
                    quickStats += '<div style="display: flex; justify-content: space-between; padding: 6px 0;"><span style="color: var(--text-secondary);">Batches Finished</span><span style="font-weight: 600; font-family: monospace;">' + emp.extraction.batches + '</span></div>';
                }

                if (!quickStats) {
                    quickStats = '<div style="color: var(--text-secondary); text-align: center; padding: 10px;">No tracked activities</div>';
                }

                // Determine current task status for this employee
                let currentTask = null;
                batches.forEach(batch => {
                    // Check packaging in progress - status stays as 'finishing' while packaging
                    if (batch.status === 'finishing') {
                        const hasStarted = batch.timeline && batch.timeline.some(t =>
                            t.action && t.action.toLowerCase().includes('packaging started') &&
                            t.user === emp.name);
                        const hasCompleted = batch.timeline && batch.timeline.some(t =>
                            t.stage === 'packaging' && t.action &&
                            (t.action.toLowerCase().includes('packaged') || t.action.includes('Packaging completed')));
                        if (hasStarted && !hasCompleted) {
                            currentTask = {
                                type: 'packaging',
                                batchId: batch.id,
                                strain: batch.strain || batch.strain_name || 'Unknown',
                                weight: batch.final_weight || batch.net_weight || batch.bulk_weight || 0,
                                paused: batch.packaging_paused || false
                            };
                        }
                    }
                    // Check labeling in progress - status is 'complete' while labeling
                    if (batch.status === 'complete') {
                        const hasStarted = batch.timeline && batch.timeline.some(t =>
                            t.action && t.action.toLowerCase().includes('labeling started') &&
                            t.user === emp.name);
                        const hasCompleted = batch.timeline && batch.timeline.some(t =>
                            t.stage === 'labeling' && t.action && t.action.toLowerCase().includes('labeled'));
                        if (hasStarted && !hasCompleted) {
                            currentTask = {
                                type: 'labeling',
                                batchId: batch.id,
                                strain: batch.strain || batch.strain_name || 'Unknown',
                                weight: batch.final_weight || batch.net_weight || batch.bulk_weight || 0,
                                paused: batch.labeling_paused || false
                            };
                        }
                    }
                });

                const currentTaskHtml = currentTask ? `
                    <div style="margin-top: 12px; display: flex; align-items: center; gap: 8px; padding: 8px 12px; border-radius: 20px; font-size: 0.85rem; font-weight: 600;
                        background: ${currentTask.paused ? 'rgba(255, 107, 0, 0.2)' : 'rgba(57, 255, 20, 0.2)'};
                        border: 1px solid ${currentTask.paused ? 'var(--accent-orange)' : 'var(--accent-green)'};
                        color: ${currentTask.paused ? 'var(--accent-orange)' : 'var(--accent-green)'};">
                        <span style="font-size: 1rem;">${currentTask.paused ? '' : currentTask.type === 'packaging' ? '' : ''}</span>
                        <span>${currentTask.paused ? 'PAUSED' : 'WORKING'}: ${currentTask.type === 'packaging' ? 'Packaging' : 'Labeling'} ${currentTask.strain}${currentTask.weight ? ' (' + currentTask.weight + 'g)' : ''}</span>
                    </div>
                ` : '';

                return `
                    <div onclick="showEmployeeDetailModal('${emp.name}')" style="background: var(--bg-tertiary); padding: 20px; border-radius: 15px; border: 2px solid var(--border); cursor: pointer; transition: all 0.2s ease; position: relative;" onmouseover="this.style.borderColor='var(--accent-purple)'; this.style.transform='translateY(-2px)';" onmouseout="this.style.borderColor='var(--border)'; this.style.transform='none';">
                        <!-- Performance Score Badge -->
                        <div style="position: absolute; top: 15px; right: 15px; background: ${scoreColor}; color: white; padding: 5px 10px; border-radius: 20px; font-weight: 700; font-size: 0.85rem;">
                            ${avgScore.toFixed(0)}%
                        </div>

                        <!-- Name and Days Active -->
                        <h3 style="font-size: 1.4rem; margin: 0 0 5px 0; color: var(--text-primary);">${emp.name.replace(' (Admin)', '')}</h3>
                        <div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 12px;">${emp.daysActiveCount} days active</div>

                        <!-- Current Task Badge -->
                        ${currentTaskHtml}

                        <!-- Skill Badges -->
                        <div style="display: flex; gap: 5px; flex-wrap: wrap; margin-bottom: 15px; margin-top: 12px;">
                            ${skillBadges.join('')}
                        </div>

                        <!-- Quick Stats -->
                        <div style="font-size: 0.95rem;">
                            ${quickStats}
                        </div>
                    </div>
                `;
            }).join('');
        }

        // Show employee detail modal
        function showEmployeeDetailModal(employeeName) {
            const role = getEmployeeRole(employeeName);
            if (!role) return;

            const access = role.access || [];
            const timeRange = parseInt(document.getElementById('performanceTimeRange')?.value) || 30;
            const targets = loadTargets();

            // Recalculate employee data
            const now = new Date();
            const rangeStart = getPerformanceRangeStart(timeRange);

            let empData = {
                packaging: { units: 0, batches: 0, byProduct: {}, dates: [], timeMinutes: 0 },
                labeling: { units: 0, batches: 0, dates: [], timeMinutes: 0 },
                extraction: { batches: 0, runs: 0, trimWeight: 0, dates: [] },
                finishing: { batches: 0, dates: [] },
                daysActive: new Set()
            };

            // Add extraction runs from localStorage first
            const extractionRuns = JSON.parse(localStorage.getItem('wm_extraction_runs') || '[]');
            extractionRuns.forEach(run => {
                if (run.user !== employeeName) return;
                const runDate = new Date(run.timestamp);
                if (runDate < rangeStart) return;

                empData.extraction.runs += 1;
                empData.extraction.trimWeight += run.trimWeight || 0;
                empData.daysActive.add(runDate.toDateString());
            });

            // Calculate stats from batches
            batches.forEach(batch => {
                // Packaging - with time calculation
                if (batch.packaging_user === employeeName && batch.packaging_date && batch.units_packaged) {
                    const packagingDate = new Date(batch.packaging_date);
                    if (packagingDate >= rangeStart) {
                        empData.packaging.units += batch.units_packaged;
                        empData.packaging.batches += 1;
                        empData.daysActive.add(packagingDate.toDateString());
                        const productType = batch.packaged_product_type || 'Unknown';
                        empData.packaging.byProduct[productType] = (empData.packaging.byProduct[productType] || 0) + batch.units_packaged;

                        // Calculate packaging time from timeline
                        if (batch.timeline) {
                            const packagingStart = batch.timeline.find(t => t.action && t.action.toLowerCase().includes('packaging started'));
                            const packagingComplete = batch.timeline.find(t => t.stage === 'packaging' && t.action &&
                                (t.action.toLowerCase().includes('packaged') || t.action.includes('Packaging completed')));

                            if (packagingStart && packagingComplete) {
                                const startTime = new Date(packagingStart.date || packagingStart.timestamp);
                                const endTime = new Date(packagingComplete.date || packagingComplete.timestamp);
                                let batchTime = (endTime - startTime) / (1000 * 60); // minutes

                                // Subtract paused time
                                const pauses = batch.timeline.filter(t => t.action && t.action.toLowerCase().includes('packaging paused'));
                                const resumes = batch.timeline.filter(t => t.action && t.action.toLowerCase().includes('packaging resumed'));
                                for (let i = 0; i < Math.min(pauses.length, resumes.length); i++) {
                                    const pauseTime = new Date(pauses[i].date || pauses[i].timestamp);
                                    const resumeTime = new Date(resumes[i].date || resumes[i].timestamp);
                                    if (resumeTime > pauseTime) {
                                        batchTime -= (resumeTime - pauseTime) / (1000 * 60);
                                    }
                                }
                                empData.packaging.timeMinutes += Math.max(0, batchTime);
                            }
                        }
                    }
                }

                // Timeline events
                if (batch.timeline && batch.timeline.length > 0) {
                    batch.timeline.forEach(event => {
                        if (event.user !== employeeName) return;
                        const eventDate = new Date(event.timestamp || event.date);
                        if (eventDate < rangeStart) return;

                        // Labeling - with time calculation
                        if (event.stage === 'labeling' && event.action &&
                            (event.action.toLowerCase().includes('completed') || event.action.toLowerCase().includes('labeled'))) {
                            empData.labeling.units += batch.units_packaged || 0;
                            empData.labeling.batches += 1;
                            empData.daysActive.add(eventDate.toDateString());

                            // Calculate labeling time from timeline
                            const labelingStart = batch.timeline.find(t => t.action && t.action.toLowerCase().includes('labeling started'));
                            const labelingComplete = batch.timeline.find(t => t.stage === 'labeling' &&
                                (t.action && t.action.toLowerCase().includes('labeled') || t.timestamp));

                            if (labelingStart && labelingComplete) {
                                const startTime = new Date(labelingStart.date || labelingStart.timestamp);
                                const endTime = new Date(labelingComplete.date || labelingComplete.timestamp);
                                let batchTime = (endTime - startTime) / (1000 * 60); // minutes

                                // Subtract paused time
                                const pauses = batch.timeline.filter(t => t.action && t.action.toLowerCase().includes('labeling paused'));
                                const resumes = batch.timeline.filter(t => t.action && t.action.toLowerCase().includes('labeling resumed'));
                                for (let i = 0; i < Math.min(pauses.length, resumes.length); i++) {
                                    const pauseTime = new Date(pauses[i].date || pauses[i].timestamp);
                                    const resumeTime = new Date(resumes[i].date || resumes[i].timestamp);
                                    if (resumeTime > pauseTime) {
                                        batchTime -= (resumeTime - pauseTime) / (1000 * 60);
                                    }
                                }
                                empData.labeling.timeMinutes += Math.max(0, batchTime);
                            }
                        }

                        // Extraction - check multiple formats
                        const isExtractionComplete = (
                            (event.stage === 'extraction' && event.action && event.action.toLowerCase().includes('completed')) ||
                            (event.stage === 'ready_for_testing' && event.action && event.action.includes('Extraction Complete'))
                        );
                        if (isExtractionComplete) {
                            empData.extraction.batches += 1;
                            empData.extraction.runs += batch.extraction_runs ? parseInt(batch.extraction_runs) : 0;
                            empData.extraction.trimWeight += batch.trim_weight ? parseFloat(batch.trim_weight) : 0;
                            empData.daysActive.add(eventDate.toDateString());
                        }

                        // Finishing
                        if (event.stage === 'finishing' && event.action && event.action.toLowerCase().includes('completed')) {
                            empData.finishing.batches += 1;
                            empData.daysActive.add(eventDate.toDateString());
                        }
                    });
                }
            });

            const daysActive = empData.daysActive.size || 1;

            // Combined units calculation (available to both packaging and labeling sections)
            const unitsTarget = (targets.unitsPerDay || 800) * daysActive;
            const totalUnits = empData.packaging.units + empData.labeling.units;
            const unitsPct = unitsTarget > 0 ? ((totalUnits / unitsTarget) * 100).toFixed(0) : 0;
            const unitsColor = unitsPct >= 90 ? 'var(--accent-green)' : unitsPct >= 70 ? 'var(--accent-blue)' : unitsPct >= 50 ? 'var(--accent-orange)' : 'var(--accent-red)';

            // Build detail sections based on access
            let detailSections = '';

            if (access.includes('extraction')) {
                const extractionTarget = (targets.extractionTrim || 11200) * daysActive;
                const extractionPct = extractionTarget > 0 ? ((empData.extraction.trimWeight / extractionTarget) * 100).toFixed(0) : 0;
                const color = extractionPct >= 90 ? 'var(--accent-green)' : extractionPct >= 70 ? 'var(--accent-blue)' : extractionPct >= 50 ? 'var(--accent-orange)' : 'var(--accent-red)';

                detailSections += `
                    <div style="background: var(--bg-tertiary); padding: 20px; border-radius: 12px; margin-bottom: 15px; border-left: 4px solid var(--accent-orange);">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                            <h3 style="margin: 0; color: var(--accent-orange); font-size: 1.2rem;">Extraction</h3>
                            <span style="font-size: 1.5rem; font-weight: 700; color: ${color};">${extractionPct}%</span>
                        </div>
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; text-align: center;">
                            <div style="background: var(--bg-primary); padding: 15px; border-radius: 8px;">
                                <div style="font-size: 0.8rem; color: var(--text-secondary);">Trim Processed</div>
                                <div style="font-size: 1.8rem; font-weight: 700; color: var(--accent-orange);">${empData.extraction.trimWeight.toFixed(0)}g</div>
                            </div>
                            <div style="background: var(--bg-primary); padding: 15px; border-radius: 8px;">
                                <div style="font-size: 0.8rem; color: var(--text-secondary);">Batches</div>
                                <div style="font-size: 1.8rem; font-weight: 700; color: var(--accent-blue);">${empData.extraction.batches}</div>
                            </div>
                            <div style="background: var(--bg-primary); padding: 15px; border-radius: 8px;">
                                <div style="font-size: 0.8rem; color: var(--text-secondary);">Per Day Avg</div>
                                <div style="font-size: 1.8rem; font-weight: 700; color: var(--accent-green);">${(empData.extraction.trimWeight / daysActive).toFixed(0)}g</div>
                            </div>
                        </div>
                        <div style="margin-top: 15px; padding: 10px; background: var(--bg-primary); border-radius: 8px; font-size: 0.9rem; color: var(--text-secondary);">
                            Target: ${targets.extractionTrim || 11200}g/day x ${daysActive} days = ${extractionTarget.toLocaleString()}g
                        </div>
                    </div>
                `;
            }

            if (access.includes('packaging')) {
                const productBreakdown = Object.entries(empData.packaging.byProduct)
                    .sort((a, b) => b[1] - a[1])
                    .map(([product, units]) => `<div style="display: flex; justify-content: space-between; padding: 5px 0;"><span>${product}</span><span style="font-weight: 600;">${units}</span></div>`)
                    .join('');

                detailSections += `
                    <div style="background: var(--bg-tertiary); padding: 20px; border-radius: 12px; margin-bottom: 15px; border-left: 4px solid var(--accent-purple);">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                            <h3 style="margin: 0; color: var(--accent-purple); font-size: 1.2rem;">Packaging</h3>
                            <span style="font-size: 1.5rem; font-weight: 700; color: ${unitsColor};">${unitsPct}%</span>
                        </div>
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; text-align: center;">
                            <div style="background: var(--bg-primary); padding: 15px; border-radius: 8px;">
                                <div style="font-size: 0.8rem; color: var(--text-secondary);">Units Packaged</div>
                                <div style="font-size: 1.8rem; font-weight: 700; color: var(--accent-purple);">${empData.packaging.units.toLocaleString()}</div>
                            </div>
                            <div style="background: var(--bg-primary); padding: 15px; border-radius: 8px;">
                                <div style="font-size: 0.8rem; color: var(--text-secondary);">Batches</div>
                                <div style="font-size: 1.8rem; font-weight: 700; color: var(--accent-blue);">${empData.packaging.batches}</div>
                            </div>
                            <div style="background: var(--bg-primary); padding: 15px; border-radius: 8px;">
                                <div style="font-size: 0.8rem; color: var(--text-secondary);">Per Day Avg</div>
                                <div style="font-size: 1.8rem; font-weight: 700; color: var(--accent-green);">${(empData.packaging.units / daysActive).toFixed(0)}</div>
                            </div>
                        </div>
                        ${empData.packaging.timeMinutes > 0 ? `
                        <div style="margin-top: 15px; display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; text-align: center;">
                            <div style="background: linear-gradient(135deg, rgba(191, 0, 255, 0.2), rgba(191, 0, 255, 0.1)); padding: 15px; border-radius: 8px; border: 1px solid rgba(191, 0, 255, 0.3);">
                                <div style="font-size: 0.8rem; color: var(--text-secondary);">Time Worked</div>
                                <div style="font-size: 1.4rem; font-weight: 700; color: var(--accent-purple);">${Math.floor(empData.packaging.timeMinutes / 60)}h ${Math.round(empData.packaging.timeMinutes % 60)}m</div>
                            </div>
                            <div style="background: linear-gradient(135deg, rgba(57, 255, 20, 0.2), rgba(57, 255, 20, 0.1)); padding: 15px; border-radius: 8px; border: 1px solid rgba(57, 255, 20, 0.3);">
                                <div style="font-size: 0.8rem; color: var(--text-secondary);">Units/Hour</div>
                                <div style="font-size: 1.4rem; font-weight: 700; color: var(--accent-green);">${(empData.packaging.units / (empData.packaging.timeMinutes / 60)).toFixed(0)}</div>
                            </div>
                        </div>
                        ` : ''}
                        ${productBreakdown ? `<div style="margin-top: 15px; padding: 10px; background: var(--bg-primary); border-radius: 8px;"><div style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 8px;">By Product Type:</div>${productBreakdown}</div>` : ''}
                        <div style="margin-top: 15px; padding: 10px; background: var(--bg-primary); border-radius: 8px; font-size: 0.9rem; color: var(--text-secondary);">
                            Target: ${targets.unitsPerDay || 800}/day x ${daysActive} days = ${unitsTarget.toLocaleString()} units
                        </div>
                    </div>
                `;
            }

            if (access.includes('labeling')) {
                // Uses combined units target from outer scope

                detailSections += `
                    <div style="background: var(--bg-tertiary); padding: 20px; border-radius: 12px; margin-bottom: 15px; border-left: 4px solid var(--accent-green);">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                            <h3 style="margin: 0; color: var(--accent-green); font-size: 1.2rem;">Labeling</h3>
                            <span style="font-size: 1.5rem; font-weight: 700; color: ${unitsColor};">${unitsPct}%</span>
                        </div>
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; text-align: center;">
                            <div style="background: var(--bg-primary); padding: 15px; border-radius: 8px;">
                                <div style="font-size: 0.8rem; color: var(--text-secondary);">Units Labeled</div>
                                <div style="font-size: 1.8rem; font-weight: 700; color: var(--accent-green);">${empData.labeling.units.toLocaleString()}</div>
                            </div>
                            <div style="background: var(--bg-primary); padding: 15px; border-radius: 8px;">
                                <div style="font-size: 0.8rem; color: var(--text-secondary);">Batches</div>
                                <div style="font-size: 1.8rem; font-weight: 700; color: var(--accent-blue);">${empData.labeling.batches}</div>
                            </div>
                            <div style="background: var(--bg-primary); padding: 15px; border-radius: 8px;">
                                <div style="font-size: 0.8rem; color: var(--text-secondary);">Per Day Avg</div>
                                <div style="font-size: 1.8rem; font-weight: 700; color: var(--accent-purple);">${(empData.labeling.units / daysActive).toFixed(0)}</div>
                            </div>
                        </div>
                        ${empData.labeling.timeMinutes > 0 ? `
                        <div style="margin-top: 15px; display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; text-align: center;">
                            <div style="background: linear-gradient(135deg, rgba(57, 255, 20, 0.2), rgba(57, 255, 20, 0.1)); padding: 15px; border-radius: 8px; border: 1px solid rgba(57, 255, 20, 0.3);">
                                <div style="font-size: 0.8rem; color: var(--text-secondary);">Time Worked</div>
                                <div style="font-size: 1.4rem; font-weight: 700; color: var(--accent-green);">${Math.floor(empData.labeling.timeMinutes / 60)}h ${Math.round(empData.labeling.timeMinutes % 60)}m</div>
                            </div>
                            <div style="background: linear-gradient(135deg, rgba(191, 0, 255, 0.2), rgba(191, 0, 255, 0.1)); padding: 15px; border-radius: 8px; border: 1px solid rgba(191, 0, 255, 0.3);">
                                <div style="font-size: 0.8rem; color: var(--text-secondary);">Units/Hour</div>
                                <div style="font-size: 1.4rem; font-weight: 700; color: var(--accent-purple);">${(empData.labeling.units / (empData.labeling.timeMinutes / 60)).toFixed(0)}</div>
                            </div>
                        </div>
                        ` : ''}
                        <div style="margin-top: 15px; padding: 10px; background: var(--bg-primary); border-radius: 8px; font-size: 0.9rem; color: var(--text-secondary);">
                            Target: ${targets.unitsPerDay || 800}/day x ${daysActive} days = ${unitsTarget.toLocaleString()} units
                        </div>
                    </div>
                `;
            }

            if (access.includes('finishing')) {
                detailSections += `
                    <div style="background: var(--bg-tertiary); padding: 20px; border-radius: 12px; margin-bottom: 15px; border-left: 4px solid var(--accent-blue);">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                            <h3 style="margin: 0; color: var(--accent-blue); font-size: 1.2rem;">Finishing</h3>
                        </div>
                        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; text-align: center;">
                            <div style="background: var(--bg-primary); padding: 15px; border-radius: 8px;">
                                <div style="font-size: 0.8rem; color: var(--text-secondary);">Batches Finished</div>
                                <div style="font-size: 1.8rem; font-weight: 700; color: var(--accent-blue);">${empData.finishing.batches}</div>
                            </div>
                            <div style="background: var(--bg-primary); padding: 15px; border-radius: 8px;">
                                <div style="font-size: 0.8rem; color: var(--text-secondary);">Days Active</div>
                                <div style="font-size: 1.8rem; font-weight: 700; color: var(--accent-green);">${daysActive}</div>
                            </div>
                        </div>
                    </div>
                `;
            }

            if (!detailSections) {
                detailSections = '<p style="text-align: center; color: var(--text-secondary); padding: 30px;">No tracked activities for this employee based on their access level.</p>';
            }

            // Create modal
            const modal = document.createElement('div');
            modal.id = 'employeeDetailModal';
            modal.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); z-index: 10001; display: flex; justify-content: center; align-items: flex-start; padding: 40px 20px; overflow-y: auto;';

            modal.innerHTML = `
                <div style="background: var(--bg-secondary); border-radius: 20px; max-width: 700px; width: 100%; max-height: 90vh; overflow-y: auto; position: relative;">
                    <div style="padding: 25px; border-bottom: 2px solid var(--border); display: flex; justify-content: space-between; align-items: center; position: sticky; top: 0; background: var(--bg-secondary); z-index: 10;">
                        <div>
                            <h2 style="margin: 0; font-size: 1.6rem;">${employeeName.replace(' (Admin)', '')}</h2>
                            <p style="margin: 5px 0 0 0; color: var(--text-secondary); font-size: 0.9rem;">Performance details for last ${timeRange} days</p>
                        </div>
                        <button onclick="document.getElementById('employeeDetailModal').remove()" style="background: rgba(255,255,255,0.2); border: none; color: white; font-size: 1.5rem; cursor: pointer; padding: 5px 12px; border-radius: 8px;">&times;</button>
                    </div>
                    <div style="padding: 25px;">
                        ${detailSections}
                    </div>
                </div>
            `;

            // Remove existing modal if any
            const existingModal = document.getElementById('employeeDetailModal');
            if (existingModal) existingModal.remove();

            document.body.appendChild(modal);

            // Close on backdrop click
            modal.addEventListener('click', function(e) {
                if (e.target === modal) {
                    modal.remove();
                }
            });
        }


                // Analytics filter buttons
        document.addEventListener('click', function(e) {
            if (e.target.classList.contains('filter-btn') && e.target.dataset.filterAnalytics) {
                document.querySelectorAll('[data-filter-analytics]').forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
                
                const filter = e.target.dataset.filterAnalytics;
                let filteredBatches = batches.filter(b => b.status === 'complete' && b.units_packaged);
                
                if (filter === 'thisMonth') {
                    const now = new Date();
                    const thisMonth = now.getMonth();
                    const thisYear = now.getFullYear();
                    filteredBatches = filteredBatches.filter(b => {
                        const date = new Date(b.completed_at);
                        return date.getMonth() === thisMonth && date.getFullYear() === thisYear;
                    });
                } else if (filter === 'lastMonth') {
                    const now = new Date();
                    const lastMonth = now.getMonth() === 0 ? 11 : now.getMonth() - 1;
                    const year = now.getMonth() === 0 ? now.getFullYear() - 1 : now.getFullYear();
                    filteredBatches = filteredBatches.filter(b => {
                        const date = new Date(b.completed_at);
                        return date.getMonth() === lastMonth && date.getFullYear() === year;
                    });
                }
                
                renderAnalyticsTable(filteredBatches);
            }
        });

        // Edit Batch Functions
        function openEditBatch(batchId) {
            const batch = batches.find(b => b.id === batchId);
            if (!batch) return;
            
            // Store original batch ID in hidden field
            document.getElementById('originalBatchId').value = batch.id;
            
            // Populate form
            document.getElementById('editBatchId').value = batch.id;
            document.getElementById('editBatchStatus').value = batch.status;
            document.getElementById('editStrainName').value = batch.strain;
            document.getElementById('editStrainType').value = batch.strain_type;
            document.getElementById('editProductType').value = batch.product_made || '';
            document.getElementById('editTrimWeight').value = batch.trim_weight;
            document.getElementById('editSocksRemaining').value = batch.socks_remaining ?? batch.socks_total ?? '';
            document.getElementById('editBulkWeight').value = batch.final_weight || '';
            document.getElementById('editMaterialCost').value = batch.material_cost;
            document.getElementById('editCultivationLicense').value = batch.cultivation_license || '';
            document.getElementById('editGrowerName').value = batch.grower_name || '';
            document.getElementById('editMetrcTags').value = batch.metrc_tags || '';
            document.getElementById('editLabelsApplied').checked = batch.labels_applied || false;
            document.getElementById('editUnits1g').value = batch.units_1g || '';
            document.getElementById('editUnits4g').value = batch.units_4g || '';
            document.getElementById('editUnitsPackaged').value = batch.units_packaged || '';
            document.getElementById('editNotes').value = '';

            // Parse batch ID to extract info
            parseBatchIdForEdit(batch.id);
            
            // Show modal
            document.getElementById('editBatchModal').style.display = 'block';
        }

        // Parse batch ID to extract METRC last 4 and expiration date
        function parseBatchIdForEdit(batchId) {
            // Format: M.D.XXXX or MM.DD.XXXX
            const parts = batchId.split('.');
            
            if (parts.length === 3) {
                const month = parts[0];
                const day = parts[1];
                const last4 = parts[2];
                
                // Show parsed METRC last 4
                document.getElementById('parsedMetrcLast4').value = last4;
                
                // Calculate expiration date (use current/next year)
                const currentYear = new Date().getFullYear();
                const expMonth = parseInt(month, 10);
                const expDay = parseInt(day, 10);
                
                if (expMonth >= 1 && expMonth <= 12 && expDay >= 1 && expDay <= 31) {
                    // Create date - if it's in the past, use next year
                    let expDate = new Date(currentYear, expMonth - 1, expDay);
                    const today = new Date();
                    
                    if (expDate < today) {
                        expDate = new Date(currentYear + 1, expMonth - 1, expDay);
                    }
                    
                    document.getElementById('parsedExpirationDate').value = expDate.toISOString().split('T')[0];
                } else {
                    document.getElementById('parsedExpirationDate').value = '';
                }
            } else {
                // Invalid format
                document.getElementById('parsedMetrcLast4').value = '';
                document.getElementById('parsedExpirationDate').value = '';
            }
        }

        // Add event listener for batch ID changes
        document.getElementById('editBatchId').addEventListener('input', function() {
            parseBatchIdForEdit(this.value);
        });

        // Auto-calculate total units when 1g or 4g changes
        function updateEditUnitsTotal() {
            const units1g = parseInt(document.getElementById('editUnits1g').value) || 0;
            const units4g = parseInt(document.getElementById('editUnits4g').value) || 0;
            document.getElementById('editUnitsPackaged').value = units1g + units4g;
        }
        document.getElementById('editUnits1g').addEventListener('input', updateEditUnitsTotal);
        document.getElementById('editUnits4g').addEventListener('input', updateEditUnitsTotal);

        function closeEditBatch() {
            document.getElementById('editBatchModal').style.display = 'none';
        }

        async function saveEditedBatch() {
            if (blockDemoWrite('Editing batches')) return;

            const oldBatchId = document.getElementById('originalBatchId').value;
            const newBatchId = document.getElementById('editBatchId').value.trim();
            const batch = batches.find(b => b.id === oldBatchId);
            const editNotes = document.getElementById('editNotes').value;
            
            if (!batch) {
                alert('Error: Could not find batch to edit.');
                return;
            }
            
            if (!editNotes || editNotes.trim() === '') {
                alert('Please enter a note explaining why you\'re making this change.');
                return;
            }
            
            // Check if batch ID changed
            const batchIdChanged = oldBatchId !== newBatchId;
            
            if (batchIdChanged) {
                // Verify new batch ID doesn't already exist
                const existingBatch = batches.find(b => b.id === newBatchId);
                if (existingBatch && existingBatch.id !== oldBatchId) {
                    alert(`Error: Batch ID "${newBatchId}" already exists. Please choose a different ID.`);
                    return;
                }
                
                const confirmChange = confirm(
                    ` BATCH ID CHANGE\n\n` +
                    `Old ID: ${oldBatchId}\n` +
                    `New ID: ${newBatchId}\n\n` +
                    `This will update the batch ID and recalculate expiration date.\n\n` +
                    `Continue?`
                );
                
                if (!confirmChange) return;
            }
            
            // Collect updated values
            const bulkWeight = document.getElementById('editBulkWeight').value;
            const parsedBulkWeight = bulkWeight ? parseFloat(bulkWeight) : null;
            const socksRemainingVal = document.getElementById('editSocksRemaining').value;
            const updates = {
                status: document.getElementById('editBatchStatus').value,
                strain: document.getElementById('editStrainName').value,
                strain_type: document.getElementById('editStrainType').value,
                product_made: document.getElementById('editProductType').value || null,
                trim_weight: parseFloat(document.getElementById('editTrimWeight').value),
                socks_remaining: socksRemainingVal !== '' ? parseInt(socksRemainingVal) : null,
                final_weight: parsedBulkWeight,
                net_weight: parsedBulkWeight, // Keep net_weight in sync with final_weight
                material_cost: parseFloat(document.getElementById('editMaterialCost').value),
                cultivation_license: document.getElementById('editCultivationLicense').value,
                grower_name: document.getElementById('editGrowerName').value,
                metrc_tags: document.getElementById('editMetrcTags').value || null,
                labels_applied: document.getElementById('editLabelsApplied').checked,
                units_1g: parseInt(document.getElementById('editUnits1g').value) || null,
                units_4g: parseInt(document.getElementById('editUnits4g').value) || null,
                units_packaged: parseInt(document.getElementById('editUnitsPackaged').value) || null
            };
            
            // If expiration date was parsed, update it
            const parsedExpDate = document.getElementById('parsedExpirationDate').value;
            if (parsedExpDate) {
                updates.test_expiration_date = parsedExpDate;
            }
            
            // Add edit to timeline
            const timeline = batch.timeline || [];
            const batchIdNote = batchIdChanged ? ` | Batch ID changed: ${oldBatchId}  ${newBatchId}` : '';
            timeline.push({
                stage: 'edit',
                timestamp: new Date().toISOString(),
                user: currentRole.name,
                action: `Edited batch - ${editNotes}${batchIdNote}`
            });
            updates.timeline = timeline;
            
            // Handle batch ID change
            if (batchIdChanged) {
                // Create new batch with new ID
                const { error: insertError } = await supabaseClient
                    .from('wm_batches')
                    .insert({
                        ...batch,
                        ...updates,
                        id: newBatchId
                    });
                
                if (insertError) {
                    console.error('Error creating new batch:', insertError);
                    alert('Error updating batch ID. Please try again.');
                    return;
                }
                
                // Delete old batch
                const { error: deleteError } = await supabaseClient
                    .from('wm_batches')
                    .delete()
                    .eq('id', oldBatchId);
                
                if (deleteError) {
                    console.error('Error deleting old batch:', deleteError);
                    alert('Warning: New batch created but old batch could not be removed.');
                }
            } else {
                // Normal update
                const { error } = await supabaseClient
                    .from('wm_batches')
                    .update(updates)
                    .eq('id', oldBatchId);
                
                if (error) {
                    console.error('Error updating batch:', error);
                    alert('Error saving changes. Please try again.');
                    return;
                }
            }
            
            const finalBatchId = batchIdChanged ? newBatchId : oldBatchId;
            alert(`Batch ${finalBatchId} updated successfully!${batchIdChanged ? '\n Batch ID changed and expiration date updated' : ''}`);
            closeEditBatch();
            await loadBatches();
            renderBatches();
        }

        // Close modal when clicking outside
        document.getElementById('editBatchModal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeEditBatch();
            }
        });

        // ==============================================
        // BATCH PRINT MENU FUNCTIONS
        // ==============================================

        let currentPrintBatchId = null;

        function openBatchPrintMenu(batchId, event) {
            currentPrintBatchId = batchId;
            const menu = document.getElementById('batchPrintMenu');

            // Position menu near the button
            const rect = event.target.getBoundingClientRect();
            menu.style.top = (rect.bottom + 5) + 'px';
            menu.style.left = Math.min(rect.left, window.innerWidth - 220) + 'px';
            menu.style.display = 'block';

            // Close menu when clicking outside
            setTimeout(() => {
                document.addEventListener('click', closeBatchPrintMenuOnClickOutside);
            }, 10);
        }

        function closeBatchPrintMenu() {
            document.getElementById('batchPrintMenu').style.display = 'none';
            document.removeEventListener('click', closeBatchPrintMenuOnClickOutside);
            currentPrintBatchId = null;
        }

        function closeBatchPrintMenuOnClickOutside(event) {
            const menu = document.getElementById('batchPrintMenu');
            if (!menu.contains(event.target)) {
                closeBatchPrintMenu();
            }
        }

        async function printBatchLabel(labelType) {
            if (!currentPrintBatchId) return;

            const batch = batches.find(b => b.id === currentPrintBatchId);
            if (!batch) {
                alert('Batch not found');
                closeBatchPrintMenu();
                return;
            }

            closeBatchPrintMenu();

            switch(labelType) {
                case 'intake':
                    await printIntakeLabelDirectly(batch);
                    break;
                case 'postprod':
                    await printPostProductionLabelDirectly(batch, batch.final_weight || batch.net_weight, batch.sample_weight || 0);
                    break;
                case 'labeling':
                    await printLabelingCompletionLabel(batch, currentRole ? currentRole.name : 'Unknown');
                    break;
                default:
                    alert('Unknown label type');
            }
        }

        // ==============================================
        // CREATE SUB-BATCH FUNCTIONS
        // ==============================================

        function openCreateSubBatch(batchId) {
            const batch = batches.find(b => b.id === batchId);

            if (!batch) {
                alert('Batch not found: ' + batchId);
                return;
            }
            
            // Store parent batch ID
            document.getElementById('subBatchParentId').value = batchId;
            
            // Generate next available sub-batch ID
            const existingSubBatches = batches.filter(b => b.parent_batch_id === batchId || b.id.startsWith(batchId + '-'));
            
            const subBatchLetters = existingSubBatches.map(b => {
                const match = b.id.match(/-([A-Z]|SIFT)$/);
                return match ? match[1] : null;
            }).filter(l => l && l !== 'SIFT');
            
            let nextLetter = 'A';
            if (subBatchLetters.length > 0) {
                const lastLetter = subBatchLetters.sort().pop();
                nextLetter = String.fromCharCode(lastLetter.charCodeAt(0) + 1);
            }
            
            const newSubBatchId = `${batchId}-${nextLetter}`;
            document.getElementById('newSubBatchId').value = newSubBatchId;
            
            // Show parent batch info
            const parentInfo = `
                <p><strong>Batch ID:</strong> ${batch.id}</p>
                <p><strong>Product:</strong> ${batch.strain} (${batch.strain_type})</p>
                <p><strong>Product Made:</strong> ${batch.product_made || 'N/A'}</p>
                <p><strong>Final Weight:</strong> ${batch.final_weight || batch.net_weight || 'N/A'}g</p>
                <p><strong>Status:</strong> ${batch.status}</p>
                ${existingSubBatches.length > 0 ? `<p style="color: var(--accent-orange);"><strong>Existing Sub-Batches:</strong> ${existingSubBatches.map(b => b.id).join(', ')}</p>` : ''}
            `;
            document.getElementById('subBatchParentDetails').innerHTML = parentInfo;
            
            // Clear form
            document.getElementById('subBatchProductType').value = '';
            document.getElementById('subBatchNotes').value = '';
            
            // Show modal
            const modal = document.getElementById('createSubBatchModal');
            if (modal) {
                // Force hide first to ensure clean state
                modal.style.display = 'none';
                // Force browser repaint
                modal.offsetHeight;
                // Now show it
                modal.style.display = 'block';
                modal.style.visibility = 'visible';
                modal.style.opacity = '1';

                // Scroll to top in case modal is below fold
                window.scrollTo(0, 0);
            } else {
                console.error('Modal element not found!');
                alert('Error: Modal not found in DOM');
            }
        }

        function closeCreateSubBatch() {
            document.getElementById('createSubBatchModal').style.display = 'none';
        }

        async function saveSubBatch() {
            if (!currentRole) {
                alert('Please login first!');
                return;
            }
            
            const parentBatchId = document.getElementById('subBatchParentId').value;
            const parentBatch = batches.find(b => b.id === parentBatchId);
            
            if (!parentBatch) {
                alert('Parent batch not found');
                return;
            }
            
            const newSubBatchId = document.getElementById('newSubBatchId').value;
            const productType = document.getElementById('subBatchProductType').value;
            const notes = document.getElementById('subBatchNotes').value;
            
            if (!productType) {
                alert('Please select a product type');
                return;
            }
            
            if (!notes.trim()) {
                alert('Please enter a reason for creating this retroactive sub-batch');
                return;
            }
            
            // Calculate proportional trim used from parent
            const parentTrimWeight = parseFloat(parentBatch.adjusted_trim_weight || parentBatch.trim_weight || 0);
            
            // Get all existing sub-batches BEFORE creating new one
            const existingSubBatches = batches.filter(b => 
                (b.parent_batch_id === parentBatchId || b.id.startsWith(parentBatchId + '-')) && 
                b.id !== parentBatchId
            );
            
            // For now, allocate equal trim across all sub-batches (will be recalculated when weights are entered)
            const numSubBatches = existingSubBatches.length + 1; // Including new one
            const trimUsed = parentTrimWeight / numSubBatches;
            
            // Set status to 'extraction' so it must go through post-processing (finishing)
            // This ensures the post-processor completes it properly
            const newStatus = 'extraction';
            
            // Create sub-batch
            const subBatch = {
                id: newSubBatchId,
                business_id: parentBatch.business_id, // Inherit business from parent
                strain: parentBatch.strain,
                strain_type: parentBatch.strain_type,
                trim_weight: trimUsed,
                material_cost: 0,
                material_agreement: parentBatch.material_agreement,
                pre_sift: 'no',
                cultivation_license: parentBatch.cultivation_license,
                grower_name: parentBatch.grower_name,
                metrc_tags: parentBatch.metrc_tags,
                intake_date: parentBatch.intake_date,
                planned_products: [productType],
                intake_notes: `Retroactive sub-batch created from ${parentBatchId}. ${notes}`,
                status: newStatus,
                intake_user: parentBatch.intake_user,

                // Mark as sub-batch
                is_sub_batch: true,
                parent_batch_id: parentBatchId,
                
                // Set extraction data (completed by extractor)
                extraction_date: parentBatch.extraction_date || new Date().toISOString().split('T')[0],
                extraction_method: parentBatch.extraction_method,
                product_made: productType,
                extraction_notes: `Retroactive sub-batch of ${parentBatchId} - needs post-processing`,
                extraction_user: parentBatch.extraction_user || currentRole.name,
                
                // NO finishing data yet - post-processor must complete this
                finishing_date: null,
                final_weight: null,
                sample_weight: null,
                net_weight: null,
                finishing_notes: `Retroactive sub-batch - awaiting post-processing`,
                finishing_user: null,
                
                timeline: [
                    {
                        stage: 'intake',
                        timestamp: parentBatch.intake_date,
                        user: parentBatch.intake_user,
                        action: 'Batch created (parent)'
                    },
                    {
                        stage: 'extraction',
                        timestamp: parentBatch.extraction_date || new Date().toISOString(),
                        user: parentBatch.extraction_user || currentRole.name,
                        action: `Extracted as ${productType} - retroactive sub-batch created by ${currentRole.name}`
                    }
                ],
                created_at: new Date().toISOString()
            };

            // Insert sub-batch
            const { error: insertError } = await supabaseClient
                .from('wm_batches')
                .insert([subBatch]);
            
            if (insertError) {
                console.error('Error creating sub-batch:', insertError);
                alert(`Error creating sub-batch: ${insertError.message}`);
                return;
            }
            
            // Update parent batch timeline
            const parentTimeline = parentBatch.timeline || [];
            parentTimeline.push({
                stage: 'admin',
                timestamp: new Date().toISOString(),
                user: currentRole.name,
                action: `Retroactive sub-batch created: ${newSubBatchId} (${productType}) - needs post-processing`
            });
            
            await supabaseClient
                .from('wm_batches')
                .update({ timeline: parentTimeline })
                .eq('id', parentBatchId);
            
            alert(` Sub-batch ${newSubBatchId} created successfully!\n\nProduct: ${productType}\nStatus: extraction\n\n NEXT STEP:\nPost-processor must complete this batch on the "Post Extraction" page to:\n Enter final bulk weight\n Enter sample weight\n Complete finishing\n\nYields will be recalculated when weights are entered.`);
            
            closeCreateSubBatch();
            await loadBatches();
            renderBatches();
            
            // Refresh finishing select
            populateFinishingSelect();
        }

        // Close modal when clicking outside
        document.getElementById('createSubBatchModal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeCreateSubBatch();
            }
        });

        async function deleteSubBatch(subBatchId) {
            if (!currentRole || !currentRole.canEditBatches) {
                alert('You do not have permission to delete sub-batches');
                return;
            }
            
            const subBatch = batches.find(b => b.id === subBatchId);
            if (!subBatch) {
                alert('Sub-batch not found');
                return;
            }
            
            if (!subBatch.is_sub_batch) {
                alert('This is not a sub-batch. Only sub-batches can be deleted this way.');
                return;
            }
            
            const parentBatchId = subBatch.parent_batch_id;
            const parentBatch = batches.find(b => b.id === parentBatchId);
            
            const confirmation = confirm(
                ` DELETE SUB-BATCH?\n\n` +
                `Sub-Batch: ${subBatchId}\n` +
                `Product: ${subBatch.product_made || 'N/A'}\n` +
                `Weight: ${subBatch.final_weight || subBatch.net_weight || 'N/A'}g\n\n` +
                `This will:\n` +
                ` Delete this sub-batch permanently\n` +
                ` Recalculate yields for remaining sub-batches\n` +
                ` Update parent batch timeline\n\n` +
                `This action CANNOT be undone!\n\n` +
                `Type YES to confirm deletion.`
            );
            
            if (!confirmation) return;
            
            const userConfirmation = prompt('Type YES in capital letters to confirm deletion:');
            if (userConfirmation !== 'YES') {
                alert('Deletion cancelled.');
                return;
            }
            
            // Delete the sub-batch
            const { error: deleteError } = await supabaseClient
                .from('wm_batches')
                .delete()
                .eq('id', subBatchId);
            
            if (deleteError) {
                console.error('Error deleting sub-batch:', deleteError);
                alert(`Error deleting sub-batch: ${deleteError.message}`);
                return;
            }
            
            // Recalculate remaining sub-batches if parent exists and has other sub-batches
            if (parentBatch) {
                const remainingSubBatches = batches.filter(b => 
                    b.parent_batch_id === parentBatchId && 
                    b.id !== subBatchId &&
                    b.final_weight // Only completed sub-batches
                );
                
                if (remainingSubBatches.length > 0) {
                    const parentTrimWeight = parseFloat(parentBatch.adjusted_trim_weight || parentBatch.trim_weight || 0);
                    const totalRemainingWeight = remainingSubBatches.reduce((sum, b) => 
                        sum + parseFloat(b.final_weight || b.net_weight || 0), 0
                    );
                    
                    // Recalculate trim for each remaining sub-batch
                    for (const sub of remainingSubBatches) {
                        const subWeight = parseFloat(sub.final_weight || sub.net_weight || 0);
                        const recalculatedTrim = (subWeight / totalRemainingWeight) * parentTrimWeight;
                        
                        await supabaseClient
                            .from('wm_batches')
                            .update({ trim_weight: recalculatedTrim })
                            .eq('id', sub.id);
                    }
                }
                
                // Update parent timeline
                const parentTimeline = parentBatch.timeline || [];
                parentTimeline.push({
                    stage: 'admin',
                    timestamp: new Date().toISOString(),
                    user: currentRole.name,
                    action: `Sub-batch ${subBatchId} deleted. Yields recalculated for remaining sub-batches.`
                });
                
                await supabaseClient
                    .from('wm_batches')
                    .update({ timeline: parentTimeline })
                    .eq('id', parentBatchId);
                
                const resultMessage = remainingSubBatches.length > 0 
                    ? ' Remaining sub-batch yields recalculated' 
                    : ' This was the last sub-batch';
                alert(` Sub-batch ${subBatchId} deleted successfully!\n\n${resultMessage}`);
            } else {
                alert(` Sub-batch ${subBatchId} deleted successfully!`);
            }
            
            await loadBatches();
            renderBatches();
            
            // Refresh all selects
            
            populateFinishingSelect();
            populatePackagingSelect();
            populateTestingSelect();
        }

        // ==============================================
        // COA AUTO-IMPORT (via backend service account)
        // ==============================================
        let processedCOAs = JSON.parse(localStorage.getItem('processedCOAs') || '[]');

        // Initialize COA sync UI on page load
        function initCOASync() {
            const lastSync = localStorage.getItem('coaLastSync');
            if (lastSync) {
                document.getElementById('coaLastSync').textContent = new Date(lastSync).toLocaleString();
            }
            document.getElementById('coaImportCount').textContent = processedCOAs.length;
        }

        // Sync COAs from Google Drive (via backend service account)
        async function syncCOAsFromDrive(forceFullSync = false) {
            const syncBtn = document.getElementById('coaSyncBtn');
            syncBtn.textContent = ' Syncing...';
            syncBtn.disabled = true;

            // Check if SHIFT is held for full rescan
            const isShiftHeld = event && event.shiftKey;
            if (isShiftHeld || forceFullSync) {
                console.log('[COA sync] Full rescan requested');
            }

            try {
                // Get current business slug
                const businessSlug = businessesList.find(b => b.id === currentBusinessId)?.slug || 'white-mousse';

                // Get last sync time to only fetch new files (unless full sync requested)
                const lastSync = (!isShiftHeld && !forceFullSync) ? localStorage.getItem('coaLastSync') : null;
                const sinceParam = lastSync ? `?since=${encodeURIComponent(lastSync)}` : '';

                // List COA files via our backend (only files modified since last sync)
                const listResponse = await fetch(`/api/google-drive/list-coas/${businessSlug}${sinceParam}`);
                const listData = await listResponse.json();

                if (!listResponse.ok) {
                    throw new Error(listData.error || 'Failed to list COA files');
                }

                if (!listData.files || listData.files.length === 0) {
                    const msg = lastSync
                        ? `No new COA files since last sync (${new Date(lastSync).toLocaleString()}).\n\nHold SHIFT and click Sync to force a full rescan.`
                        : 'No PDF files found in COAs folder.';
                    alert(msg);
                    syncBtn.textContent = ' Sync Now';
                    syncBtn.disabled = false;
                    return;
                }

                // Process each new file
                let importedCount = 0;
                let skippedCount = 0;
                let errorCount = 0;
                const importDetails = [];

                for (const file of listData.files) {
                    if (processedCOAs.includes(file.id)) {
                        skippedCount++;
                        continue;
                    }

                    try {
                        // Download the PDF via our backend
                        const downloadResponse = await fetch(`/api/google-drive/download/${businessSlug}/${file.id}`);
                        const downloadData = await downloadResponse.json();

                        if (!downloadResponse.ok) {
                            throw new Error(downloadData.error || 'Failed to download file');
                        }

                        // Convert base64 to ArrayBuffer for PDF parsing
                        const binaryString = atob(downloadData.data);
                        const bytes = new Uint8Array(binaryString.length);
                        for (let i = 0; i < binaryString.length; i++) {
                            bytes[i] = binaryString.charCodeAt(i);
                        }
                        const pdfData = bytes.buffer;

                        // Parse the PDF
                        const coaData = await parseCOAPdf(pdfData);

                        if (coaData && coaData.batchId) {
                            // Find matching batch
                            const matchResult = await matchAndUpdateBatch(coaData);

                            if (matchResult.success) {
                                processedCOAs.push(file.id);
                                importedCount++;
                                importDetails.push(` ${coaData.batchId}: THC ${coaData.totalThc}%`);
                            } else {
                                importDetails.push(` ${coaData.batchId}: ${matchResult.message}`);
                            }
                        } else {
                            errorCount++;
                            importDetails.push(` ${file.name}: Could not parse COA data`);
                        }
                    } catch (err) {
                        console.error('Error processing file:', file.name, err);
                        errorCount++;
                        importDetails.push(` ${file.name}: ${err.message}`);
                    }
                }

                // Save processed list
                localStorage.setItem('processedCOAs', JSON.stringify(processedCOAs));
                localStorage.setItem('coaLastSync', new Date().toISOString());

                // Update UI
                document.getElementById('coaLastSync').textContent = new Date().toLocaleString();
                document.getElementById('coaImportCount').textContent = processedCOAs.length;

                // Show results
                let message = `COA Sync Complete!\n\n`;
                message += ` Imported: ${importedCount}\n`;
                message += ` Already processed: ${skippedCount}\n`;
                if (errorCount > 0) message += ` Errors: ${errorCount}\n`;
                if (importDetails.length > 0) {
                    message += `\nDetails:\n${importDetails.join('\n')}`;
                }
                alert(message);

                // Refresh batches to show updated data
                if (importedCount > 0) {
                    await loadBatches();
                    populateTestingSelect();
                    populateLabelingSelect();
                }

            } catch (error) {
                console.error('Sync error:', error);
                alert('Error syncing COAs: ' + error.message);
            }

            syncBtn.textContent = ' Sync Now';
            syncBtn.disabled = false;
        }

        // Parse AgriScience Labs COA PDF
        async function parseCOAPdf(pdfData) {
            try {
                // Set worker source for PDF.js
                if (typeof pdfjsLib !== 'undefined') {
                    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
                }

                const pdf = await pdfjsLib.getDocument({ data: pdfData }).promise;
                const page = await pdf.getPage(1);
                const textContent = await page.getTextContent();
                const text = textContent.items.map(item => item.str).join(' ');

                console.log('COA Text:', text);

                // Extract data using patterns for AgriScience Labs format
                const coaData = {
                    batchId: null,
                    metrcId: null,
                    sampleId: null,
                    productName: null,
                    totalThc: null,
                    totalCbd: null,
                    totalCannabinoids: null,
                    thca: null,
                    thc: null,
                    cbga: null,
                    cbca: null,
                    receivedDate: null
                };

                // === BATCH ID PATTERNS ===
                // Format 1: "Batch ID: X.X.XXXX" (single sample COA)
                let batchIdMatch = text.match(/Batch ID[:\s]+(\d+\.\d+\.\d+)/i);
                if (batchIdMatch) coaData.batchId = batchIdMatch[1];

                // Format 2: Table format "CN X.X.XXXX" (multi-sample COA)
                if (!coaData.batchId) {
                    batchIdMatch = text.match(/CN\s+(\d+\.\d+\.\d+)/i);
                    if (batchIdMatch) coaData.batchId = batchIdMatch[1];
                }

                // === METRC ID PATTERNS ===
                // Format 1: "Metrc ID: 1A4..."
                let metrcMatch = text.match(/Metrc ID[:\s]+(1A[A-Z0-9]+)/i);
                if (metrcMatch) coaData.metrcId = metrcMatch[1];

                // Format 2: "...XXXX" (truncated in table)
                if (!coaData.metrcId) {
                    metrcMatch = text.match(/\.\.\.(\d{4})/);
                    if (metrcMatch) coaData.metrcId = metrcMatch[1]; // Just last 4
                }

                // === SAMPLE ID PATTERNS ===
                // Format 1: "Sample ID: XXR-XXXX-XX"
                let sampleMatch = text.match(/Sample ID[:\s]+(\d+[A-Z]-\d+-\d+)/i);
                if (sampleMatch) coaData.sampleId = sampleMatch[1];

                // Format 2: Sample ID at start of row "25R-2078-02"
                if (!coaData.sampleId) {
                    sampleMatch = text.match(/(\d{2}[A-Z]-\d{4}-\d{2})/i);
                    if (sampleMatch) coaData.sampleId = sampleMatch[1];
                }

                // === PRODUCT NAME PATTERNS ===
                // Format 1: "WM [Product Name] (Xg)"
                let productMatch = text.match(/WM\s+([^(]+)\s*\(\d+g\)/i);
                if (productMatch) coaData.productName = productMatch[1].trim();

                // Format 2: "Product Name: WM [Name]" or in sample name column
                if (!coaData.productName) {
                    productMatch = text.match(/WM\s+([A-Za-z\s]+(?:Bulk|SW|W|Live|Badder|Sauce|Sugar|Diamonds))/i);
                    if (productMatch) coaData.productName = productMatch[1].trim();
                }

                // === THC PATTERNS ===
                // Format 1: "Total THC: XX.X%"
                let totalThcMatch = text.match(/Total THC[:\s]+(\d+\.?\d*)%/i);
                if (totalThcMatch) coaData.totalThc = parseFloat(totalThcMatch[1]);

                // Format 2: "THC %*" header with value in row - look for "X.X.XXXX ...XXXX XX.X" pattern
                if (!coaData.totalThc) {
                    // Match batch ID followed by metrc and then THC value
                    totalThcMatch = text.match(/\d+\.\d+\.\d+\s+\.\.\.\d+\s+(\d+\.?\d*)\s+\d+\.?\d*/);
                    if (totalThcMatch) coaData.totalThc = parseFloat(totalThcMatch[1]);
                }

                // Format 3: Look for THC value near "THC %"
                if (!coaData.totalThc) {
                    totalThcMatch = text.match(/THC\s*%\*?\s*Total[^0-9]*(\d+\.?\d*)/i);
                    if (totalThcMatch) coaData.totalThc = parseFloat(totalThcMatch[1]);
                }

                // === CBD PATTERNS ===
                // Format 1: "Total CBD: X.XXX%"
                let totalCbdMatch = text.match(/Total CBD[:\s]+(\d+\.?\d*)%/i);
                if (totalCbdMatch) coaData.totalCbd = parseFloat(totalCbdMatch[1]);

                // Format 2: "% CBD" column with ND or value
                if (!coaData.totalCbd) {
                    const cbdMatch = text.match(/%\s*CBD[^N]*?(\d+\.?\d*)|CBD[^N]*?ND/i);
                    if (cbdMatch && cbdMatch[1]) coaData.totalCbd = parseFloat(cbdMatch[1]);
                    else coaData.totalCbd = 0;
                }

                // === TOTAL CANNABINOIDS PATTERNS ===
                // Format 1: "Total Cannabinoids: XX.X%"
                let totalCannMatch = text.match(/Total Cannabinoids?[:\s]+(\d+\.?\d*)%/i);
                if (totalCannMatch) coaData.totalCannabinoids = parseFloat(totalCannMatch[1]);

                // Format 2: "Percentage Detected" column
                if (!coaData.totalCannabinoids) {
                    totalCannMatch = text.match(/Detected\*?\*?\s+[^0-9]*?(\d+\.\d+\.\d+)[^0-9]+\.\.\.\d+\s+\d+\.?\d*\s+(\d+\.?\d*)/i);
                    if (totalCannMatch) coaData.totalCannabinoids = parseFloat(totalCannMatch[2]);
                }

                // === THCA PATTERN ===
                // Format 1: "delta-9 THCA XX.X"
                let thcaMatch = text.match(/delta-9 THCA\s+(\d+\.?\d*)/i);
                if (thcaMatch) coaData.thca = parseFloat(thcaMatch[1]);

                // Format 2: "% THCA" column
                if (!coaData.thca) {
                    thcaMatch = text.match(/%\s*THCA\s+[^0-9]*?(\d+\.?\d*)/i);
                    if (thcaMatch) coaData.thca = parseFloat(thcaMatch[1]);
                }

                // === D9-THC PATTERN ===
                let thcMatch = text.match(/delta-9 THC\s+(\d+\.?\d*)/i);
                if (thcMatch) coaData.thc = parseFloat(thcMatch[1]);

                // Format 2: "% d9-THC" column
                if (!coaData.thc) {
                    thcMatch = text.match(/%\s*d9-THC\s+[^0-9]*?(\d+\.?\d*)/i);
                    if (thcMatch) coaData.thc = parseFloat(thcMatch[1]);
                }

                // === DATE PATTERN ===
                let dateMatch = text.match(/(?:Received|Date Received)[:\s]+(\d{1,2}\/\d{1,2}\/\d{4})/i);
                if (dateMatch) coaData.receivedDate = dateMatch[1];

                console.log('Parsed COA:', coaData);
                return coaData;

            } catch (error) {
                console.error('PDF parsing error:', error);
                return null;
            }
        }

        // Match COA data to batch and update database
        async function matchAndUpdateBatch(coaData) {
            if (!coaData.batchId) {
                return { success: false, message: 'No batch ID found in COA' };
            }

            // Find matching batch - try exact match first
            let batch = batches.find(b => b.id === coaData.batchId);

            // If no exact match, try matching by METRC tag last 4 digits
            if (!batch && coaData.metrcId) {
                const last4 = coaData.metrcId.slice(-4);
                batch = batches.find(b => b.id && b.id.endsWith(last4));
            }

            // Also try matching by product name
            if (!batch && coaData.productName) {
                batch = batches.find(b =>
                    b.strain && b.strain.toLowerCase().includes(coaData.productName.toLowerCase())
                );
            }

            if (!batch) {
                return {
                    success: false,
                    message: `No matching batch found for ID: ${coaData.batchId}`
                };
            }

            // Check if already has test results
            if (batch.test_thc_percent && batch.test_thc_percent > 0) {
                return {
                    success: false,
                    message: `Batch ${batch.id} already has test results (THC: ${batch.test_thc_percent}%)`
                };
            }

            // Update the batch with COA data
            const timeline = batch.timeline || [];
            timeline.push({
                stage: 'testing',
                user: 'COA Auto-Import',
                date: new Date().toISOString(),
                action: `Auto-imported from COA: THC ${coaData.totalThc}%, CBD ${coaData.totalCbd || 0}% | Sample: ${coaData.sampleId || 'N/A'}`
            });

            const updates = {
                test_thc_percent: coaData.totalThc,
                test_cbd_percent: coaData.totalCbd || 0,
                timeline: timeline,
                test_results_notes: `[COA AUTO-IMPORT]\nSample ID: ${coaData.sampleId || 'N/A'}\nMETRC: ${coaData.metrcId || 'N/A'}\nTotal Cannabinoids: ${coaData.totalCannabinoids || 'N/A'}%\nTHCA: ${coaData.thca || 'N/A'}%\nReceived: ${coaData.receivedDate || 'N/A'}`
            };

            try {
                const { error } = await supabaseClient
                    .from('wm_batches')
                    .update(updates)
                    .eq('id', batch.id);

                if (error) throw error;

                // Update local batches array so UI reflects changes
                Object.assign(batch, updates);

                // Add to Google Sheets for Canva label generation
                try {
                    const labelData = {
                        productType: batch.product_made || '',
                        strainName: batch.strain || '',
                        totalThc: coaData.totalThc,
                        totalCbd: coaData.totalCbd || 0,
                        netWeight: batch.net_weight || batch.final_weight || '',
                        cultivationLicense: batch.cultivation_license || '',
                        batchId: batch.id,
                        useByDate: batch.test_expiration_date || '',
                        unitsNeeded: batch.units_packaged || 0
                    };

                    const sheetResponse = await fetch('/api/google-sheets/add-label', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(labelData)
                    });

                    if (sheetResponse.ok) {
                        console.log(`Label row added to spreadsheet for batch ${batch.id}`);
                    } else {
                        console.warn('Failed to add label to spreadsheet:', await sheetResponse.text());
                    }
                } catch (sheetError) {
                    console.warn('Spreadsheet update failed (non-critical):', sheetError);
                }

                return { success: true, message: `Updated batch ${batch.id}` };
            } catch (error) {
                console.error('Database update error:', error);
                return { success: false, message: `Database error: ${error.message}` };
            }
        }

        // Initialize COA sync on page load
        document.addEventListener('DOMContentLoaded', function() {
            setTimeout(initCOASync, 1000);
        });

        // ==============================================
        // 50/50 SPLIT GOOGLE SHEETS TRACKING
        // ==============================================

        // Add a 50/50 split batch to the tracking spreadsheet (at intake - weights pending)
        async function add5050SplitToSheet(batch) {
            const splitData = {
                intakeDate: batch.intake_date || new Date().toLocaleDateString('en-US'),
                customer: batch.grower_name || batch.cultivation_license || 'Unknown',
                batchNumber: batch.id,
                batchName: batch.strain || ''
                // Weight columns will show "Pending" until batch finishes
            };

            const response = await fetch('/api/google-sheets/add-split', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(splitData)
            });

            if (response.ok) {
                console.log(`50/50 split tracked in Google Sheets for batch ${batch.id}`);
            } else {
                const error = await response.text();
                console.warn('Failed to add 50/50 split to spreadsheet:', error);
            }
        }

        // Update 50/50 split with finished weight and date when batch completes
        async function update5050SplitFinished(batch) {
            // Get the final weight (net_weight or final_weight after extraction/finishing)
            const finishedWeight = parseFloat(batch.net_weight) || parseFloat(batch.final_weight) || 0;
            const customersHalf = Math.round(finishedWeight / 2 * 10) / 10; // Round to nearest tenth

            try {
                const response = await fetch('/api/google-sheets/update-split-finished', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        batchNumber: batch.id,
                        finishedWeight: finishedWeight,
                        customersHalf: customersHalf,
                        dateFinished: new Date().toLocaleDateString('en-US')
                    })
                });

                if (response.ok) {
                    console.log(`50/50 split updated for batch ${batch.id}: ${finishedWeight}g finished, ${customersHalf}g owed`);
                    return true;
                } else {
                    // 404 is expected if batch isn't a 50/50 split
                    if (response.status !== 404) {
                        console.warn('Failed to update 50/50 split finish date:', await response.text());
                    }
                    return false;
                }
            } catch (error) {
                console.error('Error updating 50/50 split finish date:', error);
                return false;
            }
        }

        // ==============================================
        // METRC INTEGRATION FUNCTIONS
        // ==============================================

        let metrcManifests = [];
        let selectedManifest = null;
        let selectedTags = [];

        // Load METRC config from localStorage
        function loadMetrcConfig() {
            const integratorKey = localStorage.getItem('metrcIntegratorKey');
            const userKey = localStorage.getItem('metrcUserKey');
            const licenseNumber = localStorage.getItem('metrcLicenseNumber') || '404R-00016';
            
            if (integratorKey) {
                document.getElementById('metrcIntegratorKey').value = integratorKey;
            }
            if (userKey) {
                document.getElementById('metrcUserKey').value = userKey;
            }
            document.getElementById('metrcLicenseNumber').value = licenseNumber;
            
            if (integratorKey && userKey) {
                updateMetrcConfigStatus(true);
            } else {
                updateMetrcConfigStatus(false);
            }
        }

        function updateMetrcConfigStatus(configured) {
            const statusEl = document.getElementById('metrcConfigStatus');
            if (configured) {
                statusEl.style.background = 'rgba(16, 185, 129, 0.2)';
                statusEl.style.color = 'var(--accent-green)';
                statusEl.style.border = '2px solid var(--accent-green)';
                statusEl.textContent = ' Configured';
            } else {
                statusEl.style.background = 'rgba(239, 68, 68, 0.2)';
                statusEl.style.color = 'var(--accent-red)';
                statusEl.style.border = '2px solid var(--accent-red)';
                statusEl.textContent = ' Not Configured';
            }
        }

        function saveMetrcConfig() {
            const integratorKey = document.getElementById('metrcIntegratorKey').value.trim();
            const userKey = document.getElementById('metrcUserKey').value.trim();
            const licenseNumber = document.getElementById('metrcLicenseNumber').value.trim();
            
            if (!integratorKey || !userKey || !licenseNumber) {
                alert('Please enter both Integrator Key and User API Key');
                return;
            }
            
            localStorage.setItem('metrcIntegratorKey', integratorKey);
            localStorage.setItem('metrcUserKey', userKey);
            localStorage.setItem('metrcLicenseNumber', licenseNumber);
            
            updateMetrcConfigStatus(true);
            alert('METRC credentials saved successfully!\n\nClick "Test Connection" to verify they work.');
        }

        async function testMetrcConnection() {
            const integratorKey = localStorage.getItem('metrcIntegratorKey');
            const userKey = localStorage.getItem('metrcUserKey');
            const licenseNumber = localStorage.getItem('metrcLicenseNumber');
            
            if (!integratorKey || !userKey || !licenseNumber) {
                showTestResult('error', 'Please save your credentials first.');
                return;
            }

            showTestResult('testing', 'Testing connection to METRC API...');

            try {
                // Try to get facilities as a simple test
                const url = `https://api-co.metrc.com/facilities/v1/`;
                
                // METRC requires: integratorKey:userKey
                const authString = `${integratorKey}:${userKey}`;
                
                const response = await fetch(url, {
                    method: 'GET',
                    headers: {
                        'Authorization': `Basic ${btoa(authString)}`,
                        'Content-Type': 'application/json'
                    },
                    mode: 'cors'
                });

                if (response.ok) {
                    const data = await response.json();
                    showTestResult('success', ` Connection successful!\n\nFound ${data.length} facilities in your account.\n\nAuthentication format is correct.\nYou can try loading manifests (may still face CORS).`);
                } else {
                    let errorDetails = '';
                    try {
                        const errorData = await response.json();
                        errorDetails = errorData.Message || JSON.stringify(errorData);
                    } catch (e) {
                        errorDetails = await response.text();
                    }

                    showTestResult('error', ` METRC returned ${response.status}\n\n${errorDetails}\n\nTroubleshooting:\n Verify Integrator Key is from METRC Connect\n Verify User API Key from Settings  Integrations  User API Keys\n Check if user has permissions for license 404R-00016\n Try Manual Entry instead`);
                }
            } catch (error) {
                if (error.message.includes('Failed to fetch') || error.name === 'TypeError') {
                    showTestResult('error', ` Browser blocked the request (CORS)\n\nThis is expected - browsers block METRC API calls for security.\n\nSolutions:\n1.  Use Manual Entry tab (recommended)\n2. Set up a server proxy for API calls\n3. Use METRC web interface and copy data`);
                } else {
                    showTestResult('error', ` Connection failed:\n\n${error.message}`);
                }
            }
        }

        function showTestResult(type, message) {
            const resultEl = document.getElementById('metrcTestResult');
            resultEl.style.display = 'block';
            resultEl.style.padding = '15px';
            resultEl.style.borderRadius = '10px';
            resultEl.style.marginTop = '15px';
            resultEl.style.whiteSpace = 'pre-line';

            if (type === 'success') {
                resultEl.style.background = 'rgba(16, 185, 129, 0.2)';
                resultEl.style.border = '2px solid var(--accent-green)';
                resultEl.style.color = 'var(--accent-green)';
            } else if (type === 'error') {
                resultEl.style.background = 'rgba(239, 68, 68, 0.2)';
                resultEl.style.border = '2px solid var(--accent-red)';
                resultEl.style.color = 'var(--accent-red)';
            } else if (type === 'testing') {
                resultEl.style.background = 'rgba(245, 158, 11, 0.2)';
                resultEl.style.border = '2px solid var(--accent-orange)';
                resultEl.style.color = 'var(--accent-orange)';
            }

            resultEl.textContent = message;
        }

        function openMetrcImport() {
            document.getElementById('metrcImportModal').style.display = 'block';
            loadMetrcConfig();
            
            // Set default dates (last 7 days)
            const endDate = new Date();
            const startDate = new Date();
            startDate.setDate(startDate.getDate() - 7);
            
            document.getElementById('metrcStartDate').value = startDate.toISOString().split('T')[0];
            document.getElementById('metrcEndDate').value = endDate.toISOString().split('T')[0];
            
            // Default to manual entry tab (more reliable)
            switchMetrcTab('manual');
        }

        function closeMetrcImport() {
            document.getElementById('metrcImportModal').style.display = 'none';
            clearManifestSelection();
        }

        async function loadMetrcManifests() {
            const integratorKey = localStorage.getItem('metrcIntegratorKey');
            const userKey = localStorage.getItem('metrcUserKey');
            const licenseNumber = localStorage.getItem('metrcLicenseNumber');
            
            if (!integratorKey || !userKey || !licenseNumber) {
                showMetrcError('Please configure your METRC API credentials first (both Integrator and User keys required).');
                return;
            }
            
            const startDate = document.getElementById('metrcStartDate').value;
            const endDate = document.getElementById('metrcEndDate').value;
            
            if (!startDate || !endDate) {
                showMetrcError('Please select both start and end dates.');
                return;
            }
            
            // Show loading
            document.getElementById('metrcLoadingIndicator').style.display = 'block';
            document.getElementById('metrcManifestsList').style.display = 'none';
            document.getElementById('metrcError').style.display = 'none';
            
            try {
                // METRC API endpoint for incoming transfers
                const url = `https://api-co.metrc.com/transfers/v1/incoming?licenseNumber=${licenseNumber}&lastModifiedStart=${startDate}&lastModifiedEnd=${endDate}`;
                
                // METRC requires: integratorKey:userKey
                const authString = `${integratorKey}:${userKey}`;
                
                const response = await fetch(url, {
                    method: 'GET',
                    headers: {
                        'Authorization': `Basic ${btoa(authString)}`,
                        'Content-Type': 'application/json'
                    },
                    mode: 'cors'
                });
                
                if (!response.ok) {
                    let errorMsg = `METRC API returned ${response.status}`;
                    
                    if (response.status === 401) {
                        errorMsg = `Authentication failed (401).\n\nTroubleshooting:\n Verify your Integrator Key is from METRC Connect\n Verify your User API Key from Settings  Integrations  User API Keys\n Format must be integratorKey:userKey (done automatically)\n Check that user has permissions for license 404R-00016\n User must have access to view incoming transfers`;
                    } else if (response.status === 403) {
                        errorMsg = `Access forbidden (403).\n\nThe user may not have permission to access transfers for this license.`;
                    } else if (response.status === 404) {
                        errorMsg = `Endpoint not found (404).\n\nThe license number may be incorrect.`;
                    }
                    
                    // Try to get more details from response
                    try {
                        const errorData = await response.json();
                        if (errorData.Message) {
                            errorMsg += `\n\nMETRC says: ${errorData.Message}`;
                        }
                    } catch (e) {
                        // Response wasn't JSON
                    }
                    
                    throw new Error(errorMsg);
                }
                
                const data = await response.json();
                metrcManifests = data;
                
                if (metrcManifests.length === 0) {
                    showMetrcError('No incoming transfers found for the selected date range.');
                    return;
                }
                
                displayManifests();
                
            } catch (error) {
                console.error('METRC API Error:', error);
                
                // Check if it's a CORS error
                if (error.message.includes('CORS') || error.message.includes('Failed to fetch')) {
                    showMetrcError(` Browser Security Block Detected\n\nDirect API calls from browsers are often blocked by CORS.\n\nOptions:\n1. Use METRC's web interface to export manifests\n2. Set up a server-side proxy (recommended for production)\n3. Use a browser extension to disable CORS (development only)\n\nOriginal error: ${error.message}`);
                } else {
                    showMetrcError(error.message);
                }
            } finally {
                document.getElementById('metrcLoadingIndicator').style.display = 'none';
            }
        }

        function showMetrcError(message) {
            const errorEl = document.getElementById('metrcError');
            errorEl.textContent = message;
            errorEl.style.display = 'block';
        }

        function displayManifests() {
            const container = document.getElementById('manifestsContainer');
            
            container.innerHTML = metrcManifests.map((manifest, index) => {
                const manifestDate = new Date(manifest.ReceivedDateTime || manifest.CreatedDate).toLocaleDateString();
                const packageCount = manifest.Deliveries ? manifest.Deliveries.reduce((sum, d) => sum + (d.Packages?.length || 0), 0) : 0;
                
                return `
                    <div onclick="selectManifest(${index})" style="background: var(--bg-tertiary); padding: 20px; border-radius: 12px; margin-bottom: 15px; cursor: pointer; border: 2px solid var(--border); transition: all 0.3s ease;">
                        <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 10px;">
                            <div>
                                <div style="font-size: 1.2rem; font-weight: 700; color: var(--accent-purple); font-family: 'Space Mono', monospace; margin-bottom: 5px;">
                                    Manifest #${manifest.ManifestNumber || manifest.Id}
                                </div>
                                <div style="color: var(--text-secondary); font-size: 0.9rem;">
                                    ${manifestDate}  ${packageCount} packages
                                </div>
                            </div>
                            <div style="background: rgba(147, 51, 234, 0.2); color: var(--accent-purple); padding: 6px 12px; border-radius: 15px; font-size: 0.85rem; font-weight: 600;">
                                Click to View
                            </div>
                        </div>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--border);">
                            <div>
                                <div style="color: var(--text-secondary); font-size: 0.8rem;">Shipper</div>
                                <div style="font-weight: 600; font-size: 0.95rem;">${manifest.ShipperFacilityName || 'N/A'}</div>
                            </div>
                            <div>
                                <div style="color: var(--text-secondary); font-size: 0.8rem;">Shipper License</div>
                                <div style="font-weight: 600; font-size: 0.95rem; font-family: 'Space Mono', monospace;">${manifest.ShipperFacilityLicenseNumber || 'N/A'}</div>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
            
            document.getElementById('metrcManifestsList').style.display = 'block';
            document.getElementById('metrcError').style.display = 'none';
        }

        function selectManifest(index) {
            selectedManifest = metrcManifests[index];
            selectedTags = [];
            
            // Display manifest details
            const manifestInfo = document.getElementById('manifestInfo');
            const manifestDate = new Date(selectedManifest.ReceivedDateTime || selectedManifest.CreatedDate);
            
            manifestInfo.innerHTML = `
                <div>
                    <div style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 5px;">Manifest Number</div>
                    <div style="font-family: 'Space Mono', monospace; font-size: 1.1rem; font-weight: 700;">${selectedManifest.ManifestNumber || selectedManifest.Id}</div>
                </div>
                <div>
                    <div style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 5px;">Received Date</div>
                    <div style="font-weight: 600;">${manifestDate.toLocaleDateString()} ${manifestDate.toLocaleTimeString([], {hour: '2-digit', minute: '2-digit'})}</div>
                </div>
                <div>
                    <div style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 5px;">Shipper Name</div>
                    <div style="font-weight: 600;">${selectedManifest.ShipperFacilityName || 'N/A'}</div>
                </div>
                <div>
                    <div style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 5px;">Shipper License (403R)</div>
                    <div style="font-family: 'Space Mono', monospace; font-weight: 700; color: var(--accent-blue);">${selectedManifest.ShipperFacilityLicenseNumber || 'N/A'}</div>
                </div>
            `;
            
            // Display packages/tags
            displayManifestTags();
            
            // Show details section, hide manifests list
            document.getElementById('metrcManifestsList').style.display = 'none';
            document.getElementById('manifestDetailsSection').style.display = 'block';
        }

        function displayManifestTags() {
            const container = document.getElementById('tagsContainer');
            
            // Extract all packages from all deliveries
            let allPackages = [];
            if (selectedManifest.Deliveries) {
                selectedManifest.Deliveries.forEach(delivery => {
                    if (delivery.Packages) {
                        allPackages = allPackages.concat(delivery.Packages);
                    }
                });
            }
            
            // Filter for trim/shake packages only
            const trimPackages = allPackages.filter(pkg => {
                const productName = (pkg.ProductName || '').toLowerCase();
                const productCategory = (pkg.ProductCategoryName || '').toLowerCase();
                return productName.includes('trim') || productName.includes('shake') || 
                       productCategory.includes('trim') || productCategory.includes('shake');
            });
            
            if (trimPackages.length === 0) {
                container.innerHTML = '<div style="color: var(--text-secondary); font-style: italic; padding: 20px; text-align: center;">No trim or shake packages found in this manifest.</div>';
                return;
            }
            
            container.innerHTML = trimPackages.map((pkg, index) => {
                const tagNumber = pkg.PackageLabel || pkg.Label || 'N/A';
                const shortTag = tagNumber.length > 10 ? tagNumber.slice(-5) : tagNumber;
                const weight = parseFloat(pkg.Quantity || pkg.ShippedQuantity || 0);
                const unitWeight = pkg.UnitOfMeasureName || 'Grams';
                const strain = pkg.ProductName || 'Unknown Strain';
                
                return `
                    <label style="background: var(--bg-primary); padding: 20px; border-radius: 12px; border: 2px solid var(--border); cursor: pointer; transition: all 0.3s ease; display: flex; align-items: center; gap: 15px;" 
                           onmouseover="this.style.borderColor='var(--accent-purple)'" 
                           onmouseout="this.style.borderColor=document.getElementById('tagCheck${index}').checked ? 'var(--accent-purple)' : 'var(--border)'">
                        <input type="checkbox" id="tagCheck${index}" 
                               onchange="toggleTag(${index}, '${tagNumber}', ${weight}, '${strain}')"
                               style="width: 20px; height: 20px; cursor: pointer;">
                        <div style="flex: 1;">
                            <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 8px;">
                                <div>
                                    <div style="font-family: 'Space Mono', monospace; font-size: 1.1rem; font-weight: 700; color: var(--accent-purple);">
                                        Tag: ...${shortTag}
                                    </div>
                                    <div style="color: var(--text-secondary); font-size: 0.85rem; margin-top: 3px;">${tagNumber}</div>
                                </div>
                                <div style="text-align: right;">
                                    <div style="font-size: 1.5rem; font-weight: 700; color: var(--accent-green);">${weight.toFixed(1)}</div>
                                    <div style="color: var(--text-secondary); font-size: 0.85rem;">${unitWeight}</div>
                                </div>
                            </div>
                            <div style="color: var(--text-secondary); font-size: 0.9rem;">
                                <strong>Product:</strong> ${strain}
                            </div>
                        </div>
                    </label>
                `;
            }).join('');
            
            updateSelectedSummary();
        }

        function toggleTag(index, tagNumber, weight, strain) {
            const checkbox = document.getElementById(`tagCheck${index}`);
            
            if (checkbox.checked) {
                selectedTags.push({ tagNumber, weight, strain });
            } else {
                selectedTags = selectedTags.filter(t => t.tagNumber !== tagNumber);
            }
            
            updateSelectedSummary();
        }

        function updateSelectedSummary() {
            const summary = document.getElementById('selectedTagsSummary');
            
            if (selectedTags.length === 0) {
                summary.innerHTML = '<div style="color: var(--text-secondary); font-style: italic;">No tags selected. Select tags above to continue.</div>';
                return;
            }
            
            const totalWeight = selectedTags.reduce((sum, tag) => sum + tag.weight, 0);
            const uniqueStrains = [...new Set(selectedTags.map(t => t.strain))];
            
            summary.innerHTML = `
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-bottom: 20px;">
                    <div style="background: var(--bg-primary); padding: 15px; border-radius: 10px; text-align: center;">
                        <div style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 5px;">Tags Selected</div>
                        <div style="font-size: 2rem; font-weight: 700; color: var(--accent-purple);">${selectedTags.length}</div>
                    </div>
                    <div style="background: var(--bg-primary); padding: 15px; border-radius: 10px; text-align: center;">
                        <div style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 5px;">Total Weight</div>
                        <div style="font-size: 2rem; font-weight: 700; color: var(--accent-green);">${totalWeight.toFixed(1)}g</div>
                    </div>
                    <div style="background: var(--bg-primary); padding: 15px; border-radius: 10px; text-align: center;">
                        <div style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 5px;">Unique Strains</div>
                        <div style="font-size: 2rem; font-weight: 700; color: var(--accent-blue);">${uniqueStrains.length}</div>
                    </div>
                </div>
                <div style="background: var(--bg-primary); padding: 15px; border-radius: 10px;">
                    <div style="color: var(--text-secondary); font-size: 0.85rem; margin-bottom: 10px;">Selected Tags:</div>
                    ${selectedTags.map(tag => `
                        <div style="display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid var(--border);">
                            <span style="font-family: 'Space Mono', monospace; font-size: 0.9rem;">...${tag.tagNumber.slice(-5)}</span>
                            <span style="font-weight: 600; color: var(--accent-green);">${tag.weight.toFixed(1)}g</span>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        function clearManifestSelection() {
            selectedManifest = null;
            selectedTags = [];
            document.getElementById('manifestDetailsSection').style.display = 'none';
            if (metrcManifests.length > 0) {
                document.getElementById('metrcManifestsList').style.display = 'block';
            }
        }

        function importManifestToBatch() {
            if (selectedTags.length === 0) {
                alert('Please select at least one tag to import.');
                return;
            }
            
            const totalWeight = selectedTags.reduce((sum, tag) => sum + tag.weight, 0);
            const uniqueStrains = [...new Set(selectedTags.map(t => t.strain))];
            const tagNumbers = selectedTags.map(t => t.tagNumber.slice(-5)).join(', ');
            
            // Determine strain name
            let strainName = uniqueStrains.length === 1 ? uniqueStrains[0] : 'Mixed Strains';
            
            // Pre-fill the intake form
            document.getElementById('trimWeight').value = totalWeight.toFixed(1);
            document.getElementById('cultivationLicense').value = selectedManifest.ShipperFacilityLicenseNumber || '';
            document.getElementById('growerName').value = selectedManifest.ShipperFacilityName || '';
            document.getElementById('metrcTags').value = tagNumbers;
            document.getElementById('strainName').value = strainName;
            document.getElementById('intakeDate').value = new Date(selectedManifest.ReceivedDateTime || selectedManifest.CreatedDate).toISOString().split('T')[0];
            
            // Close modal and switch to intake tab
            closeMetrcImport();
            
            // Switch to intake tab
            document.querySelectorAll('.station-tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.station-content').forEach(content => content.classList.remove('active'));
            document.querySelector('[data-station="intake"]').classList.add('active');
            document.getElementById('intake').classList.add('active');
            
            alert(` Imported ${selectedTags.length} tags (${totalWeight.toFixed(1)}g total)\n\nPlease review and complete the intake form.`);
        }

        // Close METRC modal when clicking outside
        document.getElementById('metrcImportModal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeMetrcImport();
            }
        });

        // Tab switching for METRC modal
        function switchMetrcTab(tab) {
            // Update tab buttons
            document.querySelectorAll('.metrc-tab-btn').forEach(btn => {
                if (btn.dataset.tab === tab) {
                    btn.style.borderBottom = '3px solid var(--accent-purple)';
                    btn.style.color = 'var(--accent-purple)';
                    btn.classList.add('active');
                } else {
                    btn.style.borderBottom = '3px solid transparent';
                    btn.style.color = 'var(--text-secondary)';
                    btn.classList.remove('active');
                }
            });

            // Show/hide sections
            if (tab === 'api') {
                document.getElementById('metrcLoadSection').style.display = 'block';
                document.getElementById('metrcManualSection').style.display = 'none';
            } else {
                document.getElementById('metrcLoadSection').style.display = 'none';
                document.getElementById('metrcManualSection').style.display = 'block';
                updateManualSummary();
            }
        }

        // Manual package entry
        function addManualPackageRow() {
            const container = document.getElementById('manualPackagesContainer');
            const newRow = document.createElement('div');
            newRow.className = 'manual-package-row';
            newRow.style.cssText = 'display: grid; grid-template-columns: 2fr 1fr 1fr auto; gap: 10px; margin-bottom: 10px; align-items: end;';
            newRow.innerHTML = `
                <div class="form-group" style="margin: 0;">
                    <input type="text" class="manual-tag-number" placeholder="1A4060300001234567890">
                </div>
                <div class="form-group" style="margin: 0;">
                    <input type="number" class="manual-tag-weight" step="0.1" placeholder="0">
                </div>
                <div class="form-group" style="margin: 0;">
                    <input type="text" class="manual-tag-strain" placeholder="Strain name">
                </div>
                <button onclick="this.parentElement.remove(); updateManualSummary();" 
                        style="padding: 10px 15px; background: var(--accent-red); border: none; border-radius: 8px; color: white; cursor: pointer; font-weight: 600;">
                    
                </button>
            `;
            container.appendChild(newRow);

            // Add event listeners for auto-summary update
            newRow.querySelectorAll('input').forEach(input => {
                input.addEventListener('input', updateManualSummary);
            });
        }

        function updateManualSummary() {
            const rows = document.querySelectorAll('.manual-package-row');
            const packages = [];
            
            rows.forEach(row => {
                const tag = row.querySelector('.manual-tag-number')?.value || '';
                const weight = parseFloat(row.querySelector('.manual-tag-weight')?.value) || 0;
                const strain = row.querySelector('.manual-tag-strain')?.value || '';
                
                if (tag && weight > 0) {
                    packages.push({ tag, weight, strain });
                }
            });

            const summaryEl = document.getElementById('manualSummary');
            
            if (packages.length === 0) {
                summaryEl.innerHTML = '<div style="color: var(--text-secondary); font-style: italic;">Enter package details above to see summary</div>';
                return;
            }

            const totalWeight = packages.reduce((sum, pkg) => sum + pkg.weight, 0);
            const uniqueStrains = [...new Set(packages.map(p => p.strain).filter(s => s))];

            summaryEl.innerHTML = `
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; margin-bottom: 15px;">
                    <div style="text-align: center;">
                        <div style="font-size: 2rem; font-weight: 700; color: var(--accent-purple);">${packages.length}</div>
                        <div style="color: var(--text-secondary); font-size: 0.85rem;">Packages</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="font-size: 2rem; font-weight: 700; color: var(--accent-green);">${totalWeight.toFixed(1)}g</div>
                        <div style="color: var(--text-secondary); font-size: 0.85rem;">Total Weight</div>
                    </div>
                    <div style="text-align: center;">
                        <div style="font-size: 2rem; font-weight: 700; color: var(--accent-blue);">${uniqueStrains.length}</div>
                        <div style="color: var(--text-secondary); font-size: 0.85rem;">Unique Strains</div>
                    </div>
                </div>
                <div style="font-size: 0.9rem;">
                    ${packages.map(pkg => `
                        <div style="display: flex; justify-content: space-between; padding: 5px 0; border-bottom: 1px solid var(--border);">
                            <span style="font-family: 'Space Mono', monospace; font-size: 0.85rem;">...${pkg.tag.slice(-5)}</span>
                            <span style="color: var(--text-secondary);">${pkg.strain || 'Unknown'}</span>
                            <span style="font-weight: 600; color: var(--accent-green);">${pkg.weight.toFixed(1)}g</span>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        function importManualManifest() {
            const manifestNumber = document.getElementById('manualManifestNumber').value.trim();
            const receivedDate = document.getElementById('manualReceivedDate').value;
            const shipperName = document.getElementById('manualShipperName').value.trim();
            const shipperLicense = document.getElementById('manualShipperLicense').value.trim();

            if (!manifestNumber || !receivedDate) {
                alert('Please enter at least the manifest number and received date.');
                return;
            }

            const rows = document.querySelectorAll('.manual-package-row');
            const packages = [];
            
            rows.forEach(row => {
                const tag = row.querySelector('.manual-tag-number')?.value || '';
                const weight = parseFloat(row.querySelector('.manual-tag-weight')?.value) || 0;
                const strain = row.querySelector('.manual-tag-strain')?.value || '';
                
                if (tag && weight > 0) {
                    packages.push({ tag, weight, strain });
                }
            });

            if (packages.length === 0) {
                alert('Please add at least one package with tag and weight.');
                return;
            }

            const totalWeight = packages.reduce((sum, pkg) => sum + pkg.weight, 0);
            const uniqueStrains = [...new Set(packages.map(p => p.strain).filter(s => s))];
            const tagNumbers = packages.map(p => p.tag.slice(-5)).join(', ');
            const strainName = uniqueStrains.length === 1 ? uniqueStrains[0] : 'Mixed Strains';

            // Pre-fill the intake form
            document.getElementById('trimWeight').value = totalWeight.toFixed(1);
            document.getElementById('cultivationLicense').value = shipperLicense;
            document.getElementById('growerName').value = shipperName;
            document.getElementById('metrcTags').value = tagNumbers;
            document.getElementById('strainName').value = strainName;
            document.getElementById('intakeDate').value = receivedDate;
            
            // Add manifest number to notes
            const notesField = document.getElementById('intakeNotes');
            notesField.value = `METRC Manifest #${manifestNumber}${notesField.value ? '\n\n' + notesField.value : ''}`;

            // Close modal and switch to intake tab
            closeMetrcImport();
            
            document.querySelectorAll('.station-tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.station-content').forEach(content => content.classList.remove('active'));
            document.querySelector('[data-station="intake"]').classList.add('active');
            document.getElementById('intake').classList.add('active');
            
            alert(` Imported ${packages.length} packages (${totalWeight.toFixed(1)}g total)\n\nPlease review and complete the intake form.`);
        }

        // Add event listener to first manual package row
        document.addEventListener('DOMContentLoaded', function() {
            const firstRow = document.querySelector('.manual-package-row');
            if (firstRow) {
                firstRow.querySelectorAll('input').forEach(input => {
                    input.addEventListener('input', updateManualSummary);
                });
            }

            // Load production targets
            loadTargets();
        });

        // ==================== FRONT OF HOUSE ====================

        // Partner database for auto-tagging
        const fohPartners = {
            'in the flow': { name: 'In The Flow', instagram: '@intheflow_farms', website: 'https://intheflowfarms.com', type: 'farm', hashtags: ['#InTheFlowFarms', '#ColoradoGrown'] },
            'veritas': { name: 'Veritas Fine Cannabis', instagram: '@veritasfinecannabis', website: 'https://veritasfinecannabis.com', type: 'farm', hashtags: ['#VeritasCannabis'] },
            'locol love': { name: 'Locol Love', instagram: '@locollove', website: 'https://locol-love.com', type: 'farm', hashtags: ['#LocolLove', '#DenverGrown'] },
            'snaxland': { name: 'Snaxland', instagram: '@snaxland', website: null, type: 'farm', hashtags: ['#Snaxland'] },
            'cherry': { name: 'Cherry', instagram: '@cherry.co', website: 'https://cherry.co', type: 'farm', hashtags: ['#CherryCannabis'] },
            'native roots': { name: 'Native Roots', instagram: '@nativerootsdispensary', website: 'https://nativerootsdispensary.com', type: 'dispensary', hashtags: ['#NativeRoots'] },
            'the green solution': { name: 'The Green Solution', instagram: '@thegreensolution', website: 'https://tgscolorado.com', type: 'dispensary', hashtags: ['#TGS'] },
            'lightshade': { name: 'Lightshade', instagram: '@lightshadeco', website: 'https://lightshade.com', type: 'dispensary', hashtags: ['#Lightshade'] }
        };

        // Concentrate-focused post templates for a Colorado extract brand
        // Products: live resin, wax, shatter, sugar wax, badder, carts, AIOs
        const fohPostStyles = {
            equipment: {
                templates: [
                    "{INPUT}\n\nCart hardware matters more than people realize. Ceramic coils, proper airflow, the right resistance - it all affects how those terps translate. We test everything before we fill it.",
                    "{INPUT}\n\nUpgraded our cart filling line today. Every unit needs to hit consistent - same draw, same flavor, same experience. Dialed in.",
                    "New gear: {INPUT}\n\nOur AIO game just leveled up. Better battery, better airflow, better hits. Hardware quality is half the equation.",
                    "{INPUT}\n\nPeople sleep on hardware. You can have the best live resin in Colorado but put it in trash hardware and it's a trash experience. We're picky for a reason.",
                    "{INPUT}\n\nSpent the morning calibrating the fill station. Boring? Maybe. But when every cart and AIO hits perfect? Worth it."
                ]
            },
            newStrain: {
                templates: [
                    "{INPUT}\n\nAlready know this is gonna make some fire live resin. The nose is ridiculous - terps practically jumping out the bag. Perfect candidate for our carts too.",
                    "{INPUT}\n\nThis one's getting the full treatment - live resin jars, sugar wax, and a limited cart run. Some genetics deserve the spotlight.",
                    "New strain locked in: {INPUT}\n\nThe terp profile on this reads perfect for concentrates. Gassy, fruity, complex. Can't wait to see how she extracts.",
                    "{INPUT}\n\nWe're running this for our live resin cart line. The cultivar has that smooth, flavorful profile that translates perfectly to hardware. No harshness, all terps.",
                    "{INPUT}\n\nSome strains are meant for badder, some for shatter. This one's screaming live resin. Wet, terpy, saucy. You'll see.",
                    "{INPUT}\n\nNew live resin incoming. This strain's terpene profile is exactly what Colorado heads love - loud on the inhale, smooth on the exhale.",
                    "Strain drop: {INPUT}\n\nGonna run this as both jarred concentrate and carts. Different expressions, same fire genetics.",
                    "{INPUT}\n\nThe best extracts start with the best inputs. This material is gonna yield some exceptional live resin and maybe a limited AIO run."
                ]
            },
            batch: {
                templates: [
                    "{INPUT}\n\nFresh live resin just finished curing. That light gold color, wet terpy consistency - this is what proper BHO looks like. Jars hitting shelves soon.",
                    "Just filled: {INPUT}\n\nNew batch of 1g live resin carts ready. Ceramic coils, no distillate, no cut - just full spectrum extract. How it should be done.",
                    "{INPUT}\n\nSugar wax batch came out perfect. That granulated, terpy texture with the wet sheen. Classic Colorado concentrate done right.",
                    "Fresh drop: {INPUT}\n\nOur AIOs just got loaded with this run. 100% live resin, quality hardware, ready to rip. Ask your budtender.",
                    "{INPUT}\n\nBadder batch complete. Whipped to that perfect creamy consistency - scoops clean, dabs smooth, terps loud. This one's special.",
                    "{INPUT}\n\nShatter run came out glass. That clean snap, proper clarity, stable at room temp. Old school product, premium quality.",
                    "Lab fresh: {INPUT}\n\nCarts filled, AIOs assembled, jars packed. Full product line restocked with this strain. Hitting dispensaries this week.",
                    "{INPUT}\n\nTest results back - numbers are fire but the terp percentage is what we're hyped about. This live resin is LOUD.",
                    "{INPUT}\n\nJust pulled another batch of wax. Consistency came out butter smooth, nose is insane. The cure on this one is gonna be worth the wait."
                ]
            },
            general: {
                templates: [
                    "{INPUT}\n\nLive resin carts, AIOs, badder, shatter, sugar, wax - we do the full spectrum but we do it right. No distillate fillers, no botanical terps. Real extract only.",
                    "{INPUT}\n\nEvery cart we fill, every jar we pack, every AIO we assemble - touched by our team from extraction to shelf. That's the White Mousse difference.",
                    "{INPUT}\n\nColorado's concentrate market is competitive. We stay in the lab perfecting the craft while others cut corners. Your dab sesh deserves better.",
                    "{INPUT}\n\nWhether you're a cart person, a dab rig person, or an AIO-on-the-go person - we got you. Quality concentrates for however you consume.",
                    "{INPUT}\n\nAppreciate everyone who chooses White Mousse. The market has options - thanks for rocking with craft concentrates."
                ]
            }
        };

        const fohEmojis = ['', '', '', '', '', '', '', '', '', ''];

        let fohGeneratedPost = null;

        function detectFOHPartners(input) {
            const lowerInput = input.toLowerCase();
            // Use demo partners in demo mode
            const partnersDb = isDemoMode() ? demoFOHPartners : fohPartners;
            return Object.entries(partnersDb)
                .filter(([key]) => lowerInput.includes(key))
                .map(([, partner]) => partner);
        }

        function formatPartnerShoutout(partner) {
            const webLink = partner.website ? `[${partner.name}](${partner.website})` : partner.name;
            const igLink = partner.instagram || '';
            const phrases = {
                farm: [`Huge shoutout to ${webLink} for this incredible material! ${igLink}`, `This fire came straight from ${webLink}! ${igLink}`],
                dispensary: [`Available at ${webLink}! ${igLink}`, `Find this at ${webLink} - tell them WM sent you! ${igLink}`],
                equipment: [`Thanks to ${webLink} for keeping our lab running smooth! ${igLink}`]
            };
            const typePhrs = phrases[partner.type] || [`${webLink} ${igLink}`];
            return typePhrs[Math.floor(Math.random() * typePhrs.length)];
        }

        function generateFOHHashtags(partners) {
            // Core tags - just a few, not spammy
            const core = ['#WhiteMousse', '#ColoradoConcentrates'];
            // Rotate through secondary tags
            const secondary = ['#LiveResin', '#Concentrates', '#Terps', '#Colorado710'];
            const randomSecondary = secondary[Math.floor(Math.random() * secondary.length)];
            // Partner tags if any
            const partnerTags = partners.flatMap(p => p.hashtags || []).slice(0, 2);
            return [...core, randomSecondary, ...partnerTags].join(' ');
        }

        function addQuickTag(tag) {
            const input = document.getElementById('fohQuickInput');
            input.value = input.value ? `${input.value} ${tag}` : tag;
            input.focus();
        }

        function generateBlogPost() {
            const input = document.getElementById('fohQuickInput').value.trim();
            if (!input) { alert('Type something first!'); return; }

            const lowerInput = input.toLowerCase();
            const partners = detectFOHPartners(input);

            // Detect post type
            let postType = 'general';
            if (lowerInput.match(/hardware|equipment|machine|tech|upgrade/)) postType = 'equipment';
            else if (lowerInput.match(/strain|flower|material|trim|grabbed|picked up|fresh|new.*from|got.*from/)) postType = 'newStrain';
            else if (lowerInput.match(/batch|run|extract|finish|wrap|pull/)) postType = 'batch';

            const styleCategory = fohPostStyles[postType];
            const templates = styleCategory.templates;

            // Pick random template
            const template = templates[Math.floor(Math.random() * templates.length)];

            // Clean up input - capitalize first letter, remove trailing period (template adds context)
            let cleanInput = input.charAt(0).toUpperCase() + input.slice(1);
            cleanInput = cleanInput.replace(/[.]+$/, '');

            // Generate content from template
            let content = template.replace(/{INPUT}/g, cleanInput);

            // Add partner mention naturally if detected
            if (partners.length > 0) {
                const partnerPhrases = {
                    farm: [
                        `Big ups to ${partners[0].name} for bringing the heat.`,
                        `${partners[0].name} came through with this one.`,
                        `Shoutout ${partners[0].name} - they know what they're doing over there.`,
                        `When ${partners[0].name} sends material, we clear the schedule.`
                    ],
                    dispensary: [
                        `Available at ${partners[0].name} - go show them some love.`,
                        `Find this at ${partners[0].name}.`,
                        `${partners[0].name} got you covered on this one.`
                    ]
                };
                const phrases = partnerPhrases[partners[0].type] || [`${partners[0].name}`];
                const partnerMention = phrases[Math.floor(Math.random() * phrases.length)];

                // Add Instagram handle if available
                const igHandle = partners[0].instagram ? ` ${partners[0].instagram}` : '';
                content += `\n\n${partnerMention}${igHandle}`;
            }

            // Add hashtags sparingly
            const hashtags = generateFOHHashtags(partners);
            content += `\n\n${hashtags}`;

            // Generate title - extract key words from input
            const emoji = fohEmojis[Math.floor(Math.random() * fohEmojis.length)];
            // Try to extract strain name or key descriptor
            const words = cleanInput.split(' ');
            let titleText = words.slice(0, 4).join(' ');
            if (titleText.length > 30) titleText = words.slice(0, 3).join(' ');
            const title = `${emoji} ${titleText}`;

            fohGeneratedPost = {
                title,
                content,
                excerpt: content.split('\n')[0].slice(0, 120) + '...',
                category: postType === 'equipment' ? 'update' : postType === 'newStrain' ? 'strains' : 'update',
                emoji
            };

            const partnerInfo = partners.length > 0
                ? `<div style="background: rgba(57,255,20,0.1); border: 1px solid var(--accent-green); padding: 10px; border-radius: 8px; margin-bottom: 15px;">
                     <strong> Auto-detected:</strong> ${partners.map(p => `${p.name} ${p.instagram || ''}`).join(', ')}
                   </div>` : '';

            document.getElementById('fohPartnerInfo').innerHTML = partnerInfo;
            document.getElementById('fohPreviewTitle').textContent = title;
            document.getElementById('fohPreviewContent').innerHTML = content.replace(/\n/g, '<br>');
            document.getElementById('fohGeneratedPreview').style.display = 'block';
        }

        function regenerateBlogPost() {
            generateBlogPost();
        }

        function editBlogPost() {
            if (!fohGeneratedPost) return;
            const newTitle = prompt('Edit title:', fohGeneratedPost.title);
            if (newTitle) fohGeneratedPost.title = newTitle;
            const newContent = prompt('Edit content (basic):', fohGeneratedPost.content.slice(0, 200));
            if (newContent) fohGeneratedPost.content = newContent;
            document.getElementById('fohPreviewTitle').textContent = fohGeneratedPost.title;
            document.getElementById('fohPreviewContent').innerHTML = fohGeneratedPost.content.replace(/\n/g, '<br>');
        }

        async function publishBlogPost() {
            if (!fohGeneratedPost) {
                alert('No post generated');
                return;
            }

            // Demo mode - simulate publishing
            if (isDemoMode()) {
                alert(' DEMO MODE: Publishing is disabled in demo mode.\n\nIn production, this post would be published to your blog and social media channels.');
                document.getElementById('fohQuickInput').value = '';
                document.getElementById('fohGeneratedPreview').style.display = 'none';
                fohGeneratedPost = null;
                return;
            }

            // Production mode - actual publishing
            if (!supabaseClient) {
                alert('Not connected to database');
                return;
            }

            try {
                const { error } = await supabaseClient.from('wm_blog_posts').insert([{
                    title: fohGeneratedPost.title,
                    content: fohGeneratedPost.content,
                    excerpt: fohGeneratedPost.excerpt,
                    category: fohGeneratedPost.category,
                    emoji: fohGeneratedPost.emoji,
                    status: 'published',
                    created_at: new Date().toISOString()
                }]);

                if (error) throw error;

                alert('Post published! ');
                document.getElementById('fohQuickInput').value = '';
                document.getElementById('fohGeneratedPreview').style.display = 'none';
                fohGeneratedPost = null;
                loadFOHPosts();
                loadSalesDashboard();
            } catch (error) {
                console.error('Publish error:', error);
                alert('Error publishing: ' + error.message);
            }
        }

        async function loadFOHRecentBatches() {
            const container = document.getElementById('fohRecentBatches');
            if (!container) return;

            const completedBatches = batches.filter(b => b.status === 'complete').slice(0, 5);

            if (completedBatches.length === 0) {
                container.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-secondary);">No completed batches yet</div>';
                return;
            }

            container.innerHTML = completedBatches.map(batch => `
                <div class="foh-batch-card" onclick="createPostFromBatch('${batch.id}')">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <div style="font-weight: 700; font-size: 1.1rem; color: var(--accent-green);">${batch.id}</div>
                            <div style="color: var(--text-secondary);">${batch.strain || 'Unknown Strain'}  ${batch.material_type || 'Trim'}</div>
                        </div>
                        <div style="text-align: right;">
                            <div style="font-size: 0.85rem; color: var(--text-secondary);">Final: ${batch.final_weight || batch.bulk_weight || '?'}g</div>
                            <button class="btn" style="background: var(--accent-purple); padding: 6px 12px; font-size: 0.85rem; margin-top: 5px;"> Create Post</button>
                        </div>
                    </div>
                </div>
            `).join('');
        }

        function toggleBlogGenerator() {
            const section = document.getElementById("blogGeneratorSection");
            section.style.display = section.style.display === "none" ? "block" : "none";
        }

        function createPostFromBatch(batchId) {
            const batch = batches.find(b => b.id === batchId);
            if (!batch) return;

            const input = `Fresh batch of ${batch.strain || 'premium material'} just finished! ${batch.final_weight || batch.bulk_weight || ''}g of pure fire.`;
            document.getElementById('fohQuickInput').value = input;
            generateBlogPost();
        }

        async function loadFOHPosts() {
            const container = document.getElementById('fohPostsList');
            if (!container) return;

            // Use demo data in demo mode
            if (isDemoMode()) {
                const data = generateDemoBlogPosts();

                // Helper to escape HTML
                const escapeHtml = (str) => {
                    if (!str) return '';
                    return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;').replace(/`/g, '&#96;');
                };

                container.innerHTML = data.map(post => {
                    const safeTitle = escapeHtml(post.title);
                    const safeEmoji = escapeHtml(post.emoji) || '';
                    const safeExcerpt = post.excerpt ? escapeHtml(post.excerpt.slice(0, 100)) + '...' : '';
                    const safeStatus = escapeHtml(post.status);
                    const dateStr = new Date(post.created_at).toLocaleDateString();

                    return `<div class="foh-post-card" onclick="viewBlogPost('${post.id}')" style="cursor: pointer;">
                        <div style="flex: 1;">
                            <div style="font-weight: 600;">${safeEmoji} ${safeTitle}</div>
                            <div style="font-size: 0.85rem; color: var(--text-secondary); margin-top: 5px;">${safeExcerpt}</div>
                            <div style="font-size: 0.8rem; color: var(--text-secondary); margin-top: 8px;">${dateStr}</div>
                        </div>
                        <div style="display: flex; flex-direction: column; align-items: flex-end; gap: 8px;">
                            <span class="foh-post-status ${safeStatus}">${safeStatus}</span>
                            <span style="font-size: 0.8rem; color: var(--accent-blue);">Click to view </span>
                        </div>
                    </div>`;
                }).join('');

                // Store posts for viewing
                window.fohBlogPosts = data;
                return;
            }

            // Production mode - use Supabase
            if (!supabaseClient) return;

            try {
                const { data, error } = await supabaseClient
                    .from('wm_blog_posts')
                    .select('*')
                    .order('created_at', { ascending: false })
                    .limit(10);

                if (error) throw error;

                if (!data || data.length === 0) {
                    container.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-secondary);">No posts yet. Create your first one above!</div>';
                    return;
                }

                // Helper to escape HTML
                const escapeHtml = (str) => {
                    if (!str) return '';
                    return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;').replace(/`/g, '&#96;');
                };

                container.innerHTML = data.map(post => {
                    const safeTitle = escapeHtml(post.title);
                    const safeEmoji = escapeHtml(post.emoji) || '';
                    const safeExcerpt = post.excerpt ? escapeHtml(post.excerpt.slice(0, 100)) + '...' : '';
                    const safeStatus = escapeHtml(post.status);
                    const dateStr = new Date(post.created_at).toLocaleDateString();

                    return `<div class="foh-post-card" onclick="viewBlogPost('${post.id}')" style="cursor: pointer;">
                        <div style="flex: 1;">
                            <div style="font-weight: 600;">${safeEmoji} ${safeTitle}</div>
                            <div style="font-size: 0.85rem; color: var(--text-secondary); margin-top: 5px;">${safeExcerpt}</div>
                            <div style="font-size: 0.8rem; color: var(--text-secondary); margin-top: 8px;">${dateStr}</div>
                        </div>
                        <div style="display: flex; flex-direction: column; align-items: flex-end; gap: 8px;">
                            <span class="foh-post-status ${safeStatus}">${safeStatus}</span>
                            <span style="font-size: 0.8rem; color: var(--accent-blue);">Click to view </span>
                        </div>
                    </div>`;
                }).join('');

                // Store posts for viewing
                window.fohBlogPosts = data;
            } catch (error) {
                console.error('Error loading posts:', error);
                container.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-secondary);">Error loading posts</div>';
            }
        }

        // View a blog post in modal
        function viewBlogPost(postId) {
            const posts = window.fohBlogPosts || [];
            const post = posts.find(p => p.id === postId);

            if (!post) {
                console.error('Post not found:', postId);
                return;
            }

            // Set modal content
            document.getElementById('blogPostViewTitle').textContent = (post.emoji || '') + ' ' + post.title;
            document.getElementById('blogPostViewMeta').textContent = `Posted ${new Date(post.created_at).toLocaleDateString()} | Status: ${post.status}`;
            document.getElementById('blogPostViewContent').textContent = post.content || post.excerpt || 'No content available.';

            // Show modal
            document.getElementById('blogPostViewModal').style.display = 'block';
            document.body.style.overflow = 'hidden';
        }

        function closeBlogPostView() {
            document.getElementById('blogPostViewModal').style.display = 'none';
            document.body.style.overflow = 'auto';
        }

        // ==================== LEAFLINK DROP CALENDAR ====================

        let dropCalendarData = [];
        let currentCalendarView = 'calendar';
        let calendarDisplayMonth = new Date().getMonth();
        let calendarDisplayYear = new Date().getFullYear();

        function openDropCalendarModal() {
            document.getElementById('dropCalendarModal').style.display = 'block';
            document.body.style.overflow = 'hidden';
            // Reset to current month when opening
            calendarDisplayMonth = new Date().getMonth();
            calendarDisplayYear = new Date().getFullYear();
            // Auto-refresh if no data
            if (dropCalendarData.length === 0) {
                loadDropCalendar();
            } else {
                renderCalendarView();
            }
        }

        function closeDropCalendarModal() {
            document.getElementById('dropCalendarModal').style.display = 'none';
            document.body.style.overflow = 'auto';
        }

        function navigateCalendarMonth(direction) {
            calendarDisplayMonth += direction;
            if (calendarDisplayMonth > 11) {
                calendarDisplayMonth = 0;
                calendarDisplayYear++;
            } else if (calendarDisplayMonth < 0) {
                calendarDisplayMonth = 11;
                calendarDisplayYear--;
            }
            renderCalendarView();
        }

        async function loadDropCalendar() {
            const content = document.getElementById('dropCalendarContent');
            content.innerHTML = '<div style="text-align: center; padding: 60px; color: var(--text-secondary);"><div style="font-size: 2rem; margin-bottom: 10px;"></div>Loading drop data from LeafLink...</div>';

            try {
                // Calculate date 2 months ago
                const twoMonthsAgo = new Date();
                twoMonthsAgo.setMonth(twoMonthsAgo.getMonth() - 2);
                const dateFilter = twoMonthsAgo.toISOString().split('T')[0];

                // Fetch shipped and complete orders via proxy
                let allOrders = [];
                const businessSlug = currentBusinessId === 'all' ? 'white-mousse' :
                    (businessesList.find(b => b.id === currentBusinessId)?.slug || 'white-mousse');
                let nextUrl = `${window.location.origin}/api/leaflink?slug=${businessSlug}&endpoint=orders-received&status=Accepted&status=Shipped&status=Complete&created_on__gte=${dateFilter}&page_size=100`;

                while (nextUrl) {
                    const response = await fetch(nextUrl);

                    if (!response.ok) throw new Error('API request failed - is the proxy server running?');

                    const data = await response.json();
                    allOrders = allOrders.concat(data.results);
                    nextUrl = data.next;

                    // Safety limit
                    if (allOrders.length > 500) break;
                }

                // Process orders into drop calendar data
                dropCalendarData = processDropData(allOrders);
                updateDropStats();
                renderCalendarView();

            } catch (error) {
                console.error('Error loading drop calendar:', error);
                content.innerHTML = `<div style="text-align: center; padding: 60px; color: var(--accent-red);">
                    <div style="font-size: 2rem; margin-bottom: 10px;"></div>
                    Error loading data: ${error.message}<br>
                    <small style="color: var(--text-secondary);">Make sure the proxy server is running:<br><code>cd proxy && npm install && npm start</code></small>
                </div>`;
            }
        }

        function processDropData(orders) {
            const customerDrops = {};

            orders.forEach(order => {
                if (!order.customer || !order.ship_date) return;

                const customerId = order.customer.id;
                const customerName = order.customer.display_name;
                const shipDate = order.ship_date.split('T')[0];

                // Extract products from line_items
                const products = (order.line_items || []).map(item => ({
                    name: item.frozen_data?.product?.name || 'Unknown Product',
                    quantity: Math.round(parseFloat(item.quantity) || 1),
                    sku: item.frozen_data?.product?.sku || ''
                }));

                // Aggregate products by name for cleaner display
                const productSummary = {};
                products.forEach(p => {
                    if (productSummary[p.name]) {
                        productSummary[p.name] += p.quantity;
                    } else {
                        productSummary[p.name] = p.quantity;
                    }
                });

                if (!customerDrops[customerId]) {
                    customerDrops[customerId] = {
                        id: customerId,
                        name: customerName,
                        deliveryPrefs: order.delivery_preferences || '',
                        drops: [],
                        totalOrders: 0,
                        totalProducts: 0
                    };
                }

                const totalProductCount = products.reduce((sum, p) => sum + p.quantity, 0);

                customerDrops[customerId].drops.push({
                    date: shipDate,
                    orderId: order.short_id,
                    products: productSummary,
                    productCount: totalProductCount,
                    status: order.status,
                    notes: order.notes || ''
                });
                customerDrops[customerId].totalOrders++;
                customerDrops[customerId].totalProducts += totalProductCount;
            });

            // Sort drops by date for each customer
            Object.values(customerDrops).forEach(customer => {
                customer.drops.sort((a, b) => new Date(b.date) - new Date(a.date));
                customer.lastDrop = customer.drops[0]?.date;
                customer.avgDaysBetween = calculateAvgDaysBetween(customer.drops);
            });

            return Object.values(customerDrops).sort((a, b) =>
                new Date(b.lastDrop) - new Date(a.lastDrop)
            );
        }

        function calculateAvgDaysBetween(drops) {
            if (drops.length < 2) return null;
            let totalDays = 0;
            for (let i = 1; i < drops.length; i++) {
                const diff = new Date(drops[i-1].date) - new Date(drops[i].date);
                totalDays += diff / (1000 * 60 * 60 * 24);
            }
            return Math.round(totalDays / (drops.length - 1));
        }

        function updateDropStats() {
            const totalDrops = dropCalendarData.reduce((sum, c) => sum + c.totalOrders, 0);
            const uniqueCustomers = dropCalendarData.length;
            const totalProducts = dropCalendarData.reduce((sum, c) => sum + c.totalProducts, 0);

            // This week
            const now = new Date();
            const weekStart = new Date(now);
            weekStart.setDate(now.getDate() - now.getDay());
            const thisWeek = dropCalendarData.reduce((sum, c) => {
                return sum + c.drops.filter(d => new Date(d.date) >= weekStart).length;
            }, 0);

            // Avg per week (over 2 months = ~8 weeks)
            const avgPerWeek = Math.round(totalDrops / 8);

            document.getElementById('statTotalDrops').textContent = totalDrops;
            document.getElementById('statUniqueCustomers').textContent = uniqueCustomers;
            document.getElementById('statThisWeek').textContent = thisWeek;
            document.getElementById('statTotalProducts').textContent = totalProducts;
        }

        function setCalendarView(view) {
            currentCalendarView = view;

            // Update button styles
            document.getElementById('viewCalendarBtn').style.background = view === 'calendar' ? 'var(--accent-blue)' : 'var(--bg-tertiary)';
            document.getElementById('viewListBtn').style.background = view === 'list' ? 'var(--accent-blue)' : 'var(--bg-tertiary)';
            document.getElementById('viewFreqBtn').style.background = view === 'frequency' ? 'var(--accent-blue)' : 'var(--bg-tertiary)';

            renderCalendarView();
        }

        function renderCalendarView() {
            const content = document.getElementById('dropCalendarContent');

            if (dropCalendarData.length === 0) {
                content.innerHTML = '<div style="text-align: center; padding: 60px; color: var(--text-secondary);">No drop data loaded yet</div>';
                return;
            }

            switch (currentCalendarView) {
                case 'calendar':
                    renderMonthCalendar(content);
                    break;
                case 'list':
                    renderCustomerList(content);
                    break;
                case 'frequency':
                    renderFrequencyView(content);
                    break;
            }
        }

        function renderMonthCalendar(container) {
            const now = new Date();
            const year = calendarDisplayYear;
            const month = calendarDisplayMonth;

            // Build calendar grid
            const firstDay = new Date(year, month, 1);
            const lastDay = new Date(year, month + 1, 0);
            const startPad = firstDay.getDay();

            // Get all drops for this month
            const monthDrops = {};
            dropCalendarData.forEach(customer => {
                customer.drops.forEach(drop => {
                    const dropDate = new Date(drop.date);
                    if (dropDate.getMonth() === month && dropDate.getFullYear() === year) {
                        const day = dropDate.getDate();
                        if (!monthDrops[day]) monthDrops[day] = [];
                        monthDrops[day].push({ customer: customer.name, ...drop });
                    }
                });
            });

            const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                               'July', 'August', 'September', 'October', 'November', 'December'];

            // Check if this is the current month
            const isCurrentMonth = month === now.getMonth() && year === now.getFullYear();

            let html = `
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                    <button onclick="navigateCalendarMonth(-1)" style="background: var(--accent-blue); border: none; color: white; padding: 10px 18px; border-radius: 8px; cursor: pointer; font-size: 1.1rem; font-weight: 700; transition: all 0.2s ease;" onmouseover="this.style.background='var(--accent-purple)'" onmouseout="this.style.background='var(--accent-blue)'">&larr; Prev</button>
                    <h3 style="margin: 0; font-size: 1.3rem;">${monthNames[month]} ${year}</h3>
                    <button onclick="navigateCalendarMonth(1)" style="background: var(--accent-blue); border: none; color: white; padding: 10px 18px; border-radius: 8px; cursor: pointer; font-size: 1.1rem; font-weight: 700; transition: all 0.2s ease;" onmouseover="this.style.background='var(--accent-purple)'" onmouseout="this.style.background='var(--accent-blue)'">Next &rarr;</button>
                </div>
                <div style="display: grid; grid-template-columns: repeat(7, 1fr); gap: 5px;">
                    <div style="text-align: center; font-weight: 700; color: var(--text-secondary); padding: 10px;">Sun</div>
                    <div style="text-align: center; font-weight: 700; color: var(--text-secondary); padding: 10px;">Mon</div>
                    <div style="text-align: center; font-weight: 700; color: var(--text-secondary); padding: 10px;">Tue</div>
                    <div style="text-align: center; font-weight: 700; color: var(--text-secondary); padding: 10px;">Wed</div>
                    <div style="text-align: center; font-weight: 700; color: var(--text-secondary); padding: 10px;">Thu</div>
                    <div style="text-align: center; font-weight: 700; color: var(--text-secondary); padding: 10px;">Fri</div>
                    <div style="text-align: center; font-weight: 700; color: var(--text-secondary); padding: 10px;">Sat</div>
            `;

            // Empty cells for start padding
            for (let i = 0; i < startPad; i++) {
                html += '<div></div>';
            }

            // Calendar days
            for (let day = 1; day <= lastDay.getDate(); day++) {
                const drops = monthDrops[day] || [];
                const isToday = isCurrentMonth && day === now.getDate();
                const hasDrops = drops.length > 0;

                html += `
                    <div style="background: ${hasDrops ? 'var(--accent-green)' : 'var(--bg-secondary)'};
                                ${isToday ? 'border: 2px solid var(--accent-blue);' : ''}
                                border-radius: 8px; padding: 8px; min-height: 60px; cursor: ${hasDrops ? 'pointer' : 'default'};"
                         ${hasDrops ? `onclick="showDayDrops(${day}, ${month}, ${year})"` : ''}>
                        <div style="font-weight: 700; ${hasDrops ? 'color: white;' : ''}">${day}</div>
                        ${hasDrops ? `<div style="font-size: 0.75rem; color: rgba(255,255,255,0.9); margin-top: 3px;">${drops.length} drop${drops.length > 1 ? 's' : ''}</div>` : ''}
                    </div>
                `;
            }

            html += '</div>';
            container.innerHTML = html;
        }

        function showDayDrops(day, month, year) {
            const drops = [];
            dropCalendarData.forEach(customer => {
                customer.drops.forEach(drop => {
                    const dropDate = new Date(drop.date);
                    if (dropDate.getDate() === day && dropDate.getMonth() === month && dropDate.getFullYear() === year) {
                        drops.push({ customer: customer.name, ...drop });
                    }
                });
            });

            // Build a nice modal instead of alert
            const dateStr = new Date(year, month, day).toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric' });

            let modalHtml = `
                <div id="dropDayModal" style="position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.8); z-index: 10002; display: flex; align-items: center; justify-content: center; padding: 20px;" onclick="if(event.target.id==='dropDayModal')this.remove()">
                    <div style="background: var(--bg-secondary); border-radius: 16px; padding: 25px; max-width: 600px; width: 100%; max-height: 80vh; overflow-y: auto;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                            <h3 style="margin: 0; color: var(--accent-green);"> ${dateStr}</h3>
                            <button onclick="this.closest('#dropDayModal').remove()" style="background: none; border: none; color: var(--text-primary); font-size: 1.5rem; cursor: pointer;">&times;</button>
                        </div>
                        <div style="display: grid; gap: 15px;">
                            ${drops.map(d => `
                                <div style="background: var(--bg-primary); border-radius: 12px; padding: 15px; border-left: 4px solid var(--accent-green);">
                                    <div style="font-weight: 700; font-size: 1.1rem; margin-bottom: 10px;">${d.customer}</div>
                                    <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                                        ${Object.entries(d.products || {}).map(([name, qty]) => `
                                            <div style="background: var(--bg-tertiary); padding: 6px 12px; border-radius: 20px; font-size: 0.85rem;">
                                                <span style="color: var(--accent-blue); font-weight: 700;">${qty}x</span> ${name.length > 40 ? name.substring(0, 40) + '...' : name}
                                            </div>
                                        `).join('')}
                                    </div>
                                    <div style="margin-top: 10px; font-size: 0.85rem; color: var(--text-secondary);">
                                        ${d.productCount} items total
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                </div>
            `;
            document.body.insertAdjacentHTML('beforeend', modalHtml);
        }

        function renderCustomerList(container) {
            let html = `
                <div style="display: grid; gap: 10px;">
                    ${dropCalendarData.map(customer => `
                        <div style="background: var(--bg-secondary); padding: 15px; border-radius: 10px;">
                            <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 10px;">
                                <div>
                                    <div style="font-weight: 700; font-size: 1.1rem;">${customer.name}</div>
                                    <div style="color: var(--text-secondary); font-size: 0.85rem;">
                                        Last drop: ${customer.lastDrop || 'N/A'}  ${customer.totalOrders} orders  ${customer.totalProducts} products
                                    </div>
                                </div>
                                <div style="text-align: right;">
                                    ${customer.avgDaysBetween ? `<div style="background: var(--accent-purple); color: white; padding: 5px 10px; border-radius: 20px; font-size: 0.85rem;">Every ~${customer.avgDaysBetween} days</div>` : ''}
                                </div>
                            </div>
                            ${customer.drops.length > 0 && customer.drops[0].products ? `
                                <div style="display: flex; flex-wrap: wrap; gap: 6px; margin-top: 8px;">
                                    ${Object.entries(customer.drops[0].products).slice(0, 5).map(([name, qty]) => `
                                        <div style="background: var(--bg-tertiary); padding: 4px 10px; border-radius: 15px; font-size: 0.8rem;">
                                            <span style="color: var(--accent-green); font-weight: 600;">${qty}x</span> ${name.length > 30 ? name.substring(0, 30) + '...' : name}
                                        </div>
                                    `).join('')}
                                    ${Object.keys(customer.drops[0].products).length > 5 ? `<div style="color: var(--text-secondary); font-size: 0.8rem; padding: 4px;">+${Object.keys(customer.drops[0].products).length - 5} more</div>` : ''}
                                </div>
                            ` : ''}
                        </div>
                    `).join('')}
                </div>
            `;
            container.innerHTML = html;
        }

        function renderFrequencyView(container) {
            // Group by frequency
            const weekly = dropCalendarData.filter(c => c.avgDaysBetween && c.avgDaysBetween <= 10);
            const biweekly = dropCalendarData.filter(c => c.avgDaysBetween && c.avgDaysBetween > 10 && c.avgDaysBetween <= 20);
            const monthly = dropCalendarData.filter(c => c.avgDaysBetween && c.avgDaysBetween > 20);
            const oneTime = dropCalendarData.filter(c => !c.avgDaysBetween);

            const renderGroup = (title, customers, color) => `
                <div style="margin-bottom: 20px;">
                    <h4 style="color: ${color}; margin: 0 0 10px 0; display: flex; align-items: center; gap: 10px;">
                        ${title} <span style="background: ${color}; color: white; padding: 2px 8px; border-radius: 10px; font-size: 0.8rem;">${customers.length}</span>
                    </h4>
                    <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                        ${customers.map(c => `
                            <div style="background: var(--bg-secondary); padding: 8px 12px; border-radius: 20px; font-size: 0.9rem; border-left: 3px solid ${color};">
                                ${c.name}
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;

            container.innerHTML = `
                ${renderGroup(' Weekly (1-10 days)', weekly, 'var(--accent-green)')}
                ${renderGroup(' Bi-Weekly (11-20 days)', biweekly, 'var(--accent-blue)')}
                ${renderGroup(' Monthly (21+ days)', monthly, 'var(--accent-purple)')}
                ${renderGroup(' One-Time / New', oneTime, 'var(--accent-orange)')}
            `;
        }

        // ==================== SHARED LEAFLINK DATA ====================

        let allLeafLinkOrders = [];
        let customerFirstOrderDates = {};
        let leafLinkDataLoaded = false;
        const LEAFLINK_CACHE_DURATION = 15 * 60 * 1000; // 15 minutes

        // Get business-specific cache key
        function getLeafLinkCacheKey() {
            const bizSlug = currentBusinessId === 'all' ? 'all' :
                (businessesList.find(b => b.id === currentBusinessId)?.slug || 'white-mousse');
            return `leaflink_orders_cache_${bizSlug}`;
        }

        function getNeedsCacheKey() {
            const bizSlug = currentBusinessId === 'all' ? 'all' :
                (businessesList.find(b => b.id === currentBusinessId)?.slug || 'white-mousse');
            return `foh_needs_cache_${bizSlug}`;
        }

        // Load cached data from localStorage
        function loadCachedLeafLinkData() {
            try {
                const cached = localStorage.getItem(getLeafLinkCacheKey());
                if (!cached) return null;

                const { orders, timestamp, customerDates } = JSON.parse(cached);
                const age = Date.now() - timestamp;

                // Return cached data if less than 15 minutes old
                if (age < LEAFLINK_CACHE_DURATION) {
                    console.log(`Using cached LeafLink data (${Math.round(age/1000)}s old, ${orders.length} orders)`);
                    return { orders, customerDates, isFresh: false };
                }

                // Return stale data but flag for refresh
                console.log(`Cached data is stale (${Math.round(age/60000)}min old), will refresh`);
                return { orders, customerDates, isFresh: false, needsRefresh: true };
            } catch (e) {
                console.error('Error loading cache:', e);
                return null;
            }
        }

        // Save data to localStorage cache
        function saveLeafLinkCache(orders, customerDates) {
            // Skip caching for "all" view to avoid quota issues
            if (currentBusinessId === 'all') {
                console.log('Skipping cache for "all" business view');
                return;
            }
            try {
                const cacheData = {
                    orders,
                    customerDates,
                    timestamp: Date.now()
                };
                localStorage.setItem(getLeafLinkCacheKey(), JSON.stringify(cacheData));
                console.log(`Cached ${orders.length} LeafLink orders for ${getLeafLinkCacheKey()}`);
            } catch (e) {
                // Clear old caches on quota error
                console.warn('Cache quota exceeded, clearing old caches');
                Object.keys(localStorage).forEach(key => {
                    if (key.startsWith('leaflink_orders_cache_')) {
                        localStorage.removeItem(key);
                    }
                });
            }
        }

        // Build customer first order dates from orders
        function buildCustomerFirstOrderDates(orders) {
            const dates = {};
            orders.forEach(order => {
                if (!order.customer) return;
                const customerId = order.customer.id;
                const orderDate = new Date(order.created_on);
                if (!dates[customerId] || orderDate < dates[customerId].date) {
                    dates[customerId] = {
                        date: orderDate,
                        name: order.customer.display_name
                    };
                }
            });
            return dates;
        }

        // Shared function to load LeafLink data with caching
        
        // Force refresh sales data from LeafLink (bypasses all caches)
        async function forceRefreshSales() {
            try {
                // Clear business-specific cache
                localStorage.removeItem(getLeafLinkCacheKey());
                allLeafLinkOrders = [];
                leafLinkDataLoaded = false;
                
                // Fetch fresh from LeafLink
                const orders = await fetchLeafLinkOrders();
                if (orders && orders.length > 0) {
                    allLeafLinkOrders = orders;
                    customerFirstOrderDates = buildCustomerFirstOrderDates(orders);
                    leafLinkDataLoaded = true;
                    saveLeafLinkCache(orders, customerFirstOrderDates);
                    
                    // Update Supabase cache
                    saveSalesDataToSupabase(orders);
                }
                
                // Refresh display
                updateSalesDashboard();
                renderSalesBarChart();
                console.log('Force refreshed ' + orders.length + ' orders from LeafLink');
            } catch (error) {
                console.error('Error force refreshing sales:', error);
                alert('Error refreshing data: ' + error.message);
            }
        }

        async function ensureLeafLinkData(forceRefresh = false) {
            // Return fake data in demo mode
            if (isDemoMode()) {
                if (allLeafLinkOrders.length === 0) {
                    allLeafLinkOrders = generateDemoLeafLinkOrders();
                    customerFirstOrderDates = buildCustomerFirstOrderDates(allLeafLinkOrders);
                    leafLinkDataLoaded = true;
                }
                return allLeafLinkOrders;
            }

            // Check if already loaded in memory
            if (!forceRefresh && leafLinkDataLoaded && allLeafLinkOrders.length > 0) {
                return allLeafLinkOrders;
            }

            // Try to load from cache first
            if (!forceRefresh) {
                const cached = loadCachedLeafLinkData();
                if (cached && !cached.needsRefresh) {
                    allLeafLinkOrders = cached.orders;
                    customerFirstOrderDates = cached.customerDates || buildCustomerFirstOrderDates(cached.orders);
                    leafLinkDataLoaded = true;
                    return allLeafLinkOrders;
                }

                // Use stale cache immediately, refresh in background
                if (cached && cached.needsRefresh) {
                    allLeafLinkOrders = cached.orders;
                    customerFirstOrderDates = cached.customerDates || buildCustomerFirstOrderDates(cached.orders);
                    leafLinkDataLoaded = true;
                    // Refresh in background
                    fetchLeafLinkOrders().then(orders => {
                        if (orders.length > 0) {
                            allLeafLinkOrders = orders;
                            customerFirstOrderDates = buildCustomerFirstOrderDates(orders);
                            saveLeafLinkCache(orders, customerFirstOrderDates);
                        }
                    });
                    return allLeafLinkOrders;
                }
            }

            // No cache or force refresh - fetch fresh data
            const orders = await fetchLeafLinkOrders();
            if (orders.length > 0) {
                allLeafLinkOrders = orders;
                customerFirstOrderDates = buildCustomerFirstOrderDates(orders);
                leafLinkDataLoaded = true;
                saveLeafLinkCache(orders, customerFirstOrderDates);
            }
            return allLeafLinkOrders;
        }

        // Get the LeafLink proxy URL for current business
        function getLeafLinkProxyUrl(endpoint, businessSlug = null) {
            const slug = businessSlug || (currentBusinessId === 'all' ? 'white-mousse' :
                (businessesList.find(b => b.id === currentBusinessId)?.slug || 'white-mousse'));
            // Use direct endpoint with query params (no rewrites needed)
            const base = `${window.location.origin}/api/leaflink?slug=${slug}&endpoint=${encodeURIComponent(endpoint)}`;
            return base;
        }

        // Fetch orders from LeafLink API
        // Fetch orders from a specific business
        async function fetchOrdersForBusiness(businessSlug) {
            try {
                const twoMonthsAgo = new Date();
                twoMonthsAgo.setMonth(twoMonthsAgo.getMonth() - 2);
                const dateFilter = twoMonthsAgo.toISOString().split('T')[0];

                console.log(`Fetching LeafLink orders for: ${businessSlug}`);
                let orders = [];
                let nextUrl = `${window.location.origin}/api/leaflink?slug=${businessSlug}&endpoint=orders-received&status=Accepted&status=Shipped&status=Complete&created_on__gte=${dateFilter}&page_size=100`;

                while (nextUrl && orders.length < 300) {
                    const response = await fetch(nextUrl);
                    if (!response.ok) throw new Error(`API request failed for ${businessSlug}`);
                    const data = await response.json();
                    orders = orders.concat(data.results);
                    nextUrl = data.next;
                }

                console.log(`Fetched ${orders.length} orders from ${businessSlug}`);
                return orders;
            } catch (error) {
                console.error(`Error fetching orders for ${businessSlug}:`, error);
                return [];
            }
        }

        async function fetchLeafLinkOrders() {
            // Return fake data in demo mode
            if (isDemoMode()) {
                return generateDemoLeafLinkOrders();
            }

            // If viewing all businesses, fetch from each in parallel and combine
            if (currentBusinessId === 'all' && businessesList.length > 0) {
                const activeBusinesses = businessesList.filter(b => b.is_active);
                const orderPromises = activeBusinesses.map(async biz => {
                    const orders = await fetchOrdersForBusiness(biz.slug);
                    // Tag each order with business info for display
                    orders.forEach(o => o._business = { id: biz.id, slug: biz.slug, name: biz.display_name });
                    return orders;
                });
                const results = await Promise.all(orderPromises);
                const allOrders = results.flat();
                console.log(`Combined ${allOrders.length} orders from all businesses`);
                return allOrders;
            }

            // Single business fetch
            try {
                const twoMonthsAgo = new Date();
                twoMonthsAgo.setMonth(twoMonthsAgo.getMonth() - 2);
                const dateFilter = twoMonthsAgo.toISOString().split('T')[0];

                const businessSlug = businessesList.find(b => b.id === currentBusinessId)?.slug || 'white-mousse';
                console.log('Fetching LeafLink orders for:', businessSlug);
                let allOrders = [];
                let nextUrl = `${window.location.origin}/api/leaflink?slug=${businessSlug}&endpoint=orders-received&status=Accepted&status=Shipped&status=Complete&created_on__gte=${dateFilter}&page_size=100`;

                while (nextUrl && allOrders.length < 300) {
                    const response = await fetch(nextUrl);
                    if (!response.ok) throw new Error('API request failed');
                    const data = await response.json();
                    allOrders = allOrders.concat(data.results);
                    nextUrl = data.next;
                }

                console.log(`Fetched ${allOrders.length} orders from LeafLink`);
                return allOrders;
            } catch (error) {
                console.error('Error fetching LeafLink data:', error);
                return [];
            }
        }

        // Helper: check if order should be counted (excludes Combined status to avoid duplicates)
        function shouldCountOrder(order) {
            return order.status !== 'Combined';
        }

        // Helper: check if order is effectively paid
        // Checks: paid flag, payment_status field, or zero balance (credit memo)
        function isOrderPaid(order) {
            return order.paid === true ||
                   order.payment_status === 'paid' ||
                   (order.total?.amount || 0) === 0;
        }

        // Calculate payment stats from orders
        function calculatePaymentStats(orders) {
            const countableOrders = orders.filter(o => shouldCountOrder(o));
            const paid = countableOrders.filter(o => isOrderPaid(o));
            const unpaid = countableOrders.filter(o => !isOrderPaid(o));
            const paidTotal = paid.reduce((sum, o) => sum + (o.total?.amount || 0), 0);
            const unpaidTotal = unpaid.reduce((sum, o) => sum + (o.total?.amount || 0), 0);

            // Find overdue payments (unpaid and past due date)
            const now = new Date();
            const overdue = unpaid.filter(o => {
                if (!o.payment_due_date) return false;
                return new Date(o.payment_due_date) < now;
            });
            const overdueTotal = overdue.reduce((sum, o) => sum + (o.total?.amount || 0), 0);

            // Calculate days overdue for each order
            const overdueOrders = overdue.map(o => {
                const dueDate = new Date(o.payment_due_date);
                const daysOverdue = Math.floor((now - dueDate) / (1000 * 60 * 60 * 24));
                return {
                    orderNumber: o.number || o.id,
                    customer: o.customer?.display_name || 'Unknown',
                    amount: o.total?.amount || 0,
                    dueDate: o.payment_due_date,
                    daysOverdue: daysOverdue
                };
            });

            return {
                paidCount: paid.length,
                unpaidCount: unpaid.length,
                paidTotal,
                unpaidTotal,
                overdueCount: overdue.length,
                overdueTotal,
                overdueOrders: overdueOrders
            };
        }

        // Global variable to track current sort for overdue payments
        let overduePaymentSort = 'daysOverdue';
        let overduePaymentData = [];

        function sortOverduePayments(sortBy) {
            overduePaymentSort = sortBy;
            const sorted = [...overduePaymentData];

            switch(sortBy) {
                case 'amount':
                    sorted.sort((a, b) => b.amount - a.amount);
                    break;
                case 'daysOverdue':
                    sorted.sort((a, b) => b.daysOverdue - a.daysOverdue);
                    break;
                case 'customer':
                    sorted.sort((a, b) => a.customer.localeCompare(b.customer));
                    break;
                case 'dueDate':
                    sorted.sort((a, b) => new Date(a.dueDate) - new Date(b.dueDate));
                    break;
            }

            renderOverduePayments(sorted);

            // Update active sort button
            document.querySelectorAll('.overdue-sort-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.sort === sortBy) btn.classList.add('active');
            });
        }

        function renderOverduePayments(orders) {
            const container = document.getElementById('overduePaymentsList');
            if (!container) return;

            container.innerHTML = orders.map(order => {
                const severityColor = order.daysOverdue > 60 ? '#ff0000' :
                                      order.daysOverdue > 30 ? '#ff6b00' :
                                      'var(--accent-red)';
                const severityLabel = order.daysOverdue > 60 ? ' CRITICAL' :
                                      order.daysOverdue > 30 ? ' SEVERE' : '';
                return `
                    <div style="background: linear-gradient(135deg, rgba(239, 68, 68, 0.1), rgba(239, 68, 68, 0.05)); border: 1px solid rgba(239, 68, 68, 0.3); padding: 15px; border-radius: 10px; display: flex; justify-content: space-between; align-items: center;">
                        <div style="flex: 1;">
                            <div style="font-weight: 600; color: var(--text-primary);">${order.customer}</div>
                            <div style="font-size: 0.85rem; color: var(--text-secondary);">Order #${order.orderNumber}</div>
                        </div>
                        <div style="text-align: center; min-width: 80px;">
                            <div style="font-weight: 700; color: ${severityColor}; font-size: 1.1rem;">${order.daysOverdue} days</div>
                            ${severityLabel ? `<div style="font-size: 0.75rem; color: ${severityColor};">${severityLabel}</div>` : ''}
                        </div>
                        <div style="text-align: right; min-width: 100px;">
                            <div style="font-weight: 700; color: var(--accent-red);">${order.amount.toLocaleString('en-US', {minimumFractionDigits: 0, maximumFractionDigits: 0})}</div>
                            <div style="font-size: 0.8rem; color: var(--accent-red);">Due: ${new Date(order.dueDate).toLocaleDateString()}</div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function toggleOverduePayments() {
            const content = document.getElementById('overduePaymentsContent');
            const arrow = document.getElementById('overdueArrow');
            if (content.style.display === 'none') {
                content.style.display = 'block';
                arrow.textContent = '';
            } else {
                content.style.display = 'none';
                arrow.textContent = '';
            }
        }

        // Calculate sales stats from loaded data
        function calculateSalesStats(period = 'month') {
            const now = new Date();
            let startDate, prevStartDate, prevEndDate;

            switch (period) {
                case 'week':
                    startDate = new Date(now);
                    startDate.setDate(now.getDate() - now.getDay());
                    startDate.setHours(0, 0, 0, 0);
                    prevStartDate = new Date(startDate);
                    prevStartDate.setDate(prevStartDate.getDate() - 7);
                    prevEndDate = new Date(startDate);
                    break;
                case 'month':
                    startDate = new Date(now.getFullYear(), now.getMonth(), 1);
                    prevStartDate = new Date(now.getFullYear(), now.getMonth() - 1, 1);
                    prevEndDate = new Date(now.getFullYear(), now.getMonth(), 0);
                    break;
                case 'quarter':
                    const quarter = Math.floor(now.getMonth() / 3);
                    startDate = new Date(now.getFullYear(), quarter * 3, 1);
                    prevStartDate = new Date(now.getFullYear(), (quarter - 1) * 3, 1);
                    prevEndDate = new Date(now.getFullYear(), quarter * 3, 0);
                    break;
                case 'all':
                    startDate = new Date(0);
                    prevStartDate = new Date(0);
                    prevEndDate = new Date(0);
                    break;
            }

            const currentOrders = allLeafLinkOrders.filter(o => {
                const orderDate = new Date(o.created_on);
                return orderDate >= startDate && orderDate <= now;
            });

            const prevOrders = allLeafLinkOrders.filter(o => {
                const orderDate = new Date(o.created_on);
                return orderDate >= prevStartDate && orderDate < prevEndDate;
            });

            const totalOrders = currentOrders.length;
            const totalDollars = currentOrders.reduce((sum, o) => sum + (o.total?.amount || 0), 0);
            const prevTotalOrders = prevOrders.length;
            const prevTotalDollars = prevOrders.reduce((sum, o) => sum + (o.total?.amount || 0), 0);

            // Find new shops
            const newShops = [];
            const seenCustomers = new Set();
            currentOrders.forEach(order => {
                if (!order.customer) return;
                const customerId = order.customer.id;
                if (seenCustomers.has(customerId)) return;
                seenCustomers.add(customerId);

                const firstOrderInfo = customerFirstOrderDates[customerId];
                if (firstOrderInfo && firstOrderInfo.date >= startDate) {
                    newShops.push({
                        id: customerId,
                        name: order.customer.display_name,
                        firstOrderDate: firstOrderInfo.date
                    });
                }
            });

            const ordersChange = prevTotalOrders > 0 ? Math.round(((totalOrders - prevTotalOrders) / prevTotalOrders) * 100) : 0;
            const dollarsChange = prevTotalDollars > 0 ? Math.round(((totalDollars - prevTotalDollars) / prevTotalDollars) * 100) : 0;

            return {
                totalOrders,
                totalDollars,
                newShops,
                ordersChange,
                dollarsChange,
                uniqueCustomers: seenCustomers.size
            };
        }

        // Load FOH data when switching to that tab
        const origShowStation = typeof showStation === 'function' ? showStation : null;
        function showStationWithFOH(stationId) {
            if (origShowStation) origShowStation(stationId);
            if (stationId === 'frontofhouse') {
                loadFOHRecentBatches();
                loadDropCalendar();
                loadFOHPosts();
                loadSalesDashboard();
            }
        }


        // ==================== SALES DASHBOARD ====================

        const COMMISSION_RATE = 0.08; // 8% commission

        // Bubbleman Royalty Constants
        const BUBBLEMAN_SLUG = 'bubblman';

        const ROYALTY_1_11_LLC = {
            name: '1-11 LLC',
            type: 'percentage',
            rate: 0.92,
            products: [
                { pattern: 'bubble hash', match: 'contains' },
                { pattern: 'cold cure', match: 'contains' },
                { pattern: 'rosin', match: 'contains' }
            ]
        };

        const ROYALTY_TED = {
            name: 'Ted',
            type: 'per_unit',
            products: [
                { pattern: 'brick hash', match: 'contains', requires4g: true, unitRate: 2.90 },
                { pattern: 'hash hit', match: 'contains', unitRate: 1.80 }
            ]
        };

        // Extract unique sales reps from orders (dedupe by name for multi-business)
        function extractSalesReps(orders) {
            const repsMap = new Map();
            orders.forEach(order => {
                if (order.sales_reps && Array.isArray(order.sales_reps)) {
                    order.sales_reps.forEach(rep => {
                        if (rep.user) {
                            // Handle both string and object user formats
                            const userName = typeof rep.user === 'string' ? rep.user : (rep.user.name || rep.user.first_name || `Rep ${rep.id}`);
                            const nameKey = userName.toLowerCase().trim();
                            // Use name as key to combine same rep across different businesses
                            if (!repsMap.has(nameKey)) {
                                repsMap.set(nameKey, { id: rep.id, name: userName, ids: [rep.id] });
                            } else {
                                // Add additional ID if this rep has different IDs in different accounts
                                const existing = repsMap.get(nameKey);
                                if (!existing.ids.includes(rep.id)) {
                                    existing.ids.push(rep.id);
                                }
                            }
                        }
                    });
                }
            });
            return Array.from(repsMap.values()).sort((a, b) => a.name.localeCompare(b.name));
        }

        // Filter orders by sales rep (handles reps with multiple IDs across businesses)
        function filterOrdersBySalesRep(orders, repIdOrName) {
            if (repIdOrName === 'all') return orders;

            // Check if repIdOrName is actually a rep object with multiple IDs
            let idsToMatch = [repIdOrName];
            if (typeof repIdOrName === 'object' && repIdOrName.ids) {
                idsToMatch = repIdOrName.ids;
            }

            return orders.filter(order => {
                if (!order.sales_reps || !Array.isArray(order.sales_reps)) return false;
                return order.sales_reps.some(rep => {
                    // Check if this rep's ID matches any of the IDs we're looking for
                    if (idsToMatch.some(id => rep.id == id)) return true;
                    const userName = typeof rep.user === 'string' ? rep.user : (rep.user?.name || rep.user?.first_name || '');
                    return userName.toLowerCase().includes(String(repIdOrName).toLowerCase());
                });
            });
        }

        // Calculate commission for a set of orders
        function calculateCommission(orders, salesRepFilter = 'all') {
            const filteredOrders = filterOrdersBySalesRep(orders, salesRepFilter).filter(o => shouldCountOrder(o));
            const paidOrders = filteredOrders.filter(o => isOrderPaid(o));
            const paidTotal = paidOrders.reduce((sum, o) => sum + (o.total?.amount || 0), 0);
            return paidTotal * COMMISSION_RATE;
        }

        // Get orders for a specific month
        function getOrdersForMonth(orders, year, month) {
            return orders.filter(order => {
                // Use paid_date for commission calculations (when invoice was paid)
                const dateField = order.paid ? (order.paid_date || order.created_on) : order.created_on;
                if (!dateField) return false;
                const orderDate = new Date(dateField);
                return orderDate.getFullYear() === year && orderDate.getMonth() === month;
            });
        }

        // Get paid orders for a specific month (for commission)
        function getPaidOrdersForMonth(orders, year, month) {
            return orders.filter(order => {
                if (!isOrderPaid(order)) return false;
                // Use paid_date if available, otherwise created_on
                const dateField = order.paid_date || order.created_on;
                if (!dateField) return false;
                const paidDate = new Date(dateField);
                return paidDate.getFullYear() === year && paidDate.getMonth() === month;
            });
        }

        // Determine next payday and what commission period it covers
        // Commission is paid on the FIRST pay period of each month
        // Commission covers all payments received SINCE the last commission payout
        function getNextPaydayInfo() {
            const now = new Date();
            // Starting reference: January 9, 2025 (Friday) - first payday of the year
            const referencePayday = new Date(2025, 0, 9); // Jan 9, 2025

            // Build list of all paydays from reference
            const allPaydays = [];
            let payday = new Date(referencePayday);
            // Go back to find earlier paydays (for historical commission dates)
            while (payday.getFullYear() >= 2024) {
                payday.setDate(payday.getDate() - 14);
            }
            payday.setDate(payday.getDate() + 14); // Move forward to first valid payday

            // Build list of paydays through 2026
            while (payday.getFullYear() <= 2026) {
                allPaydays.push(new Date(payday));
                payday.setDate(payday.getDate() + 14);
            }

            // Find which paydays are "first pay periods" (on or before 14th of month)
            // These are the commission paydays
            const commissionPaydays = allPaydays.filter(pd => pd.getDate() <= 14);

            // Find next payday (any payday, not just commission)
            let nextPayday = allPaydays.find(pd => pd > now);
            if (!nextPayday) {
                nextPayday = allPaydays[allPaydays.length - 1];
            }

            // Determine if next payday is a commission payday (first pay period)
            const payMonth = nextPayday.getMonth();
            const payYear = nextPayday.getFullYear();
            const dayOfMonth = nextPayday.getDate();
            const isFirstPayPeriod = dayOfMonth <= 14;

            // Find last commission payout date (most recent commission payday before now)
            let lastCommissionPayday = null;
            for (let i = commissionPaydays.length - 1; i >= 0; i--) {
                if (commissionPaydays[i] <= now) {
                    lastCommissionPayday = commissionPaydays[i];
                    break;
                }
            }
            // Fallback: Dec 6, 2024 was a known commission payday
            if (!lastCommissionPayday) {
                lastCommissionPayday = new Date(2024, 11, 6); // Dec 6, 2024
            }

            // Find next commission payday (for calculating commission period end)
            let nextCommissionPayday = null;
            for (let i = 0; i < commissionPaydays.length; i++) {
                if (commissionPaydays[i] > now) {
                    nextCommissionPayday = commissionPaydays[i];
                    break;
                }
            }

            return {
                nextPayday,
                isFirstPayPeriod,
                payMonth,
                payYear,
                lastCommissionPayday,
                nextCommissionPayday,
                // Legacy fields for backward compatibility
                commissionMonth: isFirstPayPeriod ? (payMonth === 0 ? 11 : payMonth - 1) : null,
                commissionYear: isFirstPayPeriod ? (payMonth === 0 ? payYear - 1 : payYear) : null
            };
        }

        // Get paid orders between two dates (for commission calculation)
        // Uses paid_date field to determine when payment was received
        function getPaidOrdersBetweenDates(orders, startDate, endDate) {
            return orders.filter(order => {
                if (!isOrderPaid(order)) return false;
                if (!order.paid_date) return false;
                const paidDate = new Date(order.paid_date);
                // Include orders with paid_date > startDate and <= endDate
                return paidDate > startDate && paidDate <= endDate;
            });
        }

        // Format month name
        function getMonthName(month) {
            const months = ['January', 'February', 'March', 'April', 'May', 'June',
                           'July', 'August', 'September', 'October', 'November', 'December'];
            return months[month];
        }

        // Load and display sales dashboard
        async function loadSalesDashboard() {
            try {
                await ensureLeafLinkData();
                // Load Pipeline, Inventory, Needs data for inline display
                loadSalesPipeline();
                await loadLeafLinkInventory();
                await loadNeedsData();

                // Populate sales rep dropdown (use name as value for multi-business dedup)
                const salesReps = extractSalesReps(allLeafLinkOrders);
                const dropdown = document.getElementById('salesRepFilter');
                if (dropdown) {
                    dropdown.innerHTML = '<option value="all">All Sales Reps</option>';
                    salesReps.forEach(rep => {
                        const option = document.createElement('option');
                        // Store IDs as JSON for filtering across businesses
                        option.value = JSON.stringify({ name: rep.name, ids: rep.ids });
                        option.textContent = rep.name;
                        dropdown.appendChild(option);
                    });
                }

                updateSalesDashboard();
            } catch (error) {
                console.error('Error loading sales dashboard:', error);
            }
        }

        // Update dashboard with current filter
        function updateSalesDashboard() {
            const rawFilter = document.getElementById('salesRepFilter')?.value || 'all';
            // Parse JSON filter value (contains name and ids array for multi-business)
            let salesRepFilter = rawFilter;
            if (rawFilter !== 'all') {
                try {
                    salesRepFilter = JSON.parse(rawFilter);
                } catch (e) {
                    // Fallback to raw value if not JSON
                }
            }
            const filteredOrders = filterOrdersBySalesRep(allLeafLinkOrders, salesRepFilter);

            // Calculate stats
            const now = new Date();
            const currentMonth = now.getMonth();
            const currentYear = now.getFullYear();
            const prevMonth = currentMonth === 0 ? 11 : currentMonth - 1;
            const prevYear = currentMonth === 0 ? currentYear - 1 : currentYear;

            // Current month orders (by created_on)
            const currentMonthOrders = filteredOrders.filter(o => {
                const d = new Date(o.created_on);
                return d.getMonth() === currentMonth && d.getFullYear() === currentYear;
            });

            // All-time stats
            const totalOrders = filteredOrders.length;
            // Last 30 days revenue
            const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
            const last30DaysOrders = filteredOrders.filter(o => new Date(o.created_on) >= thirtyDaysAgo);
            const totalRevenue = last30DaysOrders.reduce((sum, o) => sum + (o.total?.amount || 0), 0);
            const paidOrders = filteredOrders.filter(o => isOrderPaid(o));
            const unpaidOrders = filteredOrders.filter(o => !isOrderPaid(o));

            // Count unique new customers this month
            const currentMonthCustomers = new Set();
            currentMonthOrders.forEach(o => {
                if (o.customer?.id) currentMonthCustomers.add(o.customer.id);
            });

            // Check which are truly new (first order ever)
            let newCustomersCount = 0;
            currentMonthCustomers.forEach(customerId => {
                const firstOrderInfo = customerFirstOrderDates[customerId];
                if (firstOrderInfo) {
                    const firstOrderDate = new Date(firstOrderInfo.date);
                    if (firstOrderDate.getMonth() === currentMonth && firstOrderDate.getFullYear() === currentYear) {
                        newCustomersCount++;
                    }
                }
            });

            // Update stats display
            document.getElementById('salesStatTotalOrders').textContent = totalOrders.toLocaleString();
            document.getElementById('salesStatTotalRevenue').textContent = '$' + totalRevenue.toLocaleString(undefined, {minimumFractionDigits: 0, maximumFractionDigits: 0});
            document.getElementById('salesStatPaidOrders').textContent = paidOrders.length.toLocaleString();
            document.getElementById('salesStatUnpaidOrders').textContent = unpaidOrders.length.toLocaleString();
            document.getElementById('salesStatNewCustomers').textContent = newCustomersCount.toLocaleString();

            // Commission calculations - based on PAYMENT DATE, not order date
            const currentMonthPaid = getPaidOrdersForMonth(filteredOrders, currentYear, currentMonth);
            const prevMonthPaid = getPaidOrdersForMonth(filteredOrders, prevYear, prevMonth);
            const currentMonthCommission = currentMonthPaid.reduce((sum, o) => sum + (o.total?.amount || 0), 0) * COMMISSION_RATE;
            const prevMonthCommission = prevMonthPaid.reduce((sum, o) => sum + (o.total?.amount || 0), 0) * COMMISSION_RATE;

            // Update commission display
            document.getElementById('commissionCurrentMonth').textContent = '$' + currentMonthCommission.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2});
            document.getElementById('commissionCurrentMonthLabel').textContent = `${getMonthName(currentMonth)} ${currentYear}`;

            document.getElementById('commissionPrevMonth').textContent = '$' + prevMonthCommission.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2});
            document.getElementById('commissionPrevMonthLabel').textContent = `${getMonthName(prevMonth)} ${prevYear}`;

            // Build monthly breakdown
            renderMonthlyBreakdown(filteredOrders);
        }

        // Store for commission details modal data
        let currentCommissionOrders = [];

        // Show commission details modal
        function showCommissionDetails(period) {
            const rawFilter = document.getElementById('salesRepFilter')?.value || 'all';
            let salesRepFilter = rawFilter;
            if (rawFilter !== 'all') {
                try {
                    salesRepFilter = JSON.parse(rawFilter);
                } catch (e) {}
            }
            const filteredOrders = filterOrdersBySalesRep(allLeafLinkOrders, salesRepFilter);

            const now = new Date();
            const currentMonth = now.getMonth();
            const currentYear = now.getFullYear();
            const prevMonth = currentMonth === 0 ? 11 : currentMonth - 1;
            const prevYear = currentMonth === 0 ? currentYear - 1 : currentYear;

            let orders = [];
            let title = '';
            let subtitle = '';
            let startDate, endDate;

            if (period === 'currentMonth') {
                orders = getPaidOrdersForMonth(filteredOrders, currentYear, currentMonth);
                title = `Commission Details - ${getMonthName(currentMonth)} ${currentYear}`;
                startDate = new Date(currentYear, currentMonth, 1);
                endDate = new Date(currentYear, currentMonth + 1, 0);
                subtitle = `Payments from ${formatDateShort(startDate)} to ${formatDateShort(endDate)}`;
            } else if (period === 'prevMonth') {
                orders = getPaidOrdersForMonth(filteredOrders, prevYear, prevMonth);
                title = `Commission Details - ${getMonthName(prevMonth)} ${prevYear}`;
                startDate = new Date(prevYear, prevMonth, 1);
                endDate = new Date(prevYear, prevMonth + 1, 0);
                subtitle = `Payments from ${formatDateShort(startDate)} to ${formatDateShort(endDate)}`;
            }

            // Store for clipboard copy
            currentCommissionOrders = orders;

            // Update modal content
            document.getElementById('commissionModalTitle').textContent = title;
            document.getElementById('commissionModalSubtitle').textContent = subtitle;

            // Build table rows
            const tbody = document.getElementById('commissionDetailsBody');
            let totalAmount = 0;
            let totalCommission = 0;

            if (orders.length === 0) {
                tbody.innerHTML = `<tr><td colspan="6" style="padding: 30px; text-align: center; color: var(--text-secondary);">No paid orders found for this period</td></tr>`;
            } else {
                // Sort orders by paid_date
                const sortedOrders = [...orders].sort((a, b) => {
                    const dateA = new Date(a.paid_date || a.created_on);
                    const dateB = new Date(b.paid_date || b.created_on);
                    return dateA - dateB;
                });

                tbody.innerHTML = sortedOrders.map((order, index) => {
                    const invoiceNumber = order.short_id || order.number || 'N/A';
                    const store = order.customer?.display_name || order.customer?.name || 'Unknown';
                    const amount = order.total?.amount || 0;
                    const payAmount = amount * COMMISSION_RATE;
                    const paidDate = order.paid_date ? formatDateShort(new Date(order.paid_date)) : 'N/A';

                    totalAmount += amount;
                    totalCommission += payAmount;

                    const rowBg = index % 2 === 0 ? 'transparent' : 'rgba(255,255,255,0.02)';

                    return `<tr style="background: ${rowBg}; border-bottom: 1px solid var(--border);">
                        <td style="padding: 12px; color: var(--accent-blue); font-family: 'Space Mono', monospace;">${invoiceNumber}</td>
                        <td style="padding: 12px; color: var(--text-primary);">${escapeHtml(store)}</td>
                        <td style="padding: 12px; text-align: right; color: var(--text-primary);">$${amount.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})}</td>
                        <td style="padding: 12px; text-align: right; color: var(--accent-green); font-weight: 600;">$${payAmount.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})}</td>
                        <td style="padding: 12px; color: var(--text-secondary);">${paidDate}</td>
                    </tr>`;
                }).join('');
            }

            // Update totals
            document.getElementById('commissionTotalOrders').textContent = orders.length.toLocaleString();
            document.getElementById('commissionTotalAmount').textContent = '$' + totalAmount.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2});
            document.getElementById('commissionTotalPay').textContent = '$' + totalCommission.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2});

            // Show modal
            document.getElementById('commissionDetailsModal').style.display = 'block';
            document.body.style.overflow = 'hidden';
        }

        // Close commission details modal
        function closeCommissionDetailsModal() {
            document.getElementById('commissionDetailsModal').style.display = 'none';
            document.body.style.overflow = '';
        }

        // Format date in short format (e.g., "Dec 15, 2024")
        function formatDateShort(date) {
            return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
        }

        // Escape HTML to prevent XSS
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Copy commission details to clipboard
        function copyCommissionToClipboard() {
            if (currentCommissionOrders.length === 0) {
                alert('No orders to copy');
                return;
            }

            // Sort orders by paid_date
            const sortedOrders = [...currentCommissionOrders].sort((a, b) => {
                const dateA = new Date(a.paid_date || a.created_on);
                const dateB = new Date(b.paid_date || b.created_on);
                return dateA - dateB;
            });

            // Build tab-separated data (for pasting into spreadsheet)
            let clipboardData = 'Invoice Number\tStore\tAmount\tPay Amount\tPaid Date\n';
            let totalAmount = 0;
            let totalCommission = 0;

            sortedOrders.forEach(order => {
                const invoiceNumber = order.short_id || order.number || 'N/A';
                const store = order.customer?.display_name || order.customer?.name || 'Unknown';
                const amount = order.total?.amount || 0;
                const payAmount = amount * COMMISSION_RATE;
                const paidDate = order.paid_date ? formatDateShort(new Date(order.paid_date)) : 'N/A';

                totalAmount += amount;
                totalCommission += payAmount;

                clipboardData += `${invoiceNumber}\t${store}\t$${amount.toFixed(2)}\t$${payAmount.toFixed(2)}\t${paidDate}\n`;
            });

            // Add totals row
            clipboardData += `\nTOTAL\t${sortedOrders.length} orders\t$${totalAmount.toFixed(2)}\t$${totalCommission.toFixed(2)}\t\n`;

            navigator.clipboard.writeText(clipboardData).then(() => {
                const statusEl = document.getElementById('commissionCopyStatus');
                statusEl.style.display = 'inline';
                setTimeout(() => {
                    statusEl.style.display = 'none';
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy:', err);
                alert('Failed to copy to clipboard');
            });
        }

        // Close modal on backdrop click
        document.addEventListener('click', function(e) {
            const modal = document.getElementById('commissionDetailsModal');
            if (e.target === modal) {
                closeCommissionDetailsModal();
            }
        });

        // Close modal on Escape key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                const commissionModal = document.getElementById('commissionDetailsModal');
                if (commissionModal && commissionModal.style.display === 'block') {
                    closeCommissionDetailsModal();
                }
                const royaltyModal = document.getElementById('royaltyDetailsModal');
                if (royaltyModal && royaltyModal.style.display === 'block') {
                    closeRoyaltyDetailsModal();
                }
            }
        });

        // ==================== BUBBLEMAN ROYALTY CALCULATOR ====================

        // Store current royalty items for clipboard copy
        let currentRoyaltyItems = [];

        // Filter orders to Bubbleman business only
        function getBubblemanOrders(orders) {
            return orders.filter(order => order._business?.slug === BUBBLEMAN_SLUG);
        }

        // Case-insensitive product name matching
        function productMatchesPattern(productName, pattern, matchType = 'contains') {
            const name = (productName || '').toLowerCase();
            const pat = pattern.toLowerCase();
            if (matchType === 'contains') {
                return name.includes(pat);
            }
            return name === pat;
        }

        // Calculate line item total (qty  unit price)
        function getLineItemTotal(item) {
            const qty = parseFloat(item.quantity) || 0;
            const unitMultiplier = parseFloat(item.unit_multiplier) || 1;
            // LeafLink stores case prices - divide by unit_multiplier to get unit price
            const casePrice = parseFloat(item.ordered_unit_price?.amount) ||
                              parseFloat(item.frozen_data?.product?.price) ||
                              parseFloat(item.sale_price?.amount) ||
                              parseFloat(item.price) || 0;
            const unitPrice = casePrice / unitMultiplier;
            return qty * unitPrice;
        }

        // Check if product name indicates 4g size
        function isProduct4g(productName) {
            const name = (productName || '').toLowerCase();
            return name.includes('4g') || name.includes('4 gram') || name.includes('4-gram');
        }

        // Calculate 1-11 LLC royalty (92% on qualifying products)
        function calculateRoyalty1_11LLC(orders) {
            const items = [];
            const paidOrders = orders.filter(o => isOrderPaid(o) && shouldCountOrder(o));

            paidOrders.forEach(order => {
                (order.line_items || []).forEach(item => {
                    const productName = item.frozen_data?.product?.name || item.product?.name || '';

                    // Check if product matches any 1-11 LLC pattern
                    const matches = ROYALTY_1_11_LLC.products.some(p =>
                        productMatchesPattern(productName, p.pattern, p.match)
                    );

                    if (matches) {
                        const qty = parseFloat(item.quantity) || 0;
                        const lineTotal = getLineItemTotal(item);
                        const royalty = lineTotal * ROYALTY_1_11_LLC.rate;

                        items.push({
                            invoiceNumber: order.short_id || order.number || 'N/A',
                            customer: order.customer?.display_name || order.customer?.name || 'Unknown',
                            product: productName,
                            qty: qty,
                            amount: lineTotal,
                            royalty: royalty,
                            paidDate: order.paid_date || order.created_on
                        });
                    }
                });
            });

            return items;
        }

        // Calculate Ted royalty (per-unit on qualifying products)
        function calculateRoyaltyTed(orders) {
            const items = [];
            const paidOrders = orders.filter(o => isOrderPaid(o) && shouldCountOrder(o));

            paidOrders.forEach(order => {
                (order.line_items || []).forEach(item => {
                    const productName = item.frozen_data?.product?.name || item.product?.name || '';

                    // Check if product matches any Ted pattern
                    ROYALTY_TED.products.forEach(p => {
                        if (productMatchesPattern(productName, p.pattern, p.match)) {
                            // Check 4g requirement (Brick Hash must be 4g)
                            if (p.requires4g && !isProduct4g(productName)) {
                                return; // Skip non-4g products
                            }

                            const qty = parseFloat(item.quantity) || 0;
                            const lineTotal = getLineItemTotal(item);
                            const royalty = qty * p.unitRate;

                            items.push({
                                invoiceNumber: order.short_id || order.number || 'N/A',
                                customer: order.customer?.display_name || order.customer?.name || 'Unknown',
                                product: productName,
                                qty: qty,
                                amount: lineTotal,
                                royalty: royalty,
                                paidDate: order.paid_date || order.created_on,
                                unitRate: p.unitRate
                            });
                        }
                    });
                });
            });

            return items;
        }

        // Filter royalty items by paid_date month
        function getRoyaltyItemsForMonth(items, year, month) {
            return items.filter(item => {
                if (!item.paidDate) return false;
                const paidDate = new Date(item.paidDate);
                return paidDate.getFullYear() === year && paidDate.getMonth() === month;
            });
        }

        // Show royalty details modal
        function showRoyaltyDetails(agreementName, period) {
            const now = new Date();
            const currentMonth = now.getMonth();
            const currentYear = now.getFullYear();
            const prevMonth = currentMonth === 0 ? 11 : currentMonth - 1;
            const prevYear = currentMonth === 0 ? currentYear - 1 : currentYear;

            let targetYear, targetMonth, periodLabel;
            if (period === 'currentMonth') {
                targetYear = currentYear;
                targetMonth = currentMonth;
                periodLabel = `${getMonthName(currentMonth)} ${currentYear}`;
            } else {
                targetYear = prevYear;
                targetMonth = prevMonth;
                periodLabel = `${getMonthName(prevMonth)} ${prevYear}`;
            }

            // Get Bubbleman orders
            const bubblemanOrders = getBubblemanOrders(allLeafLinkOrders);

            // Calculate items based on agreement
            let allItems;
            if (agreementName === '1-11 LLC') {
                allItems = calculateRoyalty1_11LLC(bubblemanOrders);
            } else {
                allItems = calculateRoyaltyTed(bubblemanOrders);
            }

            // Filter by month
            const items = getRoyaltyItemsForMonth(allItems, targetYear, targetMonth);
            currentRoyaltyItems = items;

            // Update modal header
            document.getElementById('royaltyModalTitle').textContent = `${agreementName} Royalty Details`;
            document.getElementById('royaltyModalSubtitle').textContent = periodLabel;

            // Populate table
            const tbody = document.getElementById('royaltyDetailsBody');
            let totalQty = 0;
            let totalAmount = 0;
            let totalRoyalty = 0;

            if (items.length === 0) {
                tbody.innerHTML = `<tr><td colspan="7" style="padding: 30px; text-align: center; color: var(--text-secondary);">No royalty items found for this period</td></tr>`;
            } else {
                // Sort by paid_date
                const sortedItems = [...items].sort((a, b) => {
                    const dateA = new Date(a.paidDate);
                    const dateB = new Date(b.paidDate);
                    return dateA - dateB;
                });

                tbody.innerHTML = sortedItems.map((item, index) => {
                    totalQty += item.qty;
                    totalAmount += item.amount;
                    totalRoyalty += item.royalty;

                    const rowBg = index % 2 === 0 ? 'transparent' : 'rgba(255,255,255,0.02)';
                    const paidDate = item.paidDate ? formatDateShort(new Date(item.paidDate)) : 'N/A';

                    return `<tr style="background: ${rowBg}; border-bottom: 1px solid var(--border);">
                        <td style="padding: 12px; color: var(--accent-blue); font-family: 'Space Mono', monospace;">${item.invoiceNumber}</td>
                        <td style="padding: 12px; color: var(--text-primary);">${escapeHtml(item.customer)}</td>
                        <td style="padding: 12px; color: var(--text-primary); max-width: 200px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="${escapeHtml(item.product)}">${escapeHtml(item.product)}</td>
                        <td style="padding: 12px; text-align: right; color: var(--text-primary);">${item.qty}</td>
                        <td style="padding: 12px; text-align: right; color: var(--text-primary);">$${item.amount.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})}</td>
                        <td style="padding: 12px; text-align: right; color: var(--accent-orange); font-weight: 600;">$${item.royalty.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})}</td>
                        <td style="padding: 12px; color: var(--text-secondary);">${paidDate}</td>
                    </tr>`;
                }).join('');
            }

            // Update totals
            document.getElementById('royaltyTotalItems').textContent = items.length.toLocaleString();
            document.getElementById('royaltyTotalQty').textContent = totalQty.toLocaleString();
            document.getElementById('royaltyTotalAmount').textContent = '$' + totalAmount.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2});
            document.getElementById('royaltyTotalPay').textContent = '$' + totalRoyalty.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2});

            // Show modal
            document.getElementById('royaltyDetailsModal').style.display = 'block';
            document.body.style.overflow = 'hidden';
        }

        // Close royalty details modal
        function closeRoyaltyDetailsModal() {
            document.getElementById('royaltyDetailsModal').style.display = 'none';
            document.body.style.overflow = '';
        }

        // Copy royalty details to clipboard
        function copyRoyaltyToClipboard() {
            if (currentRoyaltyItems.length === 0) {
                alert('No royalty items to copy');
                return;
            }

            // Sort items by paid_date
            const sortedItems = [...currentRoyaltyItems].sort((a, b) => {
                const dateA = new Date(a.paidDate);
                const dateB = new Date(b.paidDate);
                return dateA - dateB;
            });

            // Build tab-separated data (for pasting into spreadsheet)
            let clipboardData = 'Invoice #\tCustomer\tProduct\tQty\tAmount\tRoyalty\tPaid Date\n';
            let totalQty = 0;
            let totalAmount = 0;
            let totalRoyalty = 0;

            sortedItems.forEach(item => {
                const paidDate = item.paidDate ? formatDateShort(new Date(item.paidDate)) : 'N/A';
                totalQty += item.qty;
                totalAmount += item.amount;
                totalRoyalty += item.royalty;

                clipboardData += `${item.invoiceNumber}\t${item.customer}\t${item.product}\t${item.qty}\t$${item.amount.toFixed(2)}\t$${item.royalty.toFixed(2)}\t${paidDate}\n`;
            });

            // Add totals row
            clipboardData += `\nTOTAL\t${sortedItems.length} items\t\t${totalQty}\t$${totalAmount.toFixed(2)}\t$${totalRoyalty.toFixed(2)}\t\n`;

            navigator.clipboard.writeText(clipboardData).then(() => {
                const statusEl = document.getElementById('royaltyCopyStatus');
                statusEl.style.display = 'inline';
                setTimeout(() => {
                    statusEl.style.display = 'none';
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy:', err);
                alert('Failed to copy to clipboard');
            });
        }

        // Close royalty modal on backdrop click
        document.addEventListener('click', function(e) {
            const modal = document.getElementById('royaltyDetailsModal');
            if (e.target === modal) {
                closeRoyaltyDetailsModal();
            }
        });

        // ===== Machine Run Log Functions =====
        let allMachineRuns = [];

        async function openMachineLogModal() {
            // Show modal immediately with loading state
            document.getElementById('machineLogModal').style.display = 'block';
            document.body.style.overflow = 'hidden';
            document.getElementById('machineLogBody').innerHTML = `
                <tr>
                    <td colspan="7" style="padding: 40px; text-align: center; color: var(--text-secondary);">
                        Loading machine runs...
                    </td>
                </tr>
            `;

            // Reset filters
            document.getElementById('machineLogFilterMachine').value = 'all';
            document.getElementById('machineLogFilterDays').value = '7';
            document.getElementById('machineLogSearch').value = '';

            // Load runs from database (or localStorage in demo mode)
            if (DEMO_MODE) {
                allMachineRuns = JSON.parse(localStorage.getItem('wm_extraction_runs') || '[]');
                allMachineRuns.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                filterMachineLog();
            } else {
                const { data, error } = await supabaseClient
                    .from('wm_machine_runs')
                    .select('*')
                    .order('timestamp', { ascending: false });

                if (error) {
                    console.error('Error loading machine runs:', error);
                    // Fall back to localStorage
                    allMachineRuns = JSON.parse(localStorage.getItem('wm_extraction_runs') || '[]');
                } else {
                    // Map database columns to expected format
                    allMachineRuns = (data || []).map(r => ({
                        timestamp: r.timestamp,
                        user: r.user_name,
                        machine: r.machine,
                        column: r.column_letter,
                        trimWeight: r.trim_weight,
                        socks: r.socks,
                        batches: r.batches || [],
                        strain: r.strain,
                        filterState: r.filter_state,
                        backfilled: r.backfilled
                    }));
                }
                filterMachineLog();
            }
        }

        function closeMachineLogModal() {
            document.getElementById('machineLogModal').style.display = 'none';
            document.body.style.overflow = '';
        }

        function filterMachineLog() {
            const machineFilter = document.getElementById('machineLogFilterMachine').value;
            const daysFilter = document.getElementById('machineLogFilterDays').value;
            const searchFilter = document.getElementById('machineLogSearch').value.toLowerCase().trim();

            let filtered = [...allMachineRuns];

            // Filter by machine
            if (machineFilter !== 'all') {
                filtered = filtered.filter(run => run.machine === machineFilter);
            }

            // Filter by days
            if (daysFilter !== 'all') {
                const daysAgo = new Date();
                daysAgo.setDate(daysAgo.getDate() - parseInt(daysFilter));
                filtered = filtered.filter(run => new Date(run.timestamp) >= daysAgo);
            }

            // Filter by search (strain or batch)
            if (searchFilter) {
                filtered = filtered.filter(run => {
                    const strainMatch = (run.strain || '').toLowerCase().includes(searchFilter);
                    const batchMatch = (run.batches || []).some(b => b.toLowerCase().includes(searchFilter));
                    return strainMatch || batchMatch;
                });
            }

            populateMachineLogTable(filtered);
        }

        function populateMachineLogTable(runs) {
            const tbody = document.getElementById('machineLogBody');
            tbody.innerHTML = '';

            let totalSocks = 0;
            const uniqueStrains = new Set();

            runs.forEach(run => {
                const date = new Date(run.timestamp);
                const dateStr = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: '2-digit' });
                const timeStr = date.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });

                const machineDisplay = run.machine === 'left' ? 'Machine 1 (Left)' :
                                       run.machine === 'right' ? 'Machine 2 (Right)' : run.machine;

                const batchDisplay = (run.batches || []).join(', ');
                const strainDisplay = run.strain || 'Unknown';

                // Build filter state display
                let filterDisplay = 'N/A';
                if (run.filterState) {
                    const fs = run.filterState;
                    filterDisplay = `${fs.filter_runs}r (${fs.silica_top}/${fs.clay}/${fs.silica_bottom})`;
                }

                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td style="padding: 10px; border-bottom: 1px solid var(--border); white-space: nowrap;">
                        <div style="font-weight: 500;">${dateStr}</div>
                        <div style="font-size: 0.8rem; color: var(--text-secondary);">${timeStr}</div>
                    </td>
                    <td style="padding: 10px; border-bottom: 1px solid var(--border);">${machineDisplay}</td>
                    <td style="padding: 10px; border-bottom: 1px solid var(--border); font-family: monospace; font-weight: 600;">${batchDisplay}</td>
                    <td style="padding: 10px; border-bottom: 1px solid var(--border);">${strainDisplay}</td>
                    <td style="padding: 10px; border-bottom: 1px solid var(--border); text-align: center; font-weight: 600;">${run.socks || 0}</td>
                    <td style="padding: 10px; border-bottom: 1px solid var(--border);">${run.user || 'Unknown'}</td>
                    <td style="padding: 10px; border-bottom: 1px solid var(--border); font-size: 0.85rem; color: var(--text-secondary);">${filterDisplay}</td>
                `;
                tbody.appendChild(tr);

                totalSocks += run.socks || 0;
                if (run.strain) {
                    run.strain.split(', ').forEach(s => uniqueStrains.add(s.trim()));
                }
            });

            // Update summary
            document.getElementById('machineLogTotalRuns').textContent = runs.length;
            document.getElementById('machineLogTotalSocks').textContent = totalSocks;
            document.getElementById('machineLogUniqueStrains').textContent = uniqueStrains.size;

            // Show empty state if no runs
            if (runs.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="7" style="padding: 40px; text-align: center; color: var(--text-secondary);">
                            No machine runs found matching the current filters.
                        </td>
                    </tr>
                `;
            }
        }

        // Close machine log modal on backdrop click
        document.addEventListener('click', function(e) {
            const modal = document.getElementById('machineLogModal');
            if (e.target === modal) {
                closeMachineLogModal();
            }
        });

        // Backfill machine run log from batch timeline data
        // Run this from console: backfillMachineLogFromTimelines()
        async function backfillMachineLogFromTimelines() {
            console.log('Starting machine run log backfill from batch timelines...');

            // Get existing runs from database to avoid duplicates
            let existingKeys = new Set();
            if (!DEMO_MODE) {
                const { data: existingData } = await supabaseClient
                    .from('wm_machine_runs')
                    .select('timestamp, batches');
                if (existingData) {
                    existingData.forEach(r => {
                        existingKeys.add(`${r.timestamp}-${(r.batches || []).join(',')}`);
                    });
                }
            }

            let addedCount = 0;
            let skippedCount = 0;
            const runsToInsert = [];

            // Process all batches with timelines
            for (const batch of batches) {
                let timeline = batch.timeline || [];
                if (typeof timeline === 'string') {
                    try { timeline = JSON.parse(timeline); } catch(e) { continue; }
                }

                for (const entry of timeline) {
                    // Look for extraction completed entries
                    if (entry.stage === 'extraction' && entry.action && entry.action.includes('Extraction completed')) {
                        const action = entry.action;

                        // Parse machine from action string
                        let machine = null;
                        if (action.includes('Machine 1') || action.includes('Left')) {
                            machine = 'left';
                        } else if (action.includes('Machine 2') || action.includes('Right')) {
                            machine = 'right';
                        }

                        // Parse runs from action string (e.g., "2 runs")
                        const runsMatch = action.match(/(\d+)\s*runs?/i);
                        const runs = runsMatch ? parseInt(runsMatch[1]) : 0;

                        // Parse product type
                        let productType = 'unknown';
                        if (action.includes('Shatter')) productType = 'shatter';
                        else if (action.includes('Sugar Wax')) productType = 'sugar_wax';
                        else if (action.includes('Wax')) productType = 'wax';
                        else if (action.includes('Live Resin')) productType = 'live_resin';

                        // Get batch IDs - check for combined batches
                        let batchIds = [batch.id];
                        const sourcesMatch = action.match(/Sources:\s*([^|]+)/);
                        if (sourcesMatch) {
                            const sourcesStr = sourcesMatch[1];
                            const sourceMatches = sourcesStr.match(/([A-Z0-9-]+)\(\d+socks?\)/gi);
                            if (sourceMatches) {
                                batchIds = sourceMatches.map(s => s.replace(/\(\d+socks?\)/i, ''));
                            }
                        }

                        // Parse filter state from action string
                        let filterState = null;
                        const filterMatch = action.match(/Filter:\s*(\d+)c?\s*silica\s*\/\s*(\d+)c?\s*clay\s*\/\s*(\d+)c?\s*silica\s*\((\d+)\s*runs?\)/i);
                        if (filterMatch) {
                            filterState = {
                                silica_top: parseFloat(filterMatch[1]),
                                clay: parseFloat(filterMatch[2]),
                                silica_bottom: parseFloat(filterMatch[3]),
                                filter_runs: parseInt(filterMatch[4])
                            };
                        }

                        // Create unique key for deduplication
                        const key = `${entry.timestamp}-${batchIds.join(',')}`;
                        if (existingKeys.has(key)) {
                            skippedCount++;
                            continue;
                        }

                        // Get socks from batch or source contributions
                        let socks = batch.socks_total || 0;
                        if (batch.source_contributions) {
                            let contributions = batch.source_contributions;
                            if (typeof contributions === 'string') {
                                try { contributions = JSON.parse(contributions); } catch(e) { contributions = []; }
                            }
                            socks = contributions.reduce((sum, c) => sum + (c.socks || 0), 0);
                        }

                        // Create run entry for database
                        runsToInsert.push({
                            timestamp: entry.timestamp,
                            user_name: entry.user || 'Unknown',
                            machine: machine,
                            column_letter: null,
                            trim_weight: parseFloat(batch.combined_trim_weight) || parseFloat(batch.trim_weight) || 0,
                            socks: socks,
                            batches: batchIds,
                            strain: batch.strain || 'Unknown',
                            filter_state: filterState,
                            product_type: productType,
                            backfilled: true
                        });

                        existingKeys.add(key);
                        addedCount++;

                        console.log(`Queued: ${batch.id} - ${batch.strain} - ${entry.timestamp}`);
                    }
                }
            }

            // Insert all runs in batches of 100
            if (runsToInsert.length > 0 && !DEMO_MODE) {
                console.log(`Inserting ${runsToInsert.length} runs to database...`);
                for (let i = 0; i < runsToInsert.length; i += 100) {
                    const batch = runsToInsert.slice(i, i + 100);
                    const { error } = await supabaseClient
                        .from('wm_machine_runs')
                        .insert(batch);
                    if (error) {
                        console.error('Error inserting batch:', error);
                    } else {
                        console.log(`Inserted ${Math.min(i + 100, runsToInsert.length)} / ${runsToInsert.length}`);
                    }
                }
            }

            console.log(`Backfill complete! Added ${addedCount} entries, skipped ${skippedCount} duplicates.`);

            return { added: addedCount, skipped: skippedCount };
        }

        // Update royalty calculator display
        function updateRoyaltyCalculator() {
            // Check if Bubbleman business exists
            const bubblemanExists = businessesList.some(b => b.slug === BUBBLEMAN_SLUG);
            const royaltySection = document.getElementById('royaltyCalculatorSection');

            if (!royaltySection) return;

            if (!bubblemanExists) {
                royaltySection.style.display = 'none';
                return;
            }

            royaltySection.style.display = 'block';

            const now = new Date();
            const currentMonth = now.getMonth();
            const currentYear = now.getFullYear();
            const prevMonth = currentMonth === 0 ? 11 : currentMonth - 1;
            const prevYear = currentMonth === 0 ? currentYear - 1 : currentYear;

            // Get Bubbleman orders
            const bubblemanOrders = getBubblemanOrders(allLeafLinkOrders);

            // Calculate 1-11 LLC royalties
            const items1_11 = calculateRoyalty1_11LLC(bubblemanOrders);
            const currentMonth1_11 = getRoyaltyItemsForMonth(items1_11, currentYear, currentMonth);
            const prevMonth1_11 = getRoyaltyItemsForMonth(items1_11, prevYear, prevMonth);
            const current1_11Total = currentMonth1_11.reduce((sum, item) => sum + item.royalty, 0);
            const prev1_11Total = prevMonth1_11.reduce((sum, item) => sum + item.royalty, 0);

            // Calculate Ted royalties
            const itemsTed = calculateRoyaltyTed(bubblemanOrders);
            const currentMonthTed = getRoyaltyItemsForMonth(itemsTed, currentYear, currentMonth);
            const prevMonthTed = getRoyaltyItemsForMonth(itemsTed, prevYear, prevMonth);
            const currentTedTotal = currentMonthTed.reduce((sum, item) => sum + item.royalty, 0);
            const prevTedTotal = prevMonthTed.reduce((sum, item) => sum + item.royalty, 0);

            // Update UI elements
            const updateEl = (id, val) => {
                const el = document.getElementById(id);
                if (el) el.textContent = val;
            };

            // 1-11 LLC
            updateEl('royalty1_11CurrentMonth', '$' + current1_11Total.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2}));
            updateEl('royalty1_11CurrentMonthLabel', `${getMonthName(currentMonth)} ${currentYear}`);
            updateEl('royalty1_11PrevMonth', '$' + prev1_11Total.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2}));
            updateEl('royalty1_11PrevMonthLabel', `${getMonthName(prevMonth)} ${prevYear}`);

            // Ted
            updateEl('royaltyTedCurrentMonth', '$' + currentTedTotal.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2}));
            updateEl('royaltyTedCurrentMonthLabel', `${getMonthName(currentMonth)} ${currentYear}`);
            updateEl('royaltyTedPrevMonth', '$' + prevTedTotal.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2}));
            updateEl('royaltyTedPrevMonthLabel', `${getMonthName(prevMonth)} ${prevYear}`);
        }

        // ==================== END ROYALTY CALCULATOR ====================

        // Render monthly sales breakdown
        function renderMonthlyBreakdown(orders) {
            const container = document.getElementById('salesMonthlyBreakdown');
            if (!container) return;

            // Group orders by month
            const monthlyData = {};
            orders.forEach(order => {
                const date = new Date(order.created_on);
                const key = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                if (!monthlyData[key]) {
                    monthlyData[key] = {
                        year: date.getFullYear(),
                        month: date.getMonth(),
                        orders: [],
                        paidOrders: [],
                        revenue: 0,
                        paidRevenue: 0
                    };
                }
                monthlyData[key].orders.push(order);
                monthlyData[key].revenue += order.total?.amount || 0;
                if (isOrderPaid(order)) {
                    monthlyData[key].paidOrders.push(order);
                    monthlyData[key].paidRevenue += order.total?.amount || 0;
                }
            });

            // Sort by date descending
            const sortedMonths = Object.keys(monthlyData).sort().reverse();

            if (sortedMonths.length === 0) {
                container.innerHTML = '<div style="text-align: center; padding: 30px; color: var(--text-secondary);">No sales data available</div>';
                return;
            }

            let html = '<table style="width: 100%; border-collapse: collapse;">';
            html += '<thead><tr style="border-bottom: 2px solid var(--border-color);">';
            html += '<th style="text-align: left; padding: 10px; color: var(--text-secondary);">Month</th>';
            html += '<th style="text-align: right; padding: 10px; color: var(--text-secondary);">Orders</th>';
            html += '<th style="text-align: right; padding: 10px; color: var(--text-secondary);">Revenue</th>';
            html += '<th style="text-align: right; padding: 10px; color: var(--text-secondary);">Paid</th>';
            html += '<th style="text-align: right; padding: 10px; color: var(--text-secondary);">Commission</th>';
            html += '</tr></thead><tbody>';

            sortedMonths.forEach(key => {
                const data = monthlyData[key];
                const commission = data.paidRevenue * COMMISSION_RATE;
                const monthName = getMonthName(data.month);

                html += `<tr style="border-bottom: 1px solid var(--border-color);">`;
                html += `<td style="padding: 12px 10px; font-weight: 600;">${monthName} ${data.year}</td>`;
                html += `<td style="padding: 12px 10px; text-align: right; color: var(--accent-blue);">${data.orders.length}</td>`;
                html += `<td style="padding: 12px 10px; text-align: right; color: #FFD700;">$${data.revenue.toLocaleString(undefined, {minimumFractionDigits: 0, maximumFractionDigits: 0})}</td>`;
                html += `<td style="padding: 12px 10px; text-align: right; color: var(--accent-green);">$${data.paidRevenue.toLocaleString(undefined, {minimumFractionDigits: 0, maximumFractionDigits: 0})}</td>`;
                html += `<td style="padding: 12px 10px; text-align: right; color: var(--accent-purple); font-weight: 600;">$${commission.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})}</td>`;
                html += '</tr>';
            });

            html += '</tbody></table>';
            container.innerHTML = html;
        }

        // ============================================
        // SALES TAB FUNCTIONS (Separate from FOH)
        // ============================================

        // Store ALL orders (including pending/submitted) for Sales tab
        let allOrdersIncludingPending = [];
        let currentInvoiceFilter = 'all';
        let currentInvoiceData = [];
        let salesDateRangeDays = 30; // Default to 30 days, or 'month' for current month

        // Set date range and update dashboard
        function setSalesDateRange(days) {
            salesDateRangeDays = days;

            // Update button styles
            document.querySelectorAll('.sales-range-btn').forEach(btn => {
                btn.style.background = 'var(--bg-tertiary)';
                btn.style.border = '1px solid var(--border-color)';
                btn.style.color = 'var(--text-primary)';
                btn.style.fontWeight = '500';
            });

            const activeBtn = document.getElementById(`salesRange${days}`);
            if (activeBtn) {
                activeBtn.style.background = '#FFD700';
                activeBtn.style.border = '1px solid #FFD700';
                activeBtn.style.color = '#000';
                activeBtn.style.fontWeight = '600';
            }

            // Update date range label
            const now = new Date();
            const label = document.getElementById('salesDateRangeLabel');
            if (label) {
                if (days === 'month') {
                    const monthStart = new Date(now.getFullYear(), now.getMonth(), 1);
                    const monthName = monthStart.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
                    label.textContent = monthName;
                } else {
                    const startDate = new Date(now.getTime() - days * 24 * 60 * 60 * 1000);
                    label.textContent = `${startDate.toLocaleDateString()} - ${now.toLocaleDateString()}`;
                }
            }

            // Refresh dashboard with new filter
            updateSalesDashboardSales();
        }

        // Helper to get date cutoff based on salesDateRangeDays
        function getSalesDateCutoff() {
            const now = new Date();
            if (salesDateRangeDays === 'month') {
                // First day of current month
                return new Date(now.getFullYear(), now.getMonth(), 1);
            } else {
                return new Date(now.getTime() - salesDateRangeDays * 24 * 60 * 60 * 1000);
            }
        }

        // Fetch ALL orders (no status filter) for a specific business
        async function fetchAllOrdersForBusiness(businessSlug) {
            try {
                const twoMonthsAgo = new Date();
                twoMonthsAgo.setMonth(twoMonthsAgo.getMonth() - 2);
                const dateFilter = twoMonthsAgo.toISOString().split('T')[0];

                console.log(`Fetching ALL LeafLink orders for: ${businessSlug}`);
                let orders = [];
                // No status filter - gets Submitted, Accepted, Shipped, Complete
                let nextUrl = `${window.location.origin}/api/leaflink?slug=${businessSlug}&endpoint=orders-received&created_on__gte=${dateFilter}&page_size=100`;

                while (nextUrl && orders.length < 500) {
                    const response = await fetch(nextUrl);
                    if (!response.ok) throw new Error(`API request failed for ${businessSlug}`);
                    const data = await response.json();
                    orders = orders.concat(data.results);
                    nextUrl = data.next;
                }

                console.log(`Fetched ${orders.length} total orders from ${businessSlug}`);
                return orders;
            } catch (error) {
                console.error(`Error fetching all orders for ${businessSlug}:`, error);
                return [];
            }
        }

        // Fetch ALL LeafLink orders (no status filter) for the Sales tab
        async function fetchAllLeafLinkOrdersIncludingPending() {
            if (isDemoMode()) {
                return generateDemoLeafLinkOrders();
            }

            // If viewing all businesses, fetch from each in parallel and combine
            if (currentBusinessId === 'all' && businessesList.length > 0) {
                const activeBusinesses = businessesList.filter(b => b.is_active);
                const orderPromises = activeBusinesses.map(async biz => {
                    const orders = await fetchAllOrdersForBusiness(biz.slug);
                    // Tag each order with business info for display
                    orders.forEach(o => o._business = { id: biz.id, slug: biz.slug, name: biz.display_name });
                    return orders;
                });
                const results = await Promise.all(orderPromises);
                const combinedOrders = results.flat();
                console.log(`Combined ${combinedOrders.length} total orders from all businesses`);
                allOrdersIncludingPending = combinedOrders;
                return combinedOrders;
            }

            // Single business fetch
            const businessSlug = businessesList.find(b => b.id === currentBusinessId)?.slug || 'white-mousse';
            const orders = await fetchAllOrdersForBusiness(businessSlug);
            allOrdersIncludingPending = orders;
            return orders;
        }

        // Load Sales Dashboard for the dedicated Sales tab
        async function loadSalesDashboardSales() {
            try {
                // Fetch both shipped orders and ALL orders
                await ensureLeafLinkData();
                await fetchAllLeafLinkOrdersIncludingPending();

                // Populate sales rep dropdown for Sales tab
                const salesReps = extractSalesReps(allLeafLinkOrders);
                const dropdown = document.getElementById('salesRepFilterSales');
                if (dropdown) {
                    dropdown.innerHTML = '<option value="all">All Sales Reps</option>';
                    salesReps.forEach(rep => {
                        const option = document.createElement('option');
                        option.value = JSON.stringify({ name: rep.name, ids: rep.ids });
                        option.textContent = rep.name;
                        dropdown.appendChild(option);
                    });
                }

                updateSalesDashboardSales();
            } catch (error) {
                console.error('Error loading Sales Dashboard:', error);
            }
        }

        // Update the Sales tab dashboard stats
        function updateSalesDashboardSales() {
            const rawFilter = document.getElementById('salesRepFilterSales')?.value || 'all';
            let salesRepFilter = rawFilter;
            if (rawFilter !== 'all') {
                try {
                    salesRepFilter = JSON.parse(rawFilter);
                } catch (e) {}
            }

            // Filter both order sets by sales rep
            let shippedOrders = filterOrdersBySalesRep(allLeafLinkOrders, salesRepFilter);
            let allOrders = filterOrdersBySalesRep(allOrdersIncludingPending, salesRepFilter);

            const now = new Date();
            const currentMonth = now.getMonth();
            const currentYear = now.getFullYear();
            const prevMonth = currentMonth === 0 ? 11 : currentMonth - 1;
            const prevYear = currentMonth === 0 ? currentYear - 1 : currentYear;

            // Apply date range filter
            const cutoffDate = getSalesDateCutoff();
            shippedOrders = shippedOrders.filter(o => new Date(o.created_on) >= cutoffDate && shouldCountOrder(o));
            allOrders = allOrders.filter(o => new Date(o.created_on) >= cutoffDate && shouldCountOrder(o));

            // Update date range label
            const label = document.getElementById('salesDateRangeLabel');
            if (label) {
                if (salesDateRangeDays === 'month') {
                    const monthName = cutoffDate.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
                    label.textContent = monthName;
                } else {
                    label.textContent = `${cutoffDate.toLocaleDateString()} - ${now.toLocaleDateString()}`;
                }
            }

            // Total Orders - ALL orders (including pending)
            const totalOrdersCount = allOrders.length;
            const totalOrdersValue = allOrders.reduce((sum, o) => sum + (o.total?.amount || 0), 0);

            // Shipped Orders
            const shippedOrdersCount = shippedOrders.length;
            const shippedRevenue = shippedOrders.reduce((sum, o) => sum + (o.total?.amount || 0), 0);

            // Paid/Unpaid (from shipped orders)
            const paidOrders = shippedOrders.filter(o => isOrderPaid(o));
            const unpaidOrders = shippedOrders.filter(o => !isOrderPaid(o));

            // Not Yet Due vs Overdue
            const notYetDue = unpaidOrders.filter(o => {
                if (!o.payment_due_date) return true; // No due date = not overdue yet
                return new Date(o.payment_due_date) >= now;
            });
            const overdueOrders = unpaidOrders.filter(o => {
                if (!o.payment_due_date) return false;
                return new Date(o.payment_due_date) < now;
            });

            // Update Sales tab stats
            const updateEl = (id, val) => {
                const el = document.getElementById(id);
                if (el) el.textContent = val;
            };

            // Calculate dollar amounts
            const paidAmount = paidOrders.reduce((sum, o) => sum + (o.total?.amount || 0), 0);
            const unpaidAmount = unpaidOrders.reduce((sum, o) => sum + (o.total?.amount || 0), 0);
            const notYetDueAmount = notYetDue.reduce((sum, o) => sum + (o.total?.amount || 0), 0);
            const overdueAmount = overdueOrders.reduce((sum, o) => sum + (o.total?.amount || 0), 0);

            updateEl('salesStatTotalOrdersSales', totalOrdersCount.toLocaleString());
            updateEl('salesStatTotalValueSales', '$' + totalOrdersValue.toLocaleString(undefined, {minimumFractionDigits: 0, maximumFractionDigits: 0}));
            updateEl('salesStatShippedOrdersSales', shippedOrdersCount.toLocaleString());
            updateEl('salesStatRevenueSales', '$' + shippedRevenue.toLocaleString(undefined, {minimumFractionDigits: 0, maximumFractionDigits: 0}));
            updateEl('salesStatPaidOrdersSales', paidOrders.length.toLocaleString());
            updateEl('salesStatPaidAmountSales', '$' + paidAmount.toLocaleString(undefined, {minimumFractionDigits: 0, maximumFractionDigits: 0}));
            updateEl('salesStatUnpaidOrdersSales', unpaidOrders.length.toLocaleString());
            updateEl('salesStatUnpaidAmountSales', '$' + unpaidAmount.toLocaleString(undefined, {minimumFractionDigits: 0, maximumFractionDigits: 0}));
            updateEl('salesStatNotDueSales', notYetDue.length.toLocaleString());
            updateEl('salesStatNotDueAmountSales', '$' + notYetDueAmount.toLocaleString(undefined, {minimumFractionDigits: 0, maximumFractionDigits: 0}));
            updateEl('salesStatOverdueSales', overdueOrders.length.toLocaleString());
            updateEl('salesStatOverdueAmountSales', '$' + overdueAmount.toLocaleString(undefined, {minimumFractionDigits: 0, maximumFractionDigits: 0}));

            // Commission calculations - use UNFILTERED orders (not affected by date range filter)
            // Commission is always based on full current/previous month data
            const unfilteredShippedOrders = filterOrdersBySalesRep(allLeafLinkOrders, salesRepFilter);
            const currentMonthPaid = getPaidOrdersForMonth(unfilteredShippedOrders, currentYear, currentMonth);
            const prevMonthPaid = getPaidOrdersForMonth(unfilteredShippedOrders, prevYear, prevMonth);
            const currentMonthCommission = currentMonthPaid.reduce((sum, o) => sum + (o.total?.amount || 0), 0) * COMMISSION_RATE;
            const prevMonthCommission = prevMonthPaid.reduce((sum, o) => sum + (o.total?.amount || 0), 0) * COMMISSION_RATE;

            updateEl('commissionCurrentMonthSales', '$' + currentMonthCommission.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2}));
            updateEl('commissionCurrentMonthLabelSales', `${getMonthName(currentMonth)} ${currentYear}`);
            updateEl('commissionPrevMonthSales', '$' + prevMonthCommission.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2}));
            updateEl('commissionPrevMonthLabelSales', `${getMonthName(prevMonth)} ${prevYear}`);

            // Monthly breakdown for Sales tab - use UNFILTERED orders (independent of date filter)
            renderMonthlyBreakdownSales(unfilteredShippedOrders);

            // Chart - also use unfiltered for full picture
            renderSalesBarChartSales(unfilteredShippedOrders);

            // Update royalty calculator (Bubbleman only)
            updateRoyaltyCalculator();
        }

        // Render monthly breakdown for Sales tab
        function renderMonthlyBreakdownSales(orders) {
            const container = document.getElementById('salesMonthlyBreakdownSales');
            if (!container) return;

            const monthlyData = {};
            orders.forEach(order => {
                const date = new Date(order.created_on);
                const key = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                if (!monthlyData[key]) {
                    monthlyData[key] = {
                        year: date.getFullYear(),
                        month: date.getMonth(),
                        orders: [],
                        paidOrders: [],
                        revenue: 0,
                        paidRevenue: 0
                    };
                }
                monthlyData[key].orders.push(order);
                monthlyData[key].revenue += order.total?.amount || 0;
                if (isOrderPaid(order)) {
                    monthlyData[key].paidOrders.push(order);
                    monthlyData[key].paidRevenue += order.total?.amount || 0;
                }
            });

            const sortedMonths = Object.keys(monthlyData).sort().reverse();

            if (sortedMonths.length === 0) {
                container.innerHTML = '<div style="text-align: center; padding: 30px; color: var(--text-secondary);">No sales data available</div>';
                return;
            }

            let html = '<table style="width: 100%; border-collapse: collapse;">';
            html += '<thead><tr style="border-bottom: 2px solid var(--border-color);">';
            html += '<th style="text-align: left; padding: 10px; color: var(--text-secondary);">Month</th>';
            html += '<th style="text-align: right; padding: 10px; color: var(--text-secondary);">Orders</th>';
            html += '<th style="text-align: right; padding: 10px; color: var(--text-secondary);">Revenue</th>';
            html += '<th style="text-align: right; padding: 10px; color: var(--text-secondary);">Paid</th>';
            html += '<th style="text-align: right; padding: 10px; color: var(--text-secondary);">Commission</th>';
            html += '</tr></thead><tbody>';

            sortedMonths.forEach(key => {
                const data = monthlyData[key];
                const commission = data.paidRevenue * COMMISSION_RATE;
                const monthName = getMonthName(data.month);

                html += `<tr style="border-bottom: 1px solid var(--border-color);">`;
                html += `<td style="padding: 12px 10px; font-weight: 600;">${monthName} ${data.year}</td>`;
                html += `<td style="padding: 12px 10px; text-align: right; color: var(--accent-blue);">${data.orders.length}</td>`;
                html += `<td style="padding: 12px 10px; text-align: right; color: #FFD700;">$${data.revenue.toLocaleString(undefined, {minimumFractionDigits: 0, maximumFractionDigits: 0})}</td>`;
                html += `<td style="padding: 12px 10px; text-align: right; color: var(--accent-green);">$${data.paidRevenue.toLocaleString(undefined, {minimumFractionDigits: 0, maximumFractionDigits: 0})}</td>`;
                html += `<td style="padding: 12px 10px; text-align: right; color: var(--accent-purple); font-weight: 600;">$${commission.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})}</td>`;
                html += '</tr>';
            });

            html += '</tbody></table>';
            container.innerHTML = html;
        }

        // Sales bar chart for Sales tab
        let salesChartTypeSales = 'revenue';

        function setSalesChartTypeSales(type) {
            salesChartTypeSales = type;
            document.getElementById('chartTypeRevenueSales').style.background = type === 'revenue' ? 'var(--accent-orange)' : 'var(--bg-tertiary)';
            document.getElementById('chartTypeOrdersSales').style.background = type === 'orders' ? 'var(--accent-orange)' : 'var(--bg-tertiary)';
            renderSalesBarChartSales(filterOrdersBySalesRep(allLeafLinkOrders, document.getElementById('salesRepFilterSales')?.value || 'all'));
        }

        function renderSalesBarChartSales(orders) {
            const container = document.getElementById('salesBarChartSales');
            if (!container) return;

            // Group by month
            const monthlyData = {};
            orders.forEach(order => {
                const date = new Date(order.created_on);
                const key = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                if (!monthlyData[key]) {
                    monthlyData[key] = { month: date.getMonth(), year: date.getFullYear(), revenue: 0, orders: 0 };
                }
                monthlyData[key].revenue += order.total?.amount || 0;
                monthlyData[key].orders++;
            });

            const sortedMonths = Object.keys(monthlyData).sort().slice(-6);
            if (sortedMonths.length === 0) {
                container.innerHTML = '<div style="text-align: center; padding: 40px; color: var(--text-secondary);">No data for chart</div>';
                return;
            }

            const maxValue = Math.max(...sortedMonths.map(k => salesChartTypeSales === 'revenue' ? monthlyData[k].revenue : monthlyData[k].orders));

            let html = '<div style="display: flex; align-items: flex-end; height: 180px; gap: 10px; padding: 10px 0;">';
            sortedMonths.forEach(key => {
                const data = monthlyData[key];
                const value = salesChartTypeSales === 'revenue' ? data.revenue : data.orders;
                const height = maxValue > 0 ? (value / maxValue) * 150 : 0;
                const label = getMonthName(data.month).substring(0, 3);
                const displayValue = salesChartTypeSales === 'revenue' ? '$' + (value/1000).toFixed(0) + 'k' : value;

                html += `<div style="flex: 1; display: flex; flex-direction: column; align-items: center;">
                    <div style="font-size: 0.75rem; color: var(--text-secondary); margin-bottom: 5px;">${displayValue}</div>
                    <div style="width: 100%; max-width: 50px; height: ${Math.max(height, 5)}px; background: linear-gradient(to top, var(--accent-purple), var(--accent-blue)); border-radius: 4px 4px 0 0;"></div>
                    <div style="font-size: 0.75rem; color: var(--text-secondary); margin-top: 8px;">${label}</div>
                </div>`;
            });
            html += '</div>';
            container.innerHTML = html;
        }

        // Force refresh for Sales tab
        async function forceRefreshSalesDashboard() {
            const btn = event?.target;
            if (btn) {
                btn.disabled = true;
                btn.textContent = 'Refreshing...';
            }

            try {
                // Clear caches and refetch
                allLeafLinkOrders = [];
                allOrdersIncludingPending = [];
                lastLeafLinkFetch = 0;

                await loadSalesDashboardSales();

                showToast('Sales data refreshed!', 'success');
            } catch (error) {
                console.error('Error refreshing sales:', error);
                showToast('Error refreshing data', 'error');
            } finally {
                if (btn) {
                    btn.disabled = false;
                    btn.textContent = 'Refresh';
                }
            }
        }

        // ============================================
        // INVOICE LIST MODAL FUNCTIONS
        // ============================================

        function showInvoiceList(filterType) {
            currentInvoiceFilter = filterType;

            // Get filtered orders based on sales rep selection
            const rawFilter = document.getElementById('salesRepFilterSales')?.value || 'all';
            let salesRepFilter = rawFilter;
            if (rawFilter !== 'all') {
                try { salesRepFilter = JSON.parse(rawFilter); } catch (e) {}
            }

            let shippedOrders = filterOrdersBySalesRep(allLeafLinkOrders, salesRepFilter);
            let allOrders = filterOrdersBySalesRep(allOrdersIncludingPending, salesRepFilter);

            const now = new Date();

            // Apply date range filter
            const cutoffDate = getSalesDateCutoff();
            shippedOrders = shippedOrders.filter(o => new Date(o.created_on) >= cutoffDate && shouldCountOrder(o));
            allOrders = allOrders.filter(o => new Date(o.created_on) >= cutoffDate && shouldCountOrder(o));

            // Filter based on type
            let filteredOrders = [];
            let title = '';

            switch (filterType) {
                case 'all':
                    filteredOrders = allOrders;
                    title = ' All Orders';
                    break;
                case 'shipped':
                    filteredOrders = shippedOrders;
                    title = ' Shipped Orders';
                    break;
                case 'paid':
                    filteredOrders = shippedOrders.filter(o => isOrderPaid(o));
                    title = ' Paid Orders';
                    break;
                case 'unpaid':
                    filteredOrders = shippedOrders.filter(o => !isOrderPaid(o));
                    title = ' Unpaid Orders';
                    break;
                case 'notDue':
                    filteredOrders = shippedOrders.filter(o => {
                        if (isOrderPaid(o)) return false;
                        if (!o.payment_due_date) return true;
                        return new Date(o.payment_due_date) >= now;
                    });
                    title = ' Accounts Not Yet Due';
                    break;
                case 'overdue':
                    filteredOrders = shippedOrders.filter(o => {
                        if (isOrderPaid(o)) return false;
                        if (!o.payment_due_date) return false;
                        return new Date(o.payment_due_date) < now;
                    });
                    title = ' Overdue Accounts';
                    break;
            }

            currentInvoiceData = filteredOrders;
            document.getElementById('invoiceListTitle').textContent = title;
            document.getElementById('invoiceSearch').value = '';
            document.getElementById('invoiceSortBy').value = 'date-desc';

            renderInvoiceTable(filteredOrders);
            document.getElementById('invoiceListModal').style.display = 'block';
            document.body.style.overflow = 'hidden';
        }

        function closeInvoiceListModal() {
            document.getElementById('invoiceListModal').style.display = 'none';
            document.body.style.overflow = '';
        }

        function renderInvoiceTable(orders) {
            const tbody = document.getElementById('invoiceListBody');
            const countEl = document.getElementById('invoiceListCount');
            const totalEl = document.getElementById('invoiceListTotal');

            const total = orders.reduce((sum, o) => sum + (o.total?.amount || 0), 0);
            countEl.textContent = `${orders.length} order${orders.length !== 1 ? 's' : ''}`;
            totalEl.textContent = '$' + total.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });

            if (orders.length === 0) {
                tbody.innerHTML = '<tr><td colspan="7" style="padding: 40px; text-align: center; color: var(--text-secondary);">No orders found</td></tr>';
                return;
            }

            tbody.innerHTML = orders.map((order, i) => {
                const orderNum = order.short_id || order.number || order.id;
                const customer = order.customer?.display_name || order.customer?.name || 'Unknown';
                const date = order.created_on ? new Date(order.created_on).toLocaleDateString() : 'N/A';
                const amount = order.total?.amount || 0;
                const status = order.status || 'Unknown';
                const paid = isOrderPaid(order);
                const dueDate = order.payment_due_date ? new Date(order.payment_due_date).toLocaleDateString() : 'N/A';

                const statusColor = status === 'Complete' ? 'var(--accent-green)' :
                                   status === 'Shipped' ? 'var(--accent-blue)' :
                                   status === 'Accepted' ? 'var(--accent-purple)' :
                                   status === 'Submitted' ? 'var(--accent-orange)' : 'var(--text-secondary)';

                const paidColor = paid ? 'var(--accent-green)' : 'var(--accent-orange)';
                const rowBg = i % 2 === 0 ? 'transparent' : 'rgba(255,255,255,0.02)';

                // Check if overdue
                let dueDateColor = 'var(--text-secondary)';
                if (!paid && order.payment_due_date && new Date(order.payment_due_date) < new Date()) {
                    dueDateColor = '#ef4444';
                }

                return `<tr style="background: ${rowBg}; border-bottom: 1px solid var(--border-color);" data-search="${customer.toLowerCase()} ${orderNum}">
                    <td style="padding: 12px; font-family: 'Space Mono', monospace; color: var(--accent-blue);">${orderNum}</td>
                    <td style="padding: 12px;">${escapeHtml(customer)}</td>
                    <td style="padding: 12px; color: var(--text-secondary);">${date}</td>
                    <td style="padding: 12px; text-align: right; font-weight: 600;">$${amount.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})}</td>
                    <td style="padding: 12px; text-align: center;"><span style="background: ${statusColor}22; color: ${statusColor}; padding: 4px 10px; border-radius: 12px; font-size: 0.8rem;">${status}</span></td>
                    <td style="padding: 12px; text-align: center;"><span style="color: ${paidColor}; font-weight: 600;">${paid ? ' Paid' : 'Unpaid'}</span></td>
                    <td style="padding: 12px; color: ${dueDateColor};">${dueDate}</td>
                </tr>`;
            }).join('');
        }

        function filterInvoiceTable() {
            const query = document.getElementById('invoiceSearch').value.toLowerCase();
            const rows = document.querySelectorAll('#invoiceListBody tr');

            rows.forEach(row => {
                const searchData = row.getAttribute('data-search') || '';
                row.style.display = searchData.includes(query) ? '' : 'none';
            });

            // Update count for visible rows
            const visibleRows = document.querySelectorAll('#invoiceListBody tr:not([style*="display: none"])');
            document.getElementById('invoiceListCount').textContent = `${visibleRows.length} order${visibleRows.length !== 1 ? 's' : ''}`;
        }

        function sortInvoiceTable() {
            const sortBy = document.getElementById('invoiceSortBy').value;
            let sorted = [...currentInvoiceData];

            switch (sortBy) {
                case 'date-desc':
                    sorted.sort((a, b) => new Date(b.created_on || 0) - new Date(a.created_on || 0));
                    break;
                case 'date-asc':
                    sorted.sort((a, b) => new Date(a.created_on || 0) - new Date(b.created_on || 0));
                    break;
                case 'amount-desc':
                    sorted.sort((a, b) => (b.total?.amount || 0) - (a.total?.amount || 0));
                    break;
                case 'amount-asc':
                    sorted.sort((a, b) => (a.total?.amount || 0) - (b.total?.amount || 0));
                    break;
                case 'customer':
                    sorted.sort((a, b) => {
                        const nameA = a.customer?.display_name || a.customer?.name || '';
                        const nameB = b.customer?.display_name || b.customer?.name || '';
                        return nameA.localeCompare(nameB);
                    });
                    break;
                case 'status':
                    const statusOrder = { 'Complete': 0, 'Shipped': 1, 'Accepted': 2, 'Submitted': 3 };
                    sorted.sort((a, b) => (statusOrder[a.status] || 99) - (statusOrder[b.status] || 99));
                    break;
            }

            renderInvoiceTable(sorted);
        }


        // ============================================
        // SUPABASE DATA CACHING FOR FOH
        // ============================================

        /*
         * SUPABASE TABLE SCHEMAS - Run these in Supabase SQL Editor:
         *
         * -- Drop Calendar Cache Table
         * CREATE TABLE IF NOT EXISTS drop_calendar_cache (
         *     id SERIAL PRIMARY KEY,
         *     customer_id TEXT NOT NULL,
         *     customer_name TEXT NOT NULL,
         *     delivery_prefs TEXT,
         *     last_drop_date DATE,
         *     total_orders INTEGER DEFAULT 0,
         *     total_products INTEGER DEFAULT 0,
         *     avg_days_between INTEGER,
         *     drops_json JSONB,
         *     synced_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
         *     UNIQUE(customer_id)
         * );
         *
         * -- Sales Data Cache Table
         * CREATE TABLE IF NOT EXISTS sales_data_cache (
         *     id SERIAL PRIMARY KEY,
         *     order_id TEXT NOT NULL,
         *     short_id TEXT,
         *     customer_id TEXT,
         *     customer_name TEXT,
         *     sales_rep_id TEXT,
         *     sales_rep_name TEXT,
         *     total_amount DECIMAL(10,2),
         *     paid BOOLEAN DEFAULT FALSE,
         *     paid_date TIMESTAMP WITH TIME ZONE,
         *     created_on TIMESTAMP WITH TIME ZONE,
         *     status TEXT,
         *     order_json JSONB,
         *     synced_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
         *     UNIQUE(order_id)
         * );
         *
         * -- Monthly Sales Summary Table (for quick chart data)
         * CREATE TABLE IF NOT EXISTS sales_monthly_summary (
         *     id SERIAL PRIMARY KEY,
         *     year INTEGER NOT NULL,
         *     month INTEGER NOT NULL,
         *     sales_rep_id TEXT DEFAULT 'all',
         *     total_orders INTEGER DEFAULT 0,
         *     total_revenue DECIMAL(12,2) DEFAULT 0,
         *     paid_revenue DECIMAL(12,2) DEFAULT 0,
         *     commission DECIMAL(10,2) DEFAULT 0,
         *     new_customers INTEGER DEFAULT 0,
         *     synced_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
         *     UNIQUE(year, month, sales_rep_id)
         * );
         *
         * -- Cache metadata table
         * CREATE TABLE IF NOT EXISTS cache_metadata (
         *     id SERIAL PRIMARY KEY,
         *     cache_key TEXT NOT NULL UNIQUE,
         *     last_sync TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
         *     record_count INTEGER DEFAULT 0
         * );
         */

        const SUPABASE_CACHE_DURATION = 30 * 60 * 1000; // 30 minutes for Supabase cache
        let salesChartType = 'revenue';
        let cachedMonthlyData = null;
        let lastSupabaseSync = null;

        // ==================== DROP CALENDAR SUPABASE CACHING ====================

        // Save drop calendar data to Supabase
        async function saveDropCalendarToSupabase(data) {
            if (!supabaseClient || !data || data.length === 0) return false;

            try {
                // Prepare records for upsert
                const records = data.map(customer => ({
                    customer_id: String(customer.id),
                    customer_name: customer.name,
                    delivery_prefs: customer.deliveryPrefs || '',
                    last_drop_date: customer.lastDrop || null,
                    total_orders: customer.totalOrders || 0,
                    total_products: customer.totalProducts || 0,
                    avg_days_between: customer.avgDaysBetween || null,
                    drops_json: JSON.stringify(customer.drops || []),
                    synced_at: new Date().toISOString()
                }));

                // Upsert in batches
                const batchSize = 50;
                for (let i = 0; i < records.length; i += batchSize) {
                    const batch = records.slice(i, i + batchSize);
                    const { error } = await supabaseClient
                        .from('drop_calendar_cache')
                        .upsert(batch, { onConflict: 'customer_id' });

                    if (error) {
                        console.error('Error saving drop calendar batch:', error);
                    }
                }

                // Update cache metadata
                await supabaseClient
                    .from('cache_metadata')
                    .upsert({
                        cache_key: 'drop_calendar',
                        last_sync: new Date().toISOString(),
                        record_count: records.length
                    }, { onConflict: 'cache_key' });

                console.log(`Saved ${records.length} drop calendar records to Supabase`);
                return true;
            } catch (error) {
                console.error('Error saving drop calendar to Supabase:', error);
                return false;
            }
        }

        // Load drop calendar data from Supabase
        async function loadDropCalendarFromSupabase() {
            if (!supabaseClient) return null;

            try {
                // Check cache freshness
                const { data: metadata } = await supabaseClient
                    .from('cache_metadata')
                    .select('last_sync, record_count')
                    .eq('cache_key', 'drop_calendar')
                    .single();

                if (!metadata || !metadata.last_sync) return null;

                const cacheAge = Date.now() - new Date(metadata.last_sync).getTime();
                if (cacheAge > SUPABASE_CACHE_DURATION) {
                    console.log('Supabase drop calendar cache is stale');
                    return { stale: true };
                }

                // Load cached data
                const { data, error } = await supabaseClient
                    .from('drop_calendar_cache')
                    .select('*')
                    .order('last_drop_date', { ascending: false });

                if (error || !data) return null;

                // Transform back to original format
                const calendarData = data.map(record => ({
                    id: record.customer_id,
                    name: record.customer_name,
                    deliveryPrefs: record.delivery_prefs,
                    lastDrop: record.last_drop_date,
                    totalOrders: record.total_orders,
                    totalProducts: record.total_products,
                    avgDaysBetween: record.avg_days_between,
                    drops: JSON.parse(record.drops_json || '[]')
                }));

                console.log(`Loaded ${calendarData.length} drop calendar records from Supabase`);
                return { data: calendarData, lastSync: metadata.last_sync };
            } catch (error) {
                console.error('Error loading drop calendar from Supabase:', error);
                return null;
            }
        }

        // ==================== SALES DATA SUPABASE CACHING ====================

        // Save sales data to Supabase
        async function saveSalesDataToSupabase(orders) {
            if (!supabaseClient || !orders || orders.length === 0) return false;

            try {
                // Deduplicate orders by ID
                const uniqueOrders = [...new Map(orders.map(o => [String(o.id), o])).values()];

                // Get current business ID for multi-tenant support
                const bizId = currentBusinessId !== 'all' ? currentBusinessId :
                    (businessesList.find(b => b.slug === 'white-mousse')?.id || null);

                // Prepare order records
                const orderRecords = uniqueOrders.map(order => ({
                    order_id: String(order.id),
                    short_id: order.short_id || order.number || '',
                    customer_id: order.customer?.id ? String(order.customer.id) : '',
                    customer_name: order.customer?.display_name || order.customer?.name || '',
                    sales_rep_id: order.sales_reps?.[0]?.id ? String(order.sales_reps[0].id) : '',
                    sales_rep_name: getSalesRepName(order),
                    total_amount: order.total?.amount || 0,
                    paid: order.paid === true,
                    paid_date: order.paid_date || null,
                    created_on: order.created_on,
                    status: order.status || '',
                    order_json: JSON.stringify(order),
                    synced_at: new Date().toISOString(),
                    business_id: bizId
                }));

                // Upsert orders in batches
                const batchSize = 50;
                for (let i = 0; i < orderRecords.length; i += batchSize) {
                    const batchRaw = orderRecords.slice(i, i + batchSize);
                    // Extra dedup safety within each batch
                    const batch = [...new Map(batchRaw.map(r => [r.order_id, r])).values()];
                    const { error } = await supabaseClient
                        .from('sales_data_cache')
                        .upsert(batch, { onConflict: 'order_id' });

                    if (error) {
                        console.error('Error saving sales data batch:', error);
                    }
                }

                // Calculate and save monthly summaries
                await saveMonthlySummariesToSupabase(orders);

                // Update cache metadata
                await supabaseClient
                    .from('cache_metadata')
                    .upsert({
                        cache_key: 'sales_data',
                        last_sync: new Date().toISOString(),
                        record_count: orderRecords.length
                    }, { onConflict: 'cache_key' });

                lastSupabaseSync = new Date();
                updateCacheStatusDisplay();
                console.log(`Saved ${orderRecords.length} sales records to Supabase`);
                return true;
            } catch (error) {
                console.error('Error saving sales data to Supabase:', error);
                return false;
            }
        }

        // Get sales rep name from order
        function getSalesRepName(order) {
            if (!order.sales_reps || !Array.isArray(order.sales_reps) || order.sales_reps.length === 0) {
                return '';
            }
            const rep = order.sales_reps[0];
            if (rep.user) {
                return typeof rep.user === 'string' ? rep.user : (rep.user.name || rep.user.first_name || '');
            }
            return '';
        }

        // Save monthly summaries to Supabase
        async function saveMonthlySummariesToSupabase(orders) {
            if (!supabaseClient) return;

            try {
                // Group by month
                const monthlyData = {};
                orders.forEach(order => {
                    const date = new Date(order.created_on);
                    const year = date.getFullYear();
                    const month = date.getMonth();
                    const key = `${year}-${month}`;

                    if (!monthlyData[key]) {
                        monthlyData[key] = {
                            year,
                            month,
                            sales_rep_id: 'all',
                            total_orders: 0,
                            total_revenue: 0,
                            paid_revenue: 0,
                            new_customers: 0
                        };
                    }

                    monthlyData[key].total_orders++;
                    monthlyData[key].total_revenue += order.total?.amount || 0;
                    if (isOrderPaid(order)) {
                        monthlyData[key].paid_revenue += order.total?.amount || 0;
                    }
                });

                // Calculate commission
                const summaries = Object.values(monthlyData).map(data => ({
                    ...data,
                    commission: data.paid_revenue * COMMISSION_RATE,
                    synced_at: new Date().toISOString()
                }));

                // Upsert summaries
                if (summaries.length > 0) {
                    const { error } = await supabaseClient
                        .from('sales_monthly_summary')
                        .upsert(summaries, { onConflict: 'year,month,sales_rep_id' });

                    if (error) {
                        console.error('Error saving monthly summaries:', error);
                    }
                }

                cachedMonthlyData = summaries;
            } catch (error) {
                console.error('Error saving monthly summaries:', error);
            }
        }

        // Load sales data from Supabase
        async function loadSalesDataFromSupabase() {
            if (!supabaseClient) return null;

            try {
                // Check cache freshness
                const { data: metadata } = await supabaseClient
                    .from('cache_metadata')
                    .select('last_sync, record_count')
                    .eq('cache_key', 'sales_data')
                    .single();

                if (!metadata || !metadata.last_sync) return null;

                const cacheAge = Date.now() - new Date(metadata.last_sync).getTime();
                if (cacheAge > SUPABASE_CACHE_DURATION) {
                    console.log('Supabase sales cache is stale');
                    return { stale: true };
                }

                // Load cached orders (filtered by business if selected)
                let query = supabaseClient
                    .from('sales_data_cache')
                    .select('order_json')
                    .order('created_on', { ascending: false });

                if (currentBusinessId && currentBusinessId !== 'all') {
                    query = query.eq('business_id', currentBusinessId);
                }

                const { data, error } = await query;

                if (error || !data) return null;

                // Parse order JSON
                const orders = data.map(record => JSON.parse(record.order_json));

                lastSupabaseSync = new Date(metadata.last_sync);
                console.log(`Loaded ${orders.length} sales records from Supabase`);
                return { data: orders, lastSync: metadata.last_sync };
            } catch (error) {
                console.error('Error loading sales data from Supabase:', error);
                return null;
            }
        }

        // Load monthly summaries from Supabase (faster for charts)
        async function loadMonthlySummariesFromSupabase() {
            if (!supabaseClient) return null;

            try {
                const { data, error } = await supabaseClient
                    .from('sales_monthly_summary')
                    .select('*')
                    .eq('sales_rep_id', 'all')
                    .order('year', { ascending: false })
                    .order('month', { ascending: false })
                    .limit(12);

                if (error || !data) return null;

                return data;
            } catch (error) {
                console.error('Error loading monthly summaries:', error);
                return null;
            }
        }

        // Force sync to Supabase
        async function forceSyncSalesData() {
            const statusEl = document.getElementById('cacheStatusText');
            if (statusEl) statusEl.textContent = 'Syncing...';

            try {
                // Sync drop calendar
                if (dropCalendarData && dropCalendarData.length > 0) {
                    await saveDropCalendarToSupabase(dropCalendarData);
                }

                // Sync sales data
                if (allLeafLinkOrders && allLeafLinkOrders.length > 0) {
                    await saveSalesDataToSupabase(allLeafLinkOrders);
                }

                updateCacheStatusDisplay();
            } catch (error) {
                console.error('Error during force sync:', error);
                if (statusEl) statusEl.textContent = 'Sync failed';
            }
        }

        // Update cache status display
        function updateCacheStatusDisplay() {
            const statusEl = document.getElementById('cacheStatusText');
            if (!statusEl) return;

            if (lastSupabaseSync) {
                const age = Math.round((Date.now() - lastSupabaseSync.getTime()) / 60000);
                statusEl.textContent = `Last synced: ${age} min ago (${allLeafLinkOrders?.length || 0} orders)`;
                statusEl.style.color = age < 30 ? 'var(--accent-green)' : 'var(--accent-orange)';
            } else {
                statusEl.textContent = 'Not synced to cloud yet';
                statusEl.style.color = 'var(--text-secondary)';
            }
        }

        // ==================== BAR CHART RENDERING ====================

        // Set chart type
        function setSalesChartType(type) {
            salesChartType = type;

            // Update button styles
            document.getElementById('chartTypeRevenue').style.background = type === 'revenue' ? 'var(--accent-orange)' : 'var(--bg-tertiary)';
            document.getElementById('chartTypeOrders').style.background = type === 'orders' ? 'var(--accent-green)' : 'var(--bg-tertiary)';

            renderSalesBarChart();
        }

        // Render sales bar chart (CSS-based, no external dependencies)
        function renderSalesBarChart() {
            const container = document.getElementById('salesBarChart');
            if (!container) return;

            // Group orders by month (last 6 months)
            const monthlyData = {};
            const now = new Date();

            // Initialize last 6 months
            for (let i = 5; i >= 0; i--) {
                const date = new Date(now.getFullYear(), now.getMonth() - i, 1);
                const key = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                monthlyData[key] = {
                    year: date.getFullYear(),
                    month: date.getMonth(),
                    orders: 0,
                    revenue: 0,
                    paidRevenue: 0,
                    commission: 0
                };
            }

            // Populate with actual data
            if (allLeafLinkOrders && allLeafLinkOrders.length > 0) {
                allLeafLinkOrders.forEach(order => {
                    const date = new Date(order.created_on);
                    const key = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;

                    if (monthlyData[key]) {
                        monthlyData[key].orders++;
                        monthlyData[key].revenue += order.total?.amount || 0;
                        if (isOrderPaid(order)) {
                            monthlyData[key].paidRevenue += order.total?.amount || 0;
                        }
                    }
                });
            }

            // Calculate commission
            Object.values(monthlyData).forEach(data => {
                data.commission = data.paidRevenue * COMMISSION_RATE;
            });

            // Get sorted months
            const sortedMonths = Object.keys(monthlyData).sort();

            // Determine max value based on chart type
            let maxValue = 0;
            let valueKey = 'revenue';
            let valueLabel = 'Revenue';
            let valueColor = '#FFD700';
            let valuePrefix = '$';

            switch (salesChartType) {
                case 'orders':
                    valueKey = 'orders';
                    valueLabel = 'Orders';
                    valueColor = '#39ff14';
                    valuePrefix = '';
                    break;
                default:
                    valueKey = 'revenue';
                    valueLabel = 'Revenue';
                    valueColor = '#ff6b00';
                    valuePrefix = '$';
            }

            sortedMonths.forEach(key => {
                const value = monthlyData[key][valueKey];
                if (value > maxValue) maxValue = value;
            });

            if (maxValue === 0) maxValue = 1; // Prevent division by zero

            // Build chart HTML
            const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

            // Detect mobile viewport for responsive styling
            const isMobile = window.innerWidth <= 768;
            const isSmallMobile = window.innerWidth <= 480;
            const chartHeight = isSmallMobile ? 140 : (isMobile ? 160 : 180);
            const chartGap = isSmallMobile ? 2 : (isMobile ? 4 : 8);
            const labelFontSize = isSmallMobile ? '0.6rem' : (isMobile ? '0.65rem' : '0.7rem');
            const monthFontSize = isSmallMobile ? '0.65rem' : '0.75rem';

            // Helper function to abbreviate numbers on mobile
            function formatValueForDisplay(val, prefix, isOrders) {
                if (isOrders) {
                    return prefix + val;
                }
                if (isMobile && val >= 1000) {
                    const k = val / 1000;
                    return prefix + k.toFixed(k >= 10 ? 0 : 1) + 'K';
                }
                return prefix + val.toLocaleString(undefined, {minimumFractionDigits: 0, maximumFractionDigits: 0});
            }

            let html = `
                <div style="display: flex; align-items: flex-end; justify-content: space-between; height: ${chartHeight}px; padding: 10px 0; gap: ${chartGap}px;">
            `;

            sortedMonths.forEach(key => {
                const data = monthlyData[key];
                const value = data[valueKey];
                const heightPercent = Math.max((value / maxValue) * 100, 2);
                const monthLabel = monthNames[data.month];

                // Full display value for tooltip
                const fullDisplayValue = valuePrefix + (valueKey === 'orders'
                    ? value
                    : value.toLocaleString(undefined, {minimumFractionDigits: 0, maximumFractionDigits: 0}));

                // Abbreviated display value for bar label
                const displayValue = formatValueForDisplay(value, valuePrefix, valueKey === 'orders');

                // On very small screens, hide value labels (users can tap to see tooltip)
                const showValueLabel = !isSmallMobile || value > 0;
                const valueLabelOpacity = isSmallMobile ? '0.85' : '1';

                html += `
                    <div style="flex: 1; display: flex; flex-direction: column; align-items: center; height: 100%; min-width: 0;">
                        <div style="flex: 1; display: flex; align-items: flex-end; width: 100%;">
                            <div style="
                                width: 100%;
                                height: ${heightPercent}%;
                                background: linear-gradient(to top, ${valueColor}, ${valueColor}aa);
                                border-radius: ${isMobile ? '4px 4px 0 0' : '6px 6px 0 0'};
                                position: relative;
                                min-height: 4px;
                                transition: all 0.3s ease;
                                cursor: pointer;
                            "
                            onmouseover="this.style.transform='scaleY(1.02)'; this.style.boxShadow='0 -4px 12px ${valueColor}40';"
                            onmouseout="this.style.transform='scaleY(1)'; this.style.boxShadow='none';"
                            title="${monthLabel} ${data.year}: ${fullDisplayValue}">
                                ${showValueLabel ? `<div style="
                                    position: absolute;
                                    top: -22px;
                                    left: 50%;
                                    transform: translateX(-50%);
                                    font-size: ${labelFontSize};
                                    font-weight: 600;
                                    color: ${valueColor};
                                    white-space: nowrap;
                                    opacity: ${valueLabelOpacity};
                                    text-shadow: 0 1px 2px rgba(0,0,0,0.5);
                                ">${displayValue}</div>` : ''}
                            </div>
                        </div>
                        <div style="margin-top: ${isMobile ? '6px' : '8px'}; font-size: ${monthFontSize}; color: var(--text-secondary); font-weight: 500;">
                            ${monthLabel}
                        </div>
                    </div>
                `;
            });

            html += `</div>`;

            // Add total summary
            const totalValue = sortedMonths.reduce((sum, key) => sum + monthlyData[key][valueKey], 0);
            const avgValue = totalValue / sortedMonths.length;

            // Format summary values (abbreviated on mobile)
            const formattedTotal = formatValueForDisplay(totalValue, valuePrefix, valueKey === 'orders');
            const formattedAvg = formatValueForDisplay(Math.round(avgValue), valuePrefix, valueKey === 'orders');
            const summaryFontSize = isSmallMobile ? '0.95rem' : '1.1rem';
            const summaryLabelSize = isSmallMobile ? '0.7rem' : '0.75rem';

            html += `
                <div style="display: flex; justify-content: space-around; padding: ${isSmallMobile ? '10px' : '15px'} 0; border-top: 1px solid var(--border-color); margin-top: 10px;">
                    <div style="text-align: center;">
                        <div style="font-size: ${summaryLabelSize}; color: var(--text-secondary);">6-Month Total</div>
                        <div style="font-size: ${summaryFontSize}; font-weight: 700; color: ${valueColor};">
                            ${formattedTotal}
                        </div>
                    </div>
                    <div style="text-align: center;">
                        <div style="font-size: ${summaryLabelSize}; color: var(--text-secondary);">Monthly Avg</div>
                        <div style="font-size: ${summaryFontSize}; font-weight: 700; color: ${valueColor};">
                            ${formattedAvg}
                        </div>
                    </div>
                </div>
            `;

            container.innerHTML = html;
        }

        // Re-render chart on window resize for responsive behavior
        let salesChartResizeTimeout;
        window.addEventListener('resize', function() {
            clearTimeout(salesChartResizeTimeout);
            salesChartResizeTimeout = setTimeout(function() {
                if (document.getElementById('salesBarChart')) {
                    renderSalesBarChart();
                }
            }, 250);
        });

        // ==================== ENHANCED DATA LOADING WITH SUPABASE ====================

        // Enhanced loadDropCalendar with Supabase caching
        const originalLoadDropCalendar = loadDropCalendar;
        loadDropCalendar = async function() {
            const content = document.getElementById('dropCalendarContent');

            // Try to load from Supabase first
            const cached = await loadDropCalendarFromSupabase();
            if (cached && cached.data && !cached.stale) {
                dropCalendarData = cached.data;
                updateDropStats();
                renderCalendarView();
                console.log('Using Supabase cached drop calendar data');
                return;
            }

            // Show loading state
            content.innerHTML = '<div style="text-align: center; padding: 60px; color: var(--text-secondary);"><div style="font-size: 2rem; margin-bottom: 10px;">...</div>Loading drop data from LeafLink...</div>';

            try {
                const twoMonthsAgo = new Date();
                twoMonthsAgo.setMonth(twoMonthsAgo.getMonth() - 2);
                const dateFilter = twoMonthsAgo.toISOString().split('T')[0];

                let allOrders = [];
                const businessSlug = currentBusinessId === 'all' ? 'white-mousse' :
                    (businessesList.find(b => b.id === currentBusinessId)?.slug || 'white-mousse');
                let nextUrl = `${window.location.origin}/api/leaflink?slug=${businessSlug}&endpoint=orders-received&status=Accepted&status=Shipped&status=Complete&created_on__gte=${dateFilter}&page_size=100`;

                while (nextUrl) {
                    const response = await fetch(nextUrl);
                    if (!response.ok) throw new Error('API request failed');
                    const data = await response.json();
                    allOrders = allOrders.concat(data.results);
                    nextUrl = data.next;
                    if (allOrders.length > 500) break;
                }

                dropCalendarData = processDropData(allOrders);
                updateDropStats();
                renderCalendarView();

                // Save to Supabase in background
                saveDropCalendarToSupabase(dropCalendarData);

            } catch (error) {
                console.error('Error loading drop calendar:', error);

                // Try to use stale Supabase data as fallback
                if (cached && cached.stale) {
                    const staleData = await loadDropCalendarFromSupabase();
                    if (staleData && staleData.data) {
                        dropCalendarData = staleData.data;
                        updateDropStats();
                        renderCalendarView();
                        content.insertAdjacentHTML('afterbegin',
                            '<div style="background: var(--accent-orange); color: #000; padding: 10px; border-radius: 8px; margin-bottom: 15px; text-align: center;">Using cached data (API unavailable)</div>');
                        return;
                    }
                }

                content.innerHTML = `<div style="text-align: center; padding: 60px; color: var(--accent-red);">
                    <div style="font-size: 2rem; margin-bottom: 10px;">X</div>
                    Error loading data: ${error.message}
                </div>`;
            }
        };

        // Enhanced loadSalesDashboard with Supabase caching
        const originalLoadSalesDashboard = loadSalesDashboard;
        loadSalesDashboard = async function() {
            try {
                // If we already have good data in memory, just update display
                if (allLeafLinkOrders && allLeafLinkOrders.length > 10) {
                    console.log("Using existing in-memory data:", allLeafLinkOrders.length, "orders");
                } else {
                    // Skip Supabase cache - use localStorage/API instead
                    const cached = null; // await loadSalesDataFromSupabase();
                    if (false && cached && cached.data && !cached.stale && cached.data.length > 0) {
                    allLeafLinkOrders = cached.data;
                    customerFirstOrderDates = buildCustomerFirstOrderDates(cached.data);
                    leafLinkDataLoaded = true;
                    console.log('Using Supabase cached sales data');
                } else {
                    // Fetch fresh data
                    await ensureLeafLinkData();

                    // Save to Supabase in background
                    if (allLeafLinkOrders && allLeafLinkOrders.length > 0) {
                        saveSalesDataToSupabase(allLeafLinkOrders);
                    }
                }
                }

                // Populate sales rep dropdown (use name as value for multi-business dedup)
                const salesReps = extractSalesReps(allLeafLinkOrders);
                const dropdown = document.getElementById('salesRepFilter');
                if (dropdown) {
                    dropdown.innerHTML = '<option value="all">All Sales Reps</option>';
                    salesReps.forEach(rep => {
                        const option = document.createElement('option');
                        // Store IDs as JSON for filtering across businesses
                        option.value = JSON.stringify({ name: rep.name, ids: rep.ids });
                        option.textContent = rep.name;
                        dropdown.appendChild(option);
                    });
                }

                updateSalesDashboard();
                renderSalesBarChart();
                updateCacheStatusDisplay();

            } catch (error) {
                console.error('Error loading sales dashboard:', error);
            }
        };

        // Periodic sync (every 30 minutes)
        setInterval(async () => {
            if (supabaseClient && allLeafLinkOrders && allLeafLinkOrders.length > 0) {
                console.log('Running periodic Supabase sync...');
                await saveSalesDataToSupabase(allLeafLinkOrders);
                if (dropCalendarData && dropCalendarData.length > 0) {
                    await saveDropCalendarToSupabase(dropCalendarData);
                }
            }
        }, 30 * 60 * 1000);


        // ============================================
        // TIME CLOCK SYSTEM
        // ============================================

        // Authorized work IPs - add your work IP addresses here
        // For testing, Ryan (admin) can bypass IP check
        const AUTHORIZED_IPS = [
            '75.70.251.65'  // Work location IP
        ];

        // Pay period configuration - paydays are every 2 weeks on Friday
        // Pay periods run Saturday to Friday
        const PAY_PERIOD_CONFIG = {
            basePayday: new Date('2025-01-11'), // Saturday after a payday (aligns Sat-Fri periods)
            periodDays: 14 // Bi-weekly
        };

        let currentUserIP = null;
        let ipVerified = false;
        let clockUpdateInterval = null;

        // Setup timeclock table in Supabase
        async function setupTimeclockTable() {
            if (!supabaseClient) return;

            // Check if table exists by trying to query it
            const { data, error } = await supabaseClient
                .from('timeclock')
                .select('id')
                .limit(1);

            if (error && error.code === '42P01') {
                // Table does not exist - show instructions
                console.log('Timeclock table needs to be created. SQL:');
                console.log(`
CREATE TABLE timeclock (
    id SERIAL PRIMARY KEY,
    user_name TEXT NOT NULL,
    user_role TEXT NOT NULL,
    punch_type TEXT NOT NULL CHECK (punch_type IN ('in', 'out')),
    punch_time TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    ip_address TEXT,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_timeclock_user ON timeclock(user_name, punch_time);
CREATE INDEX idx_timeclock_date ON timeclock(punch_time);
                `);
            }
        }

        // Get current pay period dates
        // Pay periods run Saturday to Friday, bi-weekly
        // Staff are paid 1 week after the period ends
        function getPayPeriodDates(periodType = 'current') {
            const today = new Date();
            const basePayday = new Date(PAY_PERIOD_CONFIG.basePayday);
            const periodDays = PAY_PERIOD_CONFIG.periodDays;

            // Calculate days since base payday
            const daysSinceBase = Math.floor((today - basePayday) / (1000 * 60 * 60 * 24));

            // Find current period number
            let periodNumber = Math.floor(daysSinceBase / periodDays) + 1;
            if (daysSinceBase < 0) {
                periodNumber = Math.ceil(daysSinceBase / periodDays);
            }

            // Calculate payday for this period
            let payday = new Date(basePayday);
            payday.setDate(basePayday.getDate() + (periodNumber * periodDays));

            // Period ends 1 week (7 days) before payday
            let periodEnd = new Date(payday);
            periodEnd.setDate(payday.getDate() - 7);
            periodEnd.setHours(23, 59, 59, 999);

            let periodStart = new Date(periodEnd);
            periodStart.setDate(periodEnd.getDate() - periodDays + 1);
            periodStart.setHours(0, 0, 0, 0);

            // If today is after the period end, move to next period
            if (today > periodEnd) {
                periodNumber += 1;
                payday = new Date(basePayday);
                payday.setDate(basePayday.getDate() + (periodNumber * periodDays));
                periodEnd = new Date(payday);
                periodEnd.setDate(payday.getDate() - 7);
                periodEnd.setHours(23, 59, 59, 999);
                periodStart = new Date(periodEnd);
                periodStart.setDate(periodEnd.getDate() - periodDays + 1);
                periodStart.setHours(0, 0, 0, 0);
            }

            if (periodType === 'previous') {
                // Go back one period
                periodNumber -= 1;
                payday = new Date(basePayday);
                payday.setDate(basePayday.getDate() + (periodNumber * periodDays));
                periodEnd = new Date(payday);
                periodEnd.setDate(payday.getDate() - 7);
                periodEnd.setHours(23, 59, 59, 999);
                periodStart = new Date(periodEnd);
                periodStart.setDate(periodEnd.getDate() - periodDays + 1);
                periodStart.setHours(0, 0, 0, 0);
            } else if (periodType.startsWith('previous-')) {
                // Go back N periods (e.g., 'previous-2' goes back 2 periods)
                const offset = parseInt(periodType.split('-')[1]);
                periodNumber -= offset;
                payday = new Date(basePayday);
                payday.setDate(basePayday.getDate() + (periodNumber * periodDays));
                periodEnd = new Date(payday);
                periodEnd.setDate(payday.getDate() - 7);
                periodEnd.setHours(23, 59, 59, 999);
                periodStart = new Date(periodEnd);
                periodStart.setDate(periodEnd.getDate() - periodDays + 1);
                periodStart.setHours(0, 0, 0, 0);
            }

            return {
                start: periodStart,
                end: periodEnd,
                payday: payday
            };
        }

        // Verify user IP address
        async function verifyIP() {
            try {
                const response = await fetch('https://api.ipify.org?format=json');
                const data = await response.json();
                currentUserIP = data.ip;

                // Check if IP is authorized
                const isAuthorized = AUTHORIZED_IPS.includes(currentUserIP);

                // Admin (Ryan) bypass for testing
                const isAdmin = currentRole && currentRole.name.includes('Ryan');

                ipVerified = isAuthorized || isAdmin || AUTHORIZED_IPS.length === 0;

                // Update IP status display
                const ipStatusEl = document.getElementById('ipStatusText');
                if (ipStatusEl) {
                    if (AUTHORIZED_IPS.length === 0) {
                        ipStatusEl.textContent = 'No IP restrictions set (testing mode)';
                        ipStatusEl.style.color = 'var(--accent-blue)';
                    } else if (ipVerified) {
                        ipStatusEl.textContent = 'Verified - Work Location';
                        ipStatusEl.style.color = 'var(--accent-green)';
                    } else {
                        ipStatusEl.textContent = 'Not at work location (' + currentUserIP + ')';
                        ipStatusEl.style.color = 'var(--accent-red)';
                    }
                }

                return ipVerified;
            } catch (error) {
                console.error('IP verification error:', error);
                const ipStatusEl = document.getElementById('ipStatusText');
                if (ipStatusEl) {
                    ipStatusEl.textContent = 'Could not verify IP';
                    ipStatusEl.style.color = 'var(--accent-orange)';
                }
                // Allow clock in if IP check fails (for reliability)
                ipVerified = true;
                return true;
            }
        }

        // Get user clock status
        async function getUserClockStatus() {
            if (!supabaseClient || !currentRole) return null;

            try {
                const { data, error } = await supabaseClient
                    .from('timeclock')
                    .select('*')
                    .eq('user_name', currentRole.name)
                    .order('punch_time', { ascending: false })
                    .limit(1);

                if (error) throw error;

                if (data && data.length > 0) {
                    return data[0];
                }
                return null;
            } catch (error) {
                console.error('Error getting clock status:', error);
                return null;
            }
        }

        // Calculate hours between two timestamps
        function calculateHours(startTime, endTime) {
            const start = new Date(startTime);
            const end = new Date(endTime);
            const diffMs = end - start;
            return diffMs / (1000 * 60 * 60); // Convert to hours
        }

        // Get today's punches for a user
        async function getTodayPunches(userName) {
            if (!supabaseClient) return [];

            const today = new Date();
            today.setHours(0, 0, 0, 0);
            const tomorrow = new Date(today);
            tomorrow.setDate(tomorrow.getDate() + 1);

            try {
                // Get today's punches
                const { data: todayData, error: todayError } = await supabaseClient
                    .from('timeclock')
                    .select('*')
                    .eq('user_name', userName)
                    .gte('punch_time', today.toISOString())
                    .lt('punch_time', tomorrow.toISOString())
                    .order('punch_time', { ascending: true });

                if (todayError) throw todayError;

                let punches = todayData || [];

                // Check if there's an open clock-in from before today (overnight shift)
                // Get the most recent punch before today
                const { data: prevData, error: prevError } = await supabaseClient
                    .from('timeclock')
                    .select('*')
                    .eq('user_name', userName)
                    .lt('punch_time', today.toISOString())
                    .order('punch_time', { ascending: false })
                    .limit(1);

                if (!prevError && prevData && prevData.length > 0) {
                    const lastPunch = prevData[0];
                    // If the last punch before today was a clock-in, they're still working from yesterday
                    if (lastPunch.punch_type === 'in') {
                        // Create a synthetic "midnight" clock-in for today's calculation
                        const midnightPunch = {
                            ...lastPunch,
                            punch_time: today.toISOString(),
                            is_overnight: true
                        };
                        punches = [midnightPunch, ...punches];
                    }
                }

                return punches;
            } catch (error) {
                console.error('Error getting today punches:', error);
                return [];
            }
        }

        // Get pay period punches for a user
        async function getPayPeriodPunches(userName, periodType = 'current') {
            if (!supabaseClient) return [];

            const period = getPayPeriodDates(periodType);

            try {
                const { data, error } = await supabaseClient
                    .from('timeclock')
                    .select('*')
                    .eq('user_name', userName)
                    .gte('punch_time', period.start.toISOString())
                    .lte('punch_time', period.end.toISOString())
                    .order('punch_time', { ascending: true });

                if (error) throw error;
                return data || [];
            } catch (error) {
                console.error('Error getting pay period punches:', error);
                return [];
            }
        }

        // Calculate total hours from punch pairs
        function calculateTotalHours(punches) {
            let totalHours = 0;

            for (let i = 0; i < punches.length; i++) {
                if (punches[i].punch_type === 'in') {
                    // Find matching out punch
                    const nextPunch = punches[i + 1];
                    if (nextPunch && nextPunch.punch_type === 'out') {
                        totalHours += calculateHours(punches[i].punch_time, nextPunch.punch_time);
                        i++; // Skip the out punch
                    } else {
                        // Still clocked in - calculate to now
                        totalHours += calculateHours(punches[i].punch_time, new Date());
                    }
                }
            }

            return totalHours;
        }

        // Calculate weekly hours for overtime checking
        async function getWeeklyHours(userName) {
            if (!supabaseClient) return 0;

            // Get start of current week (Saturday)
            const now = new Date();
            const startOfWeek = new Date(now);
            const daysFromSaturday = (now.getDay() + 1) % 7; // Sat=0, Sun=1, Mon=2, etc.
            startOfWeek.setDate(now.getDate() - daysFromSaturday);
            startOfWeek.setHours(0, 0, 0, 0);

            try {
                const { data, error } = await supabaseClient
                    .from('timeclock')
                    .select('*')
                    .eq('user_name', userName)
                    .gte('punch_time', startOfWeek.toISOString())
                    .order('punch_time', { ascending: true });

                if (error) throw error;
                return calculateTotalHours(data || []);
            } catch (error) {
                console.error('Error getting weekly hours:', error);
                return 0;
            }
        }

        // ============================================
        // CURRENTLY CLOCKED IN TRACKING
        // ============================================

        let clockedInRefreshInterval = null;

        // Get all employees currently clocked in
        async function getCurrentlyClockedIn() {
            if (!supabaseClient) return [];

            try {
                // Get all unique users with their most recent punch
                const { data: allPunches, error } = await supabaseClient
                    .from('timeclock')
                    .select('*')
                    .order('punch_time', { ascending: false });

                if (error) throw error;

                // Group by user and get their latest punch
                const userLatestPunch = {};
                (allPunches || []).forEach(punch => {
                    if (!userLatestPunch[punch.user_name]) {
                        userLatestPunch[punch.user_name] = punch;
                    }
                });

                // Filter to only those clocked in
                const clockedIn = [];
                for (const [userName, punch] of Object.entries(userLatestPunch)) {
                    if (punch.punch_type === 'in') {
                        // Get today's punches to calculate hours worked today
                        const todayPunches = await getTodayPunches(userName);
                        const todayHours = calculateTotalHours(todayPunches);

                        clockedIn.push({
                            userName: userName,
                            clockInTime: punch.punch_time,
                            todayHours: todayHours
                        });
                    }
                }

                return clockedIn;
            } catch (error) {
                console.error('Error getting currently clocked in:', error);
                return [];
            }
        }

        // Render currently clocked in section
        async function renderCurrentlyClockedIn() {
            const container = document.getElementById('currentlyClockedInContainer');
            if (!container) return;

            const clockedIn = await getCurrentlyClockedIn();

            if (clockedIn.length === 0) {
                container.innerHTML = `
                    <div style="text-align: center; padding: 30px; color: var(--text-secondary);">
                        <div style="font-size: 2rem; margin-bottom: 10px;">No one currently clocked in</div>
                    </div>
                `;
                return;
            }

            let html = '<div style="display: grid; gap: 15px;">';

            clockedIn.forEach(employee => {
                const clockInTime = new Date(employee.clockInTime);
                const now = new Date();
                const hoursWorking = calculateHours(employee.clockInTime, now);

                const clockInStr = clockInTime.toLocaleTimeString('en-US', {
                    hour: '2-digit',
                    minute: '2-digit',
                    hour12: true
                });

                // Format hours and minutes working
                const hours = Math.floor(hoursWorking);
                const minutes = Math.floor((hoursWorking - hours) * 60);
                const workingStr = hours > 0 ? `${hours}h ${minutes}m` : `${minutes}m`;

                html += `
                    <div style="display: flex; justify-content: space-between; align-items: center; background: var(--bg-tertiary); padding: 15px 20px; border-radius: 10px; border-left: 4px solid var(--accent-green);">
                        <div>
                            <div style="font-weight: 600; color: var(--text-primary); font-size: 1.1rem;">${employee.userName}</div>
                            <div style="color: var(--text-secondary); font-size: 0.85rem;">Clocked in at ${clockInStr}</div>
                        </div>
                        <div style="text-align: right;">
                            <div style="font-size: 1.3rem; font-weight: 700; color: var(--accent-green);">${workingStr}</div>
                            <div style="color: var(--text-secondary); font-size: 0.8rem;">Today: ${employee.todayHours.toFixed(2)} hrs</div>
                        </div>
                    </div>
                `;
            });

            html += '</div>';

            // Add last updated timestamp
            const updateTime = new Date().toLocaleTimeString('en-US', {
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: true
            });
            html += `<div style="text-align: center; margin-top: 15px; color: var(--text-secondary); font-size: 0.8rem;">Last updated: ${updateTime}</div>`;

            container.innerHTML = html;
        }

        // Start auto-refresh for clocked in data
        function startClockedInRefresh() {
            // Initial load
            renderCurrentlyClockedIn();

            // Refresh every 45 seconds
            clockedInRefreshInterval = setInterval(() => {
                renderCurrentlyClockedIn();
            }, 45000);
        }

        // Stop auto-refresh
        function stopClockedInRefresh() {
            if (clockedInRefreshInterval) {
                clearInterval(clockedInRefreshInterval);
                clockedInRefreshInterval = null;
            }
        }

        // Open Time Clock Modal
        async function openTimeClockModal() {
            if (!currentRole) {
                alert('Please login first to use the time clock!');
                return;
            }

            document.getElementById('timeClockModal').style.display = 'block';
            document.getElementById('timeClockUserName').textContent = currentRole.name;

            // Start clock update
            updateCurrentTime();
            clockUpdateInterval = setInterval(updateCurrentTime, 1000);

            // Verify IP
            await verifyIP();

            // Update status
            await updateClockStatus();
        }

        // Close Time Clock Modal
        function closeTimeClockModal() {
            document.getElementById('timeClockModal').style.display = 'none';
            if (clockUpdateInterval) {
                clearInterval(clockUpdateInterval);
                clockUpdateInterval = null;
            }
        }

        // Update current time display
        function updateCurrentTime() {
            const now = new Date();
            const timeStr = now.toLocaleTimeString('en-US', {
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: true
            });
            const dateStr = now.toLocaleDateString('en-US', {
                weekday: 'long',
                year: 'numeric',
                month: 'long',
                day: 'numeric'
            });

            const timeEl = document.getElementById('currentTimeDisplay');
            const dateEl = document.getElementById('currentDateDisplay');
            if (timeEl) timeEl.textContent = timeStr;
            if (dateEl) dateEl.textContent = dateStr;
        }

        // Update clock status display
        async function updateClockStatus() {
            if (!currentRole) return;

            const lastPunch = await getUserClockStatus();
            const statusTextEl = document.getElementById('clockStatusText');
            const lastPunchEl = document.getElementById('clockLastPunch');
            const actionBtn = document.getElementById('clockActionBtn');
            const statusDisplay = document.getElementById('clockStatusDisplay');

            const isClockedIn = lastPunch && lastPunch.punch_type === 'in';

            if (isClockedIn) {
                statusTextEl.textContent = 'Clocked In';
                statusTextEl.style.color = 'var(--accent-green)';
                statusDisplay.style.borderLeft = '4px solid var(--accent-green)';

                actionBtn.textContent = 'CLOCK OUT';
                actionBtn.style.background = 'linear-gradient(135deg, var(--accent-orange), var(--accent-red))';
                actionBtn.style.borderColor = 'var(--accent-orange)';
                actionBtn.style.boxShadow = '0 10px 40px rgba(255, 107, 0, 0.4)';
            } else {
                statusTextEl.textContent = 'Clocked Out';
                statusTextEl.style.color = 'var(--accent-red)';
                statusDisplay.style.borderLeft = '4px solid var(--accent-red)';

                actionBtn.textContent = 'CLOCK IN';
                actionBtn.style.background = 'linear-gradient(135deg, var(--accent-green), #00aa00)';
                actionBtn.style.borderColor = 'var(--accent-green)';
                actionBtn.style.boxShadow = '0 10px 40px rgba(57, 255, 20, 0.4)';
            }

            // Update last punch time
            if (lastPunch) {
                const punchTime = new Date(lastPunch.punch_time);
                lastPunchEl.textContent = 'Last punch: ' + lastPunch.punch_type.toUpperCase() + ' at ' +
                    punchTime.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: true }) +
                    ' on ' + punchTime.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
            } else {
                lastPunchEl.textContent = 'No previous punches';
            }

            // Update hours
            await updateHoursDisplay();
        }

        // Update hours display
        async function updateHoursDisplay() {
            if (!currentRole) return;

            // Today's hours
            const todayPunches = await getTodayPunches(currentRole.name);
            const todayHours = calculateTotalHours(todayPunches);
            document.getElementById('todayHours').textContent = todayHours.toFixed(2);

            // Pay period hours
            const periodPunches = await getPayPeriodPunches(currentRole.name);
            const periodHours = calculateTotalHours(periodPunches);
            document.getElementById('payPeriodHours').textContent = periodHours.toFixed(2);
        }

        // Perform clock action (in or out)
        async function performClockAction() {
            if (!currentRole || !supabaseClient) {
                alert('Please login first!');
                return;
            }

            // Check IP verification
            if (!ipVerified && AUTHORIZED_IPS.length > 0) {
                const isAdmin = currentRole.name.includes('Ryan');
                if (!isAdmin) {
                    alert('You must be at the work location to clock in/out.\n\nYour IP: ' + currentUserIP);
                    return;
                }
            }

            const lastPunch = await getUserClockStatus();
            const isClockedIn = lastPunch && lastPunch.punch_type === 'in';
            const newPunchType = isClockedIn ? 'out' : 'in';

            // Get role key from currentRole
            let roleKey = 'unknown';
            for (const [key, role] of Object.entries(ROLES)) {
                if (role.name === currentRole.name) {
                    roleKey = key;
                    break;
                }
            }

            try {
                const { data, error } = await supabaseClient
                    .from('timeclock')
                    .insert([{
                        user_name: currentRole.name,
                        user_role: roleKey,
                        punch_type: newPunchType,
                        punch_time: new Date().toISOString(),
                        ip_address: currentUserIP || 'unknown'
                    }]);

                if (error) throw error;

                // Update display
                await updateClockStatus();

                // Check for overtime on clock out
                if (newPunchType === 'out') {
                    await checkOvertime();
                }

                // Show success feedback
                const actionBtn = document.getElementById('clockActionBtn');
                const originalText = actionBtn.textContent;
                actionBtn.textContent = 'SUCCESS!';
                setTimeout(() => {
                    updateClockStatus();
                }, 1000);

            } catch (error) {
                console.error('Clock action error:', error);
                alert('Error recording punch. Please try again.\n\n' + error.message);
            }
        }

        // Check for overtime and show alert
        async function checkOvertime() {
            if (!currentRole) return;

            const todayPunches = await getTodayPunches(currentRole.name);
            const todayHours = calculateTotalHours(todayPunches);
            const weeklyHours = await getWeeklyHours(currentRole.name);

            let alertMessage = null;

            if (todayHours > 8) {
                alertMessage = 'Daily overtime alert!\n\nYou have worked ' + todayHours.toFixed(2) + ' hours today (over 8 hours).';
            }

            if (weeklyHours > 40) {
                const overtimeWeekly = weeklyHours - 40;
                if (alertMessage) {
                    alertMessage += '\n\n';
                } else {
                    alertMessage = '';
                }
                alertMessage += 'Weekly overtime alert!\n\nYou have worked ' + weeklyHours.toFixed(2) + ' hours this week (' + overtimeWeekly.toFixed(2) + ' overtime hours).';
            }

            if (alertMessage) {
                showOvertimeAlert(alertMessage);
            }
        }

        // Show overtime alert modal
        function showOvertimeAlert(message) {
            document.getElementById('overtimeAlertMessage').textContent = message;
            document.getElementById('overtimeAlertModal').style.display = 'block';
        }

        // Close overtime alert
        function closeOvertimeAlert() {
            document.getElementById('overtimeAlertModal').style.display = 'none';
        }

        // ============================================
        // ADMIN TIMECARD FUNCTIONS
        // ============================================

        // Open Timecards Modal (Admin only)
        // Populate pay period dropdown with historical periods
        function populatePayPeriodDropdown() {
            const select = document.getElementById('timecardPayPeriodSelect');
            select.innerHTML = '';

            // Add current and previous
            const currentPeriod = getPayPeriodDates('current');
            const prevPeriod = getPayPeriodDates('previous');

            const formatRange = (period) => {
                return period.start.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }) +
                    ' - ' + period.end.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
            };

            select.innerHTML += `<option value="current">Current (${formatRange(currentPeriod)})</option>`;
            select.innerHTML += `<option value="previous">Previous (${formatRange(prevPeriod)})</option>`;

            // Add historical periods (go back 26 periods = ~1 year)
            for (let i = 2; i <= 26; i++) {
                const period = getPayPeriodDates(`previous-${i}`);
                select.innerHTML += `<option value="previous-${i}">${formatRange(period)}</option>`;
            }
        }

        async function openTimecardsModal() {
            // Check if user is admin (Ryan)
            if (!currentRole || !currentRole.name.includes('Ryan')) {
                alert('Only administrators can view timecards.');
                return;
            }

            document.getElementById('timecardsModal').style.display = 'block';

            // Populate employee dropdown
            const select = document.getElementById('timecardEmployeeSelect');
            select.innerHTML = '<option value="">Select Employee...</option>';

            // Only show hourly employees (not salaried)
            for (const [key, role] of Object.entries(ROLES)) {
                if (role.salary) continue; // Skip salaried employees
                const option = document.createElement('option');
                option.value = role.name;
                option.textContent = role.name;
                select.appendChild(option);
            }

            // Populate pay period dropdown with historical options
            populatePayPeriodDropdown();

            // Update pay period display
            updatePayPeriodDisplay();

            // Start auto-refresh for currently clocked in section
            startClockedInRefresh();
        }

        // Close Timecards Modal
        function closeTimecardsModal() {
            document.getElementById('timecardsModal').style.display = 'none';
            // Stop auto-refresh when modal closes
            stopClockedInRefresh();
        }

        // ==================== DELETED BATCHES (TRASH) ====================

        let batchToDelete = null;

        // Open Trash Modal
        async function openTrashModal() {
            if (!currentRole || !currentRole.canEditBatches) {
                alert('You do not have permission to view deleted batches.');
                return;
            }

            document.getElementById('trashModal').style.display = 'block';
            await renderTrashBatches();
        }

        // Close Trash Modal
        function closeTrashModal() {
            document.getElementById('trashModal').style.display = 'none';
        }

        // Render deleted batches
        async function renderTrashBatches() {
            const container = document.getElementById('trashBatchesList');

            try {
                const { data: deletedBatches, error } = await supabaseClient
                    .from('wm_batches')
                    .select('*')
                    .eq('status', 'deleted')
                    .order('deleted_at', { ascending: false });

                if (error) throw error;

                if (!deletedBatches || deletedBatches.length === 0) {
                    container.innerHTML = `
                        <div style="text-align: center; padding: 60px; color: var(--text-secondary);">
                            <div style="font-size: 3rem; margin-bottom: 15px;"></div>
                            <div style="font-size: 1.1rem;">No deleted batches</div>
                            <div style="font-size: 0.9rem; margin-top: 5px;">Batches you delete will appear here</div>
                        </div>
                    `;
                    return;
                }

                container.innerHTML = deletedBatches.map(batch => `
                    <div style="background: var(--bg-tertiary); border-radius: 12px; padding: 20px; margin-bottom: 15px; border-left: 4px solid #ef4444;">
                        <div style="display: flex; justify-content: space-between; align-items: flex-start; gap: 15px;">
                            <div style="flex: 1;">
                                <div style="font-weight: 700; font-size: 1.2rem; color: #ef4444; margin-bottom: 8px;">
                                    ${batch.id}
                                </div>
                                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px; font-size: 0.9rem;">
                                    <div><span style="color: var(--text-secondary);">Strain:</span> ${batch.strain || 'N/A'}</div>
                                    <div><span style="color: var(--text-secondary);">License:</span> ${batch.cultivation_license || 'N/A'}</div>
                                    <div><span style="color: var(--text-secondary);">Intake:</span> ${batch.intake_date || 'N/A'}</div>
                                    <div><span style="color: var(--text-secondary);">Deleted:</span> ${batch.deleted_at ? new Date(batch.deleted_at).toLocaleDateString() : 'N/A'}</div>
                                </div>
                                ${batch.delete_note ? `
                                    <div style="margin-top: 12px; padding: 10px; background: rgba(239, 68, 68, 0.1); border-radius: 8px;">
                                        <div style="font-size: 0.8rem; color: var(--text-secondary); margin-bottom: 4px;">Reason for deletion:</div>
                                        <div style="color: var(--text-primary);">${batch.delete_note}</div>
                                    </div>
                                ` : ''}
                                <div style="margin-top: 8px; font-size: 0.85rem; color: var(--text-secondary);">
                                    Deleted by: ${batch.deleted_by || 'Unknown'}
                                </div>
                            </div>
                        </div>
                    </div>
                `).join('');

            } catch (error) {
                console.error('Error loading deleted batches:', error);
                container.innerHTML = `
                    <div style="text-align: center; padding: 40px; color: #ef4444;">
                        Error loading deleted batches: ${error.message}
                    </div>
                `;
            }
        }

        // Open delete batch confirmation modal
        function openDeleteBatchModal(batchId) {
            if (!currentRole || !currentRole.canEditBatches) {
                alert('You do not have permission to delete batches.');
                return;
            }

            const batch = batches.find(b => b.id === batchId);
            if (!batch) {
                alert('Batch not found.');
                return;
            }

            batchToDelete = batch;
            document.getElementById('deleteBatchId').textContent = batch.id;
            document.getElementById('deleteBatchInfo').textContent = `${batch.strain || 'Unknown strain'}  ${batch.cultivation_license || 'No license'}  Status: ${batch.status}`;
            document.getElementById('deleteNoteInput').value = '';
            document.getElementById('deleteBatchModal').style.display = 'block';
        }

        // Close delete batch modal
        function closeDeleteBatchModal() {
            document.getElementById('deleteBatchModal').style.display = 'none';
            batchToDelete = null;
        }

        // Confirm and execute batch deletion
        async function confirmDeleteBatch() {
            if (!batchToDelete) return;

            const deleteNote = document.getElementById('deleteNoteInput').value.trim();
            if (!deleteNote) {
                alert('Please enter a reason for deleting this batch.');
                return;
            }

            try {
                const { error } = await supabaseClient
                    .from('wm_batches')
                    .update({
                        status: 'deleted',
                        deleted_at: new Date().toISOString(),
                        deleted_by: currentRole.name,
                        delete_note: deleteNote
                    })
                    .eq('id', batchToDelete.id);

                if (error) throw error;

                alert(` Batch ${batchToDelete.id} has been deleted.`);
                closeDeleteBatchModal();
                await loadBatches();

            } catch (error) {
                console.error('Error deleting batch:', error);
                alert('Error deleting batch: ' + error.message);
            }
        }

        // ==================== END DELETED BATCHES ====================

        // Update pay period display
        function updatePayPeriodDisplay() {
            const periodType = document.getElementById('timecardPayPeriodSelect').value;
            const period = getPayPeriodDates(periodType);

            const dateStr = period.start.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' }) +
                ' - ' + period.end.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });

            document.getElementById('timecardPeriodDates').textContent = dateStr;
        }

        // Load employee timecard
        async function loadEmployeeTimecard() {
            const employeeName = document.getElementById('timecardEmployeeSelect').value;
            const periodType = document.getElementById('timecardPayPeriodSelect').value;

            updatePayPeriodDisplay();

            if (!employeeName) {
                document.getElementById('timecardTableBody').innerHTML =
                    '<tr><td colspan="7" style="padding: 40px; text-align: center; color: var(--text-secondary);">Select an employee to view their timecard</td></tr>';
                document.getElementById('timecardSummary').style.display = 'none';
                return;
            }

            const punches = await getPayPeriodPunches(employeeName, periodType);
            renderTimecard(punches);
        }

        // Render timecard table
        function renderTimecard(punches) {
            const tbody = document.getElementById('timecardTableBody');
            const summary = document.getElementById('timecardSummary');

            if (!punches || punches.length === 0) {
                tbody.innerHTML = '<tr><td colspan="7" style="padding: 40px; text-align: center; color: var(--text-secondary);">No time records found for this period</td></tr>';
                summary.style.display = 'none';
                return;
            }

            // First, pair IN/OUT punches chronologically (handles overnight shifts)
            const shifts = [];
            for (let i = 0; i < punches.length; i++) {
                const punch = punches[i];
                if (punch.punch_type === 'in') {
                    const shift = {
                        inPunch: punch,
                        outPunch: null,
                        inTime: punch.punch_time,
                        outTime: null,
                        hours: 0,
                        date: new Date(punch.punch_time).toLocaleDateString('en-US') // Use IN punch date as shift date
                    };

                    // Look for matching OUT punch (may be next in sequence, even if on a different day)
                    const nextPunch = punches[i + 1];
                    if (nextPunch && nextPunch.punch_type === 'out') {
                        shift.outPunch = nextPunch;
                        shift.outTime = nextPunch.punch_time;
                        shift.hours = calculateHours(shift.inTime, shift.outTime);
                        i++; // Skip the OUT punch since we paired it
                    } else {
                        // Still clocked in - calculate to now
                        shift.outTime = null;
                        shift.hours = calculateHours(shift.inTime, new Date());
                    }

                    shifts.push(shift);
                }
                // Note: Orphaned OUT punches (no preceding IN) are ignored
            }

            // Group shifts by date (using the IN punch date)
            const shiftsByDate = {};
            shifts.forEach(shift => {
                if (!shiftsByDate[shift.date]) {
                    shiftsByDate[shift.date] = [];
                }
                shiftsByDate[shift.date].push(shift);
            });

            let html = '';
            let totalHours = 0;
            let totalDays = 0;

            // Sort dates
            const sortedDates = Object.keys(shiftsByDate).sort((a, b) => new Date(a) - new Date(b));

            sortedDates.forEach(date => {
                const dayShifts = shiftsByDate[date];
                const dayHours = dayShifts.reduce((sum, shift) => sum + shift.hours, 0);
                totalHours += dayHours;
                totalDays++;

                // Render each shift for this day
                dayShifts.forEach((shift, index) => {
                    const inTime = new Date(shift.inTime);
                    const inTimeStr = inTime.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: true });

                    let outTimeStr;
                    if (shift.outTime) {
                        const outTime = new Date(shift.outTime);
                        outTimeStr = outTime.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: true });
                    } else {
                        outTimeStr = '<span style="color: var(--accent-orange);">Still In</span>';
                    }

                    const isFirst = index === 0;
                    html += '<tr style="border-bottom: 1px solid var(--border);">';
                    html += '<td style="padding: 12px; color: var(--text-primary);">' + (isFirst ? new Date(date).toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' }) : '') + '</td>';
                    html += '<td style="padding: 12px; text-align: center; color: var(--accent-green);">' + inTimeStr + '</td>';
                    html += '<td style="padding: 12px; text-align: center; color: var(--accent-orange);">' + outTimeStr + '</td>';
                    html += '<td style="padding: 12px; text-align: right; color: var(--accent-blue);">' + shift.hours.toFixed(2) + '</td>';
                    html += '<td style="padding: 12px; text-align: right; font-weight: 600; color: ' + (dayHours > 8 ? 'var(--accent-orange)' : 'var(--accent-green)') + ';">' + (isFirst ? dayHours.toFixed(2) : '') + '</td>';

                    // Check if this is a sick day
                    const isSickDay = shift.inPunch.ip_address && shift.inPunch.ip_address.includes('sick-day');
                    const sickDayNote = isSickDay ? '<span style="color: var(--accent-blue); font-weight: 600;"> Sick Day</span>' : '';
                    html += '<td style="padding: 12px; text-align: center;">' + sickDayNote + '</td>';

                    const outPunchId = shift.outPunch ? shift.outPunch.id : 'null';
                    html += '<td style="padding: 12px; text-align: center;"><button onclick="openEditShiftModal(' + shift.inPunch.id + ', ' + outPunchId + ')" style="padding: 6px 12px; background: var(--accent-blue); border: none; border-radius: 4px; color: white; cursor: pointer; font-size: 0.75rem;" title="Edit Shift">Edit</button></td>';
                    html += '</tr>';
                });
            });

            tbody.innerHTML = html;

            // Calculate overtime per week (40 hours per week)
            // Group hours by week (Saturday = start of week)
            const hoursByWeek = {};
            sortedDates.forEach(date => {
                const dateObj = new Date(date);
                // Get Saturday of this week (Saturday = day 6)
                const dayOfWeek = dateObj.getDay();
                const daysFromSaturday = (dayOfWeek + 1) % 7; // Sat=0, Sun=1, Mon=2, etc.
                const saturday = new Date(dateObj);
                saturday.setDate(dateObj.getDate() - daysFromSaturday);
                const weekKey = saturday.toISOString().split('T')[0];

                const dayShifts = shiftsByDate[date];
                const dayHours = dayShifts.reduce((sum, shift) => sum + shift.hours, 0);

                if (!hoursByWeek[weekKey]) hoursByWeek[weekKey] = 0;
                hoursByWeek[weekKey] += dayHours;
            });

            // Calculate regular and overtime per week
            let regularHours = 0;
            let overtimeHours = 0;
            Object.values(hoursByWeek).forEach(weekHours => {
                regularHours += Math.min(weekHours, 40);
                overtimeHours += Math.max(0, weekHours - 40);
            });

            document.getElementById('summaryRegularHours').textContent = regularHours.toFixed(2);
            document.getElementById('summaryOvertimeHours').textContent = overtimeHours.toFixed(2);
            document.getElementById('summaryTotalHours').textContent = totalHours.toFixed(2);
            document.getElementById('summaryDaysWorked').textContent = totalDays;

            summary.style.display = 'block';
        }

        // Print/Export timecard
        // Edit punch time functions
        let currentEditPunch = null;
        
        async function openEditPunchModal(punchId) {
            // Fetch the punch record
            const { data: punch, error } = await supabaseClient
                .from('timeclock')
                .select('*')
                .eq('id', punchId)
                .single();
            
            if (error || !punch) {
                alert('Error loading punch record');
                return;
            }
            
            currentEditPunch = punch;
            
            // Populate modal
            document.getElementById('editPunchEmployee').textContent = punch.user_name;
            document.getElementById('editPunchType').innerHTML = punch.punch_type === 'in' 
                ? '<span style="color: var(--accent-green);">Clock In</span>' 
                : '<span style="color: var(--accent-orange);">Clock Out</span>';
            
            const punchTime = new Date(punch.punch_time);
            document.getElementById('editPunchOriginal').textContent = punchTime.toLocaleString();
            
            // Set datetime-local input value
            const localDateTime = new Date(punchTime.getTime() - punchTime.getTimezoneOffset() * 60000)
                .toISOString().slice(0, 16);
            document.getElementById('editPunchNewTime').value = localDateTime;
            document.getElementById('editPunchReason').value = '';
            document.getElementById('editPunchId').value = punchId;
            
            document.getElementById('editPunchModal').style.display = 'block';
        }
        
        function closeEditPunchModal() {
            document.getElementById('editPunchModal').style.display = 'none';
            currentEditPunch = null;
        }
        
        async function saveEditedPunch() {
            const punchId = document.getElementById('editPunchId').value;
            const newTimeInput = document.getElementById('editPunchNewTime').value;
            const reason = document.getElementById('editPunchReason').value.trim();
            
            if (!newTimeInput) {
                alert('Please select a new date and time');
                return;
            }
            
            if (!reason) {
                alert('Please provide a reason for this adjustment');
                return;
            }
            
            const newTime = new Date(newTimeInput).toISOString();
            const originalTime = currentEditPunch.punch_time;
            
            // Update the punch record
            const { error } = await supabaseClient
                .from('timeclock')
                .update({ punch_time: newTime })
                .eq('id', punchId);
            
            if (error) {
                console.error('Error updating punch:', error);
                alert('Error saving changes. The database may need additional columns. Please check console.');
                return;
            }
            
            alert('Punch time updated successfully!\n\nOriginal: ' + new Date(originalTime).toLocaleString() + '\nNew: ' + new Date(newTime).toLocaleString() + '\nReason: ' + reason);
            
            closeEditPunchModal();
            
            // Refresh the timecard
            const selectedEmployee = document.getElementById('timecardEmployeeSelect').value;
            if (selectedEmployee) {
                loadEmployeeTimecard(selectedEmployee);
            }
        }

        async function openAddClockOutModal(punchId) {
            const { data: punch, error } = await supabaseClient
                .from('timeclock')
                .select('*')
                .eq('id', punchId)
                .single();
            if (error || !punch) { alert('Error loading punch record'); return; }
            document.getElementById('addClockOutEmployee').textContent = punch.user_name;
            document.getElementById('addClockOutClockInTime').textContent = new Date(punch.punch_time).toLocaleString();
            const now = new Date();
            const localDateTime = new Date(now.getTime() - now.getTimezoneOffset() * 60000).toISOString().slice(0, 16);
            document.getElementById('addClockOutTime').value = localDateTime;
            document.getElementById('addClockOutClockInId').value = punchId;
            document.getElementById('addClockOutReason').value = '';
            document.getElementById('addClockOutModal').style.display = 'block';
        }

        function closeAddClockOutModal() {
            document.getElementById('addClockOutModal').style.display = 'none';
        }

        async function saveAddClockOut() {
            const clockInPunchId = document.getElementById('addClockOutClockInId').value;
            const clockOutTime = document.getElementById('addClockOutTime').value;
            const reason = document.getElementById('addClockOutReason').value.trim();
            if (!clockOutTime) { alert('Please select a clock out time'); return; }
            if (!reason) { alert('Please provide a reason'); return; }
            const { data: clockInPunch, error: fetchError } = await supabaseClient
                .from('timeclock')
                .select('*')
                .eq('id', clockInPunchId)
                .single();
            if (fetchError || !clockInPunch) { alert('Error loading clock-in record'); return; }
            const { error } = await supabaseClient
                .from('timeclock')
                .insert([{
                    user_name: clockInPunch.user_name,
                    user_role: clockInPunch.user_role,
                    punch_type: 'out',
                    punch_time: new Date(clockOutTime).toISOString(),
                    ip_address: 'admin-manual'
                }]);
            if (error) { alert('Error adding clock out: ' + error.message); return; }
            alert('Clock out added for ' + clockInPunch.user_name + '!\n\nTime: ' + new Date(clockOutTime).toLocaleString() + '\nReason: ' + reason);
            closeAddClockOutModal();
            const selectedEmployee = document.getElementById('timecardEmployeeSelect').value;
            if (selectedEmployee) { loadEmployeeTimecard(selectedEmployee); }
        }

        // Edit Shift functions
        async function openEditShiftModal(inPunchId, outPunchId) {
            const { data: inPunch, error: inError } = await supabaseClient
                .from('timeclock')
                .select('*')
                .eq('id', inPunchId)
                .single();
            if (inError || !inPunch) { alert('Error loading clock-in record'); return; }

            document.getElementById('editShiftEmployee').textContent = inPunch.user_name;
            document.getElementById('editShiftDate').textContent = new Date(inPunch.punch_time).toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric', year: 'numeric' });
            document.getElementById('editShiftInPunchId').value = inPunchId;
            document.getElementById('editShiftOutPunchId').value = outPunchId || '';

            const inTime = new Date(inPunch.punch_time);
            const inTimeLocal = new Date(inTime.getTime() - inTime.getTimezoneOffset() * 60000).toISOString().slice(0, 16);
            document.getElementById('editShiftInTime').value = inTimeLocal;

            if (outPunchId && outPunchId !== 'null') {
                const { data: outPunch, error: outError } = await supabaseClient
                    .from('timeclock')
                    .select('*')
                    .eq('id', outPunchId)
                    .single();
                if (outPunch) {
                    const outTime = new Date(outPunch.punch_time);
                    const outTimeLocal = new Date(outTime.getTime() - outTime.getTimezoneOffset() * 60000).toISOString().slice(0, 16);
                    document.getElementById('editShiftOutTime').value = outTimeLocal;
                }
            } else {
                document.getElementById('editShiftOutTime').value = '';
            }

            document.getElementById('editShiftReason').value = '';
            document.getElementById('editShiftModal').style.display = 'block';
        }

        function closeEditShiftModal() {
            document.getElementById('editShiftModal').style.display = 'none';
        }

        // Sick Day functions
        function openAddSickDayModal() {
            // Populate employee dropdown
            const select = document.getElementById('sickDayEmployee');
            select.innerHTML = '';
            Object.entries(ROLES).forEach(([key, role]) => {
                if (!role.isDemo && !role.salary) {
                    const option = document.createElement('option');
                    option.value = role.name;
                    option.textContent = role.displayName || role.name;
                    select.appendChild(option);
                }
            });

            // Set default date to today
            const today = new Date();
            const dateStr = today.toISOString().split('T')[0];
            document.getElementById('sickDayDate').value = dateStr;
            document.getElementById('sickDayHours').value = '8';
            document.getElementById('sickDayNotes').value = '';

            document.getElementById('addSickDayModal').style.display = 'block';
        }

        function closeAddSickDayModal() {
            document.getElementById('addSickDayModal').style.display = 'none';
        }

        async function saveSickDay() {
            const employeeName = document.getElementById('sickDayEmployee').value;
            const dateStr = document.getElementById('sickDayDate').value;
            const hours = parseFloat(document.getElementById('sickDayHours').value) || 8;
            const notes = document.getElementById('sickDayNotes').value.trim();

            if (!employeeName) { alert('Please select an employee'); return; }
            if (!dateStr) { alert('Please select a date'); return; }

            // Create clock in at 8am and clock out after X hours
            const clockInTime = new Date(dateStr + 'T08:00:00');
            const clockOutTime = new Date(clockInTime.getTime() + (hours * 60 * 60 * 1000));

            // Find the role to get user_role
            const roleEntry = Object.entries(ROLES).find(([key, role]) => role.name === employeeName);
            const userRole = roleEntry ? roleEntry[0] : 'unknown';

            // Insert clock in punch
            const { error: inError } = await supabaseClient
                .from('timeclock')
                .insert([{
                    user_name: employeeName,
                    user_role: userRole,
                    punch_type: 'in',
                    punch_time: clockInTime.toISOString(),
                    ip_address: 'sick-day' + (notes ? ': ' + notes : '')
                }]);

            if (inError) { alert('Error adding sick day clock in: ' + inError.message); return; }

            // Insert clock out punch
            const { error: outError } = await supabaseClient
                .from('timeclock')
                .insert([{
                    user_name: employeeName,
                    user_role: userRole,
                    punch_type: 'out',
                    punch_time: clockOutTime.toISOString(),
                    ip_address: 'sick-day' + (notes ? ': ' + notes : '')
                }]);

            if (outError) { alert('Error adding sick day clock out: ' + outError.message); return; }

            alert(' Sick day added for ' + employeeName + '!\n\nDate: ' + new Date(dateStr).toLocaleDateString() + '\nHours: ' + hours);
            closeAddSickDayModal();

            // Refresh timecard if viewing
            const selectedEmployee = document.getElementById('timecardEmployeeSelect').value;
            if (selectedEmployee) { loadEmployeeTimecard(selectedEmployee); }
        }

        async function saveEditedShift() {
            const inPunchId = document.getElementById('editShiftInPunchId').value;
            const outPunchId = document.getElementById('editShiftOutPunchId').value;
            const newInTime = document.getElementById('editShiftInTime').value;
            const newOutTime = document.getElementById('editShiftOutTime').value;
            const reason = document.getElementById('editShiftReason').value.trim();

            if (!newInTime) { alert('Please enter a clock in time'); return; }
            if (!reason) { alert('Please provide a reason for the adjustment'); return; }

            // Update the clock in punch
            const { error: inError } = await supabaseClient
                .from('timeclock')
                .update({ punch_time: new Date(newInTime).toISOString() })
                .eq('id', inPunchId);
            if (inError) { alert('Error updating clock in: ' + inError.message); return; }

            // Handle clock out
            if (newOutTime) {
                if (outPunchId && outPunchId !== 'null' && outPunchId !== '') {
                    // Update existing out punch
                    const { error: outError } = await supabaseClient
                        .from('timeclock')
                        .update({ punch_time: new Date(newOutTime).toISOString() })
                        .eq('id', outPunchId);
                    if (outError) { alert('Error updating clock out: ' + outError.message); return; }
                } else {
                    // Create new out punch
                    const { data: inPunch } = await supabaseClient
                        .from('timeclock')
                        .select('*')
                        .eq('id', inPunchId)
                        .single();
                    if (inPunch) {
                        const { error: insertError } = await supabaseClient
                            .from('timeclock')
                            .insert([{
                                user_name: inPunch.user_name,
                                user_role: inPunch.user_role,
                                punch_type: 'out',
                                punch_time: new Date(newOutTime).toISOString(),
                                ip_address: 'admin-adjusted'
                            }]);
                        if (insertError) { alert('Error adding clock out: ' + insertError.message); return; }
                    }
                }
            }

            alert('Shift updated successfully!\n\nReason: ' + reason);
            closeEditShiftModal();
            const selectedEmployee = document.getElementById('timecardEmployeeSelect').value;
            if (selectedEmployee) { loadEmployeeTimecard(selectedEmployee); }
        }

        function printTimecard() {
            const employeeName = document.getElementById('timecardEmployeeSelect').value;
            if (!employeeName) {
                alert('Please select an employee first.');
                return;
            }

            const periodDates = document.getElementById('timecardPeriodDates').textContent;
            const table = document.getElementById('timecardTable').outerHTML;
            const summary = document.getElementById('timecardSummary').innerHTML;

            const printWindow = window.open('', '_blank');
            printWindow.document.write(`
                <!DOCTYPE html>
                <html>
                <head>
                    <title>Timecard - ${employeeName}</title>
                    <style>
                        body { font-family: Arial, sans-serif; padding: 20px; }
                        h1 { color: #333; }
                        h2 { color: #666; font-size: 1.2rem; }
                        table { width: 100%; border-collapse: collapse; margin: 20px 0; }
                        th, td { border: 1px solid #ddd; padding: 10px; text-align: left; }
                        th { background: #f5f5f5; }
                        .summary { margin-top: 30px; padding: 20px; background: #f9f9f9; border-radius: 8px; }
                        .summary h3 { margin-top: 0; }
                        @media print {
                            body { padding: 0; }
                            button { display: none; }
                        }
                    </style>
                </head>
                <body>
                    <h1>Employee Timecard</h1>
                    <h2>${employeeName}</h2>
                    <p>Pay Period: ${periodDates}</p>
                    ${table}
                    <div class="summary">
                        ${summary}
                    </div>
                    <button onclick="window.print()" style="margin-top: 20px; padding: 10px 20px; cursor: pointer;">Print</button>
                </body>
                </html>
            `);
            printWindow.document.close();
        }

        // Export all employee timecards as a single CSV file for payroll
        async function exportAllTimecards() {
            if (!supabaseClient) {
                alert('Database not connected');
                return;
            }

            const periodType = document.getElementById('timecardPayPeriodSelect').value;
            const period = getPayPeriodDates(periodType);

            const periodLabel = period.start.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }) +
                ' - ' + period.end.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });

            try {
                // Get current employee names from wm_employees
                const { data: employees } = await supabaseClient
                    .from('wm_employees')
                    .select('name');

                // Create mapping from first name to full name
                const nameMapping = {};
                if (employees) {
                    employees.forEach(emp => {
                        const firstName = emp.name.split(' ')[0];
                        nameMapping[firstName] = emp.name;
                        nameMapping[emp.name] = emp.name; // Also map full name to itself
                    });
                }

                // Get all punches for the pay period
                const { data: allPunches, error } = await supabaseClient
                    .from('timeclock')
                    .select('*')
                    .gte('punch_time', period.start.toISOString())
                    .lte('punch_time', period.end.toISOString())
                    .order('user_name', { ascending: true })
                    .order('punch_time', { ascending: true });

                if (error) throw error;

                if (!allPunches || allPunches.length === 0) {
                    alert('No timecard data found for this pay period.');
                    return;
                }

                // Group by employee (using full name from mapping)
                const employeeData = {};
                allPunches.forEach(punch => {
                    // Map old name to current full name
                    const fullName = nameMapping[punch.user_name] || punch.user_name;
                    if (!employeeData[fullName]) {
                        employeeData[fullName] = [];
                    }
                    employeeData[fullName].push(punch);
                });

                // Sort employees by last name initial (assumes "First Last" format)
                const sortedEmployeeNames = Object.keys(employeeData).sort((a, b) => {
                    const getLastNameInitial = (name) => {
                        const parts = name.trim().split(' ');
                        const lastName = parts.length > 1 ? parts[parts.length - 1] : parts[0];
                        return lastName.charAt(0).toUpperCase();
                    };
                    return getLastNameInitial(a).localeCompare(getLastNameInitial(b));
                });

                // Build CSV content
                let csv = 'PAYROLL EXPORT - ' + periodLabel + '\n';
                csv += 'Generated: ' + new Date().toLocaleString() + '\n\n';

                let grandTotalRegular = 0;
                let grandTotalOvertime = 0;

                for (const employeeName of sortedEmployeeNames) {
                    const punches = employeeData[employeeName];
                    csv += '\n';
                    csv += '"EMPLOYEE: ' + employeeName + '"\n';
                    csv += 'Date,Clock In,Clock Out,Hours,OT Hours,Notes\n';

                    // First, pair IN/OUT punches chronologically (handles overnight shifts)
                    const shifts = [];
                    for (let i = 0; i < punches.length; i++) {
                        const punch = punches[i];
                        if (punch.punch_type === 'in') {
                            const shift = {
                                inPunch: punch,
                                outPunch: null,
                                inTime: punch.punch_time,
                                outTime: null,
                                hours: 0,
                                date: new Date(punch.punch_time).toLocaleDateString('en-US') // Use IN punch date
                            };

                            // Look for matching OUT punch (may be on a different day)
                            const nextPunch = punches[i + 1];
                            if (nextPunch && nextPunch.punch_type === 'out') {
                                shift.outPunch = nextPunch;
                                shift.outTime = nextPunch.punch_time;
                                const inDate = new Date(shift.inTime);
                                const outDate = new Date(shift.outTime);
                                shift.hours = (outDate - inDate) / (1000 * 60 * 60);
                                i++; // Skip the OUT punch since we paired it
                            } else {
                                // Still clocked in - don't count hours in payroll export
                                shift.hours = 0;
                            }

                            shifts.push(shift);
                        }
                        // Orphaned OUT punches are ignored
                    }

                    // Group shifts by date and calculate week key for each
                    const shiftsByDate = {};
                    shifts.forEach(shift => {
                        if (!shiftsByDate[shift.date]) {
                            shiftsByDate[shift.date] = [];
                        }
                        shiftsByDate[shift.date].push(shift);
                    });

                    // Sort dates chronologically
                    const sortedDates = Object.keys(shiftsByDate).sort((a, b) => new Date(a) - new Date(b));

                    // Track cumulative hours per week for OT calculation
                    const weekCumulativeHours = {};
                    let employeeTotalHours = 0;

                    // Track daily OT (over 12hr shifts) and weekly hours (excluding sick)
                    let totalDailyOT = 0;
                    const weekNonSickHours = {}; // Only non-sick hours count towards 40hr weekly OT

                    for (const date of sortedDates) {
                        const dayShifts = shiftsByDate[date];

                        // Get week key for this date (Saturday start)
                        const dateObj = new Date(date);
                        const dayOfWeek = dateObj.getDay();
                        const daysFromSaturday = (dayOfWeek + 1) % 7;
                        const saturday = new Date(dateObj);
                        saturday.setDate(dateObj.getDate() - daysFromSaturday);
                        const weekKey = saturday.toISOString().split('T')[0];

                        if (!weekCumulativeHours[weekKey]) weekCumulativeHours[weekKey] = 0;
                        if (!weekNonSickHours[weekKey]) weekNonSickHours[weekKey] = 0;

                        dayShifts.forEach(shift => {
                            const inTime = new Date(shift.inTime);
                            const inTimeStr = inTime.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });

                            let outTimeStr = 'Still In';
                            if (shift.outTime) {
                                const outTime = new Date(shift.outTime);
                                outTimeStr = outTime.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
                            }

                            const isSickDay = shift.inPunch.ip_address && shift.inPunch.ip_address.includes('sick-day');
                            const sickNote = isSickDay ? 'Sick Day' : '';

                            // Daily OT: hours over 12 in a single shift (not for sick days)
                            const shiftDailyOT = (!isSickDay && shift.hours > 12) ? shift.hours - 12 : 0;
                            totalDailyOT += shiftDailyOT;

                            // Add all hours to cumulative for display
                            weekCumulativeHours[weekKey] += shift.hours;

                            // Only non-sick hours count towards 40hr weekly OT
                            if (!isSickDay) {
                                weekNonSickHours[weekKey] += shift.hours;
                            }

                            // Calculate accumulated weekly OT (hours over 40, excluding sick)
                            const accumulatedWeeklyOT = Math.max(0, weekNonSickHours[weekKey] - 40);
                            // Total accumulated OT = daily OT so far + weekly OT
                            const accumulatedOT = totalDailyOT + accumulatedWeeklyOT - shiftDailyOT + (shiftDailyOT > 0 ? shiftDailyOT : Math.max(0, weekNonSickHours[weekKey] - 40) - Math.max(0, weekNonSickHours[weekKey] - shift.hours - 40));

                            csv += '"' + date + '",' + inTimeStr + ',' + outTimeStr + ',' + shift.hours.toFixed(2) + ',' + accumulatedWeeklyOT.toFixed(2) + (shiftDailyOT > 0 ? ' (+' + shiftDailyOT.toFixed(2) + ' daily)' : '') + ',"' + sickNote + '"\n';
                        });

                        employeeTotalHours += dayShifts.reduce((sum, s) => sum + s.hours, 0);
                    }

                    // Calculate final overtime
                    let weeklyOT = 0;
                    Object.values(weekNonSickHours).forEach(weekHours => {
                        weeklyOT += Math.max(0, weekHours - 40);
                    });
                    const totalOT = totalDailyOT + weeklyOT;
                    const regularHours = employeeTotalHours - totalOT;

                    csv += '\n';
                    csv += 'TOTAL HOURS,' + employeeTotalHours.toFixed(2) + '\n';
                    csv += 'Regular Hours,' + regularHours.toFixed(2) + '\n';
                    csv += 'Daily OT (over 12hr shifts),' + totalDailyOT.toFixed(2) + '\n';
                    csv += 'Weekly OT (over 40hr/week),' + weeklyOT.toFixed(2) + '\n';
                    csv += 'TOTAL OVERTIME,' + totalOT.toFixed(2) + '\n';

                    grandTotalRegular += regularHours;
                    grandTotalOvertime += totalOT;
                }

                // Grand totals
                csv += '\n';
                csv += '"GRAND TOTALS"\n';
                csv += 'Total Regular Hours,' + grandTotalRegular.toFixed(2) + '\n';
                csv += 'Total Overtime Hours,' + grandTotalOvertime.toFixed(2) + '\n';
                csv += 'Total All Hours,' + (grandTotalRegular + grandTotalOvertime).toFixed(2) + '\n';

                // Download the file
                const blob = new Blob([csv], { type: 'text/csv' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'Payroll_' + period.start.toISOString().split('T')[0] + '_to_' + period.end.toISOString().split('T')[0] + '.csv';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                alert('Payroll export downloaded!\n\nFile includes all ' + Object.keys(employeeData).length + ' employees for ' + periodLabel);

            } catch (error) {
                console.error('Export error:', error);
                alert('Error exporting timecards: ' + error.message);
            }
        }

        // Export timecards in QuickBooks-compatible CSV format
        async function exportForQuickBooks() {
            if (!supabaseClient) {
                alert('Database not connected');
                return;
            }

            const periodType = document.getElementById('timecardPayPeriodSelect').value;
            const period = getPayPeriodDates(periodType);

            try {
                // Get all punches for the pay period
                const { data: allPunches, error } = await supabaseClient
                    .from('timeclock')
                    .select('*')
                    .gte('punch_time', period.start.toISOString())
                    .lte('punch_time', period.end.toISOString())
                    .order('user_name', { ascending: true })
                    .order('punch_time', { ascending: true });

                if (error) throw error;

                if (!allPunches || allPunches.length === 0) {
                    alert('No timecard data found for this pay period.');
                    return;
                }

                // QuickBooks Time Import CSV Header
                // Format: Employee, Date, Hours, Payroll Item, Customer:Job, Notes
                let csv = 'Employee,Date,Hours,Payroll Item,Service Item,Notes\n';

                // Group by employee
                const employeeData = {};
                allPunches.forEach(punch => {
                    if (!employeeData[punch.user_name]) {
                        employeeData[punch.user_name] = [];
                    }
                    employeeData[punch.user_name].push(punch);
                });

                let totalRows = 0;

                for (const [employeeName, punches] of Object.entries(employeeData)) {
                    // Remove role suffix for cleaner QB import (e.g., "Ryan (Admin)" -> "Ryan")
                    const cleanName = employeeName.replace(/\s*\([^)]*\)\s*/g, '').trim();

                    // First, pair IN/OUT punches chronologically (handles overnight shifts)
                    const shifts = [];
                    for (let i = 0; i < punches.length; i++) {
                        const punch = punches[i];
                        if (punch.punch_type === 'in') {
                            const shift = {
                                inTime: punch.punch_time,
                                outTime: null,
                                hours: 0,
                                date: new Date(punch.punch_time).toLocaleDateString('en-US')
                            };

                            // Look for matching OUT punch (may be on a different day)
                            const nextPunch = punches[i + 1];
                            if (nextPunch && nextPunch.punch_type === 'out') {
                                shift.outTime = nextPunch.punch_time;
                                const inDate = new Date(shift.inTime);
                                const outDate = new Date(shift.outTime);
                                shift.hours = (outDate - inDate) / (1000 * 60 * 60);
                                i++; // Skip the OUT punch since we paired it
                            }
                            // Only include completed shifts (with OUT punch) in payroll
                            if (shift.outTime) {
                                shifts.push(shift);
                            }
                        }
                    }

                    // Group shifts by date
                    const shiftsByDate = {};
                    shifts.forEach(shift => {
                        if (!shiftsByDate[shift.date]) {
                            shiftsByDate[shift.date] = [];
                        }
                        shiftsByDate[shift.date].push(shift);
                    });

                    // Group dates by week (Sunday = start of week) for weekly overtime
                    const datesByWeek = {};
                    Object.keys(shiftsByDate).forEach(date => {
                        const dateObj = new Date(date);
                        const dayOfWeek = dateObj.getDay();
                        const sunday = new Date(dateObj);
                        sunday.setDate(dateObj.getDate() - dayOfWeek);
                        const weekKey = sunday.toISOString().split('T')[0];
                        if (!datesByWeek[weekKey]) datesByWeek[weekKey] = [];
                        datesByWeek[weekKey].push(date);
                    });

                    // Process each week to calculate weekly overtime
                    for (const [weekKey, dates] of Object.entries(datesByWeek)) {
                        // Sort dates within the week
                        dates.sort((a, b) => new Date(a) - new Date(b));

                        let weeklyHoursUsed = 0;

                        for (const date of dates) {
                            const dayShifts = shiftsByDate[date];
                            let dayHours = 0;

                            // Calculate total hours for the day
                            dayShifts.forEach(shift => {
                                dayHours += shift.hours;
                            });

                            if (dayHours > 0) {
                                // Determine regular vs overtime based on 40hr/week
                                const regularRemaining = Math.max(0, 40 - weeklyHoursUsed);
                                const regularHours = Math.min(dayHours, regularRemaining);
                                const overtimeHours = Math.max(0, dayHours - regularRemaining);

                                weeklyHoursUsed += dayHours;

                                // Add regular hours row
                                if (regularHours > 0) {
                                    csv += `"${cleanName}",${date},${regularHours.toFixed(2)},Regular Pay,,Auto-imported from WM Tracker\n`;
                                    totalRows++;
                                }

                                // Add overtime hours row (if any)
                                if (overtimeHours > 0) {
                                    csv += `"${cleanName}",${date},${overtimeHours.toFixed(2)},Overtime,,Auto-imported from WM Tracker\n`;
                                    totalRows++;
                                }
                            }
                        }
                    }
                }

                // Download the file
                const blob = new Blob([csv], { type: 'text/csv' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'QuickBooks_TimeImport_' + period.start.toISOString().split('T')[0] + '.csv';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                alert('QuickBooks import file downloaded!\n\n' + totalRows + ' time entries ready to import.\n\nTo import in QuickBooks:\n1. Go to Employees  Enter Time  Use Weekly Timesheet\n2. Or use File  Utilities  Import  Timer Activities');

            } catch (error) {
                console.error('QB Export error:', error);
                alert('Error exporting for QuickBooks: ' + error.message);
            }
        }

        function toggleActionsMenu() {
            const dropdown = document.querySelector('.actions-dropdown');
            if (dropdown.style.display === 'block') {
                dropdown.style.display = 'none';
            } else {
                dropdown.style.display = 'block';
            }
        }

        function closeActionsMenu() {
            const dropdown = document.querySelector('.actions-dropdown');
            if (dropdown) dropdown.style.display = 'none';
        }

        // Close actions dropdown when clicking a button inside it
        document.addEventListener('DOMContentLoaded', function() {
            const dropdown = document.querySelector('.actions-dropdown');
            if (dropdown) {
                dropdown.addEventListener('click', function(e) {
                    if (e.target.tagName === 'BUTTON') {
                        // Small delay to allow the button's onclick to fire first
                        setTimeout(closeActionsMenu, 100);
                    }
                });
            }
        });

        // Initialize timeclock on page load
        async function initializeTimeclock() {
            if (supabaseClient) {
                await setupTimeclockTable();
            }
        }

        // ============================================
        // DYNAMIC CATEGORY FUNCTIONS (Multi-tenant)
        // ============================================

        let cachedBusinessCategories = null;
        let cachedBusinessCategoriesId = null;

        // Default categories for fallback (when no business selected or no mappings)
        function getDefaultCategories() {
            return [
                { key: 'Wax', label: 'Wax', color: '#F59E0B' },
                { key: 'Shatter', label: 'Shatter', color: '#3B82F6' },
                { key: 'Sugar Wax', label: 'Sugar Wax', color: '#F97316' },
                { key: 'Live Resin Carts', label: 'Live Resin Carts', color: '#10B981' },
                { key: 'Live Resin AIOs', label: 'Live Resin AIOs', color: '#8B5CF6' },
                { key: 'Brick Hash', label: 'Brick Hash', color: '#6B7280' }
            ];
        }

        // Load categories from business mappings (multi-tenant)
        async function loadBusinessCategories(forceReload = false) {
            // Return cached if same business and not forcing reload
            if (!forceReload && cachedBusinessCategories && cachedBusinessCategoriesId === currentBusinessId) {
                return cachedBusinessCategories;
            }

            try {
                let query = supabaseClient
                    .from('leaflink_product_mappings')
                    .select('app_product_type, business_id')
                    .eq('is_active', true);

                // If specific business selected, filter by it; otherwise get all mappings
                if (currentBusinessId && currentBusinessId !== 'all') {
                    query = query.eq('business_id', currentBusinessId);
                    console.log('Loading categories for business:', currentBusinessId);
                } else {
                    console.log('Loading categories for ALL businesses');
                }

                const { data, error } = await query;

                if (error) throw error;

                // If no mappings found, use defaults
                if (!data || data.length === 0) {
                    console.log('No LeafLink mappings found for business, using defaults');
                    cachedBusinessCategories = getDefaultCategories();
                    cachedBusinessCategoriesId = currentBusinessId;
                    return cachedBusinessCategories;
                }

                // Build categories from mappings with colors
                const colors = ['#F59E0B', '#3B82F6', '#F97316', '#10B981', '#8B5CF6', '#6B7280', '#EC4899', '#06B6D4'];
                const categories = [];
                const seenTypes = new Set();

                console.log('Raw mappings received:', data.length, data.map(m => m.app_product_type));

                data.forEach((mapping, i) => {
                    if (!seenTypes.has(mapping.app_product_type)) {
                        seenTypes.add(mapping.app_product_type);
                        categories.push({
                            key: mapping.app_product_type,
                            label: mapping.app_product_type,
                            color: colors[categories.length % colors.length]
                        });
                    }
                });

                console.log('Built categories:', categories.map(c => c.key));
                cachedBusinessCategories = categories;
                cachedBusinessCategoriesId = currentBusinessId;
                return categories;

            } catch (err) {
                console.error('Error loading business categories:', err);
                cachedBusinessCategories = getDefaultCategories();
                cachedBusinessCategoriesId = currentBusinessId;
                return cachedBusinessCategories;
            }
        }

        // Get product category using dynamic categories
        function getProductCategoryDynamic(productMade, categories) {
            if (!productMade || !categories) return null;
            const product = productMade.toLowerCase();

            // Sort categories by key length (longest first) so "Sugar Wax" matches before "Wax"
            const sortedCats = [...categories].sort((a, b) => b.key.length - a.key.length);

            // First pass: check for exact full category name match
            for (const cat of sortedCats) {
                const catKey = cat.key.toLowerCase();
                if (product.includes(catKey)) return cat.key;
            }

            // Check for common abbreviations (e.g., "Quackers W" = Wax, "Quackers SW" = Sugar Wax)
            // Match " W " or " W)" or ends with " W" for Wax
            if (/ sw[)\s]| sw$/.test(product)) {
                const swCat = categories.find(c => c.key.toLowerCase() === 'sugar wax');
                if (swCat) return swCat.key;
            }
            if (/ w[)\s]| w$/.test(product)) {
                const waxCat = categories.find(c => c.key.toLowerCase() === 'wax');
                if (waxCat) return waxCat.key;
            }
            if (/ s[)\s]| s$/.test(product)) {
                const shatterCat = categories.find(c => c.key.toLowerCase() === 'shatter');
                if (shatterCat) return shatterCat.key;
            }

            // Special handling for AIOs (check BEFORE carts since AIOs might contain "cart")
            if (product.includes('aio') || product.includes('all-in-one') || product.includes('all in one') || product.includes('disposable')) {
                const aioCat = categories.find(c => c.key.toLowerCase().includes('aio'));
                if (aioCat) return aioCat.key;
            }

            // Special handling for carts
            if (product.includes('cart')) {
                const cartCat = categories.find(c => c.key.toLowerCase().includes('cart') && !c.key.toLowerCase().includes('aio'));
                if (cartCat) return cartCat.key;
            }

            // Second pass: check individual significant words (but skip very short words)
            for (const cat of sortedCats) {
                const catKey = cat.key.toLowerCase();
                const catWords = catKey.split(/\s+/);
                // Only match on words 4+ chars to avoid false positives
                const significantWords = catWords.filter(word => word.length >= 4);
                if (significantWords.length > 0 && significantWords.every(word => product.includes(word))) {
                    return cat.key;
                }
            }

            return null;
        }

        // ============================================
        // SALES PIPELINE FUNCTIONS
        // ============================================

        let pipelineData = [];
        let pipelineCategoryData = {};

        function openSalesPipelineModal() {
            document.getElementById('salesPipelineModal').style.display = 'block';
            document.body.style.overflow = 'hidden';
            loadSalesPipeline();
        }

        function closeSalesPipelineModal() {
            document.getElementById('salesPipelineModal').style.display = 'none';
            document.body.style.overflow = '';
        }

        function closePipelineStrainsPopup() {
            document.getElementById('pipelineStrainsPopup').style.display = 'none';
        }

        // Get sales percentage based on material agreement
        function getSalesPercentage(materialAgreement) {
            if (!materialAgreement) return 100;
            const agreement = materialAgreement.toLowerCase();
            if (agreement.includes('house') || agreement.includes('wholesale') || agreement === 'wholesale') return 100;
            if (agreement.includes('50') || agreement.includes('split') || agreement.includes('percentage')) return 50;
            if (agreement.includes('gram') || agreement.includes('buyback') || agreement.includes('buy back') || agreement.includes('buy-back')) return 0;
            return 100;
        }

        // Map product names to categories
        function getProductCategory(productMade) {
            if (!productMade) return null;
            const product = productMade.toLowerCase();

            if (product.includes('wax') && !product.includes('sugar')) return 'Wax';
            if (product.includes('sugar')) return 'Sugar Wax';
            if (product.includes('shatter')) return 'Shatter';
            if (product.includes('cart') || product === 'live resin oil') return 'Live Resin Carts';
            if (product.includes('aio') || product.includes('all-in-one') || product.includes('all in one')) return 'Live Resin AIOs';
            if (product.includes('brick') || product.includes('hash')) return 'Brick Hash';

            return null;
        }

        async function loadSalesPipeline() {
            // If batches not loaded yet, retry after delay
            if (!batches || batches.length === 0) {
                console.log('Pipeline: batches not loaded yet, retrying in 2s...');
                setTimeout(loadSalesPipeline, 2000);
                return;
            }

            // Load dynamic categories from business LeafLink mappings
            const categories = await loadBusinessCategories();

            // Initialize category data
            pipelineCategoryData = {};
            categories.forEach(cat => {
                pipelineCategoryData[cat.key] = { count: 0, strains: [], color: cat.color, label: cat.label };
            });

            // Cutoff date for LeafLink auto-list tracking (Jan 8, 2026 - before this, batches weren't auto-listed)
            const leaflinkCutoffDate = new Date('2026-01-08T00:00:00');

            // Filter batches in pipeline (all stages until listed on LeafLink)
            pipelineData = batches.filter(batch => {
                // Exclude legacy 4g sub-batches (IDs ending in -4g)
                if (batch.id && batch.id.endsWith('-4g')) return false;

                const hasWeight = batch.final_weight || batch.net_weight || batch.grams_labeled;
                if (!hasWeight) return false;
                const salesPercent = getSalesPercentage(batch.material_agreement);
                if (salesPercent === 0) return false;
                // Exclude batches already listed on LeafLink
                if (batch.leaflink_product_id) return false;

                // Exclude old labeled batches (before cutoff) - they're already on LeafLink manually
                if (batch.labels_applied) {
                    const labelingDate = batch.labeling_date ? new Date(batch.labeling_date) : null;
                    if (!labelingDate || labelingDate < leaflinkCutoffDate) {
                        return false; // Old labeled batch, assume already on LeafLink
                    }
                }

                // Include all in-progress stages AND labeled batches awaiting LeafLink
                const validStatuses = ['extraction', 'finishing', 'packaging', 'complete'];
                return validStatuses.includes(batch.status);
            });

            // Group batches by category

            pipelineData.forEach(batch => {
                const category = getProductCategoryDynamic(batch.product_made, categories);
                if (category && pipelineCategoryData[category]) {
                    pipelineCategoryData[category].count++;
                    const weight = batch.final_weight || batch.net_weight || batch.grams_labeled || 0;
                    const salesPercent = getSalesPercentage(batch.material_agreement);
                    const availableGrams = (weight * salesPercent / 100).toFixed(1);

                    // Determine pipeline stage for display
                    let pipelineStage = batch.status;
                    if (batch.labels_applied && !batch.leaflink_product_id) {
                        pipelineStage = 'awaiting_leaflink';
                    } else if (batch.status === 'complete' && batch.test_thc_percent && !batch.labels_applied) {
                        pipelineStage = 'labeling';
                    } else if (batch.status === 'complete' && !batch.test_thc_percent) {
                        pipelineStage = 'testing';
                    }

                    pipelineCategoryData[category].strains.push({
                        strain: batch.strain || 'Unknown',
                        strainType: batch.strain_type || 'Hybrid',
                        batchId: batch.id,
                        status: batch.status,
                        pipelineStage: pipelineStage,
                        labelsApplied: batch.labels_applied,
                        labelingDate: batch.labeling_date,
                        weight: weight,
                        availableGrams: availableGrams
                    });
                }
            });

            renderPipelineCategories();
        }

        function renderPipelineCategories() {
            // Use dynamic category order from pipelineCategoryData keys
            const categoryOrder = Object.keys(pipelineCategoryData);

            const html = categoryOrder.map(key => {
                const data = pipelineCategoryData[key];
                if (!data) return '';
                const hasItems = data.count > 0;

                // Count by strain type and awaiting LeafLink
                const strainCounts = { Sativa: 0, Hybrid: 0, Indica: 0 };
                let awaitingLeafLink = 0;
                let urgentCount = 0;
                (data.strains || []).forEach(item => {
                    if (item.strainType) strainCounts[item.strainType]++;
                    if (item.pipelineStage === 'awaiting_leaflink') {
                        awaitingLeafLink++;
                        // Check if waiting > 24 hours
                        if (item.labelingDate) {
                            const hoursWaiting = (Date.now() - new Date(item.labelingDate).getTime()) / (1000 * 60 * 60);
                            if (hoursWaiting > 24) urgentCount++;
                        }
                    }
                });

                // Calculate total grams
                const totalGrams = (data.strains || []).reduce((sum, s) => sum + (parseFloat(s.availableGrams) || 0), 0);

                // Show indicator if batches are ready to list
                let readyIndicator = '';
                if (awaitingLeafLink > 0) {
                    const indicatorColor = urgentCount > 0 ? '#ff6b00' : '#FFD700';
                    readyIndicator = `<div style="font-size: 0.7rem; color: ${indicatorColor}; margin-top: 2px;"> ${awaitingLeafLink} ready</div>`;
                }

                return `
                    <button onclick="showPipelineStrains('${key}')" class="foh-btn" style="opacity: ${hasItems ? '1' : '0.5'}; ${urgentCount > 0 ? 'border: 2px solid #ff6b00;' : ''}">
                        <div class="foh-btn-name">${data.label}</div>
                        <div class="foh-btn-num">${data.count}</div>
                        <div class="foh-btn-sub">${totalGrams.toFixed(0)}g</div>
                        ${readyIndicator}
                    </button>
                `;
            }).join('');

            // Render to both modal and inline
            const modalContainer = document.getElementById('pipelineCategoryGrid');
            const inlineContainer = document.getElementById('inlinePipelineGrid');
            if (modalContainer) modalContainer.innerHTML = html;
            if (inlineContainer) inlineContainer.innerHTML = html;
        }

        // Get stage label and color for pipeline display
        function getPipelineStageInfo(stage) {
            const stages = {
                'extraction': { label: 'Extracting', color: '#F59E0B', icon: '' },
                'finishing': { label: 'Finishing', color: '#3B82F6', icon: '' },
                'packaging': { label: 'Packaging', color: '#8B5CF6', icon: '' },
                'testing': { label: 'Testing', color: '#EC4899', icon: '' },
                'labeling': { label: 'Labeling', color: '#10B981', icon: '' },
                'awaiting_leaflink': { label: 'Ready to List', color: '#FFD700', icon: '' },
                'complete': { label: 'Complete', color: '#6B7280', icon: '' }
            };
            return stages[stage] || stages['complete'];
        }

        function showPipelineStrains(category) {
            const data = pipelineCategoryData[category];
            if (!data || data.count === 0) {
                return;
            }

            document.getElementById('pipelinePopupTitle').textContent = data.label + ' (' + data.count + ')';
            document.getElementById('pipelinePopupTitle').style.color = data.color;

            const contentEl = document.getElementById('pipelinePopupContent');

            // Group by strain but keep individual batch details
            const strainGroups = {};
            let totalGrams = 0;
            let awaitingLeafLinkCount = 0;

            data.strains.forEach(item => {
                const key = item.strain;
                if (!strainGroups[key]) {
                    strainGroups[key] = { count: 0, batches: [], grams: 0, strainType: item.strainType };
                }
                strainGroups[key].count++;
                strainGroups[key].batches.push({
                    id: item.batchId,
                    grams: item.availableGrams,
                    pipelineStage: item.pipelineStage,
                    labelingDate: item.labelingDate
                });
                strainGroups[key].grams += parseFloat(item.availableGrams) || 0;
                totalGrams += parseFloat(item.availableGrams) || 0;

                if (item.pipelineStage === 'awaiting_leaflink') awaitingLeafLinkCount++;
            });

            // Update title with total grams and awaiting count
            let titleText = data.label + ' - ' + totalGrams.toFixed(1) + 'g';
            if (awaitingLeafLinkCount > 0) {
                titleText += ` (${awaitingLeafLinkCount} ready to list)`;
            }
            document.getElementById('pipelinePopupTitle').textContent = titleText;

            // Sort by strain type (Sativa, Hybrid, Indica), then by grams descending
            const strainOrder = { 'Sativa': 0, 'Hybrid': 1, 'Indica': 2 };
            const sortedStrains = Object.entries(strainGroups)
                .sort((a, b) => {
                    const typeA = strainOrder[a[1].strainType] ?? 1;
                    const typeB = strainOrder[b[1].strainType] ?? 1;
                    if (typeA !== typeB) return typeA - typeB;
                    return b[1].grams - a[1].grams;
                });

            // Get strain color based on type (Sativa=Red, Indica=Blue, Hybrid=Green)
            const getStrainColor = (type) => {
                if (type === 'Sativa') return '#ff0055';
                if (type === 'Indica') return '#0055ff';
                return '#39ff14'; // Hybrid default
            };

            contentEl.innerHTML = sortedStrains.map(([strain, info]) => {
                const strainColor = getStrainColor(info.strainType);

                // Show individual batches with their stages
                const batchDetails = info.batches.map(batch => {
                    const stageInfo = getPipelineStageInfo(batch.pipelineStage);
                    let waitingWarning = '';

                    // Check if awaiting LeafLink for more than 24 hours
                    if (batch.pipelineStage === 'awaiting_leaflink' && batch.labelingDate) {
                        const labeledDate = new Date(batch.labelingDate);
                        const hoursWaiting = (Date.now() - labeledDate.getTime()) / (1000 * 60 * 60);
                        if (hoursWaiting > 24) {
                            waitingWarning = `<span style="color: #ff6b00; font-size: 0.75rem; margin-left: 5px;"> ${Math.floor(hoursWaiting)}h</span>`;
                        }
                    }

                    return `<span style="display: inline-flex; align-items: center; background: ${stageInfo.color}22; color: ${stageInfo.color}; padding: 2px 8px; border-radius: 10px; font-size: 0.75rem; margin-right: 5px; margin-top: 5px;">${stageInfo.icon} ${batch.id} (${batch.grams}g)${waitingWarning}</span>`;
                }).join('');

                return `
                <div style="padding: 12px 15px; background: var(--bg-primary); border-radius: 8px; margin-bottom: 10px; border-left: 3px solid ${strainColor}; box-shadow: 0 0 10px ${strainColor}33;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <span style="font-weight: 600; color: var(--text-primary);">${strain}</span>
                        <span style="background: ${strainColor}22; color: ${strainColor}; padding: 6px 12px; border-radius: 12px; font-size: 1.1rem; font-weight: 700;">${info.grams.toFixed(1)}g</span>
                    </div>
                    <div style="margin-top: 8px; display: flex; flex-wrap: wrap;">${batchDetails}</div>
                </div>
            `;
            }).join('');

            document.getElementById('pipelineStrainsPopup').style.display = 'block';
        }

    </script>

    <!-- RTA Manager Modal -->
    <div id="rtaManagerModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); z-index: 10005; overflow-y: auto;">
        <div style="max-width: 800px; margin: 30px auto; background: var(--bg-secondary); border-radius: 20px; overflow: hidden;">
            <div style="background: linear-gradient(135deg, var(--accent-purple), var(--accent-blue)); padding: 25px; display: flex; justify-content: space-between; align-items: center;">
                <h2 style="margin: 0; color: white;"> RTA Qualification Manager</h2>
                <button onclick="closeRTAManager()" style="background: rgba(255,255,255,0.2); border: none; color: white; font-size: 1.5rem; cursor: pointer; padding: 5px 15px; border-radius: 8px;">&times;</button>
            </div>
            <div style="padding: 25px;">
                <!-- Status Overview Cards -->
                <div id="rtaStatusCards" style="margin-bottom: 25px;">
                    <!-- Populated by JS -->
                </div>

                <!-- 30-Day Compliance Reminders -->
                <div id="rtaReminder" style="margin-bottom: 25px;">
                    <!-- Populated by JS -->
                </div>

                <div style="background: var(--bg-tertiary); padding: 15px; border-radius: 10px; margin-bottom: 20px;">
                    <h4 style="margin: 0 0 10px; color: var(--accent-orange);"> Colorado MED RTA Requirements</h4>
                    <ul style="margin: 0; padding-left: 20px; color: var(--text-secondary); font-size: 0.9rem;">
                        <li><strong>Initial Qualification:</strong> 4 consecutive passing full panel batches within 4 weeks</li>
                        <li><strong>RTA Duration:</strong> Valid for 1 year from first passing batch</li>
                        <li><strong>Reauthorization (after fail):</strong> 5 consecutive passing batches required</li>
                        <li><strong>Ongoing:</strong> 1 full panel test every 30 days to maintain</li>
                    </ul>
                </div>
                <div id="rtaManagerContent">
                    <!-- Product type RTA cards populated by JS -->
                </div>
                <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid var(--bg-tertiary);">
                    <button class="btn" style="background: var(--accent-red);" onclick="resetAllRTA()">Reset All RTA Status</button>
                </div>
            </div>
        </div>
    </div>

    <!-- LeafLink Inventory Modal -->
    <!-- LeafLink Inventory Modal -->
    <div id="leafLinkInventoryModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); z-index: 10001; overflow-y: auto;">
        <div style="max-width: 800px; margin: 50px auto; background: var(--bg-secondary); border-radius: 20px; padding: 0; box-shadow: 0 20px 60px rgba(139, 92, 246, 0.4);">
            <!-- Header -->
            <div style="background: linear-gradient(135deg, #8B5CF6, #EC4899); padding: 25px 30px; border-radius: 20px 20px 0 0;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <h2 style="color: white; margin: 0; font-size: 1.5rem;">Inventory</h2>
                    <button onclick="closeLeafLinkInventoryModal()" style="background: rgba(255,255,255,0.2); border: none; color: white; font-size: 1.5rem; cursor: pointer; padding: 5px 12px; border-radius: 8px;">&times;</button>
                </div>
            </div>

            <!-- Content -->
            <div style="padding: 30px;">
                <!-- Product Category Grid -->
                <div id="inventoryCategoryGrid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 15px;">
                    <!-- Populated dynamically -->
                </div>
            </div>
        </div>
    </div>

    <!-- Inventory Items Popup (matches Pipeline strains popup) -->
    <div id="inventoryItemsPopup" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); z-index: 10002; overflow-y: auto;">
        <div style="max-width: 500px; margin: 80px auto; background: var(--bg-secondary); border-radius: 16px; padding: 0; box-shadow: 0 20px 60px rgba(0,0,0,0.5);">
            <div style="background: var(--bg-tertiary); padding: 20px 25px; border-radius: 16px 16px 0 0; display: flex; justify-content: space-between; align-items: center;">
                <h3 id="inventoryPopupTitle" style="margin: 0; color: var(--text-primary); font-size: 1.2rem;">Items</h3>
                <button onclick="closeInventoryItemsPopup()" style="background: none; border: none; color: var(--text-secondary); font-size: 1.5rem; cursor: pointer;">&times;</button>
            </div>
            <div id="inventoryPopupContent" style="padding: 20px 25px; max-height: 400px; overflow-y: auto;">
            </div>
        </div>
    </div>

    <!-- Needs Modal -->
    <div id="needsModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.85); z-index: 10001; overflow-y: auto;">
        <div style="max-width: 800px; margin: 50px auto; background: var(--bg-secondary); border-radius: 20px; padding: 0; box-shadow: 0 20px 60px rgba(245, 158, 11, 0.4);">
            <div style="background: linear-gradient(135deg, #F59E0B, #EF4444); padding: 25px 30px; border-radius: 20px 20px 0 0;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <h2 style="color: white; margin: 0; font-size: 1.5rem;">Needs</h2>
                    <button onclick="closeNeedsModal()" style="background: rgba(255,255,255,0.2); border: none; color: white; font-size: 1.5rem; cursor: pointer; padding: 5px 12px; border-radius: 8px;">&times;</button>
                </div>
            </div>
            <div style="padding: 30px;">
                <div id="needsCategoryGrid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 15px;"></div>
            </div>
        </div>
    </div>

    <!-- Needs Items Popup -->
    <div id="needsItemsPopup" style="display: none; position: fixed; bottom: 0; left: 0; right: 0; background: var(--bg-secondary); border-radius: 20px 20px 0 0; z-index: 10002; box-shadow: 0 -10px 40px rgba(0,0,0,0.5); max-height: 70vh;">
        <div style="background: var(--bg-tertiary); padding: 20px 25px; border-radius: 16px 16px 0 0; display: flex; justify-content: space-between; align-items: center;">
            <h3 id="needsPopupTitle" style="margin: 0; color: var(--text-primary); font-size: 1.2rem;">Needs</h3>
            <button onclick="closeNeedsItemsPopup()" style="background: none; border: none; color: var(--text-secondary); font-size: 1.5rem; cursor: pointer;">&times;</button>
        </div>
        <div id="needsPopupContent" style="padding: 20px 25px; max-height: 400px; overflow-y: auto;"></div>
    </div>

    <script>
    // ==================== LEAFLINK INVENTORY MANAGEMENT ====================

    let inventoryCategoryData = {};

    const inventoryCategories = [
        { key: 'Wax', label: 'Wax', color: '#FFD700', keywords: ['wax'] },
        { key: 'Shatter', label: 'Shatter', color: '#00CED1', keywords: ['shatter'] },
        { key: 'Sugar Wax', label: 'Sugar Wax', color: '#FF69B4', keywords: ['sugar'] },
        { key: 'Live Resin Carts', label: 'Carts', color: '#10B981', keywords: ['cart'] },
        { key: 'Live Resin AIOs', label: 'AIOs', color: '#8B5CF6', keywords: ['aio', 'disposable'] },
        { key: 'Brick Hash', label: 'Brick Hash', color: '#6B7280', keywords: ['hash', 'brick'] },
        { key: '4g Wax', label: '4g Wax', color: '#F97316', keywords: ['4 gram', 'bucket'] },
        { key: '4g Sugar', label: '4g Sugar', color: '#EC4899', keywords: ['4 gram sugar', 'bucket sugar'] }
    ];

    function openLeafLinkInventoryModal() {
        document.getElementById('leafLinkInventoryModal').style.display = 'block';
        loadLeafLinkInventory();
    }

    function closeLeafLinkInventoryModal() {
        document.getElementById('leafLinkInventoryModal').style.display = 'none';
    }

    function closeInventoryItemsPopup() {
        document.getElementById('inventoryItemsPopup').style.display = 'none';
    }

    async function refreshLeafLinkInventory() {
        await loadLeafLinkInventory();
    }

    async function loadLeafLinkInventory() {
        const container = document.getElementById('inventoryCategoryGrid');
        if (container) {
            container.innerHTML = '<div style="grid-column: span 3; text-align: center; padding: 40px; color: var(--text-secondary);">Loading...</div>';
        }

        // Load dynamic categories from business LeafLink mappings (force reload to get current business)
        const dynamicCategories = await loadBusinessCategories(true);

        // Initialize category data with dynamic categories
        inventoryCategoryData = {};
        dynamicCategories.forEach(cat => {
            inventoryCategoryData[cat.key] = { count: 0, items: [], color: cat.color, label: cat.label, totalQty: 0 };
        });

        // Fetch products from LeafLink
        const products = await fetchLeafLinkInventory();

        // Categorize products
        products.forEach(product => {
            const name = (product.name || '').toLowerCase();
            const displayName = product.display_name || product.name || '';
            // Handle parent as object or string
            let parentName = '';
            if (product.parent && typeof product.parent === 'object') {
                parentName = (product.parent.name || '').toLowerCase();
            } else if (typeof product.parent === 'string') {
                parentName = product.parent.toLowerCase();
            }
            const productLine = (typeof product.product_line === 'string' ? product.product_line : (product.product_line?.name || '')).toLowerCase();
            const category_field = (typeof product.category === 'string' ? product.category : (product.category?.name || '')).toLowerCase();
            const qty = parseFloat(product.available_inventory != null ? product.available_inventory : (product.quantity || 0)) || 0;

            // Combine all fields for matching - include display name too
            const matchText = (parentName + ' ' + productLine + ' ' + category_field + ' ' + displayName).toLowerCase();

            // Check if this is a 4g bucket product (allow Internal for these)
            const is4gBucket = matchText.includes('4 gram') || matchText.includes('4gram') || matchText.includes('4g') || matchText.includes('4-gram') || matchText.includes('bucket');

            // Skip archived products always, skip internal unless it's a 4g bucket
            if (product.listing_state === 'Archived') return;
            if (product.listing_state === 'Internal' && !is4gBucket) return;

            // Skip products with 0 quantity
            if (qty <= 0) return;

            // Determine strain type from name
            let strainType = 'Hybrid';
            if (name.includes('sativa') || name.includes('(sativa)')) strainType = 'Sativa';
            else if (name.includes('indica') || name.includes('(indica)')) strainType = 'Indica';

            // Skip non-concentrate products
            if (matchText.includes('syrup') || matchText.includes('jousse') ||
                matchText.includes('rso') || matchText.includes('battery') ||
                matchText.includes('510 thread')) {
                return; // Skip syrups, RSO, batteries
            }

            // Map to categories using dynamic matching
            let category = getProductCategoryDynamic(matchText, dynamicCategories);

            // Redirect 4g products to their proper 4g categories
            if (is4gBucket) {
                if (category === 'Wax') {
                    // Check which 4g wax category exists
                    if (inventoryCategoryData['4g Wax']) category = '4g Wax';
                    else if (inventoryCategoryData['Wax 4g']) category = 'Wax 4g';
                } else if (category === 'Sugar Wax') {
                    // Check which 4g sugar category exists
                    if (inventoryCategoryData['4g Sugar']) category = '4g Sugar';
                    else if (inventoryCategoryData['Sugar Wax 4g']) category = 'Sugar Wax 4g';
                }
            }

            if (category && inventoryCategoryData[category]) {
                inventoryCategoryData[category].count++;
                inventoryCategoryData[category].totalQty += qty;
                inventoryCategoryData[category].items.push({
                    name: displayName || product.name,
                    quantity: qty,
                    strainType: strainType,
                    sku: product.sku
                });
            }
        });

        renderInventoryCategories();
    }

    // Fetch inventory from a specific business
    async function fetchInventoryForBusiness(businessSlug) {
        let products = [];
        let nextUrl = `${window.location.origin}/api/leaflink?slug=${businessSlug}&endpoint=products&page_size=200`;
        let pageCount = 0;
        const maxPages = 25; // Increased to support more products

        while (nextUrl && pageCount < maxPages) {
            try {
                const response = await fetch(nextUrl);
                if (!response.ok) break;
                const data = await response.json();
                const results = data.results || [];
                if (results.length === 0) break;
                products = products.concat(results);
                nextUrl = data.next;
                pageCount++;
            } catch (error) {
                break;
            }
        }
        console.log(`Fetched ${products.length} products from ${businessSlug}`);
        return products;
    }

    async function fetchLeafLinkInventory() {
        if (typeof isDemoMode === 'function' && isDemoMode()) {
            return generateDemoInventory();
        }

        // If viewing all businesses, fetch from each in parallel and combine
        if (currentBusinessId === 'all' && businessesList.length > 0) {
            const activeBusinesses = businessesList.filter(b => b.is_active);
            const productPromises = activeBusinesses.map(async biz => {
                const products = await fetchInventoryForBusiness(biz.slug);
                // Tag each product with business info
                products.forEach(p => p._business = { id: biz.id, slug: biz.slug, name: biz.display_name });
                return products;
            });
            const results = await Promise.all(productPromises);
            const allProducts = results.flat();
            console.log(`Combined ${allProducts.length} products from all businesses`);
            return allProducts;
        }

        // Single business fetch
        let allProducts = [];
        const businessSlug = businessesList.find(b => b.id === currentBusinessId)?.slug || 'white-mousse';
        let nextUrl = `${window.location.origin}/api/leaflink?slug=${businessSlug}&endpoint=products&page_size=200`;
        let pageCount = 0;
        const maxPages = 25; // Increased to support 5000+ products

        while (nextUrl && pageCount < maxPages) {
            try {
                const response = await fetch(nextUrl);
                if (!response.ok) {
                    // Stop pagination on error (likely end of data)
                    break;
                }
                const data = await response.json();
                const results = data.results || [];
                if (results.length === 0) break; // No more results
                allProducts = allProducts.concat(results);
                nextUrl = data.next;
                pageCount++;
            } catch (error) {
                // Silently stop on error
                break;
            }
        }
        return allProducts;
    }

    function generateDemoInventory() {
        const strains = ['Blue Dream Sativa', 'GMO Indica', 'Gelato Hybrid', 'Wedding Cake Indica', 'Runtz Hybrid', 'Purple Punch Indica', 'OG Kush Hybrid', 'Sour Diesel Sativa'];
        const products = [];

        inventoryCategories.forEach(cat => {
            const numProducts = Math.floor(Math.random() * 4) + 2;
            for (let i = 0; i < numProducts; i++) {
                const strain = strains[Math.floor(Math.random() * strains.length)];
                const qty = Math.floor(Math.random() * 100) + 5;
                products.push({
                    name: strain + ' ' + cat.label,
                    quantity: qty,
                    available_inventory: qty,
                    sku: 'WM-' + Math.floor(Math.random() * 10000)
                });
            }
        });
        return products;
    }

    // ============================================
    // LEAFLINK PRODUCT PUSH INTEGRATION
    // ============================================

    // LeafLink configuration - will be populated from existing products
    let leafLinkConfig = null;
    let leafLinkMappings = {}; // Per-business mappings from database { businessId: [mappings] }

    // Pending LeafLink approvals (stored on batch records in Supabase)

    async function queueForLeafLinkApproval(batch) {
        // Calculate quantity based on material agreement
        const multiplier = batch.material_agreement === '50-50 Split' ? 0.5 : 1.0;
        const quantity = Math.floor((batch.grams_labeled || batch.final_weight || 0) * multiplier);

        // Update batch with pending LeafLink flag
        const { error } = await supabaseClient
            .from('wm_batches')
            .update({
                leaflink_pending: true,
                leaflink_quantity: quantity,
                leaflink_queued_at: new Date().toISOString(),
                leaflink_queued_by: currentRole?.name || 'Unknown'
            })
            .eq('id', batch.id);

        if (error) {
            console.error('Error queueing batch for LeafLink:', error);
        } else {
            console.log('Batch queued for LeafLink approval:', batch.id);
        }
    }

    async function renderLeafLinkApprovalQueue() {
        const container = document.getElementById('leaflinkApprovalQueue');
        if (!container) return;

        container.innerHTML = '<p style="color: var(--text-secondary); text-align: center;">Loading...</p>';

        // Fetch batches pending LeafLink approval from Supabase
        const { data: pendingBatches, error } = await supabaseClient
            .from('wm_batches')
            .select('*')
            .eq('leaflink_pending', true)
            .order('leaflink_queued_at', { ascending: false });

        if (error) {
            console.error('Error loading LeafLink queue:', error);
            container.innerHTML = '<p style="color: var(--accent-red);">Error loading queue</p>';
            return;
        }

        if (!pendingBatches || pendingBatches.length === 0) {
            container.innerHTML = '<p style="color: var(--text-secondary); text-align: center;">No pending approvals</p>';
            return;
        }

        const html = pendingBatches.map(batch => {
            const productType = batch.packaged_product_type || batch.product_made || 'Unknown';
            const quantity = batch.leaflink_quantity || batch.grams_labeled || 0;
            return `
            <div style="background: var(--card-bg); border: 1px solid var(--border-color); border-radius: 8px; padding: 15px; margin-bottom: 10px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                    <strong style="color: var(--accent-green);">${batch.strain}</strong>
                    <span style="font-size: 0.85em; color: var(--text-secondary);">${batch.id}</span>
                </div>
                <div style="font-size: 0.9em; color: var(--text-secondary); margin-bottom: 10px;">
                    <div>${productType}  ${batch.strain_type || 'Hybrid'}</div>
                    <div>${quantity}g to LeafLink (${batch.material_agreement})</div>
                    <div>THC: ${batch.test_thc_percent || 'N/A'}%  Price: $${batch.wholesale_price || 0}</div>
                    <div style="font-size: 0.8em; margin-top: 5px;">Queued: ${batch.leaflink_queued_at ? new Date(batch.leaflink_queued_at).toLocaleString() : 'N/A'} by ${batch.leaflink_queued_by || 'Unknown'}</div>
                </div>
                <div style="display: flex; gap: 10px;">
                    <button onclick="approveLeafLinkPush('${batch.id}')" style="flex: 1; padding: 8px; background: var(--accent-green); color: white; border: none; border-radius: 5px; cursor: pointer;">
                         Approve & Push
                    </button>
                    <button onclick="rejectLeafLinkPush('${batch.id}')" style="flex: 1; padding: 8px; background: var(--accent-red, #ef4444); color: white; border: none; border-radius: 5px; cursor: pointer;">
                         Reject
                    </button>
                </div>
            </div>
        `}).join('');

        container.innerHTML = html;
    }

    async function approveLeafLinkPush(batchId) {
        // Get the full batch data from Supabase
        const { data: batch, error } = await supabaseClient
            .from('wm_batches')
            .select('*')
            .eq('id', batchId)
            .single();

        if (error || !batch) {
            alert('Error loading batch data: ' + (error?.message || 'Not found'));
            return;
        }

        const productType = batch.packaged_product_type || batch.product_made || 'Unknown';
        const quantity = batch.leaflink_quantity || batch.grams_labeled || 0;

        if (!confirm(`Push ${batch.strain} (${productType}) to LeafLink?\n\nQuantity: ${quantity}g\nTHC: ${batch.test_thc_percent}%`)) {
            return;
        }

        // Push to LeafLink
        const result = await pushBatchToLeafLink(batch);

        if (result.success) {
            // Clear pending flag
            await supabaseClient
                .from('wm_batches')
                .update({
                    leaflink_pending: false,
                    leaflink_product_id: result.product_id,
                    leaflink_pushed_at: new Date().toISOString(),
                    leaflink_pushed_by: currentRole?.name || 'Unknown'
                })
                .eq('id', batchId);

            alert(` Successfully pushed to LeafLink!\n\nProduct ID: ${result.product_id}`);
            renderLeafLinkApprovalQueue();
        } else {
            alert(` LeafLink push failed:\n\n${result.error}\n\n${JSON.stringify(result.details, null, 2)}`);
        }
    }

    async function rejectLeafLinkPush(batchId) {
        if (!confirm('Remove this batch from the LeafLink queue?\n\nThis will NOT delete the batch, just remove it from the approval queue.')) {
            return;
        }

        // Clear pending flag
        await supabaseClient
            .from('wm_batches')
            .update({ leaflink_pending: false })
            .eq('id', batchId);

        renderLeafLinkApprovalQueue();
    }

    // Load LeafLink product mappings from database for a business
    async function loadLeafLinkMappings(businessId) {
        if (!businessId) return [];

        // Check if already loaded
        if (leafLinkMappings[businessId]) {
            return leafLinkMappings[businessId];
        }

        try {
            const { data, error } = await supabaseClient
                .from('leaflink_product_mappings')
                .select('*')
                .eq('business_id', businessId)
                .eq('is_active', true);

            if (error) {
                console.error('Error loading LeafLink mappings:', error);
                return [];
            }

            leafLinkMappings[businessId] = data || [];
            console.log(`Loaded ${data?.length || 0} LeafLink mappings for business ${businessId}`);
            return leafLinkMappings[businessId];
        } catch (error) {
            console.error('Error loading LeafLink mappings:', error);
            return [];
        }
    }

    // Get mapping for a specific product type and business
    function getLeafLinkMapping(businessId, productType) {
        const mappings = leafLinkMappings[businessId] || [];
        return mappings.find(m => m.app_product_type === productType);
    }

    // Special rule: Brick Hash always goes to Bubblman
    function getBrickHashBusinessId() {
        const bubblman = businessesList.find(b => b.slug === 'bubblman');
        return bubblman?.id || null;
    }

    async function initLeafLinkConfig() {
        // Check cache first
        const cached = localStorage.getItem('leaflink_config');
        if (cached) {
            try {
                const parsed = JSON.parse(cached);
                // Use cache if less than 24 hours old
                if (parsed.timestamp && Date.now() - parsed.timestamp < 24 * 60 * 60 * 1000) {
                    leafLinkConfig = parsed;
                    console.log('Using cached LeafLink config:', leafLinkConfig);
                    return leafLinkConfig;
                }
            } catch (e) {
                console.log('LeafLink config cache parse error');
            }
        }

        console.log('Fetching LeafLink config from products...');

        try {
            // Fetch concentrate products (category=5) to get correct recreational license
            const businessSlug = currentBusinessId === 'all' ? 'white-mousse' :
                (businessesList.find(b => b.id === currentBusinessId)?.slug || 'white-mousse');
            const response = await fetch(`${window.location.origin}/api/leaflink?slug=${businessSlug}&endpoint=products&page_size=50&category=5`);
            if (!response.ok) {
                console.error('Failed to fetch LeafLink products for config');
                return null;
            }

            const data = await response.json();
            const products = data.results || [];

            if (products.length === 0) {
                console.error('No LeafLink concentrate products found');
                return null;
            }

            // Extract common IDs from first concentrate product (uses recreational license)
            // Note: Some fields are nested objects {id: x}, others are direct IDs or strings
            const firstProduct = products[0];
            console.log('First concentrate product:', firstProduct.name, 'License:', firstProduct.license?.number);

            // UOM string to ID mapping (LeafLink returns strings but requires IDs for POST)
            // These IDs may need adjustment based on your LeafLink account
            const UOM_STRING_TO_ID = {
                'Gram': 2,
                'gram': 2,
                'g': 2,
                'Unit': 1,
                'Each': 1,
                'Milligram': 3,
                'mg': 3,
                'Ounce': 4,
                'oz': 4
            };

            // Get UOM ID - handle string, object with id, or direct ID
            let uomId = null;
            const uom = firstProduct.unit_of_measure;
            if (typeof uom === 'string') {
                uomId = UOM_STRING_TO_ID[uom] || 2; // Default to Gram (2) if unknown
                console.log(`UOM string "${uom}" mapped to ID: ${uomId}`);
            } else if (uom?.id) {
                uomId = uom.id;
            } else if (typeof uom === 'number') {
                uomId = uom;
            } else {
                uomId = 2; // Default to Gram
                console.log('Could not determine UOM ID, defaulting to 2 (Gram)');
            }

            leafLinkConfig = {
                seller_id: firstProduct.seller?.id || firstProduct.seller,
                brand_id: firstProduct.brand?.id || firstProduct.brand,
                license_id: firstProduct.license?.id || firstProduct.license,
                unit_of_measure_id: uomId,
                unit_denomination_id: firstProduct.unit_denomination?.id || firstProduct.unit_denomination,
                category_id: firstProduct.category?.id || firstProduct.category,
                product_lines: {},
                timestamp: Date.now()
            };

            // Fetch product lines from /product-lines endpoint
            try {
                const plResponse = await fetch(`${window.location.origin}/api/leaflink?slug=${businessSlug}&endpoint=product-lines&page_size=50`);
                if (plResponse.ok) {
                    const plData = await plResponse.json();
                    const productLines = plData.results || [];

                    // Parent product IDs (the container products that varieties go under)
                    const PARENT_IDS = {
                        'Sugar Wax': 215740,
                        'Sugar Wax 4g': 215740,  // Same parent for 4g
                        'Wax': 215673,
                        'Wax 4g': 215673,  // Same parent for 4g
                        'Shatter': 215669,
                        'Live Resin Carts': 1040719,  // 100% Live Resin Cartridges 1g
                        'Live Resin AIOs': 1252729,
                        'Brick Hash': 2568608
                    };

                    productLines.forEach(pl => {
                        const name = (pl.name || '').toLowerCase();

                        // Map to our internal product types
                        if (name.includes('sugar wax') && name.includes('1 gram')) {
                            leafLinkConfig.product_lines['Sugar Wax'] = {
                                product_line_id: pl.id,
                                parent_id: PARENT_IDS['Sugar Wax'],
                                name: pl.name
                            };
                        } else if (name.includes('sugar wax') && name.includes('4 gram')) {
                            leafLinkConfig.product_lines['Sugar Wax 4g'] = {
                                product_line_id: pl.id,
                                parent_id: PARENT_IDS['Sugar Wax 4g'],
                                name: pl.name
                            };
                        } else if (name === 'shatter') {
                            leafLinkConfig.product_lines['Shatter'] = {
                                product_line_id: pl.id,
                                parent_id: PARENT_IDS['Shatter'],
                                name: pl.name
                            };
                        } else if (name.includes('wax') && name.includes('1 gram') && !name.includes('sugar')) {
                            leafLinkConfig.product_lines['Wax'] = {
                                product_line_id: pl.id,
                                parent_id: PARENT_IDS['Wax'],
                                name: pl.name
                            };
                        } else if (name.includes('wax') && name.includes('4 gram') && !name.includes('sugar')) {
                            leafLinkConfig.product_lines['Wax 4g'] = {
                                product_line_id: pl.id,
                                parent_id: PARENT_IDS['Wax 4g'],
                                name: pl.name
                            };
                        } else if (name.includes('all in one') || name.includes('disposable')) {
                            leafLinkConfig.product_lines['Live Resin AIOs'] = {
                                product_line_id: pl.id,
                                parent_id: PARENT_IDS['Live Resin AIOs'],
                                name: pl.name
                            };
                        } else if (name.includes('cartridge')) {
                            leafLinkConfig.product_lines['Live Resin Carts'] = {
                                product_line_id: pl.id,
                                parent_id: PARENT_IDS['Live Resin Carts'],
                                name: pl.name
                            };
                        } else if (name.includes('brick hash')) {
                            leafLinkConfig.product_lines['Brick Hash'] = {
                                product_line_id: pl.id,
                                parent_id: PARENT_IDS['Brick Hash'],
                                name: pl.name
                            };
                        }
                    });

                    // Fallback: hardcode product line IDs if name matching failed
                    if (!leafLinkConfig.product_lines['Live Resin Carts']) {
                        leafLinkConfig.product_lines['Live Resin Carts'] = {
                            product_line_id: 64135,  // 100% Live Resin 1g Cartridge
                            parent_id: PARENT_IDS['Live Resin Carts'],
                            name: '100% Live Resin 1g Cartridge'
                        };
                    }
                    if (!leafLinkConfig.product_lines['Live Resin AIOs']) {
                        leafLinkConfig.product_lines['Live Resin AIOs'] = {
                            product_line_id: 64132,  // 100% Live Resin Disposable Vape (All in One)
                            parent_id: PARENT_IDS['Live Resin AIOs'],
                            name: '100% Live Resin Disposable Vape (All in One)'
                        };
                    }
                }
            } catch (plError) {
                console.error('Error fetching product lines:', plError);
            }

            console.log('Mapped product lines:', leafLinkConfig.product_lines);

            // Cache the config
            localStorage.setItem('leaflink_config', JSON.stringify(leafLinkConfig));
            console.log('LeafLink config initialized:', leafLinkConfig);

            return leafLinkConfig;
        } catch (error) {
            console.error('Error initializing LeafLink config:', error);
            return null;
        }
    }

    async function pushBatchToLeafLink(batch) {
        // Skip if no batch or buyback agreement
        if (!batch) return { success: false, error: 'No batch provided' };
        if (batch.material_agreement === 'Custom Buyback') {
            console.log('Skipping LeafLink push for buyback batch:', batch.id);
            return { success: false, error: 'Buyback - not pushed to LeafLink' };
        }

        // Get product type - normalize compound types
        let productType = batch.packaged_product_type || batch.product_made || '';

        // Normalize product types that don't match LeafLink categories exactly
        const productTypeNormalization = {
            'Sugar': 'Sugar Wax',
            'Live Resin': 'Wax',
            'Badder': 'Badder',
            'Diamonds': 'Diamonds',
            'Sauce': 'Sauce'
        };

        if (productTypeNormalization[productType]) {
            console.log(`Normalizing product type: ${productType} -> ${productTypeNormalization[productType]}`);
            productType = productTypeNormalization[productType];
        }

        // Determine which business to use for this push
        // Special rule: Brick Hash always goes to Bubblman
        let targetBusinessId = batch.business_id || batch._business?.id;
        let targetBusinessSlug = batch._business?.slug;

        if (productType === 'Brick Hash') {
            const bubblmanId = getBrickHashBusinessId();
            if (bubblmanId) {
                console.log('Brick Hash detected - routing to Bubblman');
                targetBusinessId = bubblmanId;
                targetBusinessSlug = 'bubblman';
            }
        }

        // Fall back to current business if needed
        if (!targetBusinessId) {
            targetBusinessId = currentBusinessId === 'all' ?
                businessesList.find(b => b.slug === 'white-mousse')?.id :
                currentBusinessId;
        }
        if (!targetBusinessSlug) {
            targetBusinessSlug = businessesList.find(b => b.id === targetBusinessId)?.slug || 'white-mousse';
        }

        // Load mappings for this business from database
        await loadLeafLinkMappings(targetBusinessId);
        const mapping = getLeafLinkMapping(targetBusinessId, productType);

        if (!mapping) {
            console.error('No LeafLink mapping found for:', productType, 'in business:', targetBusinessSlug);
            return { success: false, error: `No LeafLink mapping configured for ${productType}. Configure in Admin > LeafLink.` };
        }

        // Calculate quantity based on material agreement
        // Wholesale = 100%, 50-50 Split = 50%
        const multiplier = batch.material_agreement === '50-50 Split' ? 0.5 : 1.0;
        const quantity = Math.floor((batch.grams_labeled || batch.final_weight || 0) * multiplier);

        if (quantity <= 0) {
            console.error('No sellable quantity for batch:', batch.id);
            return { success: false, error: 'No sellable quantity' };
        }

        // Get pricing and category from database mapping
        const pricePerUnit = mapping.price_per_unit || 6;
        const categoryId = mapping.leaflink_category_id || 5;

        // Clean strain name - remove WM prefix, product type suffixes, and size
        let strainName = (batch.strain || 'Unknown Strain')
            .replace(/^WM\s+/i, '')           // Remove "WM " prefix
            .replace(/\s+(SW|SH|WX|LRC|AIO|BH)\b/gi, '')  // Remove product type codes
            .replace(/\s*\(\d+g?\)/gi, '')    // Remove size like "(1g)" or "(4g)"
            .trim();

        // Format strain type for display (capitalize first letter)
        const strainType = (batch.strain_type || 'Hybrid').charAt(0).toUpperCase() + (batch.strain_type || 'Hybrid').slice(1).toLowerCase();

        // Build payload using database mapping values
        const payload = {
            sku: batch.id, // Use batch ID as SKU (e.g., "9.23.5447")
            name: `${strainName} (${strainType})`,
            description: `${strainName} (${strainType}) - ${productType}`,
            // Use values from database mapping
            seller: mapping.leaflink_seller_id,
            brand: mapping.leaflink_brand_id,
            license: mapping.leaflink_license_id,
            category: categoryId,
            manufacturer: mapping.leaflink_seller_id,
            unit_of_measure: 'Gram',
            sell_in_unit_of_measure: 'Case',
            unit_multiplier: 10, // 10 units per case
            unit_denomination: mapping.leaflink_unit_denomination_id,
            listing_state: 'Internal', // TODO: Change to 'Available' after testing
            strain_classification: (batch.strain_type || 'hybrid').toLowerCase(),
            inventory_management: 1, // 1 = track inventory
            quantity: quantity.toFixed(4), // Initial inventory quantity
            minimum_order: '1.0000', // 1 case minimum
            maximum_order: null,
            wholesale_price: {
                amount: pricePerUnit,
                currency: 'USD'
            },
            retail_price: {
                amount: 0,
                currency: 'USD'
            },
            sale_price: {
                amount: 0,
                currency: 'USD'
            }
        };

        // Add product_line if configured in mapping
        if (mapping.leaflink_product_line_id) {
            payload.product_line = mapping.leaflink_product_line_id;
        }

        // Add parent to make this a variety under the parent product
        if (mapping.leaflink_parent_id) {
            payload.parent = { id: mapping.leaflink_parent_id };
        }

        // Add test results if available
        if (batch.test_thc_percent) {
            payload.product_specification_items = [
                {
                    product_specification_id: 1, // THC
                    decimal_value: batch.test_thc_percent.toString()
                }
            ];
            if (batch.test_cbd_percent) {
                payload.product_specification_items.push({
                    product_specification_id: 2, // CBD
                    decimal_value: batch.test_cbd_percent.toString()
                });
            }
        }

        console.log('Pushing batch to LeafLink:', batch.id, 'to business:', targetBusinessSlug, payload);

        try {
            // Use the target business slug determined earlier (handles Brick Hash  Bubblman rule)
            const response = await fetch(`${window.location.origin}/api/leaflink?slug=${targetBusinessSlug}&endpoint=products`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });

            const result = await response.json();

            if (!response.ok) {
                console.error('LeafLink API error:', result);
                return { success: false, error: result.detail || 'API error', details: result };
            }

            console.log('LeafLink product created:', result.id);

            // Store LeafLink product ID on batch
            try {
                await supabaseClient.from('wm_batches')
                    .update({ leaflink_product_id: result.id })
                    .eq('id', batch.id);
            } catch (dbError) {
                console.error('Error saving LeafLink ID to batch:', dbError);
            }

            return { success: true, product_id: result.id, data: result };
        } catch (error) {
            console.error('Error pushing to LeafLink:', error);
            return { success: false, error: error.message };
        }
    }

    function renderInventoryCategories() {
        // Use dynamic category order from inventoryCategoryData keys
        const categoryOrder = Object.keys(inventoryCategoryData);

        const html = categoryOrder.map(key => {
            const data = inventoryCategoryData[key];
            if (!data) return '';
            const hasItems = data.count > 0;

            // Count by strain type
            const strainCounts = { Sativa: 0, Hybrid: 0, Indica: 0 };
            (data.items || []).forEach(item => {
                if (item.strainType) strainCounts[item.strainType]++;
            });

            const unit = (key.includes('Cart') || key.includes('AIO') || key.includes('4g')) ? '' : 'g';
            return `
                <button onclick="showInventoryItems('${key}')" class="foh-btn" style="opacity: ${hasItems ? '1' : '0.5'};">
                    <div class="foh-btn-name">${data.label}</div>
                    <div class="foh-btn-num">${data.count}</div>
                    <div class="foh-btn-sub">${Math.round(data.totalQty)}${unit}</div>
                </button>
            `;
        }).join('');

        // Render to both modal and inline
        const modalContainer = document.getElementById('inventoryCategoryGrid');
        const inlineContainer = document.getElementById('inlineInventoryGrid');
        if (modalContainer) modalContainer.innerHTML = html;
        if (inlineContainer) inlineContainer.innerHTML = html;
    }

        function showInventoryItems(category) {
        const data = inventoryCategoryData[category];
        if (!data || data.count === 0) return;

        const unit = (category.includes('Cart') || category.includes('AIO') || category.includes('4g')) ? '' : 'g';
        document.getElementById('inventoryPopupTitle').textContent = data.label + ' - ' + Math.round(data.totalQty) + unit;
        document.getElementById('inventoryPopupTitle').style.color = data.color;

        const contentEl = document.getElementById('inventoryPopupContent');

        // Sort by strain type (Sativa, Hybrid, Indica), then by quantity descending
        const strainOrder = { 'Sativa': 0, 'Hybrid': 1, 'Indica': 2 };
        const sortedItems = [...data.items].sort((a, b) => {
            const typeA = strainOrder[a.strainType] ?? 1;
            const typeB = strainOrder[b.strainType] ?? 1;
            if (typeA !== typeB) return typeA - typeB;
            return b.quantity - a.quantity;
        });

        // Get strain color
        const getStrainColor = (type) => {
            if (type === 'Sativa') return '#ff0055';
            if (type === 'Indica') return '#0055ff';
            return '#39ff14';
        };

        contentEl.innerHTML = sortedItems.map(item => {
            const strainColor = getStrainColor(item.strainType);
            return `
                <div style="padding: 12px 15px; background: var(--bg-primary); border-radius: 8px; margin-bottom: 10px; border-left: 3px solid ${strainColor}; box-shadow: 0 0 10px ${strainColor}33;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <span style="font-weight: 600; color: var(--text-primary);">${item.name}</span>
                        <span style="background: ${strainColor}22; color: ${strainColor}; padding: 6px 12px; border-radius: 12px; font-size: 1.1rem; font-weight: 700;">${item.quantity}${unit}</span>
                    </div>
                </div>
            `;
        }).join('');

        document.getElementById('inventoryItemsPopup').style.display = 'block';
    }

    // ============ NEEDS MODAL ============
    let needsData = {};
    let salesByCategory = {};
    let needsDataLoading = null; // Track loading promise to prevent concurrent loads

    function openNeedsModal() {
        document.getElementById('needsModal').style.display = 'block';
        loadNeedsData();
    }

    function closeNeedsModal() {
        document.getElementById('needsModal').style.display = 'none';
    }

    function closeNeedsItemsPopup() {
        document.getElementById('needsItemsPopup').style.display = 'none';
    }

    async function loadNeedsData(forceReload = false) {
        // If already loading, return the existing promise
        if (needsDataLoading && !forceReload) {
            return needsDataLoading;
        }

        // Load cached data immediately for instant display
        const cachedData = localStorage.getItem(getNeedsCacheKey());
        if (cachedData && Object.keys(needsData).length === 0) {
            try {
                const parsed = JSON.parse(cachedData);
                // Validate cache structure - must have Wax with needs array
                // Also check that cache has actual data (not all zeros)
                const hasRealData = parsed && parsed['Wax'] && Array.isArray(parsed['Wax'].needs) &&
                    Object.values(parsed).some(cat => cat.totalInventory > 0 || cat.totalPipeline > 0 || (cat.needs && cat.needs.length > 0));
                if (hasRealData) {
                    needsData = parsed;
                    renderNeedsCategories();
                } else {
                    // Invalid or empty cache, clear it
                    console.log('Needs cache invalid or empty, clearing...');
                    localStorage.removeItem(getNeedsCacheKey());
                }
            } catch (e) {
                console.log('Cache parse error:', e);
                localStorage.removeItem(getNeedsCacheKey());
            }
        }

        // If data already exists and not forcing reload, just re-render
        if (!forceReload && Object.keys(needsData).length > 0 && needsData['Wax']?.needs?.length > 0) {
            renderNeedsCategories();
            // Still refresh in background but don't wait
            setTimeout(() => loadNeedsData(true), 100);
            return Promise.resolve();
        }

        needsDataLoading = (async () => {
            // Ensure pipeline data is loaded first (it populates pipelineCategoryData)
            await loadSalesPipeline();

        // Load dynamic categories from business LeafLink mappings (pass forceReload through)
        const dynamicCategories = await loadBusinessCategories(forceReload);
        const categoryKeys = dynamicCategories.map(c => c.key);
        const strainTypes = ['Indica', 'Sativa', 'Hybrid'];

        const newNeedsData = {};
        salesByCategory = {};

        dynamicCategories.forEach(cat => {
            newNeedsData[cat.key] = { label: cat.label, color: cat.color, needs: [] };
            salesByCategory[cat.key] = { Indica: 0, Sativa: 0, Hybrid: 0 };
        });

        // Get 60-day sales data
        const orders = await fetchLeafLinkOrders();
        const salesPeriodStart = new Date();
        salesPeriodStart.setDate(salesPeriodStart.getDate() - 60);

        // Calculate sales by category and strain type
        orders.forEach(order => {
            const orderDate = new Date(order.ordered_at || order.created_on);
            if (orderDate < salesPeriodStart) return;

            (order.line_items || []).forEach(item => {
                const productName = (item.frozen_data?.product?.name || item.product?.name || '').toLowerCase();
                const qty = parseFloat(item.quantity) || 0;

                // Determine category using dynamic matching
                let category = getProductCategoryDynamic(productName, dynamicCategories);
                if (!category) return;

                // Redirect 4g products to their proper 4g categories
                const is4g = productName.includes('4 gram') || productName.includes('4g') || productName.includes('4-gram') || productName.includes('bucket');
                if (is4g) {
                    if (category === 'Wax') {
                        if (salesByCategory['4g Wax']) category = '4g Wax';
                        else if (salesByCategory['Wax 4g']) category = 'Wax 4g';
                    } else if (category === 'Sugar Wax') {
                        if (salesByCategory['4g Sugar']) category = '4g Sugar';
                        else if (salesByCategory['Sugar Wax 4g']) category = 'Sugar Wax 4g';
                    }
                }

                // Skip if category not in current business's categories
                if (!salesByCategory[category]) return;

                // Determine strain type
                let strainType = 'Hybrid';
                if (productName.includes('sativa') || productName.includes('(s)')) strainType = 'Sativa';
                else if (productName.includes('indica') || productName.includes('(i)')) strainType = 'Indica';

                salesByCategory[category][strainType] += qty;
            });
        });

        // Get current inventory
        const products = await fetchLeafLinkInventory();
        const inventoryByCategory = {};
        categoryKeys.forEach(cat => {
            inventoryByCategory[cat] = { Indica: [], Sativa: [], Hybrid: [] };
        });

        products.forEach(product => {
            const name = (product.name || '').toLowerCase();
            const displayName = product.display_name || product.name || '';
            let parentName = '';
            if (product.parent && typeof product.parent === 'object') {
                parentName = (product.parent.name || '').toLowerCase();
            }
            const matchText = (parentName + ' ' + displayName).toLowerCase();
            const qty = parseFloat(product.available_inventory != null ? product.available_inventory : (product.quantity || 0)) || 0;

            // Skip archived
            if (product.listing_state === 'Archived') return;
            if (qty <= 0) return;

            // Skip non-concentrates
            if (matchText.includes('syrup') || matchText.includes('jousse') || matchText.includes('rso') || matchText.includes('battery')) return;

            // Determine category using dynamic matching
            let category = getProductCategoryDynamic(matchText, dynamicCategories);
            if (!category) return;

            // Redirect 4g products to their proper 4g categories
            const is4g = matchText.includes('4 gram') || matchText.includes('4g') || matchText.includes('4-gram') || matchText.includes('bucket');
            if (is4g) {
                if (category === 'Wax') {
                    if (inventoryByCategory['4g Wax']) category = '4g Wax';
                    else if (inventoryByCategory['Wax 4g']) category = 'Wax 4g';
                } else if (category === 'Sugar Wax') {
                    if (inventoryByCategory['4g Sugar']) category = '4g Sugar';
                    else if (inventoryByCategory['Sugar Wax 4g']) category = 'Sugar Wax 4g';
                }
            }

            // Skip if category not in current business's categories
            if (!inventoryByCategory[category]) return;

            // Determine strain type
            let strainType = 'Hybrid';
            if (name.includes('sativa') || name.includes('(sativa)')) strainType = 'Sativa';
            else if (name.includes('indica') || name.includes('(indica)')) strainType = 'Indica';

            inventoryByCategory[category][strainType].push({ name: displayName, qty: qty });
        });

        // Add pipeline inventory to the calculation (product being made counts as upcoming inventory)
        try {
            if (typeof pipelineCategoryData === 'object' && pipelineCategoryData !== null) {
                categoryKeys.forEach(cat => {
                    if (!pipelineCategoryData[cat]) return;
                    const strains = pipelineCategoryData[cat].strains;
                    if (!Array.isArray(strains)) return;

                    strains.forEach(item => {
                        // Normalize strain type to match inventory keys
                        let strainType = (item.strainType || 'Hybrid').trim();
                        if (!['Indica', 'Sativa', 'Hybrid'].includes(strainType)) {
                            strainType = 'Hybrid';
                        }

                        const weight = parseFloat(item.availableGrams) || parseFloat(item.weight) || 0;
                        if (weight > 0) {
                            // Double check the array exists before pushing
                            if (inventoryByCategory[cat] && Array.isArray(inventoryByCategory[cat][strainType])) {
                                inventoryByCategory[cat][strainType].push({
                                    name: (item.strain || 'Unknown') + ' (Pipeline)',
                                    qty: weight,
                                    isPipeline: true
                                });
                            }
                        }
                    });
                });
            }
        } catch(e) {
            console.log('Pipeline data error in needs calc:', e.message);
        }

        // Calculate needs: 1-week supply based on 60-day sales average (7 days for urgent visibility)
        categoryKeys.forEach(cat => {
            strainTypes.forEach(strain => {
                const totalSold = salesByCategory[cat][strain];
                const parLevel = Math.ceil((totalSold / 60) * 7); // 1-week supply based on 60-day daily average
                const currentItems = inventoryByCategory[cat][strain];

                // Separate pipeline and inventory quantities
                const pipelineQty = currentItems.filter(i => i.isPipeline).reduce((sum, i) => sum + i.qty, 0);
                const inventoryQty = currentItems.filter(i => !i.isPipeline).reduce((sum, i) => sum + i.qty, 0);
                const totalQty = pipelineQty + inventoryQty;
                // Only count varieties with 60g or more as "stocked"
                const varietyCount = currentItems.filter(i => i.qty >= 60).length;

                // Need more if total quantity is below par level
                const qtyNeeded = Math.max(0, parLevel - totalQty);
                // Need varieties if we have less than 3 varieties with adequate stock (60g+)
                const varietiesNeeded = Math.max(0, 3 - varietyCount);

                // Always add all strain types so they show in popup
                const existingIndex = newNeedsData[cat].needs.findIndex(n => n.strainType === strain);
                const needEntry = {
                    strainType: strain,
                    varietiesNeeded: varietiesNeeded,
                    qtyNeeded: Math.round(qtyNeeded),
                    parLevel: parLevel,
                    pipelineQty: Math.round(pipelineQty),
                    inventoryQty: Math.round(inventoryQty),
                    currentVarieties: varietyCount,
                    currentQty: Math.round(totalQty),
                    isStocked: qtyNeeded === 0 && varietiesNeeded === 0
                };
                if (existingIndex >= 0) {
                    newNeedsData[cat].needs[existingIndex] = needEntry;
                } else {
                    newNeedsData[cat].needs.push(needEntry);
                }
            });
        });

        // Update global data and cache
        needsData = newNeedsData;
        localStorage.setItem(getNeedsCacheKey(), JSON.stringify(needsData));
        renderNeedsCategories();
        })();

        // Wait for the loading to complete, then clear the flag
        try {
            await needsDataLoading;
        } finally {
            needsDataLoading = null;
        }
    }

    function getCategoryColor(cat) {
        const colors = {
            'Wax': '#8B5CF6',
            'Shatter': '#EC4899',
            'Sugar Wax': '#F59E0B',
            'Live Resin Carts': '#10B981',
            'Live Resin AIOs': '#3B82F6',
            'Brick Hash': '#6366F1',
            '4g Wax': '#F97316',
            '4g Sugar': '#EC4899'
        };
        return colors[cat] || '#8B5CF6';
    }

    function renderNeedsCategories() {
        // Use dynamic category order from needsData keys
        const categoryOrder = Object.keys(needsData);

        const html = categoryOrder.map(key => {
            const data = needsData[key] || { label: key, needs: [] };
            if (!data) return '';

            // Get needs by strain type
            const needsByStrain = { Sativa: 0, Hybrid: 0, Indica: 0 };
            (data.needs || []).forEach(need => {
                needsByStrain[need.strainType] = need.varietiesNeeded;
            });

            const totalNeeded = needsByStrain.Sativa + needsByStrain.Hybrid + needsByStrain.Indica;
            const isOk = totalNeeded === 0;
            // Color based on urgency: green=stocked, yellow=1-2 needed, red=3+ needed
            const glowColor = isOk ? '#10B981' : (totalNeeded <= 2 ? '#F59E0B' : '#EF4444');
            return `
                <button onclick="showNeedsItems('${key}')" class="foh-btn">
                    <div class="foh-btn-name">${data.label}</div>
                    <div class="foh-btn-num foh-needs-num" style="text-shadow: 0 0 8px ${glowColor}, 0 0 15px ${glowColor}, 0 0 25px ${glowColor}, 0 0 40px ${glowColor};">${isOk ? '' : totalNeeded}</div>
                    <div class="foh-btn-sub">${isOk ? 'Stocked' : 'varieties needed'}</div>
                </button>
            `;
        }).join('');

        // Render to modal, inline FOH, and dashboard
        const modalContainer = document.getElementById('needsCategoryGrid');
        const inlineContainer = document.getElementById('inlineNeedsGrid');
        const dashboardContainer = document.getElementById('dashboardNeedsGrid');
        if (modalContainer) modalContainer.innerHTML = html;
        if (inlineContainer) inlineContainer.innerHTML = html;
        if (dashboardContainer) dashboardContainer.innerHTML = html;
    }

    function showNeedsItems(category) {
        const data = needsData[category];
        const contentEl = document.getElementById('needsPopupContent');

        // Check if data is ready
        if (!data || !data.needs || data.needs.length === 0) {
            document.getElementById('needsPopupTitle').textContent = (data?.label || category) + ' Needs';
            document.getElementById('needsPopupTitle').style.color = data?.color || '#F59E0B';
            contentEl.innerHTML = '<div style="padding: 20px; text-align: center; color: var(--text-secondary);">Loading data...</div>';
            document.getElementById('needsItemsPopup').style.display = 'block';
            // Try to reload data
            loadNeedsData().then(() => {
                if (needsData[category]?.needs?.length > 0) {
                    showNeedsItems(category);
                }
            });
            return;
        }

        document.getElementById('needsPopupTitle').textContent = data.label + ' Needs';
        document.getElementById('needsPopupTitle').style.color = data.color;

        const getStrainColor = (type) => {
            if (type === 'Sativa') return '#ff0055';
            if (type === 'Indica') return '#0055ff';
            return '#39ff14';
        };

        {
            // Sort by strain type (Sativa, Hybrid, Indica)
            const strainOrder = { 'Sativa': 0, 'Hybrid': 1, 'Indica': 2 };
            const sortedNeeds = [...data.needs].sort((a, b) => {
                const typeA = strainOrder[a.strainType] ?? 1;
                const typeB = strainOrder[b.strainType] ?? 1;
                return typeA - typeB;
            });
            contentEl.innerHTML = sortedNeeds.map(need => {
                const strainColor = getStrainColor(need.strainType);
                const isStocked = need.isStocked || (need.qtyNeeded === 0 && need.varietiesNeeded === 0);
                const statusBadge = isStocked
                    ? '<span style="background: #10B98122; color: #10B981; padding: 4px 10px; border-radius: 8px; font-size: 0.9rem; font-weight: 600;"> Stocked</span>'
                    : `<span style="background: #EF444422; color: #EF4444; padding: 4px 10px; border-radius: 8px; font-size: 0.9rem; font-weight: 600;">Need ${need.varietiesNeeded > 0 ? need.varietiesNeeded + ' varieties' : need.qtyNeeded + 'g'}</span>`;
                return `
                    <div style="padding: 15px; background: var(--bg-primary); border-radius: 8px; margin-bottom: 10px; border-left: 3px solid ${strainColor}; box-shadow: 0 0 10px ${strainColor}33; opacity: ${isStocked ? '0.7' : '1'};">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <span style="font-weight: 700; color: ${strainColor}; font-size: 1.1rem;">${need.strainType}</span>
                            ${statusBadge}
                        </div>
                        <div style="display: flex; gap: 20px; color: var(--text-secondary); font-size: 0.9rem;">
                            <span><strong>Par:</strong> ${need.parLevel}g</span>
                            <span><strong>Pipeline:</strong> ${need.pipelineQty || 0}g</span>
                            <span><strong>Inventory:</strong> ${need.inventoryQty || 0}g</span>
                        </div>
                    </div>
                `;
            }).join('');
        }

        document.getElementById('needsItemsPopup').style.display = 'block';
    }

    // Initialize FOH grids on page load
    window.addEventListener('load', function() {
        setTimeout(function() {
            if (document.getElementById('inlinePipelineGrid')) {
                loadSalesPipeline();
                loadLeafLinkInventory();
                loadNeedsData();
            }
        }, 1000);
    });

    </script>

</body>
</html>
